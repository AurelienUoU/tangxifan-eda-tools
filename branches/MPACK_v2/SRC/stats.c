#include <stdio.h>
#include <stdlib.h>
#include "util.h"
#include "blif_parser.h"
#include "blearch_parser.h"
#include "mpack_types.h"
#include "mpack_conf.h"
#include "mpack_util.h"
#include "sat_api.h"
#include "stats.h"
#include "init_mpack_types.h"
#include "global.h"

float stats_ble_resource_util(t_ble_arch* ble_arch,
                              t_ble_info* ble_info)
{
  int used = 0;
  int total = 0;
  int im;
  int ip;
  float ret;

  total += ble_info->input_num;
  total += ble_info->output_num;

  for (im=0; im<ble_info->input_num; im++) {
    used += ble_info->input_used[im];
  }

  for (im=0; im<ble_info->blend_num; im++) {
    total += ble_arch->blends[im].input_num;
    for (ip=0; ip<ble_arch->blends[im].input_num; ip++) {
    used += ble_info->blend_port_used[im][ip];
    }
  }

  for (im=0; im<ble_info->output_num; im++) {
    used += ble_info->output_used[im];
  }

  ret = (float)(100*used/total);  
  return ret;
}

int stats_ble_num(t_ble_arch* ble_arch,
                  t_ble_info* head,
                  int verbose)
{
  int ble_num = 0;
  t_ble_info* tmp = head->next;
  int im;
  int total;
  int used;

  while(tmp) {
    if (1 == verbose) {
      printf("Stats: BLE No.:%d ",ble_num);
    }
    used = 0;
    for (im=0; im<tmp->input_num; im++) {
      used += tmp->input_used[im];
    }
    total = tmp->input_num;
    if (1 == verbose) {
      printf("Input Used(%d/%d) ",used,total);
    }

    total = tmp->blend_num;
    used = 0;
    for (im=0; im<tmp->blend_num; im++) {
      used += tmp->blend_used[im];
    }
    if (1 == verbose) {
      printf("BLE Used(%d/%d) ",used,total);
    }

    total = tmp->output_num;
    used = 0;
    for (im=0; im<tmp->output_num; im++) {
      used += tmp->output_used[im];
    }
    if (1 == verbose) {
      printf("Output Used(%d/%d)\n",used,total);
    }

    ble_num++;
    //printf("Stats: BLE no:%d,Resource Utilization:%.2f%.\n",ble_num,stats_ble_resource_util(ble_arch,tmp));
    tmp = tmp->next;
  }

  return ble_num;
}

/*Stats the number of nets*/
int stats_net_num(t_lgkntwk* lgkntwk,
                  t_ble_info* ble_info,
                  int verbose)
{
  int net_num = 0;
  int ip;
  t_ble_info* head = ble_info->next;

  /*Primary inputs cannot be absorbed*/
  net_num += lgkntwk->pi_num;

  /* We just count the number of outputs that has been used
   * All the nets except Primary inputs which has none inputs,
   * the rest they have inputs from an output of BLE.
   */
  while(head) {
    /* Ensure that BLE output nets cannot be absorbed inside BLE.*/
    for (ip = 0; ip<head->output_num; ip++) {
      if ((NULL != head->output_lgknds[ip])&&(0 == check_ble_absorb_lgknd_output(head,head->output_lgknds[ip],verbose))) {
          net_num++;
      }
    }
    head = head->next;
  } 

  /*Count the clk network in if we have any latch*/
  if (0 < lgkntwk->latch_num) {
    net_num++;
  }

  return net_num;
}

/*****Print Stats File*****/
void print_stats(char* fstats_name,
                 t_stats* stats,
                 t_blif_arch* blif_arch,
                 t_lgkntwk* lgkntwk,
                 t_ble_arch* ble_arch,
                 t_ble_info* ble_info,
                 int verbose)
{
  FILE* fstats;
  t_ble_info* tmp = ble_info->next;
  int im;
  int total;
  int used;
  t_lgknd* cur;
  int ip;
  int cell_idx;
  int ble_num = stats_ble_num(ble_arch,ble_info,0);
  double ble_util = (double)(lgkntwk->libgate_num)/(double)(ble_num);
  int net_num = stats_net_num(lgkntwk,ble_info,verbose);
   
  printf("Output Statistics(%s)...\n",fstats_name);
  printf("Info: BLE num: %d, Net num: %d.\n",ble_num,net_num);
  fstats = my_fopen(fstats_name,"w");
  fputs("Statisitics Generated by MPACK " __DATE__, fstats);
  fprintf(fstats,"\nCircuit Name: %s\n",blif_arch->model);
  /*Echo BLE Number and Fill rate*/
  fprintf(fstats,"BLE Number: %d\n",ble_num);
  fprintf(fstats,"BLE Fill Rate: %.2f\n",ble_util);
  fprintf(fstats,"Net Number: %d\n",net_num);
  fprintf(fstats,"avg_lt10: %.3g\n",stats->avg_lt10);
  /*Echo Statistics for Circuit*/
  fprintf(fstats,"**Circuit Components**\n");
  fprintf(fstats,"No. of Primary Input: %d.\n",lgkntwk->pi_num);
  fprintf(fstats,"No. of Primary Output: %d.\n",lgkntwk->po_num);
  fprintf(fstats,"No. of Libgates: %d.\n",lgkntwk->libgate_num);
  fprintf(fstats,"No. of Latch: %d.\n", lgkntwk->latch_num);
  fprintf(fstats,"Statistics of Standard Library Gates:\n");
  for (im=0; im<10; im++) {
    fprintf(fstats,"No. of %s: %d.\n",typepair_list[im].type_name,stats->stdgate_stats[typepair_list[im].type_id]);
  }
  fprintf(fstats,"**End of Circuit Components**\n");

  /*Echo BLE architecture*/
  fprintf(fstats,"\n**BLE Architecture**\n");
  fprintf(fstats,"No. of BLE Inputs: %d.\n",ble_arch->input_num);
  fprintf(fstats,"No. of BLE Cell: %d.\n",ble_arch->blend_num);
  fprintf(fstats,"No. of BLE Outputs: %d.\n",ble_arch->output_num);
  fprintf(fstats,"**End of BLE Architecture**\n");
  
  
  /*Echo BLE infos*/
  ble_num = 0;
  fprintf(fstats,"\n**MPacked BLEs Statistics**\n");
  while(tmp) {
    fprintf(fstats,"BLE No.:%d ",tmp->idx);
    used = 0;
    for (im=0; im<tmp->input_num; im++) {
      used += tmp->input_used[im];
    }
    total = tmp->input_num;
    fprintf(fstats,"Input Used(%d/%d) ",used,total);

    total = tmp->blend_num;
    used = 0;
    for (im=0; im<tmp->blend_num; im++) {
      used += tmp->blend_used[im];
    }
    fprintf(fstats,"BLE Used(%d/%d) ",used,total);

    total = tmp->output_num;
    used = 0;
    for (im=0; im<tmp->output_num; im++) {
      used += tmp->output_used[im];
    }
    fprintf(fstats,"Output Used(%d/%d)\n",used,total);

    ble_num++;
    tmp = tmp->next;
  }
  fprintf(fstats,"**End of MPacked BLEs Statistics**\n");

  fprintf(fstats,"\n**MPacked BLEs Details**\n");
  tmp = ble_info->next;
  while(tmp) {
    fprintf(fstats,"BLE No.:%d ",tmp->idx);
    for (im=0; im < tmp->blend_num; im++) {
      if (1 == tmp->blend_used[im]) {
        cur = tmp->blend_lgknds[im];
        fprintf(fstats,"Cell: %d(Type: %s Index: %d) ",im,typepair_list[cur->type].type_name,cur->idx);
      }
      else {
        fprintf(fstats,"Cell: %d(Type: N/A Index: N/A) ",im);
      }
    }
    fprintf(fstats,"\n");
    tmp = tmp->next;
  }

  fprintf(fstats,"**End of MPacked BLEs Details**\n");

  fprintf(fstats,"\n**Standard Gates Mpack Information**\n");
  
  for (im=0; im<lgkntwk->libgate_num; im++) {
    cur = lgkntwk->libgate_ptrs[im];
    cell_idx = -1;
    for (ip=0; ip<((t_ble_info*)cur->ble_info)->blend_num; ip++) {
      if (((t_ble_info*)cur->ble_info)->blend_lgknds[ip] == cur) {
        cell_idx = ip;
        break;
      }
    } 
    if (-1 == cell_idx) {
      printf("Error:(print_stats) N/A cell index in BLE info of libgate!\n");
      exit(1);
    }
    fprintf(fstats,"Index:%d Type: %s Fan-in: %d Fan-out: %d BLE index: %d BLE Cell index: %d\n",cur->idx,typepair_list[cur->type].type_name,cur->input_num,cur->output_num,cur->ble_idx,cell_idx); 
  }

  fprintf(fstats,"**End of Standard Gates Mpack Information**\n");

  fclose(fstats);  
}

int stats_lgkntwk(t_lgkntwk* lgkntwk,
                  t_stats* stats) {
  t_lgknd* head;
  int i;
  int* libgates_fanout = (int*)my_malloc(sizeof(int)*10);
  int cnt = 0;
  int avg_cnt = 0;
  float sum_lt10 = 0;
  int sum_lt10_cnt = 0; 
  int* fanout_types = (int*)my_malloc(sizeof(int)*4);
  int has_latch, has_libgate;

  stats->libgate_latch_fanout_avg = 0.0;
  stats->avg_lt10 = 0.0; 

  my_init_int_ary(10,libgates_fanout,0);
  my_init_int_ary(3,fanout_types,0);
  // report the number of fanout types
  head = lgkntwk->libgate_head->next;
  while(head) {
    has_latch = 0;
    has_libgate = 0;
    for (i=0; i < head->output_num; i++) {
      if (ND_LATCH == head->outputs[i]->type) {
        has_latch = 1;
      } else if ((ND_PO != head->outputs[i]->type)&&(ND_PI != head->outputs[i]->type)) {
        has_libgate = 1;
      }
    }
    if ((0 == has_latch)&&(0 == has_libgate)) {
      fanout_types[0]++; 
    } else if ((0 == has_latch)&&(1 == has_libgate)) {
      fanout_types[1]++; 
    } else if ((1 == has_latch)&&(0 == has_libgate)) {
      fanout_types[2]++; 
    } else if ((1 == has_latch)&&(1 == has_libgate)) {
      fanout_types[3]++; 
    }
    head = head->next;
  }
  printf("Info: No. of fanout types(0 latch,0 comb) = %d\n",fanout_types[0]);
  printf("Info: No. of fanout types(0 latch,has comb) = %d\n",fanout_types[1]);
  printf("Info: No. of fanout types(has latch,0 comb) = %d\n",fanout_types[2]);
  printf("Info: No. of fanout types(has latch,has comb) = %d\n",fanout_types[3]);
  // Report the fanout of libgates that include both combinational and sequential 
  head = lgkntwk->latch_head->next;
  while(head) {
    if (10 > (head->inputs[0]->output_num-1)) {
      libgates_fanout[head->inputs[0]->output_num-1]++;
      if (0 != (head->inputs[0]->output_num-1)) {
        sum_lt10 += head->inputs[0]->output_num-1;
        sum_lt10_cnt++;
      }
    }
    if (0 != (head->output_num - 1)) {
      stats->libgate_latch_fanout_avg += head->inputs[0]->output_num-1;
      avg_cnt++;
    }
    cnt++;
    head = head->next;
  }

  stats->libgate_latch_fanout_avg /= avg_cnt;
  printf("Info: Average fanout of libgates with latches = %.3g.\n",stats->libgate_latch_fanout_avg);
  printf("Info: counter = %d.\n",cnt);
  for (i=0; i<10; i++) {
    printf("Info: %d libgates with sequential output have fanout No. %d.\n",libgates_fanout[i],i);
  }
  sum_lt10 /= sum_lt10_cnt;
  printf("Info: libgates with sequential output less than 10 average fanout = %.3g\n",sum_lt10);
  stats->avg_lt10 = sum_lt10; 

  free(libgates_fanout);
  return 1;
}
