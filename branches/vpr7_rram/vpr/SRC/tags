!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
AAPACK_MAX_FEASIBLE_BLOCK_ARRAY_SIZE	pack/cluster.c	34;"	d	file:
AAPACK_MAX_HIGH_FANOUT_EXPLORE	pack/cluster.c	36;"	d	file:
AAPACK_MAX_NET_SINKS_IGNORE	pack/cluster.c	35;"	d	file:
AAPACK_MAX_OVERUSE_LOOKAHEAD_PINS_CONST	pack/cluster.c	32;"	d	file:
AAPACK_MAX_OVERUSE_LOOKAHEAD_PINS_FAC	pack/cluster.c	31;"	d	file:
ABORTED	place/place.c	/^	REJECTED, ACCEPTED, ABORTED$/;"	e	enum:swap_result	file:
ABSOLUTE	../../libarchfpga/include/physical_types.h	/^	ABSOLUTE, FRACTIONAL$/;"	e	enum:e_Fc_type
ABS_DIFF	place/place_stats.c	7;"	d	file:
ACCEPTED	place/place.c	/^	REJECTED, ACCEPTED, ABORTED$/;"	e	enum:swap_result	file:
ALLOW_SWITCH_OFF	route/rr_graph2.c	16;"	d	file:
ALL_NETS	base/draw.c	/^	ALL_NETS, HIGHLIGHTED$/;"	e	enum:e_draw_net_type	file:
ANY	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
ANYBUT	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
ANYOF	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
ARCH_TYPES_H	../../libarchfpga/include/arch_types.h	9;"	d
AUTO_SCHED	base/vpr_types.h	/^	AUTO_SCHED, USER_SCHED$/;"	e	enum:sched_type
ActFile	base/ReadOptions.h	/^	char *ActFile;$/;"	m	struct:s_options
ActFile	base/vpr_types.h	/^	char *ActFile;$/;"	m	struct:s_file_name_opts
AnnealSched	base/vpr_types.h	/^	struct s_annealing_sched AnnealSched; \/* Placement option annealing schedule *\/$/;"	m	struct:s_vpr_setup	typeref:struct:s_vpr_setup::s_annealing_sched
ArchFile	base/ReadOptions.h	/^	char *ArchFile;$/;"	m	struct:s_options
ArchFile	base/vpr_types.h	/^	char *ArchFile;$/;"	m	struct:s_file_name_opts
Aspect	../../libarchfpga/include/physical_types.h	/^	float Aspect;$/;"	m	struct:s_clb_grid
BISQUE	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
BI_DIRECTION	base/vpr_types.h	/^	INC_DIRECTION = 0, DEC_DIRECTION = 1, BI_DIRECTION = 2$/;"	e	enum:e_direction
BI_DIRECTIONAL	../../libarchfpga/include/physical_types.h	/^	UNI_DIRECTIONAL, BI_DIRECTIONAL$/;"	e	enum:e_directionality
BLACK	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
BLIF_TOKENS	base/read_blif.c	235;"	d	file:
BLK_FAILED_FEASIBLE	base/vpr_types.h	/^	BLK_PASSED, BLK_FAILED_FEASIBLE, BLK_FAILED_ROUTE, BLK_STATUS_UNDEFINED$/;"	e	enum:e_block_pack_status
BLK_FAILED_ROUTE	base/vpr_types.h	/^	BLK_PASSED, BLK_FAILED_FEASIBLE, BLK_FAILED_ROUTE, BLK_STATUS_UNDEFINED$/;"	e	enum:e_block_pack_status
BLK_PASSED	base/vpr_types.h	/^	BLK_PASSED, BLK_FAILED_FEASIBLE, BLK_FAILED_ROUTE, BLK_STATUS_UNDEFINED$/;"	e	enum:e_block_pack_status
BLK_STATUS_UNDEFINED	base/vpr_types.h	/^	BLK_PASSED, BLK_FAILED_FEASIBLE, BLK_FAILED_ROUTE, BLK_STATUS_UNDEFINED$/;"	e	enum:e_block_pack_status
BLOCK_COUNT	place/timing_place_lookup.c	52;"	d	file:
BLUE	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
BOL	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
BOTTOM	../../libarchfpga/include/physical_types.h	/^	TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3$/;"	e	enum:e_side
BOUNDARY	../../libarchfpga/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
BOUNDING_BOX_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, NET_TIMING_DRIVEN_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:e_place_algorithm
BRANCH	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
BREADTH_FIRST	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:e_router_algorithm
BUFFER_INSERTION_H	mrfpga/buffer_insertion.h	2;"	d
BUFSIZE	../../libarchfpga/include/util.h	23;"	d
BUFSIZE	base/graphics.c	184;"	d	file:
BUF_AND_PTRANS_FLAG	route/check_rr_graph.c	16;"	d	file:
BUF_FLAG	route/check_rr_graph.c	14;"	d	file:
BUTTON_POLY	base/graphics.c	/^   BUTTON_POLY,$/;"	e	enum:__anon3	file:
BUTTON_SEPARATOR	base/graphics.c	/^   BUTTON_SEPARATOR$/;"	e	enum:__anon3	file:
BUTTON_TEXT	base/graphics.c	/^   BUTTON_TEXT = 0,$/;"	e	enum:__anon3	file:
BUTTON_TEXT_LEN	base/graphics.c	183;"	d	file:
BlifFile	base/ReadOptions.h	/^	char *BlifFile;$/;"	m	struct:s_options
BlifFile	base/vpr_types.h	/^	char *BlifFile;$/;"	m	struct:s_file_name_opts
ButtonsWND	base/graphics.c	/^ButtonsWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)$/;"	f	file:
C	../../libarchfpga/include/arch_types_mrfpga.h	/^  float C; $/;"	m	struct:s_memristor_inf
C	../../libarchfpga/include/arch_types_mrfpga.h	/^  float C;$/;"	m	struct:s_buffer_inf
C	../../libarchfpga/include/physical_types.h	/^		float C;$/;"	m	union:s_port_power::__anon22
C	base/vpr_types.h	/^	float C;$/;"	m	struct:s_rr_node
CAD_TYPES_H	../../libarchfpga/include/cad_types.h	5;"	d
CAL_CAPACITANCE_H	mrfpga/cal_capacitance.h	2;"	d
CHANX	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
CHANX_COST_INDEX_START	base/vpr_types.h	/^	CHANX_COST_INDEX_START$/;"	e	enum:e_cost_indices
CHANY	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
CHECK	place/place.c	/^	NORMAL, CHECK$/;"	e	enum:cost_methods	file:
CHECK_NETLIST_H	base/check_netlist.h	2;"	d
CHECK_RAND	../../libarchfpga/util.c	702;"	d	file:
CHECK_RR_GRAPH_H	route/check_rr_graph.h	2;"	d
CHUNK_SIZE	../../libarchfpga/util.c	208;"	d	file:
CLOCK_DENS	power/power.h	37;"	d
CLOCK_PROB	power/power.h	36;"	d
CLOSE	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
CLUSTER_FEASIBILITY_CHECK_H	pack/cluster_feasibility_filter.h	23;"	d
CLUSTER_LEGALITY_H	pack/cluster_legality.h	2;"	d
CLUSTER_PLACEMENT_H	pack/cluster_placement.h	7;"	d
COL_REL	../../libarchfpga/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
COL_REPEAT	../../libarchfpga/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
COMPLETE_INTERC	../../libarchfpga/include/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
CONV	../../libarchfpga/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
CONVERT_NM_PER_M	power/power.c	50;"	d	file:
CONVERT_UM_PER_M	power/power.c	51;"	d	file:
CORAL	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
CREATE_ERROR	base/graphics.c	219;"	d	file:
CYAN	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
C_d	power/power.h	/^	float C_d;$/;"	m	struct:s_transistor_size_inf
C_downstream	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	m	struct:s_buffer_plan	file:
C_downstream	route/route_tree_timing.h	/^	float C_downstream;$/;"	m	struct:s_rt_node
C_downstream	timing/net_delay_types.h	/^	float C_downstream;$/;"	m	struct:s_rc_node
C_g	power/power.h	/^	float C_g;$/;"	m	struct:s_transistor_size_inf
C_internal	../../libarchfpga/include/physical_types.h	/^	float C_internal; \/*Internal capacitance of the pb *\/$/;"	m	struct:s_pb_type_power
C_ipin_cblock	../../libarchfpga/include/physical_types.h	/^	float C_ipin_cblock;$/;"	m	struct:s_arch
C_ipin_cblock	../../libarchfpga/include/physical_types.h	/^	float C_ipin_cblock;$/;"	m	struct:s_timing_inf
C_load	base/vpr_types.h	/^	float C_load;$/;"	m	struct:s_rr_indexed_data
C_s	power/power.h	/^	float C_s;$/;"	m	struct:s_transistor_size_inf
C_tile_per_m	base/vpr_types.h	/^	float C_tile_per_m;$/;"	m	struct:s_rr_indexed_data
C_wire	../../libarchfpga/include/physical_types.h	/^	float C_wire; \/* Wire capacitance (per meter) *\/$/;"	m	struct:s_clock_network
C_wire	../../libarchfpga/include/physical_types.h	/^	float C_wire;$/;"	m	struct:s_pb_graph_pin_power
C_wire_local	../../libarchfpga/include/physical_types.h	/^	float C_wire_local; \/* Capacitance of local interconnect (per meter) *\/$/;"	m	struct:s_power_arch
Chans	../../libarchfpga/include/physical_types.h	/^	t_chan_width_dist Chans;$/;"	m	struct:s_arch
CheckArch	base/CheckArch.c	/^void CheckArch(INP t_arch Arch, INP boolean TimingEnabled) {$/;"	f
CheckElement	../../libarchfpga/read_xml_util.c	/^void CheckElement(INP ezxml_t Node, INP const char *Name) {$/;"	f
CheckGrid	base/SetupGrid.c	/^static void CheckGrid() {$/;"	f	file:
CheckOptions	base/CheckOptions.c	/^void CheckOptions(INP t_options Options, INP boolean TimingEnabled) {$/;"	f
CheckSegments	base/CheckArch.c	/^static void CheckSegments(INP t_arch Arch) {$/;"	f	file:
CheckSetup	base/CheckSetup.c	/^void CheckSetup(INP enum e_operation Operation,$/;"	f
CheckSwitches	base/CheckArch.c	/^static void CheckSwitches(INP t_arch Arch, INP boolean TimingEnabled) {$/;"	f	file:
Cin	../../libarchfpga/include/physical_types.h	/^	float Cin;$/;"	m	struct:s_switch_inf
CircuitName	base/ReadOptions.h	/^	char *CircuitName;$/;"	m	struct:s_options
CircuitName	base/vpr_types.h	/^	char *CircuitName;$/;"	m	struct:s_file_name_opts
Cmetal	../../libarchfpga/include/physical_types.h	/^	float Cmetal;$/;"	m	struct:s_segment_inf
Cmetal	base/vpr_types.h	/^	float Cmetal;$/;"	m	struct:s_seg_details
Cmetal_per_m	base/vpr_types.h	/^	float Cmetal_per_m; \/* Used for power *\/$/;"	m	struct:s_seg_details
CmosTechFile	base/ReadOptions.h	/^	char *CmosTechFile;$/;"	m	struct:s_options
CmosTechFile	base/vpr_types.h	/^	char *CmosTechFile;$/;"	m	struct:s_file_name_opts
Count	base/ReadOptions.h	/^	int Count[OT_BASE_UNKNOWN];$/;"	m	struct:s_options
CountChildren	../../libarchfpga/read_xml_util.c	/^extern int CountChildren(INP ezxml_t Node, INP const char *Name,$/;"	f
CountTokens	../../libarchfpga/ReadLine.c	/^int CountTokens(INP char **Tokens) {$/;"	f
CountTokensInString	../../libarchfpga/read_xml_util.c	/^extern void CountTokensInString(INP const char *Str, OUTP int *Num,$/;"	f
Cout	../../libarchfpga/include/physical_types.h	/^	float Cout;$/;"	m	struct:s_switch_inf
CreateEchoFile	base/ReadOptions.h	/^	boolean CreateEchoFile;$/;"	m	struct:s_options
CreateModelLibrary	../../libarchfpga/read_xml_arch_file.c	/^static void CreateModelLibrary(OUTP struct s_arch *arch) {$/;"	f	file:
Cseg_global	../../libarchfpga/include/arch_types_mrfpga.h	/^  float Cseg_global;$/;"	m	struct:s_arch_mrfpga
Cseg_global	mrfpga/mrfpga_globals.c	/^float Rseg_global, Cseg_global;$/;"	v
DARKGREEN	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
DARKGREY	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
DARKKHAKI	base/easygl_constants.h	/^TURQUOISE, MEDIUMPURPLE, DARKSLATEBLUE, DARKKHAKI, NUM_COLOR};$/;"	e	enum:color_types
DARKSLATEBLUE	base/easygl_constants.h	/^TURQUOISE, MEDIUMPURPLE, DARKSLATEBLUE, DARKKHAKI, NUM_COLOR};$/;"	e	enum:color_types
DASHED	base/easygl_constants.h	/^enum line_types {SOLID, DASHED};$/;"	e	enum:line_types
DEBUG	base/vpr_types.h	46;"	d
DEBUG_TIMING_PLACE_LOOKUP	place/timing_place_lookup.c	61;"	d	file:
DEC_DIRECTION	base/vpr_types.h	/^	INC_DIRECTION = 0, DEC_DIRECTION = 1, BI_DIRECTION = 2$/;"	e	enum:e_direction
DEGTORAD	base/graphics.c	228;"	d	file:
DELAY_NORMALIZED	base/vpr_types.h	/^	INTRINSIC_DELAY, DELAY_NORMALIZED, DEMAND_ONLY$/;"	e	enum:e_base_cost_type
DELETE_ERROR	base/graphics.c	218;"	d	file:
DELTA	../../libarchfpga/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
DEMAND_ONLY	base/vpr_types.h	/^	INTRINSIC_DELAY, DELAY_NORMALIZED, DEMAND_ONLY$/;"	e	enum:e_base_cost_type
DETAILED	base/vpr_types.h	/^	GLOBAL, DETAILED$/;"	e	enum:e_route_type
DIGIT	timing/slre.c	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon19	file:
DIRECT_INTERC	../../libarchfpga/include/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
DISCOUNT_FUNCTION_BASE	timing/path_delay.h	23;"	d
DO_NOT_ANALYSE	timing/path_delay.h	4;"	d
DRAW_ALL_BUT_BUFFERS_RR	base/draw.c	/^	DRAW_ALL_BUT_BUFFERS_RR,$/;"	e	enum:e_draw_rr_toggle	file:
DRAW_ALL_RR	base/draw.c	/^	DRAW_ALL_RR,$/;"	e	enum:e_draw_rr_toggle	file:
DRAW_ERROR	base/graphics.c	220;"	d	file:
DRAW_NODES_AND_SBOX_RR	base/draw.c	/^	DRAW_NODES_AND_SBOX_RR,$/;"	e	enum:e_draw_rr_toggle	file:
DRAW_NODES_RR	base/draw.c	/^	DRAW_NODES_RR,$/;"	e	enum:e_draw_rr_toggle	file:
DRAW_NORMAL	base/graphics.h	/^enum e_draw_mode {DRAW_NORMAL = 0, DRAW_XOR};$/;"	e	enum:e_draw_mode
DRAW_NO_RR	base/draw.c	/^	DRAW_NO_RR = 0,$/;"	e	enum:e_draw_rr_toggle	file:
DRAW_RR_TOGGLE_MAX	base/draw.c	/^	DRAW_RR_TOGGLE_MAX$/;"	e	enum:e_draw_rr_toggle	file:
DRAW_XOR	base/graphics.h	/^enum e_draw_mode {DRAW_NORMAL = 0, DRAW_XOR};$/;"	e	enum:e_draw_mode
DRIVER	../../libarchfpga/include/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
DUMPFILE	place/timing_place_lookup.c	63;"	d	file:
Directs	../../libarchfpga/include/physical_types.h	/^	t_direct_inf *Directs;$/;"	m	struct:s_arch
EASYGL_CONSTANTS_H	base/easygl_constants.h	2;"	d
EMPTY	base/vpr_types.h	90;"	d
EMPTY_TYPE	../../libarchfpga/read_xml_arch_file.c	/^static t_type_ptr EMPTY_TYPE = NULL;$/;"	v	file:
EMPTY_TYPE	base/globals.c	/^t_type_ptr EMPTY_TYPE = NULL;$/;"	v
EMPTY_TYPE_BACKUP	place/timing_place_lookup.c	/^static t_type_ptr EMPTY_TYPE_BACKUP;$/;"	v	file:
EMPTY_TYPE_INDEX	../../libarchfpga/include/read_xml_arch_file.h	15;"	d
ENABLE_REVERSE	route/rr_graph2.c	21;"	d	file:
END	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
EOL	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
EPSILON	base/vpr_types.h	83;"	d
ERROR_THRESHOLD	base/check_netlist.c	15;"	d	file:
ERROR_TOL	place/place.c	31;"	d	file:
ERROR_TOL	route/route_timing.c	876;"	d	file:
ERRTAG	../../libarchfpga/include/util.h	26;"	d
ERR_PORT	../../libarchfpga/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
EXACT	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
EZXML_BUFSIZE	../../libarchfpga/include/ezxml.h	37;"	d
EZXML_DUP	../../libarchfpga/include/ezxml.h	40;"	d
EZXML_ERRL	../../libarchfpga/include/ezxml.h	41;"	d
EZXML_NAMEM	../../libarchfpga/include/ezxml.h	38;"	d
EZXML_NIL	../../libarchfpga/ezxml.c	/^char *EZXML_NIL[] = { NULL }; \/* empty, null terminated array of strings *\/$/;"	v
EZXML_NOMMAP	../../libarchfpga/ezxml.c	26;"	d	file:
EZXML_TXTM	../../libarchfpga/include/ezxml.h	39;"	d
EZXML_WS	../../libarchfpga/ezxml.c	64;"	d	file:
E_ANNOT_PIN_TO_PIN_CAPACITANCE	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_CAPACITANCE,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_CAPACITANCE_C	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_CAPACITANCE_C = 0$/;"	e	enum:e_pin_to_pin_capacitance_annotations
E_ANNOT_PIN_TO_PIN_CONSTANT	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MATRIX = 0, E_ANNOT_PIN_TO_PIN_CONSTANT$/;"	e	enum:e_pin_to_pin_annotation_format
E_ANNOT_PIN_TO_PIN_DELAY	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY = 0,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MAX	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MAX,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MIN	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MIN,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_MAX	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_MAX,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_MIN	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_MIN = 0,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_THOLD	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_THOLD$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_TSETUP	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_TSETUP,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_MATRIX	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MATRIX = 0, E_ANNOT_PIN_TO_PIN_CONSTANT$/;"	e	enum:e_pin_to_pin_annotation_format
E_ANNOT_PIN_TO_PIN_PACK_PATTERN	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_PACK_PATTERN$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_PACK_PATTERN_NAME	../../libarchfpga/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_PACK_PATTERN_NAME = 0$/;"	e	enum:e_pin_to_pin_pack_pattern_annotations
E_CRITICALITY_FILE	base/ReadOptions.h	/^	E_CRITICALITY_FILE,$/;"	e	enum:e_output_files
E_CRIT_PATH_FILE	base/ReadOptions.h	/^	E_CRIT_PATH_FILE,$/;"	e	enum:e_output_files
E_CUSTOM_PIN_DISTR	../../libarchfpga/include/physical_types.h	/^	E_SPREAD_PIN_DISTR = 1, E_CUSTOM_PIN_DISTR = 2$/;"	e	enum:e_pin_location_distr
E_DETAILED_ROUTE_AT_END_ONLY	pack/cluster.c	/^	E_DETAILED_ROUTE_AT_END_ONLY = 0, E_DETAILED_ROUTE_FOR_EACH_ATOM, E_DETAILED_ROUTE_END$/;"	e	enum:e_detailed_routing_stages	file:
E_DETAILED_ROUTE_END	pack/cluster.c	/^	E_DETAILED_ROUTE_AT_END_ONLY = 0, E_DETAILED_ROUTE_FOR_EACH_ATOM, E_DETAILED_ROUTE_END$/;"	e	enum:e_detailed_routing_stages	file:
E_DETAILED_ROUTE_FOR_EACH_ATOM	pack/cluster.c	/^	E_DETAILED_ROUTE_AT_END_ONLY = 0, E_DETAILED_ROUTE_FOR_EACH_ATOM, E_DETAILED_ROUTE_END$/;"	e	enum:e_detailed_routing_stages	file:
E_DIR_EXIST	spice/spice_utils.c	/^ E_DIR_EXIST$/;"	e	enum:e_dir_err	file:
E_DIR_NOT_EXIST	spice/spice_utils.c	/^ E_DIR_NOT_EXIST,$/;"	e	enum:e_dir_err	file:
E_ECHO_ARCH	base/ReadOptions.h	/^	E_ECHO_ARCH,$/;"	e	enum:e_echo_files
E_ECHO_BLIF_INPUT	base/ReadOptions.h	/^	E_ECHO_BLIF_INPUT,$/;"	e	enum:e_echo_files
E_ECHO_CLUSTERING_BLOCK_CRITICALITIES	base/ReadOptions.h	/^	E_ECHO_CLUSTERING_BLOCK_CRITICALITIES,$/;"	e	enum:e_echo_files
E_ECHO_CLUSTERING_TIMING_INFO	base/ReadOptions.h	/^	E_ECHO_CLUSTERING_TIMING_INFO,$/;"	e	enum:e_echo_files
E_ECHO_COMPLETE_NET_TRACE	base/ReadOptions.h	/^	E_ECHO_COMPLETE_NET_TRACE,$/;"	e	enum:e_echo_files
E_ECHO_CRITICALITY	base/ReadOptions.h	/^	E_ECHO_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_CRITICAL_PATH	base/ReadOptions.h	/^	E_ECHO_CRITICAL_PATH,$/;"	e	enum:e_echo_files
E_ECHO_END_CLB_PLACEMENT	base/ReadOptions.h	/^	E_ECHO_END_CLB_PLACEMENT,$/;"	e	enum:e_echo_files
E_ECHO_END_TOKEN	base/ReadOptions.h	/^	E_ECHO_END_TOKEN$/;"	e	enum:e_echo_files
E_ECHO_FINAL_PLACEMENT_CRITICALITY	base/ReadOptions.h	/^	E_ECHO_FINAL_PLACEMENT_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_FINAL_PLACEMENT_SLACK	base/ReadOptions.h	/^	E_ECHO_FINAL_PLACEMENT_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_FINAL_PLACEMENT_TIMING_GRAPH	base/ReadOptions.h	/^	E_ECHO_FINAL_PLACEMENT_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_CLB_PLACEMENT	base/ReadOptions.h	/^	E_ECHO_INITIAL_CLB_PLACEMENT = 0,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_PLACEMENT_CRITICALITY	base/ReadOptions.h	/^	E_ECHO_INITIAL_PLACEMENT_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_PLACEMENT_SLACK	base/ReadOptions.h	/^	E_ECHO_INITIAL_PLACEMENT_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_PLACEMENT_TIMING_GRAPH	base/ReadOptions.h	/^	E_ECHO_INITIAL_PLACEMENT_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_LUT_REMAPPING	base/ReadOptions.h	/^	E_ECHO_LUT_REMAPPING,$/;"	e	enum:e_echo_files
E_ECHO_MEM	base/ReadOptions.h	/^	E_ECHO_MEM,$/;"	e	enum:e_echo_files
E_ECHO_NET_DELAY	base/ReadOptions.h	/^	E_ECHO_NET_DELAY,$/;"	e	enum:e_echo_files
E_ECHO_PB_GRAPH	base/ReadOptions.h	/^	E_ECHO_PB_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_CRITICAL_PATH	base/ReadOptions.h	/^	E_ECHO_PLACEMENT_CRITICAL_PATH,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_CRIT_PATH	base/ReadOptions.h	/^	E_ECHO_PLACEMENT_CRIT_PATH,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_LOGIC_SINK_DELAYS	base/ReadOptions.h	/^	E_ECHO_PLACEMENT_LOGIC_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_LOWER_BOUND_SINK_DELAYS	base/ReadOptions.h	/^	E_ECHO_PLACEMENT_LOWER_BOUND_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_SINK_DELAYS	base/ReadOptions.h	/^	E_ECHO_PLACEMENT_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_POST_FLOW_TIMING_GRAPH	base/ReadOptions.h	/^	E_ECHO_POST_FLOW_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_POST_PACK_NETLIST	base/ReadOptions.h	/^	E_ECHO_POST_PACK_NETLIST,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_CRITICALITY	base/ReadOptions.h	/^	E_ECHO_PRE_PACKING_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_MOLECULES_AND_PATTERNS	base/ReadOptions.h	/^	E_ECHO_PRE_PACKING_MOLECULES_AND_PATTERNS,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_SLACK	base/ReadOptions.h	/^	E_ECHO_PRE_PACKING_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_TIMING_GRAPH	base/ReadOptions.h	/^	E_ECHO_PRE_PACKING_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_TIMING_GRAPH_AS_BLIF	base/ReadOptions.h	/^	E_ECHO_PRE_PACKING_TIMING_GRAPH_AS_BLIF,$/;"	e	enum:e_echo_files
E_ECHO_ROUTING_SINK_DELAYS	base/ReadOptions.h	/^	E_ECHO_ROUTING_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_RR_GRAPH	base/ReadOptions.h	/^	E_ECHO_RR_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_SEG_DETAILS	base/ReadOptions.h	/^	E_ECHO_SEG_DETAILS,$/;"	e	enum:e_echo_files
E_ECHO_SLACK	base/ReadOptions.h	/^	E_ECHO_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_TIMING_CONSTRAINTS	base/ReadOptions.h	/^	E_ECHO_TIMING_CONSTRAINTS,$/;"	e	enum:e_echo_files
E_ECHO_TIMING_GRAPH	base/ReadOptions.h	/^	E_ECHO_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_EXIST_BUT_NOT_DIR	spice/spice_utils.c	/^ E_EXIST_BUT_NOT_DIR,$/;"	e	enum:e_dir_err	file:
E_FILE_END_TOKEN	base/ReadOptions.h	/^	E_FILE_END_TOKEN$/;"	e	enum:e_output_files
E_SLACK_FILE	base/ReadOptions.h	/^	E_SLACK_FILE,$/;"	e	enum:e_output_files
E_SPREAD_PIN_DISTR	../../libarchfpga/include/physical_types.h	/^	E_SPREAD_PIN_DISTR = 1, E_CUSTOM_PIN_DISTR = 2$/;"	e	enum:e_pin_location_distr
EchoArch	../../libarchfpga/read_xml_arch_file.c	/^void EchoArch(INP const char *EchoFile, INP const t_type_descriptor * Types,$/;"	f
EchoEnabled	base/ReadOptions.c	/^static boolean EchoEnabled;$/;"	v	file:
Enum	base/vpr_types.h	/^	int Enum;$/;"	m	struct:s_TokenPair
Error	base/ReadOptions.c	/^static void Error(INP const char *Token) {$/;"	f	file:
FALSE	../../libarchfpga/include/util.h	/^	FALSE, TRUE$/;"	e	enum:__anon23
FALSE	base/graphics.c	146;"	d	file:
FC_ABS	../../libarchfpga/read_xml_arch_file.c	/^	FC_ABS, FC_FRAC, FC_FULL$/;"	e	enum:Fc_type	file:
FC_FRAC	../../libarchfpga/read_xml_arch_file.c	/^	FC_ABS, FC_FRAC, FC_FULL$/;"	e	enum:Fc_type	file:
FC_FULL	../../libarchfpga/read_xml_arch_file.c	/^	FC_ABS, FC_FRAC, FC_FULL$/;"	e	enum:Fc_type	file:
FEASIBLE	pack/cluster.c	/^	FEASIBLE, INFEASIBLE$/;"	e	enum:e_feasibility	file:
FF_FE	spice/spice_primitives.c	/^  FF_RE, FF_FE$/;"	e	enum:e_ff_trigger_type	file:
FF_RE	spice/spice_primitives.c	/^  FF_RE, FF_FE$/;"	e	enum:e_ff_trigger_type	file:
FF_size	../../libarchfpga/include/physical_types.h	/^	float FF_size;$/;"	m	struct:s_power_arch
FILL	../../libarchfpga/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
FILL_TYPE	../../libarchfpga/read_xml_arch_file.c	/^static t_type_ptr FILL_TYPE = NULL;$/;"	v	file:
FILL_TYPE	base/globals.c	/^t_type_ptr FILL_TYPE = NULL;$/;"	v
FILL_TYPE_BACKUP	place/timing_place_lookup.c	/^static t_type_ptr FILL_TYPE_BACKUP;$/;"	v	file:
FINAL_DISCOUNT_FUNCTION_BASE	timing/path_delay.h	28;"	d
FIRST_ITER_WIRELENTH_LIMIT	base/vpr_types.h	88;"	d
FONTMAG	base/graphics.c	229;"	d	file:
FRACTIONAL	../../libarchfpga/include/physical_types.h	/^	ABSOLUTE, FRACTIONAL$/;"	e	enum:e_Fc_type
FRAGMENT_THRESHOLD	../../libarchfpga/util.c	209;"	d	file:
FREE	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:e_pad_loc_type
FROM_X_TO_Y	base/draw.c	/^	FROM_X_TO_Y, FROM_Y_TO_X$/;"	e	enum:e_edge_dir	file:
FROM_Y_TO_X	base/draw.c	/^	FROM_X_TO_Y, FROM_Y_TO_X$/;"	e	enum:e_edge_dir	file:
FULL	../../libarchfpga/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
Fc	../../libarchfpga/include/physical_types.h	/^	float *Fc; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
Fc_type	../../libarchfpga/read_xml_arch_file.c	/^enum Fc_type {$/;"	g	file:
FileNameOpts	base/vpr_types.h	/^	struct s_file_name_opts FileNameOpts; \/* File names *\/$/;"	m	struct:s_vpr_setup	typeref:struct:s_vpr_setup::s_file_name_opts
FindElement	../../libarchfpga/read_xml_util.c	/^ezxml_t FindElement(INP ezxml_t Parent, INP const char *Name,$/;"	f
FindFirstElement	../../libarchfpga/read_xml_util.c	/^ezxml_t FindFirstElement(INP ezxml_t Parent, INP const char *Name,$/;"	f
FindProperty	../../libarchfpga/read_xml_util.c	/^FindProperty(INP ezxml_t Parent, INP const char *Name, INP boolean Required) {$/;"	f
FreeNode	../../libarchfpga/read_xml_util.c	/^void FreeNode(INOUTP ezxml_t Node) {$/;"	f
FreeSpice	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpice(t_spice* spice) {$/;"	f
FreeSpiceMeasParams	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceMeasParams(t_spice_meas_params* meas_params) {$/;"	f
FreeSpiceModel	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceModel(t_spice_model* spice_model) {$/;"	f
FreeSpiceModelBuffer	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceModelBuffer(t_spice_model_buffer* spice_model_buffer) {$/;"	f
FreeSpiceModelNetlist	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceModelNetlist(t_spice_model_netlist* spice_model_netlist) {$/;"	f
FreeSpiceModelPassGateLogic	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceModelPassGateLogic(t_spice_model_pass_gate_logic* spice_model_pass_gate_logic) {$/;"	f
FreeSpiceModelPort	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceModelPort(t_spice_model_port* spice_model_port) {$/;"	f
FreeSpiceModelWireParam	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceModelWireParam(t_spice_model_wire_param* spice_model_wire_param) {$/;"	f
FreeSpiceMuxArch	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceMuxArch(t_spice_mux_arch* spice_mux_arch) {$/;"	f
FreeSpiceParams	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceParams(t_spice_params* params) {$/;"	f
FreeSpiceStimulateParams	../../libarchfpga/read_xml_spice_util.c	/^void FreeSpiceStimulateParams(t_spice_stimulate_params* stimulate_params) {$/;"	f
FreeSramInf	../../libarchfpga/read_xml_spice_util.c	/^void FreeSramInf(t_sram_inf* sram_inf) {$/;"	f
FreeTokens	../../libarchfpga/ReadLine.c	/^void FreeTokens(INOUTP char ***TokensPtr) {$/;"	f
Fs	../../libarchfpga/include/physical_types.h	/^	int Fs;$/;"	m	struct:s_arch
Fs	base/vpr_types.h	/^	int Fs;$/;"	m	struct:s_det_routing_arch
Fs_seed	base/globals.c	/^int Fs_seed = -1;$/;"	v
GAIN	pack/cluster.c	/^	GAIN, NO_GAIN$/;"	e	enum:e_gain_update	file:
GAUSSIAN	../../libarchfpga/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
GLOBAL	base/vpr_types.h	/^	GLOBAL, DETAILED$/;"	e	enum:e_route_type
GLOBALS_H	base/globals.h	13;"	d
GOT_FROM_SCRATCH	place/place.c	47;"	d	file:
GRAPHICS_H	base/graphics.h	3;"	d
GRAPH_BIDIR	route/rr_graph.h	/^	GRAPH_BIDIR, \/* Detailed bidirectional graph *\/$/;"	e	enum:e_graph_type
GRAPH_GLOBAL	route/rr_graph.h	/^	GRAPH_GLOBAL, \/* One node per channel with wire capacity > 1 and full connectivity *\/$/;"	e	enum:e_graph_type
GRAPH_UNIDIR	route/rr_graph.h	/^	GRAPH_UNIDIR, \/* Detailed unidir graph, untilable *\/$/;"	e	enum:e_graph_type
GRAPH_UNIDIR_TILEABLE	route/rr_graph.h	/^	GRAPH_UNIDIR_TILEABLE \/* Detail unidir graph with wire groups multiples of 2*L *\/$/;"	e	enum:e_graph_type
GREEN	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
Generate_PostSynthesis_Netlist	base/ReadOptions.c	/^static boolean Generate_PostSynthesis_Netlist;$/;"	v	file:
Generate_Post_Synthesis_Netlist	base/ReadOptions.h	/^  boolean Generate_Post_Synthesis_Netlist;$/;"	m	struct:s_options
GetBooleanProperty	../../libarchfpga/read_xml_util.c	/^extern boolean GetBooleanProperty(INP ezxml_t Parent, INP char *Name,$/;"	f
GetFloatProperty	../../libarchfpga/read_xml_util.c	/^extern float GetFloatProperty(INP ezxml_t Parent, INP char *Name,$/;"	f
GetIntProperty	../../libarchfpga/read_xml_util.c	/^extern int GetIntProperty(INP ezxml_t Parent, INP char *Name,$/;"	f
GetNodeTokens	../../libarchfpga/read_xml_util.c	/^GetNodeTokens(INP ezxml_t Node) {$/;"	f
GetPostSynthesisOption	base/ReadOptions.c	/^boolean GetPostSynthesisOption(void){$/;"	f
GetTokenTypeFromChar	util/token.c	/^enum e_token_type GetTokenTypeFromChar(INP enum e_token_type cur_token_type,$/;"	f
GetTokensFromString	util/token.c	/^t_token *GetTokensFromString(INP const char* inString, OUTP int * num_tokens) {$/;"	f
GraphPause	base/ReadOptions.h	/^	int GraphPause;$/;"	m	struct:s_options
GraphPause	base/vpr_types.h	/^	int GraphPause; \/* user interactiveness graphics option *\/$/;"	m	struct:s_vpr_setup
GraphicsWND	base/graphics.c	/^GraphicsWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)$/;"	f	file:
H	../../libarchfpga/include/physical_types.h	/^	int H;$/;"	m	struct:s_clb_grid
HASHSIZE	util/hash.h	1;"	d
HIGHLIGHTED	base/draw.c	/^	ALL_NETS, HIGHLIGHTED$/;"	e	enum:e_draw_net_type	file:
HIGH_FANOUT_NET_LIM	base/vpr_types.h	86;"	d
HILL_CLIMBING	pack/cluster.c	/^	HILL_CLIMBING, NOT_HILL_CLIMBING$/;"	e	enum:e_gain_type	file:
HUGE_NEGATIVE_FLOAT	base/vpr_types.h	80;"	d
HUGE_POSITIVE_FLOAT	base/vpr_types.h	79;"	d
IA	../../libarchfpga/util.c	699;"	d	file:
IC	../../libarchfpga/util.c	700;"	d	file:
IM	../../libarchfpga/util.c	701;"	d	file:
IMPOSSIBLE	place/timing_place_lookup.h	1;"	d
INC_DIRECTION	base/vpr_types.h	/^	INC_DIRECTION = 0, DEC_DIRECTION = 1, BI_DIRECTION = 2$/;"	e	enum:e_direction
INFEASIBLE	pack/cluster.c	/^	FEASIBLE, INFEASIBLE$/;"	e	enum:e_feasibility	file:
INFINITE	base/place_and_route.h	1;"	d
INOUTP	../../libarchfpga/include/util.h	21;"	d
INOUT_PORT	../../libarchfpga/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
INP	../../libarchfpga/include/util.h	19;"	d
INPUT	pack/cluster.c	/^	INPUT, OUTPUT$/;"	e	enum:e_net_relation_to_clustered_block	file:
INPUT2INPUT_INTERC	spice/spice_globals.h	/^ INPUT2INPUT_INTERC, OUTPUT2OUTPUT_INTERC$/;"	e	enum:e_pin2pin_interc_type
INTRA_CLUSTER_EDGE	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
INTRINSIC_DELAY	base/vpr_types.h	/^	INTRINSIC_DELAY, DELAY_NORMALIZED, DEMAND_ONLY$/;"	e	enum:e_base_cost_type
INV_1X_C	power/power.h	/^	float INV_1X_C;$/;"	m	struct:s_power_commonly_used
INV_1X_C_in	power/power.h	/^	float INV_1X_C_in;$/;"	m	struct:s_power_commonly_used
INV_2X_C	power/power.h	/^	float INV_2X_C;$/;"	m	struct:s_power_commonly_used
IN_PORT	../../libarchfpga/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
IO_TYPE	../../libarchfpga/read_xml_arch_file.c	/^static t_type_ptr IO_TYPE = NULL;$/;"	v	file:
IO_TYPE	base/globals.c	/^t_type_ptr IO_TYPE = NULL;$/;"	v
IO_TYPE_BACKUP	place/timing_place_lookup.c	/^static t_type_ptr IO_TYPE_BACKUP;$/;"	v	file:
IO_TYPE_INDEX	../../libarchfpga/include/read_xml_arch_file.h	16;"	d
IPIN	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
IPIN_COST_INDEX	base/vpr_types.h	/^	IPIN_COST_INDEX,$/;"	e	enum:e_cost_indices
InEventLoop	base/graphics.c	/^static boolean InEventLoop = FALSE;$/;"	v	file:
InitSpice	../../libarchfpga/read_xml_spice_util.c	/^void InitSpice(t_spice* spice) {$/;"	f
InitSpiceMeasParams	../../libarchfpga/read_xml_spice_util.c	/^void InitSpiceMeasParams(t_spice_meas_params* meas_params) {$/;"	f
InitSpiceParams	../../libarchfpga/read_xml_spice_util.c	/^void InitSpiceParams(t_spice_params* params) {$/;"	f
InitSpiceStimulateParams	../../libarchfpga/read_xml_spice_util.c	/^void InitSpiceStimulateParams(t_spice_stimulate_params* stimulate_params) {$/;"	f
IsAuto	../../libarchfpga/include/physical_types.h	/^	boolean IsAuto;$/;"	m	struct:s_clb_grid
IsEchoEnabled	base/ReadOptions.c	/^boolean IsEchoEnabled(INP t_options *Options) {$/;"	f
IsPostSynthesisEnabled	base/ReadOptions.c	/^boolean IsPostSynthesisEnabled(INP t_options *Options) {$/;"	f
IsTimingEnabled	base/ReadOptions.c	/^boolean IsTimingEnabled(INP t_options *Options) {$/;"	f
IsWhitespace	../../libarchfpga/read_xml_util.c	/^boolean IsWhitespace(char c) {$/;"	f
KHAKI	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
LATCH_CLASS	../../libarchfpga/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
LEAVE_CLUSTERED	pack/cluster.c	/^	REMOVE_CLUSTERED, LEAVE_CLUSTERED$/;"	e	enum:e_removal_policy	file:
LEFT	../../libarchfpga/include/physical_types.h	/^	TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3$/;"	e	enum:e_side
LIGHTBLUE	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
LIGHTGREY	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
LINELENGTH	pack/output_blif.c	18;"	d	file:
LINELENGTH	pack/output_clustering.c	16;"	d	file:
LOGIC_TYPES_H	../../libarchfpga/include/logic_types.h	10;"	d
LONGLINE	route/segment_stats.c	9;"	d	file:
LUT_CLASS	../../libarchfpga/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
LUT_transistor_size	../../libarchfpga/include/physical_types.h	/^	float LUT_transistor_size;$/;"	m	struct:s_power_arch
LookaheadNodeTokens	../../libarchfpga/read_xml_util.c	/^LookaheadNodeTokens(INP ezxml_t Node) {$/;"	f
MAGENTA	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
MAJOR	base/vpr_types.h	73;"	d
MARKED_FRAC	pack/cluster.c	86;"	d	file:
MAXPIXEL	base/graphics.c	202;"	d	file:
MAXPIXEL	base/graphics.c	225;"	d	file:
MAXPTS	base/easygl_constants.h	10;"	d
MAX_ATOM_PARSE	base/read_blif.c	20;"	d	file:
MAX_BLOCK_COLOURS	base/draw.c	21;"	d	file:
MAX_CHANNEL_WIDTH	../../libarchfpga/include/arch_types.h	25;"	d
MAX_FONT_SIZE	base/graphics.c	179;"	d	file:
MAX_INV_TIMING_COST	place/place.c	64;"	d	file:
MAX_LEN	place/place_stats.c	9;"	d	file:
MAX_LOGS	power/power.h	33;"	d
MAX_MOVES_BEFORE_RECOMPUTE	place/place.c	36;"	d	file:
MAX_NUM_TRIES_TO_PLACE_MACROS_RANDOMLY	place/place.c	41;"	d	file:
MAX_SHORT	base/vpr_types.h	75;"	d
MAX_STRING_LEN	util/vpr_utils.c	18;"	d	file:
MAX_X	place/place_stats.c	8;"	d	file:
MEDIUMPURPLE	base/easygl_constants.h	/^TURQUOISE, MEDIUMPURPLE, DARKSLATEBLUE, DARKKHAKI, NUM_COLOR};$/;"	e	enum:color_types
MEMORY_CLASS	../../libarchfpga/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
MINOR	base/vpr_types.h	72;"	d
MINPIXEL	base/graphics.c	203;"	d	file:
MINPIXEL	base/graphics.c	226;"	d	file:
MODEL_INPUT	base/vpr_types.h	289;"	d
MODEL_LATCH	base/vpr_types.h	288;"	d
MODEL_LOGIC	base/vpr_types.h	287;"	d
MODEL_OUTPUT	base/vpr_types.h	290;"	d
MOLECULE_FORCED_PACK	base/vpr_types.h	/^	MOLECULE_SINGLE_ATOM, MOLECULE_FORCED_PACK$/;"	e	enum:e_pack_pattern_molecule_type
MOLECULE_SINGLE_ATOM	base/vpr_types.h	/^	MOLECULE_SINGLE_ATOM, MOLECULE_FORCED_PACK$/;"	e	enum:e_pack_pattern_molecule_type
MONO	../../libarchfpga/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
MRFPGA_H	mrfpga/mrfpga_globals.h	2;"	d
MULTI_BUFFERED	base/vpr_types.h	/^	MULTI_BUFFERED, SINGLE$/;"	e	enum:e_drivers
MUX_INTERC	../../libarchfpga/include/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
MWIDTH	base/graphics.c	177;"	d	file:
MainWND	base/graphics.c	/^MainWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)$/;"	f	file:
MergeOptions	base/ReadOptions.c	/^static void MergeOptions(INOUTP t_options * dest, INP t_options * src, int id)$/;"	f	file:
NDEBUG	base/vpr_types.h	63;"	d
NEGATIVE_EPSILON	base/vpr_types.h	84;"	d
NEM	../../libarchfpga/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
NET_COUNT	place/timing_place_lookup.c	41;"	d	file:
NET_TIMING_DRIVEN_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, NET_TIMING_DRIVEN_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:e_place_algorithm
NET_USED	place/timing_place_lookup.c	45;"	d	file:
NET_USED_SINK_BLOCK	place/timing_place_lookup.c	48;"	d	file:
NET_USED_SOURCE_BLOCK	place/timing_place_lookup.c	47;"	d	file:
NEVER_CLUSTER	base/vpr_types.h	99;"	d
NMOS	power/power.h	/^	NMOS, PMOS$/;"	e	enum:__anon11
NMOS_1X_C_d	power/power.h	/^	float NMOS_1X_C_d;$/;"	m	struct:s_power_commonly_used
NMOS_1X_C_g	power/power.h	/^	float NMOS_1X_C_g;$/;"	m	struct:s_power_commonly_used
NMOS_1X_C_s	power/power.h	/^	float NMOS_1X_C_s;$/;"	m	struct:s_power_commonly_used
NMOS_1X_st_leakage	power/power.h	/^	float NMOS_1X_st_leakage;$/;"	m	struct:s_power_commonly_used
NMOS_2X_st_leakage	power/power.h	/^	float NMOS_2X_st_leakage;$/;"	m	struct:s_power_commonly_used
NMOS_inf	power/power.h	/^	t_transistor_inf NMOS_inf;$/;"	m	struct:s_power_tech
NONSPACE	timing/slre.c	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon19	file:
NORMAL	place/place.c	/^	NORMAL, CHECK$/;"	e	enum:cost_methods	file:
NOT_FOUND	base/place_and_route.h	2;"	d
NOT_HILL_CLIMBING	pack/cluster.c	/^	HILL_CLIMBING, NOT_HILL_CLIMBING$/;"	e	enum:e_gain_type	file:
NOT_UPDATED_YET	place/place.c	45;"	d	file:
NOT_VALID	base/vpr_types.h	100;"	d
NO_CLUSTER	base/vpr_types.h	98;"	d
NO_FIXED_CHANNEL_WIDTH	base/vpr_types.h	719;"	d
NO_GAIN	pack/cluster.c	/^	GAIN, NO_GAIN$/;"	e	enum:e_gain_update	file:
NO_GRAPHICS	base/vpr_types.h	62;"	d
NO_PICTURE	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:pic_type
NO_PREVIOUS	base/vpr_types.h	919;"	d
NO_ROUTE_THROUGHS	route/route_tree_timing.c	255;"	d	file:
NO_TIMING	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:e_router_algorithm
NUM_BUCKETS	timing/path_delay.c	148;"	d	file:
NUM_COLOR	base/easygl_constants.h	/^TURQUOISE, MEDIUMPURPLE, DARKSLATEBLUE, DARKKHAKI, NUM_COLOR};$/;"	e	enum:color_types
NUM_FONT_TYPES	base/graphics.c	2781;"	d	file:
NUM_MODELS_IN_LIBRARY	../../libarchfpga/include/read_xml_arch_file.h	14;"	d
NUM_RR_TYPES	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
NUM_TYPES_USED	place/timing_place_lookup.c	59;"	d	file:
NetFile	base/ReadOptions.h	/^	char *NetFile;$/;"	m	struct:s_options
NetFile	base/vpr_types.h	/^	char *NetFile;$/;"	m	struct:s_file_name_opts
OFF	base/graphics.c	1362;"	d	file:
ON	base/graphics.c	1363;"	d	file:
OPEN	../../libarchfpga/include/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
OPEN	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
OPIN	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
OPIN_COST_INDEX	base/vpr_types.h	/^	OPIN_COST_INDEX,$/;"	e	enum:e_cost_indices
OPTIONTOKENS_H	base/OptionTokens.h	2;"	d
OT_ACC_FAC	base/OptionTokens.h	/^	OT_ACC_FAC,$/;"	e	enum:e_OptionBaseToken
OT_ACTIVITY_FILE	base/OptionTokens.h	/^	OT_ACTIVITY_FILE,$/;"	e	enum:e_OptionBaseToken
OT_ALLOW_EARLY_EXIT	base/OptionTokens.h	/^	OT_ALLOW_EARLY_EXIT,$/;"	e	enum:e_OptionBaseToken
OT_ALLOW_UNRELATED_CLUSTERING	base/OptionTokens.h	/^	OT_ALLOW_UNRELATED_CLUSTERING,$/;"	e	enum:e_OptionBaseToken
OT_ALPHA_CLUSTERING	base/OptionTokens.h	/^	OT_ALPHA_CLUSTERING,$/;"	e	enum:e_OptionBaseToken
OT_ALPHA_T	base/OptionTokens.h	/^	OT_ALPHA_T,$/;"	e	enum:e_OptionBaseToken
OT_ARG_UNKNOWN	base/OptionTokens.h	/^	OT_ARG_UNKNOWN \/* Must be last since used for counting enum items *\/$/;"	e	enum:e_OptionArgToken
OT_ASTAR_FAC	base/OptionTokens.h	/^	OT_ASTAR_FAC,$/;"	e	enum:e_OptionBaseToken
OT_AUTO	base/OptionTokens.h	/^	OT_AUTO,$/;"	e	enum:e_OptionBaseToken
OT_BASE_COST_TYPE	base/OptionTokens.h	/^	OT_BASE_COST_TYPE,$/;"	e	enum:e_OptionBaseToken
OT_BASE_UNKNOWN	base/OptionTokens.h	/^	OT_BASE_UNKNOWN \/* Must be last since used for counting enum items *\/$/;"	e	enum:e_OptionBaseToken
OT_BB_FACTOR	base/OptionTokens.h	/^	OT_BB_FACTOR,$/;"	e	enum:e_OptionBaseToken
OT_BEND_COST	base/OptionTokens.h	/^	OT_BEND_COST,$/;"	e	enum:e_OptionBaseToken
OT_BETA_CLUSTERING	base/OptionTokens.h	/^	OT_BETA_CLUSTERING,$/;"	e	enum:e_OptionBaseToken
OT_BLIF_FILE	base/OptionTokens.h	/^	OT_BLIF_FILE,$/;"	e	enum:e_OptionBaseToken
OT_BLOCK_DIST	base/OptionTokens.h	/^	OT_BLOCK_DIST,$/;"	e	enum:e_OptionBaseToken
OT_BOUNDING_BOX	base/OptionTokens.h	/^	OT_BOUNDING_BOX,$/;"	e	enum:e_OptionArgToken
OT_BREADTH_FIRST	base/OptionTokens.h	/^	OT_BREADTH_FIRST,$/;"	e	enum:e_OptionArgToken
OT_BRUTE_FORCE	base/OptionTokens.h	/^	OT_BRUTE_FORCE,$/;"	e	enum:e_OptionArgToken
OT_CLUSTER_BLOCK_DELAY	base/OptionTokens.h	/^	OT_CLUSTER_BLOCK_DELAY,$/;"	e	enum:e_OptionBaseToken
OT_CLUSTER_SEED	base/OptionTokens.h	/^	OT_CLUSTER_SEED,$/;"	e	enum:e_OptionBaseToken
OT_CMOS_TECH_BEHAVIOR_FILE	base/OptionTokens.h	/^	OT_CMOS_TECH_BEHAVIOR_FILE,$/;"	e	enum:e_OptionBaseToken
OT_CONNECTION_DRIVEN_CLUSTERING	base/OptionTokens.h	/^	OT_CONNECTION_DRIVEN_CLUSTERING,$/;"	e	enum:e_OptionBaseToken
OT_CREATE_ECHO_FILE	base/OptionTokens.h	/^	OT_CREATE_ECHO_FILE,$/;"	e	enum:e_OptionBaseToken
OT_CRITICALITY_EXP	base/OptionTokens.h	/^	OT_CRITICALITY_EXP,$/;"	e	enum:e_OptionBaseToken
OT_DELAY_NORMALIZED	base/OptionTokens.h	/^	OT_DELAY_NORMALIZED,$/;"	e	enum:e_OptionArgToken
OT_DEMAND_ONLY	base/OptionTokens.h	/^	OT_DEMAND_ONLY,$/;"	e	enum:e_OptionArgToken
OT_DETAILED	base/OptionTokens.h	/^	OT_DETAILED,$/;"	e	enum:e_OptionArgToken
OT_ENABLE_TIMING_COMPUTATIONS	base/OptionTokens.h	/^	OT_ENABLE_TIMING_COMPUTATIONS,$/;"	e	enum:e_OptionBaseToken
OT_EXIT_T	base/OptionTokens.h	/^	OT_EXIT_T,$/;"	e	enum:e_OptionBaseToken
OT_FAST	base/OptionTokens.h	/^	OT_FAST,$/;"	e	enum:e_OptionBaseToken
OT_FIRST_ITER_PRES_FAC	base/OptionTokens.h	/^	OT_FIRST_ITER_PRES_FAC,$/;"	e	enum:e_OptionBaseToken
OT_FIX_PINS	base/OptionTokens.h	/^	OT_FIX_PINS,$/;"	e	enum:e_OptionBaseToken
OT_FPGA_SPICE	base/OptionTokens.h	/^    OT_FPGA_SPICE, \/* Xifan TANG: FPGA SPICE Model Support *\/$/;"	e	enum:e_OptionBaseToken
OT_FPGA_SPICE_LEAKAGE_ONLY	base/OptionTokens.h	/^    OT_FPGA_SPICE_LEAKAGE_ONLY, \/* Xifan TANG: Print SPICE Testbench for MUXes *\/$/;"	e	enum:e_OptionBaseToken
OT_FULL_STATS	base/OptionTokens.h	/^	OT_FULL_STATS,$/;"	e	enum:e_OptionBaseToken
OT_GENERATE_POST_SYNTHESIS_NETLIST	base/OptionTokens.h	/^	OT_GENERATE_POST_SYNTHESIS_NETLIST,$/;"	e	enum:e_OptionBaseToken
OT_GLOBAL	base/OptionTokens.h	/^	OT_GLOBAL,$/;"	e	enum:e_OptionArgToken
OT_GLOBAL_CLOCKS	base/OptionTokens.h	/^	OT_GLOBAL_CLOCKS,$/;"	e	enum:e_OptionBaseToken
OT_GREEDY	base/OptionTokens.h	/^	OT_GREEDY,$/;"	e	enum:e_OptionArgToken
OT_HILL_CLIMBING_FLAG	base/OptionTokens.h	/^	OT_HILL_CLIMBING_FLAG,$/;"	e	enum:e_OptionBaseToken
OT_INITIAL_PRES_FAC	base/OptionTokens.h	/^	OT_INITIAL_PRES_FAC,$/;"	e	enum:e_OptionBaseToken
OT_INIT_T	base/OptionTokens.h	/^	OT_INIT_T,$/;"	e	enum:e_OptionBaseToken
OT_INNER_LOOP_RECOMPUTE_DIVIDER	base/OptionTokens.h	/^	OT_INNER_LOOP_RECOMPUTE_DIVIDER,$/;"	e	enum:e_OptionBaseToken
OT_INNER_NUM	base/OptionTokens.h	/^	OT_INNER_NUM,$/;"	e	enum:e_OptionBaseToken
OT_INTER_CLUSTER_NET_DELAY	base/OptionTokens.h	/^	OT_INTER_CLUSTER_NET_DELAY,$/;"	e	enum:e_OptionBaseToken
OT_INTRA_CLUSTER_NET_DELAY	base/OptionTokens.h	/^	OT_INTRA_CLUSTER_NET_DELAY,$/;"	e	enum:e_OptionBaseToken
OT_INTRINSIC_DELAY	base/OptionTokens.h	/^	OT_INTRINSIC_DELAY,$/;"	e	enum:e_OptionArgToken
OT_LP	base/OptionTokens.h	/^	OT_LP,$/;"	e	enum:e_OptionArgToken
OT_MAX_CRITICALITY	base/OptionTokens.h	/^	OT_MAX_CRITICALITY,$/;"	e	enum:e_OptionBaseToken
OT_MAX_INPUTS	base/OptionTokens.h	/^	OT_MAX_INPUTS,$/;"	e	enum:e_OptionArgToken
OT_MAX_ROUTER_ITERATIONS	base/OptionTokens.h	/^	OT_MAX_ROUTER_ITERATIONS,$/;"	e	enum:e_OptionBaseToken
OT_NET_FILE	base/OptionTokens.h	/^	OT_NET_FILE,$/;"	e	enum:e_OptionBaseToken
OT_NET_TIMING_DRIVEN	base/OptionTokens.h	/^	OT_NET_TIMING_DRIVEN,$/;"	e	enum:e_OptionArgToken
OT_NODISP	base/OptionTokens.h	/^	OT_NODISP,$/;"	e	enum:e_OptionBaseToken
OT_NO_TIMING	base/OptionTokens.h	/^	OT_NO_TIMING,$/;"	e	enum:e_OptionArgToken
OT_OFF	base/OptionTokens.h	/^	OT_OFF,$/;"	e	enum:e_OptionArgToken
OT_ON	base/OptionTokens.h	/^	OT_ON,$/;"	e	enum:e_OptionArgToken
OT_OUTFILE_PREFIX	base/OptionTokens.h	/^	OT_OUTFILE_PREFIX,$/;"	e	enum:e_OptionBaseToken
OT_PACK	base/OptionTokens.h	/^	OT_PACK,$/;"	e	enum:e_OptionBaseToken
OT_PACKER_ALGORITHM	base/OptionTokens.h	/^	OT_PACKER_ALGORITHM,$/;"	e	enum:e_OptionBaseToken
OT_PACK_CLB_PIN_REMAP	base/OptionTokens.h	/^    OT_PACK_CLB_PIN_REMAP,$/;"	e	enum:e_OptionBaseToken
OT_PATH_TIMING_DRIVEN	base/OptionTokens.h	/^	OT_PATH_TIMING_DRIVEN,$/;"	e	enum:e_OptionArgToken
OT_PLACE	base/OptionTokens.h	/^	OT_PLACE,$/;"	e	enum:e_OptionBaseToken
OT_PLACE_ALGORITHM	base/OptionTokens.h	/^	OT_PLACE_ALGORITHM,$/;"	e	enum:e_OptionBaseToken
OT_PLACE_CHAN_WIDTH	base/OptionTokens.h	/^	OT_PLACE_CHAN_WIDTH,$/;"	e	enum:e_OptionBaseToken
OT_PLACE_CLB_PIN_REMAP	base/OptionTokens.h	/^    OT_PLACE_CLB_PIN_REMAP,$/;"	e	enum:e_OptionBaseToken
OT_PLACE_COST_EXP	base/OptionTokens.h	/^	OT_PLACE_COST_EXP,$/;"	e	enum:e_OptionBaseToken
OT_PLACE_FILE	base/OptionTokens.h	/^	OT_PLACE_FILE,$/;"	e	enum:e_OptionBaseToken
OT_POWER	base/OptionTokens.h	/^	OT_POWER,$/;"	e	enum:e_OptionBaseToken
OT_POWER_OUT_FILE	base/OptionTokens.h	/^	OT_POWER_OUT_FILE,$/;"	e	enum:e_OptionBaseToken
OT_PRES_FAC_MULT	base/OptionTokens.h	/^	OT_PRES_FAC_MULT,$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_CB_MUX_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_CB_MUX_TESTBENCH, \/* Xifan TANG: Print SPICE Testbench for MUXes *\/$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_DFF_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_DFF_TESTBENCH, \/* Xifan TANG: Print SPICE Testbench for FFs *\/$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_GRID_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_GRID_TESTBENCH, \/* Xifan TANG: Print SPICE Testbench for Grids *\/$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_LUT_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_LUT_TESTBENCH, \/* Xifan TANG: Print SPICE Testbench for LUTs *\/$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_PB_MUX_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_PB_MUX_TESTBENCH, \/* Xifan TANG: Print SPICE Testbench for MUXes *\/$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_SB_MUX_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_SB_MUX_TESTBENCH, \/* Xifan TANG: Print SPICE Testbench for MUXes *\/$/;"	e	enum:e_OptionBaseToken
OT_PRINT_SPICE_TOP_TESTBENCH	base/OptionTokens.h	/^    OT_PRINT_SPICE_TOP_TESTBENCH, \/* Xifan TANG: Print Top-level SPICE Testbench *\/$/;"	e	enum:e_OptionBaseToken
OT_RANDOM	base/OptionTokens.h	/^	OT_RANDOM,$/;"	e	enum:e_OptionArgToken
OT_READ_PLACE_ONLY	base/OptionTokens.h	/^	OT_READ_PLACE_ONLY,$/;"	e	enum:e_OptionBaseToken
OT_RECOMPUTE_CRIT_ITER	base/OptionTokens.h	/^	OT_RECOMPUTE_CRIT_ITER,$/;"	e	enum:e_OptionBaseToken
OT_RECOMPUTE_TIMING_AFTER	base/OptionTokens.h	/^	OT_RECOMPUTE_TIMING_AFTER,$/;"	e	enum:e_OptionBaseToken
OT_ROUTE	base/OptionTokens.h	/^	OT_ROUTE,$/;"	e	enum:e_OptionBaseToken
OT_ROUTER_ALGORITHM	base/OptionTokens.h	/^	OT_ROUTER_ALGORITHM,$/;"	e	enum:e_OptionBaseToken
OT_ROUTE_CHAN_WIDTH	base/OptionTokens.h	/^	OT_ROUTE_CHAN_WIDTH,$/;"	e	enum:e_OptionBaseToken
OT_ROUTE_FILE	base/OptionTokens.h	/^	OT_ROUTE_FILE,$/;"	e	enum:e_OptionBaseToken
OT_ROUTE_TYPE	base/OptionTokens.h	/^	OT_ROUTE_TYPE,$/;"	e	enum:e_OptionBaseToken
OT_SDC_FILE	base/OptionTokens.h	/^	OT_SDC_FILE,$/;"	e	enum:e_OptionBaseToken
OT_SEED	base/OptionTokens.h	/^	OT_SEED,$/;"	e	enum:e_OptionBaseToken
OT_SETTINGS_FILE	base/OptionTokens.h	/^	OT_SETTINGS_FILE,$/;"	e	enum:e_OptionBaseToken
OT_SHOW_PASS_TRANS	base/OptionTokens.h	/^    OT_SHOW_PASS_TRANS,$/;"	e	enum:e_OptionBaseToken
OT_SHOW_SRAM	base/OptionTokens.h	/^    OT_SHOW_SRAM,$/;"	e	enum:e_OptionBaseToken
OT_SKIP_CLUSTERING	base/OptionTokens.h	/^	OT_SKIP_CLUSTERING,$/;"	e	enum:e_OptionBaseToken
OT_SPICE_DIR	base/OptionTokens.h	/^    OT_SPICE_DIR, \/* Xifan TANG: FPGA SPICE Model Support *\/$/;"	e	enum:e_OptionBaseToken
OT_SWEEP_HANGING_NETS_AND_INPUTS	base/OptionTokens.h	/^	OT_SWEEP_HANGING_NETS_AND_INPUTS,$/;"	e	enum:e_OptionBaseToken
OT_TD_PLACE_EXP_FIRST	base/OptionTokens.h	/^	OT_TD_PLACE_EXP_FIRST,$/;"	e	enum:e_OptionBaseToken
OT_TD_PLACE_EXP_LAST	base/OptionTokens.h	/^	OT_TD_PLACE_EXP_LAST,$/;"	e	enum:e_OptionBaseToken
OT_TIMING	base/OptionTokens.h	/^	OT_TIMING,$/;"	e	enum:e_OptionArgToken
OT_TIMING_ANALYSIS	base/OptionTokens.h	/^	OT_TIMING_ANALYSIS,$/;"	e	enum:e_OptionBaseToken
OT_TIMING_ANALYZE_ONLY_WITH_NET_DELAY	base/OptionTokens.h	/^	OT_TIMING_ANALYZE_ONLY_WITH_NET_DELAY,$/;"	e	enum:e_OptionBaseToken
OT_TIMING_DRIVEN	base/OptionTokens.h	/^	OT_TIMING_DRIVEN,$/;"	e	enum:e_OptionArgToken
OT_TIMING_DRIVEN_CLUSTERING	base/OptionTokens.h	/^	OT_TIMING_DRIVEN_CLUSTERING,$/;"	e	enum:e_OptionBaseToken
OT_TIMING_TRADEOFF	base/OptionTokens.h	/^	OT_TIMING_TRADEOFF,$/;"	e	enum:e_OptionBaseToken
OT_VERIFY_BINARY_SEARCH	base/OptionTokens.h	/^	OT_VERIFY_BINARY_SEARCH,$/;"	e	enum:e_OptionBaseToken
OUTP	../../libarchfpga/include/util.h	20;"	d
OUTPUT	pack/cluster.c	/^	INPUT, OUTPUT$/;"	e	enum:e_net_relation_to_clustered_block	file:
OUTPUT2OUTPUT_INTERC	spice/spice_globals.h	/^ INPUT2INPUT_INTERC, OUTPUT2OUTPUT_INTERC$/;"	e	enum:e_pin2pin_interc_type
OUT_PORT	../../libarchfpga/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
Operation	base/vpr_types.h	/^	enum e_operation Operation; \/* run VPR or do analysis only *\/$/;"	m	struct:s_vpr_setup	typeref:enum:s_vpr_setup::e_operation
OptionArgTokenList	base/OptionTokens.c	/^struct s_TokenPair OptionArgTokenList[] = { { "on", OT_ON }, { "off", OT_OFF },$/;"	v	typeref:struct:s_TokenPair
OptionBaseTokenList	base/OptionTokens.c	/^struct s_TokenPair OptionBaseTokenList[] = {$/;"	v	typeref:struct:s_TokenPair
PACK_BRUTE_FORCE	base/vpr_types.h	/^	PACK_GREEDY, PACK_BRUTE_FORCE$/;"	e	enum:e_packer_algorithm
PACK_GREEDY	base/vpr_types.h	/^	PACK_GREEDY, PACK_BRUTE_FORCE$/;"	e	enum:e_packer_algorithm
PACK_PATH_WEIGHT	timing/path_delay.h	34;"	d
PALCE_MACRO_H	place/place_macro.h	136;"	d
PATH_DELAY	timing/path_delay.h	2;"	d
PATH_TIMING_DRIVEN_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, NET_TIMING_DRIVEN_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:e_place_algorithm
PB_PIN_CLOCK	../../libarchfpga/include/physical_types.h	/^	PB_PIN_CLOCK$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_INPAD	../../libarchfpga/include/physical_types.h	/^	PB_PIN_INPAD,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_NORMAL	../../libarchfpga/include/physical_types.h	/^	PB_PIN_NORMAL = 0,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_OUTPAD	../../libarchfpga/include/physical_types.h	/^	PB_PIN_OUTPAD,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_SEQUENTIAL	../../libarchfpga/include/physical_types.h	/^	PB_PIN_SEQUENTIAL,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_TERMINAL	../../libarchfpga/include/physical_types.h	/^	PB_PIN_TERMINAL,$/;"	e	enum:e_pb_graph_pin_type
PB_TYPE_GRAPH_ANNOTATIONS_H	pack/pb_type_graph_annotations.h	8;"	d
PB_TYPE_GRAPH_H	pack/pb_type_graph.h	2;"	d
PCRAM_Pierre	../../libarchfpga/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
PCRAM_Xie	../../libarchfpga/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
PHYSICAL_TYPES_H	../../libarchfpga/include/physical_types.h	27;"	d
PI	base/graphics.c	181;"	d	file:
PLACEMENT	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:pic_type
PLACE_ALWAYS	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:pfreq
PLACE_NEVER	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:pfreq
PLACE_ONCE	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:pfreq
PLACE_PATH_WEIGHT	timing/path_delay.h	36;"	d
PLUM	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
PLUS	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
PLUSQ	timing/slre.c	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon19	file:
PMOS	power/power.h	/^	NMOS, PMOS$/;"	e	enum:__anon11
PMOS_1X_C_d	power/power.h	/^	float PMOS_1X_C_d;$/;"	m	struct:s_power_commonly_used
PMOS_1X_C_g	power/power.h	/^	float PMOS_1X_C_g;$/;"	m	struct:s_power_commonly_used
PMOS_1X_C_s	power/power.h	/^	float PMOS_1X_C_s;$/;"	m	struct:s_power_commonly_used
PMOS_1X_st_leakage	power/power.h	/^	float PMOS_1X_st_leakage;$/;"	m	struct:s_power_commonly_used
PMOS_2X_st_leakage	power/power.h	/^	float PMOS_2X_st_leakage;$/;"	m	struct:s_power_commonly_used
PMOS_inf	power/power.h	/^	t_transistor_inf PMOS_inf;$/;"	m	struct:s_power_tech
PN_ratio	power/power.h	/^	float PN_ratio; \/* Ratio of PMOS to NMOS in inverter *\/$/;"	m	struct:s_power_tech
PORTS	../../libarchfpga/include/logic_types.h	/^enum PORTS {$/;"	g
POSTSCRIPT	base/graphics.c	/^   POSTSCRIPT = 1$/;"	e	enum:__anon2	file:
POWER_BREAKDOWN_ENTRY_TYPE_BUFS_WIRES	power/power.c	/^	POWER_BREAKDOWN_ENTRY_TYPE_BUFS_WIRES$/;"	e	enum:__anon8	file:
POWER_BREAKDOWN_ENTRY_TYPE_COMPONENT	power/power.c	/^	POWER_BREAKDOWN_ENTRY_TYPE_COMPONENT,$/;"	e	enum:__anon8	file:
POWER_BREAKDOWN_ENTRY_TYPE_INTERC	power/power.c	/^	POWER_BREAKDOWN_ENTRY_TYPE_INTERC,$/;"	e	enum:__anon8	file:
POWER_BREAKDOWN_ENTRY_TYPE_MODE	power/power.c	/^	POWER_BREAKDOWN_ENTRY_TYPE_MODE,$/;"	e	enum:__anon8	file:
POWER_BREAKDOWN_ENTRY_TYPE_PB	power/power.c	/^	POWER_BREAKDOWN_ENTRY_TYPE_PB,$/;"	e	enum:__anon8	file:
POWER_BREAKDOWN_ENTRY_TYPE_TITLE	power/power.c	/^	POWER_BREAKDOWN_ENTRY_TYPE_TITLE = 0,$/;"	e	enum:__anon8	file:
POWER_BUFFER_TYPE_ABSOLUTE_SIZE	../../libarchfpga/include/physical_types.h	/^	POWER_BUFFER_TYPE_ABSOLUTE_SIZE$/;"	e	enum:__anon21
POWER_BUFFER_TYPE_AUTO	../../libarchfpga/include/physical_types.h	/^	POWER_BUFFER_TYPE_AUTO,$/;"	e	enum:__anon21
POWER_BUFFER_TYPE_NONE	../../libarchfpga/include/physical_types.h	/^	POWER_BUFFER_TYPE_NONE,$/;"	e	enum:__anon21
POWER_BUFFER_TYPE_UNDEFINED	../../libarchfpga/include/physical_types.h	/^	POWER_BUFFER_TYPE_UNDEFINED = 0,$/;"	e	enum:__anon21
POWER_CALLIB_COMPONENT_BUFFER	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_BUFFER = 0,$/;"	e	enum:__anon12
POWER_CALLIB_COMPONENT_BUFFER_WITH_LEVR	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_BUFFER_WITH_LEVR,$/;"	e	enum:__anon12
POWER_CALLIB_COMPONENT_FF	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_FF,$/;"	e	enum:__anon12
POWER_CALLIB_COMPONENT_LUT	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_LUT,$/;"	e	enum:__anon12
POWER_CALLIB_COMPONENT_MAX	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_MAX$/;"	e	enum:__anon12
POWER_CALLIB_COMPONENT_MUX	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_MUX,$/;"	e	enum:__anon12
POWER_COMPONENT_CLOCK	power/power_components.h	/^	POWER_COMPONENT_CLOCK, \/* Clock network *\/$/;"	e	enum:__anon13
POWER_COMPONENT_CLOCK_BUFFER	power/power_components.h	/^	POWER_COMPONENT_CLOCK_BUFFER, \/* Buffers in clock network *\/$/;"	e	enum:__anon13
POWER_COMPONENT_CLOCK_WIRE	power/power_components.h	/^	POWER_COMPONENT_CLOCK_WIRE, \/* Wires in clock network *\/$/;"	e	enum:__anon13
POWER_COMPONENT_IGNORE	power/power_components.h	/^	POWER_COMPONENT_IGNORE = 0, \/* *\/$/;"	e	enum:__anon13
POWER_COMPONENT_MAX_NUM	power/power_components.h	/^	POWER_COMPONENT_MAX_NUM$/;"	e	enum:__anon13
POWER_COMPONENT_PB	power/power_components.h	/^	POWER_COMPONENT_PB, \/* Logic Blocks, and other hard blocks *\/$/;"	e	enum:__anon13
POWER_COMPONENT_PB_BUFS_WIRE	power/power_components.h	/^	POWER_COMPONENT_PB_BUFS_WIRE, \/* Local buffers and wire capacitance *\/$/;"	e	enum:__anon13
POWER_COMPONENT_PB_INTERC_MUXES	power/power_components.h	/^	POWER_COMPONENT_PB_INTERC_MUXES, \/* Local interconnect structures (muxes) *\/$/;"	e	enum:__anon13
POWER_COMPONENT_PB_OTHER	power/power_components.h	/^	POWER_COMPONENT_PB_OTHER, \/* Power from other estimation methods - not transistor-level *\/$/;"	e	enum:__anon13
POWER_COMPONENT_PB_PRIMITIVES	power/power_components.h	/^	POWER_COMPONENT_PB_PRIMITIVES, \/* Primitives (LUTs, FF, etc) *\/$/;"	e	enum:__anon13
POWER_COMPONENT_ROUTE_CB	power/power_components.h	/^	POWER_COMPONENT_ROUTE_CB, \/* Connection box*\/$/;"	e	enum:__anon13
POWER_COMPONENT_ROUTE_GLB_WIRE	power/power_components.h	/^	POWER_COMPONENT_ROUTE_GLB_WIRE, \/* Wires *\/$/;"	e	enum:__anon13
POWER_COMPONENT_ROUTE_SB	power/power_components.h	/^	POWER_COMPONENT_ROUTE_SB, \/* Switch-box *\/$/;"	e	enum:__anon13
POWER_COMPONENT_ROUTING	power/power_components.h	/^	POWER_COMPONENT_ROUTING, \/* Power for routing fabric (not local routing) *\/$/;"	e	enum:__anon13
POWER_COMPONENT_TOTAL	power/power_components.h	/^	POWER_COMPONENT_TOTAL, \/* Total power for entire FPGA *\/$/;"	e	enum:__anon13
POWER_DRC_MIN_DIFF_L	power/power_sizing.h	34;"	d
POWER_DRC_MIN_L	power/power_sizing.h	32;"	d
POWER_DRC_MIN_W	power/power_sizing.h	33;"	d
POWER_DRC_POLY_OVERHANG	power/power_sizing.h	36;"	d
POWER_DRC_SPACING	power/power_sizing.h	35;"	d
POWER_LOG_ERROR	power/power.h	/^	POWER_LOG_ERROR, POWER_LOG_WARNING, POWER_LOG_NUM_TYPES$/;"	e	enum:__anon10
POWER_LOG_NUM_TYPES	power/power.h	/^	POWER_LOG_ERROR, POWER_LOG_WARNING, POWER_LOG_NUM_TYPES$/;"	e	enum:__anon10
POWER_LOG_WARNING	power/power.h	/^	POWER_LOG_ERROR, POWER_LOG_WARNING, POWER_LOG_NUM_TYPES$/;"	e	enum:__anon10
POWER_LUT_SLOW	power/power_components.h	37;"	d
POWER_LUT_SLOW	power/power_components.h	39;"	d
POWER_METHOD_ABSOLUTE	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_ABSOLUTE \/* Dynamic: Aboslute, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_AUTO_SIZES	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_AUTO_SIZES, \/* Transistor-level, auto-sized buffers\/wires *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_C_INTERNAL	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_C_INTERNAL, \/* Dynamic: Equiv. Internal capacitance, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_IGNORE	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_UNDEFINED = 0, POWER_METHOD_IGNORE, \/* Ignore power of this PB, and all children PB *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_SPECIFY_SIZES	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_SPECIFY_SIZES, \/* Transistor-level, user-specified buffers\/wires *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_SUM_OF_CHILDREN	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_SUM_OF_CHILDREN, \/* Ignore power of this PB, but consider children *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_TOGGLE_PINS	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_TOGGLE_PINS, \/* Dynamic: Energy per pin toggle, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_UNDEFINED	../../libarchfpga/include/physical_types.h	/^	POWER_METHOD_UNDEFINED = 0, POWER_METHOD_IGNORE, \/* Ignore power of this PB, and all children PB *\/$/;"	e	enum:e_power_estimation_method_
POWER_MTA_L	power/power_sizing.h	39;"	d
POWER_MTA_W	power/power_sizing.h	38;"	d
POWER_RET_CODE_ERRORS	power/power.h	/^	POWER_RET_CODE_SUCCESS = 0, POWER_RET_CODE_ERRORS, POWER_RET_CODE_WARNINGS$/;"	e	enum:__anon9
POWER_RET_CODE_SUCCESS	power/power.h	/^	POWER_RET_CODE_SUCCESS = 0, POWER_RET_CODE_ERRORS, POWER_RET_CODE_WARNINGS$/;"	e	enum:__anon9
POWER_RET_CODE_WARNINGS	power/power.h	/^	POWER_RET_CODE_SUCCESS = 0, POWER_RET_CODE_ERRORS, POWER_RET_CODE_WARNINGS$/;"	e	enum:__anon9
POWER_WIRE_TYPE_ABSOLUTE_LENGTH	../../libarchfpga/include/physical_types.h	/^	POWER_WIRE_TYPE_ABSOLUTE_LENGTH,$/;"	e	enum:__anon20
POWER_WIRE_TYPE_AUTO	../../libarchfpga/include/physical_types.h	/^	POWER_WIRE_TYPE_AUTO$/;"	e	enum:__anon20
POWER_WIRE_TYPE_C	../../libarchfpga/include/physical_types.h	/^	POWER_WIRE_TYPE_C,$/;"	e	enum:__anon20
POWER_WIRE_TYPE_IGNORED	../../libarchfpga/include/physical_types.h	/^	POWER_WIRE_TYPE_IGNORED,$/;"	e	enum:__anon20
POWER_WIRE_TYPE_RELATIVE_LENGTH	../../libarchfpga/include/physical_types.h	/^	POWER_WIRE_TYPE_RELATIVE_LENGTH,$/;"	e	enum:__anon20
POWER_WIRE_TYPE_UNDEFINED	../../libarchfpga/include/physical_types.h	/^	POWER_WIRE_TYPE_UNDEFINED = 0,$/;"	e	enum:__anon20
PREPACK_H	pack/prepack.h	8;"	d
PROC_TIME	base/place_and_route.h	6;"	d
PTRANS_FLAG	route/check_rr_graph.c	15;"	d	file:
PULSE	../../libarchfpga/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
PackerOpts	base/vpr_types.h	/^	struct s_packer_opts PackerOpts; \/* Options for packer *\/$/;"	m	struct:s_vpr_setup	typeref:struct:s_vpr_setup::s_packer_opts
PinFile	base/ReadOptions.h	/^	char *PinFile;$/;"	m	struct:s_options
PlaceAlgorithm	base/ReadOptions.h	/^	enum e_place_algorithm PlaceAlgorithm;$/;"	m	struct:s_options	typeref:enum:s_options::e_place_algorithm
PlaceAlphaT	base/ReadOptions.h	/^	float PlaceAlphaT;$/;"	m	struct:s_options
PlaceChanWidth	base/ReadOptions.h	/^	int PlaceChanWidth;$/;"	m	struct:s_options
PlaceExitT	base/ReadOptions.h	/^	float PlaceExitT;$/;"	m	struct:s_options
PlaceFile	base/ReadOptions.h	/^	char *PlaceFile;$/;"	m	struct:s_options
PlaceFile	base/vpr_types.h	/^	char *PlaceFile;$/;"	m	struct:s_file_name_opts
PlaceInitT	base/ReadOptions.h	/^	float PlaceInitT;$/;"	m	struct:s_options
PlaceInnerNum	base/ReadOptions.h	/^	float PlaceInnerNum;$/;"	m	struct:s_options
PlaceTimingTradeoff	base/ReadOptions.h	/^	float PlaceTimingTradeoff;$/;"	m	struct:s_options
PlacerOpts	base/vpr_types.h	/^	struct s_placer_opts PlacerOpts; \/* Options for placer *\/$/;"	m	struct:s_vpr_setup	typeref:struct:s_vpr_setup::s_placer_opts
PowerCallibInputs	power/PowerSpicedComponent.c	/^PowerCallibInputs::PowerCallibInputs(PowerSpicedComponent * parent_,$/;"	f	class:PowerCallibInputs
PowerCallibInputs	power/PowerSpicedComponent.h	/^class PowerCallibInputs {$/;"	c
PowerCallibSize	power/PowerSpicedComponent.h	/^	PowerCallibSize(float size, float power_) :$/;"	f	class:PowerCallibSize
PowerCallibSize	power/PowerSpicedComponent.h	/^class PowerCallibSize {$/;"	c
PowerFile	base/ReadOptions.h	/^	char *PowerFile;$/;"	m	struct:s_options
PowerFile	base/vpr_types.h	/^	char *PowerFile;$/;"	m	struct:s_file_name_opts
PowerOpts	base/vpr_types.h	/^	t_power_opts PowerOpts;$/;"	m	struct:s_vpr_setup
PowerSpicedComponent	power/PowerSpicedComponent.c	/^PowerSpicedComponent::PowerSpicedComponent($/;"	f	class:PowerSpicedComponent
PowerSpicedComponent	power/PowerSpicedComponent.h	/^class PowerSpicedComponent {$/;"	c
PrintPb_types_rec	../../libarchfpga/read_xml_arch_file.c	/^static void PrintPb_types_rec(INP FILE * Echo, INP const t_pb_type * pb_type,$/;"	f	file:
ProceedPressed	base/graphics.c	/^static int ProceedPressed;$/;"	v	file:
ProcessCB_SB	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessCB_SB(INOUTP ezxml_t Node, INOUTP boolean * list,$/;"	f	file:
ProcessChanWidthDistr	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessChanWidthDistr(INOUTP ezxml_t Node,$/;"	f	file:
ProcessChanWidthDistrDir	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessChanWidthDistrDir(INOUTP ezxml_t Node, OUTP t_chan * chan) {$/;"	f	file:
ProcessClocks	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessClocks(ezxml_t Parent, t_clock_arch * clocks) {$/;"	f	file:
ProcessComplexBlockProps	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessComplexBlockProps(ezxml_t Node, t_type_descriptor * Type) {$/;"	f	file:
ProcessComplexBlocks	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessComplexBlocks(INOUTP ezxml_t Node,$/;"	f	file:
ProcessDevice	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessDevice(INOUTP ezxml_t Node, OUTP struct s_arch *arch,$/;"	f	file:
ProcessDirects	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessDirects(INOUTP ezxml_t Parent, OUTP t_direct_inf **Directs,$/;"	f	file:
ProcessInterconnect	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessInterconnect(INOUTP ezxml_t Parent, t_mode * mode) {$/;"	f	file:
ProcessLayout	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessLayout(INOUTP ezxml_t Node, OUTP struct s_arch *arch) {$/;"	f	file:
ProcessLutClass	../../libarchfpga/read_xml_arch_file.c	/^void ProcessLutClass(INOUTP t_pb_type *lut_pb_type) {$/;"	f
ProcessMemoryClass	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessMemoryClass(INOUTP t_pb_type *mem_pb_type) {$/;"	f	file:
ProcessMode	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessMode(INOUTP ezxml_t Parent, t_mode * mode,$/;"	f	file:
ProcessModels	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessModels(INOUTP ezxml_t Node, OUTP struct s_arch *arch) {$/;"	f	file:
ProcessMrFPGATiming	../../libarchfpga/read_xml_mrfpga.c	/^void ProcessMrFPGATiming(INOUTP ezxml_t Cur, $/;"	f
ProcessOption	base/ReadOptions.c	/^ProcessOption(INP char **Args, INOUTP t_options * Options) {$/;"	f	file:
ProcessPb_Type	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPb_Type(INOUTP ezxml_t Parent, t_pb_type * pb_type,$/;"	f	file:
ProcessPb_TypePort	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPb_TypePort(INOUTP ezxml_t Parent, t_port * port,$/;"	f	file:
ProcessPb_TypePort_Power	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPb_TypePort_Power(ezxml_t Parent, t_port * port,$/;"	f	file:
ProcessPb_TypePower	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPb_TypePower(ezxml_t Parent, t_pb_type * pb_type) {$/;"	f	file:
ProcessPb_TypePowerEstMethod	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPb_TypePowerEstMethod(ezxml_t Parent, t_pb_type * pb_type) {$/;"	f	file:
ProcessPb_TypePowerPinToggle	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPb_TypePowerPinToggle(ezxml_t parent, t_pb_type * pb_type) {$/;"	f	file:
ProcessPinToPinAnnotations	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPinToPinAnnotations(ezxml_t Parent,$/;"	f	file:
ProcessPower	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessPower( INOUTP ezxml_t parent,$/;"	f	file:
ProcessSegments	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessSegments(INOUTP ezxml_t Parent,$/;"	f	file:
ProcessSpiceMeasParams	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceMeasParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceModel	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceModel(ezxml_t Parent,$/;"	f	file:
ProcessSpiceModelBuffer	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceModelBuffer(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelPassGateLogic	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceModelPassGateLogic(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelPort	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceModelPort(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelWireParam	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceModelWireParam(ezxml_t Parent,$/;"	f	file:
ProcessSpiceParams	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceSettings	../../libarchfpga/read_xml_spice.c	/^void ProcessSpiceSettings(ezxml_t Parent,$/;"	f
ProcessSpiceStimulateParams	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceStimulateParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceStimulateParamsRiseFall	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceStimulateParamsRiseFall(ezxml_t Parent,$/;"	f	file:
ProcessSpiceTechLibTransistors	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceTechLibTransistors(ezxml_t Parent,$/;"	f	file:
ProcessSpiceTransistorType	../../libarchfpga/read_xml_spice.c	/^static void ProcessSpiceTransistorType(ezxml_t Parent,$/;"	f	file:
ProcessSwitchSegmentPatterns	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessSwitchSegmentPatterns(INOUTP ezxml_t Parent,$/;"	f	file:
ProcessSwitches	../../libarchfpga/read_xml_arch_file.c	/^static void ProcessSwitches(INOUTP ezxml_t Parent,$/;"	f	file:
ProcessTechComp	../../libarchfpga/read_xml_mrfpga.c	/^ProcessTechComp(INOUTP ezxml_t Node,$/;"	f
ProcessTechHack	../../libarchfpga/read_xml_mrfpga.c	/^ProcessTechHack(INOUTP ezxml_t Node,$/;"	f
ProcessTechnology	../../libarchfpga/read_xml_mrfpga.c	/^ProcessTechnology(INOUTP ezxml_t Node,$/;"	f
ProcessWireBuffer	../../libarchfpga/read_xml_mrfpga.c	/^ProcessWireBuffer(INOUTP ezxml_t Node,$/;"	f
Process_Fc	../../libarchfpga/read_xml_arch_file.c	/^static void Process_Fc(ezxml_t Node, t_type_descriptor * Type) {$/;"	f	file:
ProcessmrFPGA	../../libarchfpga/read_xml_mrfpga.c	/^ProcessmrFPGA(INOUTP ezxml_t Node,$/;"	f
Provenance	base/ReadOptions.h	/^	int Provenance[OT_BASE_UNKNOWN];$/;"	m	struct:s_options
QUEST	timing/slre.c	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon19	file:
R	../../libarchfpga/include/arch_types_mrfpga.h	/^  float R; $/;"	m	struct:s_memristor_inf
R	../../libarchfpga/include/arch_types_mrfpga.h	/^  float R;$/;"	m	struct:s_buffer_inf
R	../../libarchfpga/include/physical_types.h	/^	float R;$/;"	m	struct:s_switch_inf
R	base/vpr_types.h	/^	float R;$/;"	m	struct:s_rr_node
RANDOM	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:e_pad_loc_type
READLINE_H	../../libarchfpga/include/ReadLine.h	2;"	d
READOPTIONS_H	base/ReadOptions.h	2;"	d
READ_BLIF_H	base/read_blif.h	2;"	d
READ_NETLIST_H	base/read_netlist.h	9;"	d
READ_PLACE_H	base/read_place.h	2;"	d
READ_SDC_H	timing/read_sdc.h	2;"	d
READ_SETTINGS_H	base/read_settings.h	2;"	d
READ_XML_ARCH_FILE_H	../../libarchfpga/include/read_xml_arch_file.h	2;"	d
READ_XML_UTIL_H	../../libarchfpga/include/read_xml_util.h	2;"	d
RECEIVER	../../libarchfpga/include/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
RED	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
REJECTED	place/place.c	/^	REJECTED, ACCEPTED, ABORTED$/;"	e	enum:swap_result	file:
REMOVE_CLUSTERED	pack/cluster.c	/^	REMOVE_CLUSTERED, LEAVE_CLUSTERED$/;"	e	enum:e_removal_policy	file:
RET_SWSEG_TRACK_APPLIED	route/rr_graph_swseg.c	/^  RET_SWSEG_TRACK_APPLIED$/;"	e	enum:ret_track_swseg_pattern	file:
RET_SWSEG_TRACK_DIR_UNMATCH	route/rr_graph_swseg.c	/^  RET_SWSEG_TRACK_DIR_UNMATCH,$/;"	e	enum:ret_track_swseg_pattern	file:
RET_SWSEG_TRACK_NON_SEG_LEN_PATTERN	route/rr_graph_swseg.c	/^  RET_SWSEG_TRACK_NON_SEG_LEN_PATTERN,$/;"	e	enum:ret_track_swseg_pattern	file:
RIGHT	../../libarchfpga/include/physical_types.h	/^	TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3$/;"	e	enum:e_side
ROUND_UP	route/route_timing.c	674;"	d	file:
ROUTE_PATH_WEIGHT	timing/path_delay.h	37;"	d
ROUTING	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:pic_type
RR_GRAPH2_H	route/rr_graph2.h	2;"	d
RR_GRAPH_H	route/rr_graph.h	2;"	d
RR_GRAPH_NO_WARN	route/rr_graph.h	/^	RR_GRAPH_NO_WARN = 0x00,$/;"	e	enum:__anon17
RR_GRAPH_SBOX_H	route/rr_graph_sbox.h	2;"	d
RR_GRAPH_WARN_CHAN_WIDTH_CHANGED	route/rr_graph.h	/^	RR_GRAPH_WARN_CHAN_WIDTH_CHANGED = 0x02$/;"	e	enum:__anon17
RR_GRAPH_WARN_FC_CLIPPED	route/rr_graph.h	/^	RR_GRAPH_WARN_FC_CLIPPED = 0x01,$/;"	e	enum:__anon17
RUN_FLOW	base/vpr_types.h	/^	RUN_FLOW, TIMING_ANALYSIS_ONLY$/;"	e	enum:e_operation
R_minW_nmos	../../libarchfpga/include/physical_types.h	/^	float R_minW_nmos;$/;"	m	struct:s_arch
R_minW_nmos	base/vpr_types.h	/^	float R_minW_nmos;$/;"	m	struct:s_det_routing_arch
R_minW_pmos	../../libarchfpga/include/physical_types.h	/^	float R_minW_pmos;$/;"	m	struct:s_arch
R_minW_pmos	base/vpr_types.h	/^	float R_minW_pmos;$/;"	m	struct:s_det_routing_arch
R_opin_cblock	../../libarchfpga/include/arch_types_mrfpga.h	/^  float R_opin_cblock;$/;"	m	struct:s_arch_mrfpga
R_opin_cblock	../../libarchfpga/include/physical_types.h	/^    float R_opin_cblock;$/;"	m	struct:s_timing_inf
R_upstream	route/route_common.h	/^	float R_upstream;$/;"	m	struct:s_heap
R_upstream	route/route_tree_timing.h	/^	float R_upstream;$/;"	m	struct:s_rt_node
ReadBaseCostType	base/ReadOptions.c	/^ReadBaseCostType(INP char **Args, OUTP enum e_base_cost_type *BaseCostType) {$/;"	f	file:
ReadBaseToken	base/ReadOptions.c	/^ReadBaseToken(INP char **Args, OUTP enum e_OptionBaseToken *Token) {$/;"	f	file:
ReadClusterSeed	base/ReadOptions.c	/^ReadClusterSeed(INP char **Args, OUTP enum e_cluster_seed *Type) {$/;"	f	file:
ReadFixPins	base/ReadOptions.c	/^ReadFixPins(INP char **Args, OUTP char **PinFile) {$/;"	f	file:
ReadFloat	base/ReadOptions.c	/^ReadFloat(INP char ** Args, OUTP float *Val) {$/;"	f	file:
ReadInt	base/ReadOptions.c	/^ReadInt(INP char **Args, OUTP int *Val) {$/;"	f	file:
ReadLineTokens	../../libarchfpga/ReadLine.c	/^ReadLineTokens(INOUTP FILE * InFile, INOUTP int *LineNum) {$/;"	f
ReadOnOff	base/ReadOptions.c	/^ReadOnOff(INP char **Args, OUTP boolean * Val) {$/;"	f	file:
ReadOptions	base/ReadOptions.c	/^void ReadOptions(INP int argc, INP char **argv, OUTP t_options * Options) {$/;"	f
ReadPackerAlgorithm	base/ReadOptions.c	/^ReadPackerAlgorithm(INP char **Args, OUTP enum e_packer_algorithm *Algo) {$/;"	f	file:
ReadPlaceAlgorithm	base/ReadOptions.c	/^ReadPlaceAlgorithm(INP char **Args, OUTP enum e_place_algorithm *Algo) {$/;"	f	file:
ReadRouteType	base/ReadOptions.c	/^ReadRouteType(INP char **Args, OUTP enum e_route_type *Type) {$/;"	f	file:
ReadRouterAlgorithm	base/ReadOptions.c	/^ReadRouterAlgorithm(INP char **Args, OUTP enum e_router_algorithm *Algo) {$/;"	f	file:
ReadString	base/ReadOptions.c	/^ReadString(INP char **Args, OUTP char **Val) {$/;"	f	file:
ReadToken	base/ReadOptions.c	/^ReadToken(INP char **Args, OUTP enum e_OptionArgToken *Token) {$/;"	f	file:
RecomputeCritIter	base/ReadOptions.h	/^	int RecomputeCritIter;$/;"	m	struct:s_options
Rmetal	../../libarchfpga/include/physical_types.h	/^	float Rmetal;$/;"	m	struct:s_segment_inf
Rmetal	base/vpr_types.h	/^	float Rmetal;$/;"	m	struct:s_seg_details
RouteChanWidth	base/ReadOptions.h	/^	int RouteChanWidth;$/;"	m	struct:s_options
RouteFile	base/ReadOptions.h	/^	char *RouteFile;$/;"	m	struct:s_options
RouteFile	base/vpr_types.h	/^	char *RouteFile;$/;"	m	struct:s_file_name_opts
RouteType	base/ReadOptions.h	/^	enum e_route_type RouteType;$/;"	m	struct:s_options	typeref:enum:s_options::e_route_type
RouterAlgorithm	base/ReadOptions.h	/^	enum e_router_algorithm RouterAlgorithm;$/;"	m	struct:s_options	typeref:enum:s_options::e_router_algorithm
RouterOpts	base/vpr_types.h	/^	struct s_router_opts RouterOpts; \/* router options *\/$/;"	m	struct:s_vpr_setup	typeref:struct:s_vpr_setup::s_router_opts
RoutingArch	base/vpr_types.h	/^	struct s_det_routing_arch RoutingArch; \/* routing architecture *\/$/;"	m	struct:s_vpr_setup	typeref:struct:s_vpr_setup::s_det_routing_arch
Rseg_global	../../libarchfpga/include/arch_types_mrfpga.h	/^  float Rseg_global;$/;"	m	struct:s_arch_mrfpga
Rseg_global	mrfpga/mrfpga_globals.c	/^float Rseg_global, Cseg_global;$/;"	v
SAME_TRACK	route/rr_graph2.c	23;"	d	file:
SBOX_ERROR	route/rr_graph_sbox.c	99;"	d	file:
SBType	../../libarchfpga/include/physical_types.h	/^	enum e_switch_block_type SBType;$/;"	m	struct:s_arch	typeref:enum:s_arch::e_switch_block_type
SCALE_DISTANCE_VAL	pack/cluster.c	47;"	d	file:
SCALE_NUM_PATHS	pack/cluster.c	38;"	d	file:
SCREEN	base/graphics.c	/^   SCREEN = 0,$/;"	e	enum:__anon2	file:
SDCFile	../../libarchfpga/include/physical_types.h	/^	char * SDCFile; \/* only here for convenience of passing to path_delay.c *\/$/;"	m	struct:s_timing_inf
SDCFile	base/ReadOptions.h	/^	char *SDCFile;$/;"	m	struct:s_options
SDC_TOKENS	timing/read_sdc.c	452;"	d	file:
SDF_Adder_delay_printing	base/verilog_writer.c	/^void SDF_Adder_delay_printing(FILE *SDF , t_pb *pb)$/;"	f
SDF_Mult_delay_printing	base/verilog_writer.c	/^void SDF_Mult_delay_printing(FILE *SDF , t_pb *pb)$/;"	f
SDF_interconnect_delay_printing	base/verilog_writer.c	/^void SDF_interconnect_delay_printing(FILE *SDF , conn_list *downhill)$/;"	f
SDF_ram_dual_port_delay_printing	base/verilog_writer.c	/^void SDF_ram_dual_port_delay_printing(FILE *SDF , t_pb *pb)$/;"	f
SDF_ram_single_port_delay_printing	base/verilog_writer.c	/^void SDF_ram_single_port_delay_printing(FILE *SDF , t_pb *pb)$/;"	f
SELECT_ERROR	base/graphics.c	217;"	d	file:
SETUPGRID_H	base/SetupGrid.h	2;"	d
SETUPVPR_H	base/SetupVPR.h	2;"	d
SINGLE	base/vpr_types.h	/^	MULTI_BUFFERED, SINGLE$/;"	e	enum:e_drivers
SINK	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
SINK_BLOCK	place/timing_place_lookup.c	50;"	d	file:
SINK_COST_INDEX	base/vpr_types.h	/^	SINK_COST_INDEX,$/;"	e	enum:e_cost_indices
SLACK_DEFINITION	timing/path_delay.h	8;"	d
SLRE_CASE_INSENSITIVE	timing/slre.h	/^enum slre_option {SLRE_CASE_INSENSITIVE = 1};$/;"	e	enum:slre_option
SLRE_FLOAT	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	e	enum:slre_capture
SLRE_H	timing/slre.h	78;"	d
SLRE_INT	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	e	enum:slre_capture
SLRE_STRING	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	e	enum:slre_capture
SMALL_NET	place/place.c	27;"	d	file:
SOLID	base/easygl_constants.h	/^enum line_types {SOLID, DASHED};$/;"	e	enum:line_types
SOURCE	base/vpr_types.h	/^	SOURCE = 0, SINK, IPIN, OPIN, CHANX, CHANY, INTRA_CLUSTER_EDGE, NUM_RR_TYPES$/;"	e	enum:e_rr_type
SOURCE_BLOCK	place/timing_place_lookup.c	49;"	d	file:
SOURCE_COST_INDEX	base/vpr_types.h	/^	SOURCE_COST_INDEX = 0,$/;"	e	enum:e_cost_indices
SPACE	timing/slre.c	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon19	file:
SPICE_ABS	../../libarchfpga/include/spice_types.h	/^  SPICE_FRAC, SPICE_ABS$/;"	e	enum:e_spice_accuracy_type
SPICE_CB_MUX_TB	spice/spice_mux_testbench.h	/^  SPICE_CB_MUX_TB, SPICE_SB_MUX_TB, SPICE_PB_MUX_TB$/;"	e	enum:e_spice_mux_tb_type
SPICE_FRAC	../../libarchfpga/include/spice_types.h	/^  SPICE_FRAC, SPICE_ABS$/;"	e	enum:e_spice_accuracy_type
SPICE_LIB_ACADEMIA	../../libarchfpga/include/spice_types.h	/^  SPICE_LIB_INDUSTRY,SPICE_LIB_ACADEMIA$/;"	e	enum:e_spice_tech_lib_type
SPICE_LIB_INDUSTRY	../../libarchfpga/include/spice_types.h	/^  SPICE_LIB_INDUSTRY,SPICE_LIB_ACADEMIA$/;"	e	enum:e_spice_tech_lib_type
SPICE_MEASURE_DYNAMIC_POWER	spice/spice_netlist_utils.h	/^ SPICE_MEASURE_LEAKAGE_POWER, SPICE_MEASURE_DYNAMIC_POWER$/;"	e	enum:e_measure_type
SPICE_MEASURE_LEAKAGE_POWER	spice/spice_netlist_utils.h	/^ SPICE_MEASURE_LEAKAGE_POWER, SPICE_MEASURE_DYNAMIC_POWER$/;"	e	enum:e_measure_type
SPICE_MODEL_BUF_BUF	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_BUF_BUF$/;"	e	enum:e_spice_model_buffer_type
SPICE_MODEL_BUF_INV	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_BUF_INV, $/;"	e	enum:e_spice_model_buffer_type
SPICE_MODEL_CHAN_WIRE	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_CHAN_WIRE, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_DESIGN_CMOS	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_DESIGN_CMOS, $/;"	e	enum:e_spice_model_design_tech
SPICE_MODEL_DESIGN_RRAM	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_DESIGN_RRAM$/;"	e	enum:e_spice_model_design_tech
SPICE_MODEL_FF	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_FF, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_HARDLOGIC	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_HARDLOGIC$/;"	e	enum:e_spice_model_type
SPICE_MODEL_INPAD	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_INPAD, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_LUT	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_LUT, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_MUX	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_MUX, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_OUTPAD	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_OUTPAD, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_PASS_GATE_TRANSISTOR	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PASS_GATE_TRANSMISSION, SPICE_MODEL_PASS_GATE_TRANSISTOR$/;"	e	enum:e_spice_model_pass_gate_logic_type
SPICE_MODEL_PASS_GATE_TRANSMISSION	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PASS_GATE_TRANSMISSION, SPICE_MODEL_PASS_GATE_TRANSISTOR$/;"	e	enum:e_spice_model_pass_gate_logic_type
SPICE_MODEL_PORT_CLOCK	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PORT_CLOCK, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_INOUT	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PORT_INOUT, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_INPUT	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PORT_INPUT, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_OUTPUT	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PORT_OUTPUT, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_SRAM	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_PORT_SRAM$/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_SRAM	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_SRAM, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_WIRE	../../libarchfpga/include/spice_types.h	/^  SPICE_MODEL_WIRE, $/;"	e	enum:e_spice_model_type
SPICE_PB_MUX_TB	spice/spice_mux_testbench.h	/^  SPICE_CB_MUX_TB, SPICE_SB_MUX_TB, SPICE_PB_MUX_TB$/;"	e	enum:e_spice_mux_tb_type
SPICE_SB_MUX_TB	spice/spice_mux_testbench.h	/^  SPICE_CB_MUX_TB, SPICE_SB_MUX_TB, SPICE_PB_MUX_TB$/;"	e	enum:e_spice_mux_tb_type
SPICE_TRANS_NMOS	../../libarchfpga/include/spice_types.h	/^  SPICE_TRANS_NMOS, SPICE_TRANS_PMOS$/;"	e	enum:e_spice_trans_type
SPICE_TRANS_PMOS	../../libarchfpga/include/spice_types.h	/^  SPICE_TRANS_NMOS, SPICE_TRANS_PMOS$/;"	e	enum:e_spice_trans_type
STAR	timing/slre.c	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon19	file:
STARQ	timing/slre.c	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon19	file:
STTRAM	../../libarchfpga/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
SUBSET	../../libarchfpga/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
SWSEG_UNBUF_CB	../../libarchfpga/include/physical_types.h	/^  SWSEG_UNBUF_SB, SWSEG_UNBUF_CB$/;"	e	enum:e_swseg_pattern_type
SWSEG_UNBUF_SB	../../libarchfpga/include/physical_types.h	/^  SWSEG_UNBUF_SB, SWSEG_UNBUF_CB$/;"	e	enum:e_swseg_pattern_type
Seed	base/ReadOptions.h	/^	int Seed;$/;"	m	struct:s_options
Segments	../../libarchfpga/include/physical_types.h	/^	t_segment_inf * Segments;$/;"	m	struct:s_arch
Segments	base/vpr_types.h	/^	t_segment_inf * Segments; \/* wires in routing architecture *\/$/;"	m	struct:s_vpr_setup
SetPostSynthesisOption	base/ReadOptions.c	/^void SetPostSynthesisOption(boolean post_synthesis_enabled){$/;"	f
SettingsFile	base/ReadOptions.h	/^	char *SettingsFile;$/;"	m	struct:s_options
SetupAnnealSched	base/SetupVPR.c	/^static void SetupAnnealSched(INP t_options Options,$/;"	f	file:
SetupEmptyType	../../libarchfpga/read_xml_arch_file.c	/^static void SetupEmptyType(void) {$/;"	f	file:
SetupGridLocations	../../libarchfpga/read_xml_arch_file.c	/^static void SetupGridLocations(ezxml_t Locations, t_type_descriptor * Type) {$/;"	f	file:
SetupOperation	base/SetupVPR.c	/^static void SetupOperation(INP t_options Options,$/;"	f	file:
SetupPackerOpts	base/SetupVPR.c	/^void SetupPackerOpts(INP t_options Options, INP boolean TimingEnabled,$/;"	f
SetupPinLocationsAndPinClasses	../../libarchfpga/read_xml_arch_file.c	/^static void SetupPinLocationsAndPinClasses(ezxml_t Locations,$/;"	f	file:
SetupPlacerOpts	base/SetupVPR.c	/^static void SetupPlacerOpts(INP t_options Options, INP boolean TimingEnabled,$/;"	f	file:
SetupPowerOpts	base/SetupVPR.c	/^static void SetupPowerOpts(t_options Options, t_power_opts *power_opts,$/;"	f	file:
SetupRouterOpts	base/SetupVPR.c	/^static void SetupRouterOpts(INP t_options Options, INP boolean TimingEnabled,$/;"	f	file:
SetupRoutingArch	base/SetupVPR.c	/^static void SetupRoutingArch(INP t_arch Arch,$/;"	f	file:
SetupSpiceOpts	base/SetupVPR.c	/^static void SetupSpiceOpts(t_options Options, $/;"	f	file:
SetupSwitches	base/SetupVPR.c	/^static void SetupSwitches(INP t_arch Arch,$/;"	f	file:
SetupSwitches_mrFPGA	base/SetupVPR.c	/^static void SetupSwitches_mrFPGA(INP t_arch Arch,$/;"	f	file:
SetupTiming	base/SetupVPR.c	/^static void SetupTiming(INP t_options Options, INP t_arch Arch,$/;"	f	file:
SetupVPR	base/SetupVPR.c	/^void SetupVPR(INP t_options *Options, INP boolean TimingEnabled,$/;"	f
ShowAnnealSched	base/ShowSetup.c	/^static void ShowAnnealSched(INP struct s_annealing_sched AnnealSched) {$/;"	f	file:
ShowGraphics	base/vpr_types.h	/^	boolean ShowGraphics; \/* option to show graphics *\/$/;"	m	struct:s_vpr_setup
ShowOperation	base/ShowSetup.c	/^static void ShowOperation(INP enum e_operation Operation) {$/;"	f	file:
ShowPackerOpts	base/ShowSetup.c	/^static void ShowPackerOpts(INP struct s_packer_opts PackerOpts) {$/;"	f	file:
ShowPlaceTiming	base/ReadOptions.h	/^	boolean ShowPlaceTiming;$/;"	m	struct:s_options
ShowPlacerOpts	base/ShowSetup.c	/^static void ShowPlacerOpts(INP t_options Options,$/;"	f	file:
ShowRouterOpts	base/ShowSetup.c	/^static void ShowRouterOpts(INP struct s_router_opts RouterOpts) {$/;"	f	file:
ShowRoutingArch	base/ShowSetup.c	/^static void ShowRoutingArch(INP struct s_det_routing_arch RoutingArch) {$/;"	f	file:
ShowSetup	base/ShowSetup.c	/^void ShowSetup(INP t_options options, INP t_vpr_setup vpr_setup) {$/;"	f
SpiceOpts	base/vpr_types.h	/^    t_spice_opts SpiceOpts; \/* Xifan TANG: SPICE Support*\/$/;"	m	struct:s_vpr_setup
StatusWND	base/graphics.c	/^StatusWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)$/;"	f	file:
Str	base/vpr_types.h	/^	const char *Str;$/;"	m	struct:s_TokenPair
Switches	../../libarchfpga/include/physical_types.h	/^	struct s_switch_inf *Switches;$/;"	m	struct:s_arch	typeref:struct:s_arch::s_switch_inf
SyncModelsPbTypes	../../libarchfpga/read_xml_arch_file.c	/^static void SyncModelsPbTypes(INOUTP struct s_arch *arch,$/;"	f	file:
SyncModelsPbTypes_rec	../../libarchfpga/read_xml_arch_file.c	/^static void SyncModelsPbTypes_rec(INOUTP struct s_arch *arch,$/;"	f	file:
TABLENGTH	pack/output_blif.c	19;"	d	file:
TAB_LENGTH	pack/output_clustering.c	17;"	d	file:
THISTLE	base/easygl_constants.h	/^CYAN, RED, DARKGREEN, MAGENTA, BISQUE, LIGHTBLUE, THISTLE, PLUM, KHAKI, CORAL,$/;"	e	enum:color_types
TIMING_ANALYSIS_ONLY	base/vpr_types.h	/^	RUN_FLOW, TIMING_ANALYSIS_ONLY$/;"	e	enum:e_operation
TIMING_DRIVEN	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:e_router_algorithm
TIMING_GAIN_PATH_WEIGHT	timing/path_delay.h	35;"	d
TIMING_PLACE	place/timing_place.h	2;"	d
TN_CB_IPIN	base/vpr_types.h	/^	TN_CB_IPIN, \/* input pin to complex block *\/$/;"	e	enum:__anon7
TN_CB_OPIN	base/vpr_types.h	/^	TN_CB_OPIN, \/* output pin from complex block *\/$/;"	e	enum:__anon7
TN_CONSTANT_GEN_SOURCE	base/vpr_types.h	/^	TN_CONSTANT_GEN_SOURCE \/* source of a constant logic 1 or 0 *\/$/;"	e	enum:__anon7
TN_FF_CLOCK	base/vpr_types.h	/^	TN_FF_CLOCK, \/* clock pin of flip-flop *\/$/;"	e	enum:__anon7
TN_FF_IPIN	base/vpr_types.h	/^	TN_FF_IPIN, \/* input pin to a flip-flop - goes to TN_FF_SINK *\/$/;"	e	enum:__anon7
TN_FF_OPIN	base/vpr_types.h	/^	TN_FF_OPIN, \/* output pin from a flip-flop - comes from TN_FF_SOURCE *\/$/;"	e	enum:__anon7
TN_FF_SINK	base/vpr_types.h	/^	TN_FF_SINK, \/* sink (D) pin of flip-flop *\/$/;"	e	enum:__anon7
TN_FF_SOURCE	base/vpr_types.h	/^	TN_FF_SOURCE, \/* source (Q) pin of flip-flop *\/$/;"	e	enum:__anon7
TN_INPAD_OPIN	base/vpr_types.h	/^	TN_INPAD_OPIN, \/* output from an input I\/O pad *\/$/;"	e	enum:__anon7
TN_INPAD_SOURCE	base/vpr_types.h	/^	TN_INPAD_SOURCE, \/* input to an input I\/O pad *\/$/;"	e	enum:__anon7
TN_INTERMEDIATE_NODE	base/vpr_types.h	/^	TN_INTERMEDIATE_NODE, \/* Used in post-packed timing graph only: $/;"	e	enum:__anon7
TN_OUTPAD_IPIN	base/vpr_types.h	/^	TN_OUTPAD_IPIN, \/* input to an output I\/O pad *\/$/;"	e	enum:__anon7
TN_OUTPAD_SINK	base/vpr_types.h	/^	TN_OUTPAD_SINK, \/* output from an output I\/O pad *\/$/;"	e	enum:__anon7
TN_PRIMITIVE_IPIN	base/vpr_types.h	/^	TN_PRIMITIVE_IPIN, \/* input pin to a primitive (e.g. a LUT) *\/$/;"	e	enum:__anon7
TN_PRIMITIVE_OPIN	base/vpr_types.h	/^	TN_PRIMITIVE_OPIN, \/* output pin from a primitive (e.g. a LUT) *\/$/;"	e	enum:__anon7
TOKENS	../../libarchfpga/include/arch_types.h	19;"	d
TOKENS	base/vpr_types.h	66;"	d
TOKEN_CLOSE_SQUARE_BRACKET	util/token.h	/^	TOKEN_CLOSE_SQUARE_BRACKET,$/;"	e	enum:e_token_type
TOKEN_CLOSE_SQUIG_BRACKET	util/token.h	/^	TOKEN_CLOSE_SQUIG_BRACKET,$/;"	e	enum:e_token_type
TOKEN_COLON	util/token.h	/^	TOKEN_COLON,$/;"	e	enum:e_token_type
TOKEN_DOT	util/token.h	/^	TOKEN_DOT$/;"	e	enum:e_token_type
TOKEN_H	util/token.h	8;"	d
TOKEN_INT	util/token.h	/^	TOKEN_INT,$/;"	e	enum:e_token_type
TOKEN_NULL	util/token.h	/^	TOKEN_NULL,$/;"	e	enum:e_token_type
TOKEN_OPEN_SQUARE_BRACKET	util/token.h	/^	TOKEN_OPEN_SQUARE_BRACKET,$/;"	e	enum:e_token_type
TOKEN_OPEN_SQUIG_BRACKET	util/token.h	/^	TOKEN_OPEN_SQUIG_BRACKET,$/;"	e	enum:e_token_type
TOKEN_STRING	util/token.h	/^	TOKEN_STRING,$/;"	e	enum:e_token_type
TOP	../../libarchfpga/include/physical_types.h	/^	TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3$/;"	e	enum:e_side
TRUE	../../libarchfpga/include/util.h	/^	FALSE, TRUE$/;"	e	enum:__anon23
TRUE	base/graphics.c	145;"	d	file:
TURQUOISE	base/easygl_constants.h	/^TURQUOISE, MEDIUMPURPLE, DARKSLATEBLUE, DARKKHAKI, NUM_COLOR};$/;"	e	enum:color_types
T_AREA_HEIGHT	base/graphics.c	178;"	d	file:
T_arr	base/vpr_types.h	/^	float T_arr; \/* Arrival time of the last input signal to this node. *\/$/;"	m	struct:s_tnode
T_crit	power/power.h	/^	float T_crit;$/;"	m	struct:s_solution_inf
T_ipin_cblock	../../libarchfpga/include/physical_types.h	/^	float T_ipin_cblock;$/;"	m	struct:s_arch
T_ipin_cblock	../../libarchfpga/include/physical_types.h	/^	float T_ipin_cblock;$/;"	m	struct:s_timing_inf
T_linear	base/vpr_types.h	/^	float T_linear;$/;"	m	struct:s_rr_indexed_data
T_opin_cblock	../../libarchfpga/include/arch_types_mrfpga.h	/^  float T_opin_cblock;$/;"	m	struct:s_arch_mrfpga
T_opin_cblock	../../libarchfpga/include/physical_types.h	/^    float T_opin_cblock;$/;"	m	struct:s_timing_inf
T_quadratic	base/vpr_types.h	/^	float T_quadratic;$/;"	m	struct:s_rr_indexed_data
T_req	base/vpr_types.h	/^	float T_req; \/* Required arrival time of the last input signal to this node $/;"	m	struct:s_tnode
Tdel	../../libarchfpga/include/arch_types_mrfpga.h	/^  float Tdel; $/;"	m	struct:s_memristor_inf
Tdel	../../libarchfpga/include/arch_types_mrfpga.h	/^  float Tdel;$/;"	m	struct:s_buffer_inf
Tdel	../../libarchfpga/include/physical_types.h	/^	float Tdel;$/;"	m	struct:s_switch_inf
Tdel	base/vpr_types.h	/^	float Tdel; \/* delay to go to to_node along this edge *\/$/;"	m	struct:s_tedge
Tdel	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	m	struct:s_buffer_plan	file:
Tdel	route/route_tree_timing.h	/^	float Tdel;$/;"	m	struct:s_rt_node
Tdel	timing/net_delay_types.h	/^	float Tdel;$/;"	m	struct:s_rc_node
Timing	base/vpr_types.h	/^	t_timing_inf Timing; \/* timing information *\/$/;"	m	struct:s_vpr_setup
TimingAnalysis	base/ReadOptions.h	/^	boolean TimingAnalysis;$/;"	m	struct:s_options
TimingEnabled	base/vpr_types.h	/^	boolean TimingEnabled; \/* Is VPR timing enabled *\/$/;"	m	struct:s_vpr_setup
UNDEFINED	../../libarchfpga/include/arch_types.h	22;"	d
UNDEFINED	base/vpr_types.h	103;"	d
UNIFORM	../../libarchfpga/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
UNIVERSAL	../../libarchfpga/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
UNI_DIRECTIONAL	../../libarchfpga/include/physical_types.h	/^	UNI_DIRECTIONAL, BI_DIRECTIONAL$/;"	e	enum:e_directionality
UNKNOWN_CLASS	../../libarchfpga/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
UN_SET	route/rr_graph2.c	24;"	d	file:
UPDATED_ONCE	place/place.c	46;"	d	file:
USER	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:e_pad_loc_type
USER_SCHED	base/vpr_types.h	/^	AUTO_SCHED, USER_SCHED$/;"	e	enum:sched_type
UTIL_H	../../libarchfpga/include/util.h	2;"	d
UpdateAndCheckModels	../../libarchfpga/read_xml_arch_file.c	/^static void UpdateAndCheckModels(INOUTP struct s_arch *arch) {$/;"	f	file:
VPACK_COMB	base/vpr_types.h	/^	VPACK_INPAD = -2, VPACK_OUTPAD, VPACK_COMB, VPACK_LATCH, VPACK_EMPTY$/;"	e	enum:logical_block_types
VPACK_EMPTY	base/vpr_types.h	/^	VPACK_INPAD = -2, VPACK_OUTPAD, VPACK_COMB, VPACK_LATCH, VPACK_EMPTY$/;"	e	enum:logical_block_types
VPACK_INPAD	base/vpr_types.h	/^	VPACK_INPAD = -2, VPACK_OUTPAD, VPACK_COMB, VPACK_LATCH, VPACK_EMPTY$/;"	e	enum:logical_block_types
VPACK_LATCH	base/vpr_types.h	/^	VPACK_INPAD = -2, VPACK_OUTPAD, VPACK_COMB, VPACK_LATCH, VPACK_EMPTY$/;"	e	enum:logical_block_types
VPACK_MAX_INPUTS	base/vpr_types.h	/^	VPACK_TIMING, VPACK_MAX_INPUTS$/;"	e	enum:e_cluster_seed
VPACK_OUTPAD	base/vpr_types.h	/^	VPACK_INPAD = -2, VPACK_OUTPAD, VPACK_COMB, VPACK_LATCH, VPACK_EMPTY$/;"	e	enum:logical_block_types
VPACK_TIMING	base/vpr_types.h	/^	VPACK_TIMING, VPACK_MAX_INPUTS$/;"	e	enum:e_cluster_seed
VPR_API_H	base/vpr_api.h	27;"	d
VPR_TYPES_H	base/vpr_types.h	34;"	d
VPR_UTILS_H	util/vpr_utils.h	2;"	d
VPR_VERSION	../../libarchfpga/include/arch_types.h	16;"	d
Vdd	power/power.h	/^	float Vdd;$/;"	m	struct:s_power_tech
W	../../libarchfpga/include/physical_types.h	/^	int W;$/;"	m	struct:s_clb_grid
WARNTAG	../../libarchfpga/include/util.h	27;"	d
WHITE	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
WILTON	../../libarchfpga/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
WIRE_MODEL_PIE	../../libarchfpga/include/spice_types.h	/^  WIRE_MODEL_PIE,$/;"	e	enum:e_wire_model_type
WIRE_MODEL_T	../../libarchfpga/include/spice_types.h	/^  WIRE_MODEL_T$/;"	e	enum:e_wire_model_type
WIRE_SEGMENT_LENGTH	base/vpr_api.c	425;"	d	file:
WL	base/place_and_route.h	5;"	d
WNEED	base/place_and_route.h	4;"	d
W_seed	base/globals.c	/^int W_seed = -1;$/;"	v
X11	base/graphics.h	13;"	d
XPOST	base/graphics.c	161;"	d	file:
XTOWORLD	base/graphics.c	167;"	d	file:
XmlReadArch	../../libarchfpga/read_xml_arch_file.c	/^void XmlReadArch(INP const char *ArchFile, INP boolean timing_enabled,$/;"	f
YELLOW	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	e	enum:color_types
YPOST	base/graphics.c	162;"	d	file:
YTOWORLD	base/graphics.c	168;"	d	file:
_EZXML_H	../../libarchfpga/include/ezxml.h	26;"	d
__POWER_CMOS_TECH_H__	power/power_cmos_tech.h	26;"	d
__POWER_COMPONENTS_H__	power/power_components.h	24;"	d
__POWER_H__	power/power.h	23;"	d
__POWER_LOW_LEVEL_H__	power/power_lowlevel.h	24;"	d
__POWER_MISC_H__	power/power_callibrate.h	23;"	d
__POWER_POWERSPICEDCOMPONENT_NMOS_H__	power/PowerSpicedComponent.h	19;"	d
__POWER_TRANSISTOR_CNT_H__	power/power_sizing.h	24;"	d
__POWER_UTIL_H__	power/power_util.h	23;"	d
_drawcurve	base/graphics.c	/^static void _drawcurve(t_point *points, int npoints, int fill) {$/;"	f	file:
absolute_length	../../libarchfpga/include/physical_types.h	/^		float absolute_length;$/;"	m	union:s_port_power::__anon22
absolute_power_per_instance	../../libarchfpga/include/physical_types.h	/^	t_power_usage absolute_power_per_instance; \/* User-provided absolute power per block *\/$/;"	m	struct:s_pb_type_power
absorb_buffer_luts	base/read_blif.c	/^static void absorb_buffer_luts(void) {$/;"	f	file:
acc_cost	route/route_common.h	/^	float acc_cost;$/;"	m	struct:__anon15
acc_fac	base/ReadOptions.h	/^	float acc_fac;$/;"	m	struct:s_options
acc_fac	base/vpr_types.h	/^	float acc_fac;$/;"	m	struct:s_router_opts
accuracy	../../libarchfpga/include/spice_types.h	/^  float accuracy;$/;"	m	struct:s_spice_meas_params
accuracy_type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_accuracy_type accuracy_type;$/;"	m	struct:s_spice_meas_params	typeref:enum:s_spice_meas_params::e_spice_accuracy_type
add_activity_to_net	base/read_blif.c	/^bool add_activity_to_net(char * net_name, float probability, float density) {$/;"	f
add_data_point	power/PowerSpicedComponent.c	/^void PowerSpicedComponent::add_data_point(int num_inputs, float transistor_size,$/;"	f	class:PowerSpicedComponent
add_delay_to_array	mrfpga/buffer_insertion.c	/^static void add_delay_to_array( float* sink_delay, t_linked_int* index, float delay_addition )$/;"	f	file:
add_delay_to_buffer_list	mrfpga/buffer_insertion.c	/^static void add_delay_to_buffer_list( t_buffer_plan_list list, float Tdel , boolean skip_first )$/;"	f	file:
add_delay_to_buffer_plan	mrfpga/buffer_insertion.c	/^static t_buffer_plan add_delay_to_buffer_plan( t_buffer_plan plan, float Tdel )$/;"	f	file:
add_entry	power/PowerSpicedComponent.c	/^PowerCallibInputs * PowerSpicedComponent::add_entry(int num_inputs) {$/;"	f	class:PowerSpicedComponent
add_latch	base/read_blif.c	/^static void add_latch(int doall, INP t_model *latch_model) {$/;"	f	file:
add_lut	base/read_blif.c	/^static boolean add_lut(int doall, t_model *logic_model) {$/;"	f	file:
add_molecule_to_pb_stats_candidates	pack/cluster.c	/^static void add_molecule_to_pb_stats_candidates(t_pack_molecule *molecule,$/;"	f	file:
add_net_rr_terminal_cluster	pack/cluster_legality.c	/^static void add_net_rr_terminal_cluster(int iblk_net,$/;"	f	file:
add_net_to_hash	base/read_netlist.c	/^static int add_net_to_hash(INOUTP struct s_hash **nhash, INP char *net_name,$/;"	f	file:
add_override_constraint	timing/read_sdc.c	/^static void add_override_constraint(char ** from_list, int num_from, char ** to_list, int num_to, $/;"	f	file:
add_path_to_route_tree	route/route_tree_timing.c	/^add_path_to_route_tree(struct s_heap *hptr, t_rt_node ** sink_rt_node_ptr) {$/;"	f	file:
add_pattern_name_to_hash	pack/prepack.c	/^static int add_pattern_name_to_hash(INOUTP struct s_hash **nhash,$/;"	f	file:
add_route_tree_to_heap	route/route_timing.c	/^static void add_route_tree_to_heap(t_rt_node * rt_node, int target_node,$/;"	f	file:
add_rr_graph_C_from_switches	route/rr_graph_timing_params.c	/^void add_rr_graph_C_from_switches(float C_ipin_cblock) {$/;"	f
add_rr_graph_switch_segment_pattern	route/rr_graph_swseg.c	/^int add_rr_graph_switch_segment_pattern(enum e_directionality directionality,$/;"	f
add_size	power/PowerSpicedComponent.c	/^void PowerCallibInputs::add_size(float transistor_size, float power) {$/;"	f	class:PowerCallibInputs
add_subckt	base/read_blif.c	/^static void add_subckt(int doall, t_model *user_models) {$/;"	f	file:
add_to_heap	route/route_common.c	/^static void add_to_heap(struct s_heap *hptr) {$/;"	f	file:
add_to_mod_list	route/route_common.c	/^void add_to_mod_list(float *fptr) {$/;"	f
add_to_rc_tree	timing/net_delay.c	/^void add_to_rc_tree(t_rc_node * parent_rc, t_rc_node * child_rc,$/;"	f
add_to_sort_heap	util/heapsort.c	/^static void add_to_sort_heap(int *heap, float *sort_values, int index,$/;"	f	file:
add_vpack_net	base/read_blif.c	/^static int add_vpack_net(char *ptr, int type, int bnum, int bport, int bpin,$/;"	f	file:
add_wire_to_switch	base/SetupVPR.c	/^static void add_wire_to_switch(struct s_det_routing_arch *det_routing_arch) {$/;"	f	file:
adjustButton	base/graphics.c	/^static int windowAdjustFlag = 0, adjustButton = -1;$/;"	v	file:
adjustRect	base/graphics.c	/^static RECT adjustRect, updateRect;$/;"	v	file:
adjust_one_rr_occ_and_pcost	route/route_common.c	/^static void adjust_one_rr_occ_and_pcost(int inode, int add_or_sub,$/;"	f	file:
adjustwin	base/graphics.c	/^adjustwin (void (*drawscreen) (void)) $/;"	f	file:
alloc_SRAM_values_from_truth_table	power/power_util.c	/^char * alloc_SRAM_values_from_truth_table(int LUT_size,$/;"	f
alloc_and_assign_internal_structures	place/timing_place_lookup.c	/^static void alloc_and_assign_internal_structures(struct s_net **original_net,$/;"	f	file:
alloc_and_init_clustering	pack/cluster.c	/^static void alloc_and_init_clustering(boolean global_clocks, float alpha,$/;"	f	file:
alloc_and_init_netlist_from_hash	base/read_netlist.c	/^static struct s_net *alloc_and_init_netlist_from_hash(INP int ncount,$/;"	f	file:
alloc_and_init_pattern_list_from_hash	pack/prepack.c	/^static t_pack_patterns *alloc_and_init_pattern_list_from_hash(INP int ncount,$/;"	f	file:
alloc_and_load_actual_fc	route/rr_graph.c	/^alloc_and_load_actual_fc(INP int L_num_types, INP t_type_ptr types,$/;"	f	file:
alloc_and_load_all_pb_graphs	pack/pb_type_graph.c	/^void alloc_and_load_all_pb_graphs(boolean load_power_structures) {$/;"	f
alloc_and_load_blk_pin_from_port_pin	util/vpr_utils.c	/^static void alloc_and_load_blk_pin_from_port_pin(void) {$/;"	f	file:
alloc_and_load_clb_opins_used_locally	route/route_common.c	/^alloc_and_load_clb_opins_used_locally(void) {$/;"	f	file:
alloc_and_load_clb_to_clb_directs	route/rr_graph.c	/^static t_clb_to_clb_directs * alloc_and_load_clb_to_clb_directs(INP t_direct_inf *directs, INP int num_directs) {$/;"	f	file:
alloc_and_load_cluster_info	pack/cluster.c	/^static void alloc_and_load_cluster_info(INP int num_clb, INOUTP t_block *clb) {$/;"	f	file:
alloc_and_load_cluster_legality_checker	pack/cluster_legality.c	/^void alloc_and_load_cluster_legality_checker(void) {$/;"	f
alloc_and_load_cluster_placement_stats	pack/cluster_placement.c	/^t_cluster_placement_stats *alloc_and_load_cluster_placement_stats(void) {$/;"	f
alloc_and_load_complete_interc_edges	pack/pb_type_graph.c	/^static void alloc_and_load_complete_interc_edges($/;"	f	file:
alloc_and_load_default_child_for_pb_type	../../libarchfpga/read_xml_arch_file.c	/^static void alloc_and_load_default_child_for_pb_type( INOUTP t_pb_type *pb_type,$/;"	f	file:
alloc_and_load_direct_interc_edges	pack/pb_type_graph.c	/^static void alloc_and_load_direct_interc_edges($/;"	f	file:
alloc_and_load_echo_file_info	base/ReadOptions.c	/^void alloc_and_load_echo_file_info() {$/;"	f
alloc_and_load_edges_and_switches	route/rr_graph.c	/^void alloc_and_load_edges_and_switches(INP t_rr_node * L_rr_node, INP int inode,$/;"	f
alloc_and_load_final_routing_trace	base/vpr_api.c	/^static t_trace *alloc_and_load_final_routing_trace() {$/;"	f	file:
alloc_and_load_for_fast_cost_update	place/place.c	/^static void alloc_and_load_for_fast_cost_update(float place_cost_exp) {$/;"	f	file:
alloc_and_load_global_route_seg_details	route/rr_graph.c	/^alloc_and_load_global_route_seg_details(INP int nodes_per_chan,$/;"	f	file:
alloc_and_load_grid	base/SetupGrid.c	/^void alloc_and_load_grid(INOUTP int *num_instances_type) {$/;"	f
alloc_and_load_idirect_from_blk_pin	util/vpr_utils.c	/^void alloc_and_load_idirect_from_blk_pin(t_direct_inf* directs, int num_directs, $/;"	f
alloc_and_load_imacro_from_iblk	place/place_macro.c	/^static void alloc_and_load_imacro_from_iblk(t_pl_macro * macros, int num_macros) {$/;"	f	file:
alloc_and_load_interconnect_pins	pack/pb_type_graph.c	/^static void alloc_and_load_interconnect_pins(t_interconnect_pins * interc_pins,$/;"	f	file:
alloc_and_load_is_clock	pack/pack.c	/^boolean *alloc_and_load_is_clock(boolean global_clocks) {$/;"	f
alloc_and_load_legalizer_for_cluster	pack/cluster_legality.c	/^void alloc_and_load_legalizer_for_cluster(INP t_block* clb, INP int clb_index,$/;"	f
alloc_and_load_mode_interconnect	pack/pb_type_graph.c	/^static void alloc_and_load_mode_interconnect($/;"	f	file:
alloc_and_load_mux_graph	power/power_util.c	/^static t_mux_node * alloc_and_load_mux_graph(int num_inputs, int levels) {$/;"	f	file:
alloc_and_load_mux_graph_recursive	power/power_util.c	/^static void alloc_and_load_mux_graph_recursive(t_mux_node * node,$/;"	f	file:
alloc_and_load_mux_interc_edges	pack/pb_type_graph.c	/^static void alloc_and_load_mux_interc_edges( INP t_interconnect * interconnect,$/;"	f	file:
alloc_and_load_net_pin_index	util/vpr_utils.c	/^int ** alloc_and_load_net_pin_index() {$/;"	f
alloc_and_load_netlist_clocks_and_ios	timing/read_sdc.c	/^static void alloc_and_load_netlist_clocks_and_ios(void) {$/;"	f	file:
alloc_and_load_output_file_names	base/ReadOptions.c	/^void alloc_and_load_output_file_names(const char *default_name) {$/;"	f
alloc_and_load_pack_molecules	pack/prepack.c	/^t_pack_molecule *alloc_and_load_pack_molecules($/;"	f
alloc_and_load_pack_patterns	pack/prepack.c	/^t_pack_patterns *alloc_and_load_pack_patterns(OUTP int *num_packing_patterns) {$/;"	f
alloc_and_load_pb_graph	pack/pb_type_graph.c	/^static void alloc_and_load_pb_graph(INOUTP t_pb_graph_node *pb_graph_node,$/;"	f	file:
alloc_and_load_pb_stats	pack/cluster.c	/^static void alloc_and_load_pb_stats(t_pb *pb, int max_models,$/;"	f	file:
alloc_and_load_perturb_ipins	route/rr_graph.c	/^alloc_and_load_perturb_ipins(INP int nodes_per_chan, INP int L_num_types,$/;"	f	file:
alloc_and_load_pin_locations_from_pb_graph	pack/pb_type_graph.c	/^static void alloc_and_load_pin_locations_from_pb_graph(t_type_descriptor *type) {$/;"	f	file:
alloc_and_load_pin_to_track_map	route/rr_graph.c	/^alloc_and_load_pin_to_track_map(INP enum e_pin_type pin_type,$/;"	f	file:
alloc_and_load_placement_macros	place/place_macro.c	/^int alloc_and_load_placement_macros(t_direct_inf* directs, int num_directs, t_pl_macro ** macros){$/;"	f
alloc_and_load_placement_structs	place/place.c	/^static void alloc_and_load_placement_structs($/;"	f	file:
alloc_and_load_port_pin_from_blk_pin	util/vpr_utils.c	/^static void alloc_and_load_port_pin_from_blk_pin(void) {$/;"	f	file:
alloc_and_load_port_pin_ptrs_from_string	pack/pb_type_graph.c	/^t_pb_graph_pin *** alloc_and_load_port_pin_ptrs_from_string(INP int line_num,$/;"	f
alloc_and_load_pre_packing_timing_graph	timing/path_delay.c	/^t_slack * alloc_and_load_pre_packing_timing_graph(float block_delay,$/;"	f
alloc_and_load_rc_tree	timing/net_delay.c	/^alloc_and_load_rc_tree(int inet, t_rc_node ** rc_node_free_list_ptr,$/;"	f
alloc_and_load_rr_clb_source	route/rr_graph.c	/^static void alloc_and_load_rr_clb_source(t_ivec *** L_rr_node_indices) {$/;"	f	file:
alloc_and_load_rr_graph	route/rr_graph.c	/^static void alloc_and_load_rr_graph(INP int num_nodes,$/;"	f	file:
alloc_and_load_rr_graph_for_pb_graph_node	pack/cluster_legality.c	/^void alloc_and_load_rr_graph_for_pb_graph_node($/;"	f
alloc_and_load_rr_indexed_data	route/rr_graph_indexed_data.c	/^void alloc_and_load_rr_indexed_data(INP t_segment_inf * segment_inf,$/;"	f
alloc_and_load_rr_node_indices	route/rr_graph2.c	/^alloc_and_load_rr_node_indices(INP int nodes_per_chan, INP int L_nx,$/;"	f
alloc_and_load_rr_node_route_structs	route/route_common.c	/^void alloc_and_load_rr_node_route_structs(void) {$/;"	f
alloc_and_load_seg_details	route/rr_graph2.c	/^alloc_and_load_seg_details(INOUTP int *nodes_per_chan, INP int max_len,$/;"	f
alloc_and_load_sharable_switch_trans	route/rr_graph_area.c	/^alloc_and_load_sharable_switch_trans(int num_switch, float trans_sram_bit,$/;"	f	file:
alloc_and_load_switch_block_conn	route/rr_graph_sbox.c	/^alloc_and_load_switch_block_conn(INP int nodes_per_chan,$/;"	f
alloc_and_load_timing_graph	timing/path_delay.c	/^t_slack * alloc_and_load_timing_graph(t_timing_inf timing_inf) {$/;"	f
alloc_and_load_timing_graph_levels	timing/path_delay2.c	/^int alloc_and_load_timing_graph_levels(void) {$/;"	f
alloc_and_load_tnode_fanin_and_check_edges	timing/path_delay2.c	/^alloc_and_load_tnode_fanin_and_check_edges(int *num_sinks_ptr) {$/;"	f	file:
alloc_and_load_tnodes	timing/path_delay.c	/^static void alloc_and_load_tnodes(t_timing_inf timing_inf) {$/;"	f	file:
alloc_and_load_tnodes_from_prepacked_netlist	timing/path_delay.c	/^static void alloc_and_load_tnodes_from_prepacked_netlist(float block_delay,$/;"	f	file:
alloc_and_load_track_to_pin_lookup	route/rr_graph.c	/^alloc_and_load_track_to_pin_lookup(INP int ****pin_to_track_map, INP int *Fc,$/;"	f	file:
alloc_and_load_try_swap_structs	place/place.c	/^static void alloc_and_load_try_swap_structs() {$/;"	f	file:
alloc_and_load_unsharable_switch_trans	route/rr_graph_area.c	/^alloc_and_load_unsharable_switch_trans(int num_switch, float trans_sram_bit,$/;"	f	file:
alloc_block	place/timing_place_lookup.c	/^static void alloc_block(void) {$/;"	f	file:
alloc_crit	place/timing_place.c	/^static float ** alloc_crit(t_chunk *chunk_list_ptr) {$/;"	f	file:
alloc_delta_arrays	place/timing_place_lookup.c	/^static void alloc_delta_arrays(void) {$/;"	f	file:
alloc_draw_structs	base/draw.c	/^void alloc_draw_structs(void) {$/;"	f
alloc_hash_table	util/hash.c	/^alloc_hash_table(void) {$/;"	f
alloc_heap_data	route/route_common.c	/^alloc_heap_data(void) {$/;"	f	file:
alloc_internal_cb_nets	base/read_netlist.c	/^static void alloc_internal_cb_nets(INOUTP t_pb *top_level,$/;"	f	file:
alloc_isink_to_inode	mrfpga/buffer_insertion.c	/^static int alloc_isink_to_inode( int inet, int** isink_to_inode_ptr )$/;"	f	file:
alloc_ivector_and_copy_int_list	../../libarchfpga/util.c	/^void alloc_ivector_and_copy_int_list(t_linked_int ** list_head_ptr,$/;"	f
alloc_legal_placements	place/place.c	/^static void alloc_legal_placements() {$/;"	f	file:
alloc_linked_f_pointer	route/route_common.c	/^alloc_linked_f_pointer(void) {$/;"	f	file:
alloc_linked_rc_edge	timing/net_delay.c	/^alloc_linked_rc_edge(t_linked_rc_edge ** rc_edge_free_list_ptr) {$/;"	f
alloc_linked_rt_edge	route/route_tree_timing.c	/^alloc_linked_rt_edge(void) {$/;"	f	file:
alloc_lookups_and_criticalities	place/timing_place.c	/^t_slack * alloc_lookups_and_criticalities(t_chan_width_dist chan_width_dist,$/;"	f
alloc_matrix	../../libarchfpga/util.c	/^alloc_matrix(int nrmin, int nrmax, int ncmin, int ncmax, size_t elsize) {$/;"	f
alloc_matrix3	../../libarchfpga/util.c	/^alloc_matrix3(int nrmin, int nrmax, int ncmin, int ncmax, int ndmin, int ndmax,$/;"	f
alloc_matrix4	../../libarchfpga/util.c	/^alloc_matrix4(int nrmin, int nrmax, int ncmin, int ncmax, int ndmin, int ndmax,$/;"	f
alloc_net	place/timing_place_lookup.c	/^static void alloc_net(void) {$/;"	f	file:
alloc_net_delay	timing/net_delay.c	/^alloc_net_delay(t_chunk *chunk_list_ptr, struct s_net *nets,$/;"	f
alloc_net_rr_terminals	route/rr_graph.c	/^static void alloc_net_rr_terminals(void) {$/;"	f	file:
alloc_net_rr_terminals_cluster	pack/cluster_legality.c	/^static void alloc_net_rr_terminals_cluster(void) {$/;"	f	file:
alloc_pin_classes_in_pb_graph_node	pack/cluster_feasibility_filter.c	/^static void alloc_pin_classes_in_pb_graph_node($/;"	f	file:
alloc_rc_node	timing/net_delay.c	/^alloc_rc_node(t_rc_node ** rc_node_free_list_ptr) {$/;"	f
alloc_route_static_structs	route/route_common.c	/^void alloc_route_static_structs(void) {$/;"	f
alloc_route_structs	route/route_common.c	/^alloc_route_structs(void) {$/;"	f
alloc_route_tree_timing_structs	route/route_tree_timing.c	/^void alloc_route_tree_timing_structs(void) {$/;"	f
alloc_routing_structs	place/timing_place_lookup.c	/^static void alloc_routing_structs(struct s_router_opts router_opts,$/;"	f	file:
alloc_rt_node	route/route_tree_timing.c	/^alloc_rt_node(void) {$/;"	f	file:
alloc_saved_routing	route/route_common.c	/^alloc_saved_routing(t_ivec ** clb_opins_used_locally,$/;"	f
alloc_sblock_pattern_lookup	route/rr_graph2.c	/^alloc_sblock_pattern_lookup(INP int L_nx, INP int L_ny, INP int nodes_per_chan) {$/;"	f
alloc_slacks	timing/path_delay.c	/^static t_slack * alloc_slacks(void) {$/;"	f	file:
alloc_timing_driven_route_structs	route/route_timing.c	/^void alloc_timing_driven_route_structs(float **pin_criticality_ptr,$/;"	f
alloc_timing_stats	timing/path_delay.c	/^static void alloc_timing_stats(void) {$/;"	f	file:
alloc_trace_data	route/route_common.c	/^alloc_trace_data(void) {$/;"	f	file:
allocate_and_load_critical_path	timing/path_delay.c	/^t_linked_int * allocate_and_load_critical_path(void) {$/;"	f
allow_early_exit	base/ReadOptions.h	/^	boolean allow_early_exit;$/;"	m	struct:s_options
allow_early_exit	base/vpr_types.h	/^	boolean allow_early_exit;$/;"	m	struct:s_packer_opts
allow_unrelated_clustering	base/ReadOptions.h	/^	boolean allow_unrelated_clustering;$/;"	m	struct:s_options
allow_unrelated_clustering	base/vpr_types.h	/^	boolean allow_unrelated_clustering;$/;"	m	struct:s_packer_opts
alpha	base/ReadOptions.h	/^	float alpha;$/;"	m	struct:s_options
alpha	base/vpr_types.h	/^	float alpha;$/;"	m	struct:s_packer_opts
alpha_t	base/vpr_types.h	/^	float alpha_t;$/;"	m	struct:s_annealing_sched
anchored	timing/slre.c	/^  int anchored;   \/\/ Must match from string start$/;"	m	struct:slre	file:
angnorm	base/graphics.c	/^angnorm (float ang) $/;"	f	file:
annotations	../../libarchfpga/include/physical_types.h	/^	t_pin_to_pin_annotation *annotations; \/* [0..num_annotations-1] *\/$/;"	m	struct:s_interconnect
annotations	../../libarchfpga/include/physical_types.h	/^	t_pin_to_pin_annotation *annotations; \/* [0..num_annotations-1] *\/$/;"	m	struct:s_pb_type
anyof	timing/slre.c	/^static void anyof(struct slre *r, const char **re) {$/;"	f	file:
apply_swseg_pattern_chanx_track	route/rr_graph_swseg.c	/^    apply_swseg_pattern_chanx_track(INP int track_id,$/;"	f	file:
apply_swseg_pattern_chany_track	route/rr_graph_swseg.c	/^    apply_swseg_pattern_chany_track(INP int track_id,$/;"	f	file:
arch_mrfpga	../../libarchfpga/include/physical_types.h	/^    t_arch_mrfpga arch_mrfpga;$/;"	m	struct:s_arch
area	../../libarchfpga/include/physical_types.h	/^	float area;$/;"	m	struct:s_type_descriptor
area	../../libarchfpga/include/spice_types.h	/^  float area; \/\/Xifan TANG$/;"	m	struct:s_sram_inf
aspect	base/vpr_types.h	/^	float aspect;$/;"	m	struct:s_packer_opts
assess_swap	place/place.c	/^static enum swap_result assess_swap(float delta_c, float t) {$/;"	f	file:
assign_blocks_and_route_net	place/timing_place_lookup.c	/^static float assign_blocks_and_route_net(t_type_ptr source_type,$/;"	f	file:
assign_locations	place/timing_place_lookup.c	/^static void assign_locations(t_type_ptr source_type, int source_x_loc,$/;"	f	file:
assign_lut_truth_table	spice/spice_lut.c	/^char** assign_lut_truth_table(t_logical_block* mapped_logical_block,$/;"	f
astar_fac	base/ReadOptions.h	/^	float astar_fac;$/;"	m	struct:s_options
astar_fac	base/vpr_types.h	/^	float astar_fac;$/;"	m	struct:s_router_opts
attr	../../libarchfpga/include/ezxml.h	/^	char ***attr; \/* default attributes *\/$/;"	m	struct:ezxml_root
attr	../../libarchfpga/include/ezxml.h	/^	char **attr; \/* tag attributes { name, value, name, value, ... NULL } *\/$/;"	m	struct:ezxml
auto_compute_inter_cluster_net_delay	base/vpr_types.h	/^	boolean auto_compute_inter_cluster_net_delay;$/;"	m	struct:s_packer_opts
autosize_buffer	../../libarchfpga/include/physical_types.h	/^	boolean autosize_buffer; \/* autosize clock buffers *\/$/;"	m	struct:s_clock_network
back_annotate_rr_node_map_info	spice/spice_api.c	/^void back_annotate_rr_node_map_info() {$/;"	f	file:
backannotate_clb_nets_act_info	spice/spice_api.c	/^void backannotate_clb_nets_act_info() {$/;"	f	file:
backannotate_clb_nets_init_val	spice/spice_api.c	/^void backannotate_clb_nets_init_val() {$/;"	f	file:
backannotate_rr_nodes_net_info	spice/spice_api.c	/^void backannotate_rr_nodes_net_info() {$/;"	f	file:
background_cindex	base/graphics.c	/^   int background_cindex;$/;"	m	struct:__anon5	file:
backup_one_pb_rr_node_pack_prev_node_edge	spice/spice_utils.c	/^void backup_one_pb_rr_node_pack_prev_node_edge(t_rr_node* pb_rr_node) {$/;"	f
backward_expand_pack_pattern_from_edge	pack/prepack.c	/^static void backward_expand_pack_pattern_from_edge($/;"	f	file:
backward_infer_pattern	pack/prepack.c	/^static void backward_infer_pattern(INOUTP t_pb_graph_pin *pb_graph_pin) {$/;"	f	file:
backward_path_cost	route/route_common.h	/^	float backward_path_cost;$/;"	m	struct:__anon15
backward_path_cost	route/route_common.h	/^	float backward_path_cost;$/;"	m	struct:s_heap
backward_weight	base/vpr_types.h	/^	float forward_weight, backward_weight; \/* Weightings of the importance of paths $/;"	m	struct:s_tnode
base_cost	../../libarchfpga/include/cad_types.h	/^	float base_cost; \/* base cost of pattern eg. If a group of logical blocks match a pattern of smaller primitives, that is better than the same group using bigger primitives *\/$/;"	m	struct:s_pack_patterns
base_cost	../../libarchfpga/include/cad_types.h	/^	float base_cost; \/* cost independant of current status of packing *\/$/;"	m	struct:s_cluster_placement_primitive
base_cost	base/vpr_types.h	/^	float base_cost;$/;"	m	struct:s_rr_indexed_data
base_cost_type	base/ReadOptions.h	/^	enum e_base_cost_type base_cost_type;$/;"	m	struct:s_options	typeref:enum:s_options::e_base_cost_type
base_cost_type	base/vpr_types.h	/^	enum e_base_cost_type base_cost_type;$/;"	m	struct:s_router_opts	typeref:enum:s_router_opts::e_base_cost_type
base_gain	base/vpr_types.h	/^	float base_gain; \/* Intrinsic "goodness" score for molecule independant of rest of netlist *\/$/;"	m	struct:s_pack_molecule
basics_spice_file_name	spice/spice_globals.c	/^char* basics_spice_file_name = "inv_buf_trans_gate.sp";$/;"	v
bb_coords	place/place.c	/^static struct s_bb *bb_coords = NULL, *bb_num_on_edges = NULL;$/;"	v	typeref:struct:s_bb	file:
bb_factor	base/ReadOptions.h	/^	int bb_factor;$/;"	m	struct:s_options
bb_factor	base/vpr_types.h	/^	int bb_factor;$/;"	m	struct:s_router_opts
bb_num_on_edges	place/place.c	/^static struct s_bb *bb_coords = NULL, *bb_num_on_edges = NULL;$/;"	v	typeref:struct:	file:
bb_updated_before	place/place.c	/^static char * bb_updated_before = NULL;$/;"	v	file:
bend_cost	base/ReadOptions.h	/^	float bend_cost;$/;"	m	struct:s_options
bend_cost	base/vpr_types.h	/^	float bend_cost;$/;"	m	struct:s_router_opts
best_routing	pack/cluster_legality.c	/^static struct s_trace **best_routing;$/;"	v	typeref:struct:s_trace	file:
beta	base/ReadOptions.h	/^	float beta;$/;"	m	struct:s_options
beta	base/vpr_types.h	/^	float beta;$/;"	m	struct:s_packer_opts
binary_not	power/power_callibrate.c	/^static char binary_not(char c) {$/;"	f	file:
binary_search	base/globals.c	/^int binary_search = -1;$/;"	v
binary_search_place_and_route	base/place_and_route.c	/^static int binary_search_place_and_route(struct s_placer_opts placer_opts,$/;"	f	file:
bitfield	base/vpr_types.h	/^typedef size_t bitfield;$/;"	t
blif	base/read_blif.c	/^static FILE *blif;$/;"	v	file:
blif_circuit_name	base/globals.c	/^char *blif_circuit_name = NULL;$/;"	v
blif_file_name	base/vpr_types.h	/^	char *blif_file_name;$/;"	m	struct:s_packer_opts
blif_hash	base/read_blif.c	/^static struct s_hash **blif_hash;$/;"	v	typeref:struct:s_hash	file:
blif_model	../../libarchfpga/include/physical_types.h	/^	char *blif_model;$/;"	m	struct:s_pb_type
blk_index	place/place_macro.h	/^	int blk_index;$/;"	m	struct:s_pl_macro_member
block	base/globals.c	/^struct s_block *block = NULL;$/;"	v	typeref:struct:s_block
block	base/globals_declare.h	/^struct s_block *block;$/;"	v	typeref:struct:s_block
block	base/vpr_types.h	/^	int block; \/* logical block primitive which this tnode is part of *\/$/;"	m	struct:s_tnode
block_color	base/draw.c	/^static enum color_types *net_color, *block_color;$/;"	v	typeref:enum:	file:
block_criticality	pack/cluster.c	/^static float *block_criticality = NULL;$/;"	v	file:
block_delay	base/ReadOptions.h	/^	float block_delay;$/;"	m	struct:s_options
block_delay	base/vpr_types.h	/^	float block_delay;$/;"	m	struct:s_packer_opts
block_dist	base/ReadOptions.h	/^	int block_dist;$/;"	m	struct:s_options
block_dist	base/vpr_types.h	/^	int block_dist;$/;"	m	struct:s_placer_opts
block_id	../../libarchfpga/include/cad_types.h	/^	int block_id;$/;"	m	struct:s_pack_pattern_block
block_num	place/place.c	/^	int block_num;$/;"	m	struct:s_pl_moved_block	file:
blocks	base/vpr_types.h	/^	int *blocks;$/;"	m	struct:s_grid_tile
blocks_affected	place/place.c	/^static t_pl_blocks_to_be_moved blocks_affected;$/;"	v	file:
boolean	../../libarchfpga/include/util.h	/^typedef int boolean;$/;"	t
boolean	../../libarchfpga/include/util.h	/^} boolean;$/;"	t	typeref:enum:__anon23
breadth_first_add_source_to_heap	route/route_breadth_first.c	/^static void breadth_first_add_source_to_heap(int inet) {$/;"	f	file:
breadth_first_add_source_to_heap_cluster	pack/cluster_legality.c	/^static void breadth_first_add_source_to_heap_cluster(int inet) {$/;"	f	file:
breadth_first_expand_neighbours	route/route_breadth_first.c	/^static void breadth_first_expand_neighbours(int inode, float pcost, int inet,$/;"	f	file:
breadth_first_expand_neighbours_cluster	pack/cluster_legality.c	/^static void breadth_first_expand_neighbours_cluster(int inode, float pcost,$/;"	f	file:
breadth_first_expand_trace_segment	route/route_breadth_first.c	/^static void breadth_first_expand_trace_segment(struct s_trace *start_ptr,$/;"	f	file:
breadth_first_expand_trace_segment_cluster	pack/cluster_legality.c	/^static void breadth_first_expand_trace_segment_cluster($/;"	f	file:
breadth_first_route_net	route/route_breadth_first.c	/^static boolean breadth_first_route_net(int inet, float bend_cost) {$/;"	f	file:
breadth_first_route_net_cluster	pack/cluster_legality.c	/^static boolean breadth_first_route_net_cluster(int inet) {$/;"	f	file:
buf_size	../../libarchfpga/include/physical_types.h	/^	float buf_size;$/;"	m	struct:s_switch_inf
buffer_net	place/timing_place_lookup.c	/^static void buffer_net( float* cur_net_delay )$/;"	f	file:
buffer_size	../../libarchfpga/include/physical_types.h	/^	float buffer_size; \/* if not autosized, the clock buffer size *\/$/;"	m	struct:s_clock_network
buffer_size	../../libarchfpga/include/physical_types.h	/^	float buffer_size;$/;"	m	struct:s_pb_graph_pin_power
buffer_size	../../libarchfpga/include/physical_types.h	/^	float buffer_size;$/;"	m	struct:s_port_power
buffer_size_inf	power/power.h	/^	t_power_buffer_size_inf * buffer_size_inf;$/;"	m	struct:s_power_tech
buffer_type	../../libarchfpga/include/physical_types.h	/^	e_power_buffer_type buffer_type;$/;"	m	struct:s_port_power
buffered	../../libarchfpga/include/physical_types.h	/^	boolean buffered;$/;"	m	struct:s_switch_inf
buffered	base/vpr_types.h	/^    int buffered;$/;"	m	struct:s_rr_node
build_bidir_rr_opins	route/rr_graph.c	/^static void build_bidir_rr_opins(INP int i, INP int j,$/;"	f	file:
build_default_menu	base/graphics.c	/^build_default_menu (void) $/;"	f	file:
build_prev_node_list_rr_nodes	spice/spice_api.c	/^void build_prev_node_list_rr_nodes(int LL_num_rr_nodes,$/;"	f	file:
build_rr_graph	route/rr_graph.c	/^void build_rr_graph(INP t_graph_type graph_type, INP int L_num_types,$/;"	f
build_rr_sinks_sources	route/rr_graph.c	/^static void build_rr_sinks_sources(INP int i, INP int j,$/;"	f	file:
build_rr_xchan	route/rr_graph.c	/^static void build_rr_xchan(INP int i, INP int j,$/;"	f	file:
build_rr_ychan	route/rr_graph.c	/^static void build_rr_ychan(INP int i, INP int j,$/;"	f	file:
build_textarea	base/graphics.c	/^static void build_textarea (void) $/;"	f	file:
build_unidir_rr_opins	route/rr_graph.c	/^static void build_unidir_rr_opins(INP int i, INP int j,$/;"	f	file:
button	base/graphics.c	/^static t_button *button = NULL;                 \/* [0..num_buttons-1] *\/$/;"	v	file:
cal_capacitance_from_routing	mrfpga/cal_capacitance.c	/^void cal_capacitance_from_routing ( ) {$/;"	f
calc_buffer_stage_effort	power/power_util.c	/^float calc_buffer_stage_effort(int N, float final_stage_size) {$/;"	f
calculate_constraint	timing/read_sdc.c	/^static float calculate_constraint(t_sdc_clock source_domain, t_sdc_clock sink_domain) {$/;"	f	file:
callibrate	power/PowerSpicedComponent.c	/^void PowerCallibInputs::callibrate() {$/;"	f	class:PowerCallibInputs
callibrate	power/PowerSpicedComponent.c	/^void PowerSpicedComponent::callibrate(void) {$/;"	f	class:PowerSpicedComponent
cap	timing/slre.c	/^struct cap {$/;"	s	file:
cap_val	../../libarchfpga/include/spice_types.h	/^  float cap_val; $/;"	m	struct:s_spice_model_wire_param
capacitance	../../libarchfpga/include/physical_types.h	/^	float capacitance;$/;"	m	struct:s_pb_graph_edge
capacity	../../libarchfpga/include/physical_types.h	/^	int capacity;$/;"	m	struct:s_type_descriptor
capacity	base/vpr_types.h	/^	float capacity;$/;"	m	struct:s_place_region
capacity	base/vpr_types.h	/^	short capacity;$/;"	m	struct:s_rr_node
captab	../../libarchfpga/include/spice_types.h	/^  int captab;$/;"	m	struct:s_spice_params
capture	timing/slre.c	/^static const char *capture(const struct cap *caps, int num_caps, va_list ap) {$/;"	f	file:
capture_float	timing/slre.c	/^static const char *capture_float(const struct cap *cap, void *p, size_t len) {$/;"	f	file:
capture_int	timing/slre.c	/^static const char *capture_int(const struct cap *cap, void *p, size_t len) {$/;"	f	file:
capture_string	timing/slre.c	/^static const char *capture_string(const struct cap *cap, void *p, size_t len) {$/;"	f	file:
casecmp	timing/slre.c	/^static int casecmp(const void *p1, const void *p2, size_t len) {$/;"	f	file:
cat_llists	spice/linkedlist.c	/^t_llist* cat_llists(t_llist* head1,$/;"	f
cb	../../libarchfpga/include/physical_types.h	/^	boolean *cb;$/;"	m	struct:s_segment_inf
cb	base/vpr_types.h	/^	boolean *cb;$/;"	m	struct:s_seg_details
cb_len	../../libarchfpga/include/physical_types.h	/^	int cb_len;$/;"	m	struct:s_segment_inf
cb_switches	../../libarchfpga/include/physical_types.h	/^    t_switch_inf* cb_switches;$/;"	m	struct:s_arch
cb_type_descriptors	../../libarchfpga/read_xml_arch_file.c	/^static struct s_type_descriptor *cb_type_descriptors;$/;"	v	typeref:struct:s_type_descriptor	file:
cc_constraints	base/vpr_types.h	/^	t_override_constraint * cc_constraints; \/*  [0..num_cc_constraints - 1] array of such constraints *\/$/;"	m	struct:s_timing_constraints
cf_constraints	base/vpr_types.h	/^	t_override_constraint * cf_constraints; \/*  [0..num_cf_constraints - 1] array of such constraints *\/$/;"	m	struct:s_timing_constraints
chain_name	../../libarchfpga/include/physical_types.h	/^	char *chain_name;$/;"	m	struct:s_port
chain_pattern	base/vpr_types.h	/^	t_model_chain_pattern *chain_pattern; \/* If this is a chain molecule, chain that this molecule matches *\/$/;"	m	struct:s_pack_molecule
chain_root_pin	../../libarchfpga/include/cad_types.h	/^	t_pb_graph_pin *chain_root_pin; \/* pointer to logic block input pin that drives this chain from the preceding logic block *\/	$/;"	m	struct:s_pack_patterns
chan_length	../../libarchfpga/include/spice_types.h	/^  float chan_length;$/;"	m	struct:s_spice_transistor_type
chan_width_io	../../libarchfpga/include/physical_types.h	/^	float chan_width_io;$/;"	m	struct:s_chan_width_dist
chan_width_x	base/globals.c	/^int *chan_width_x = NULL; \/* [0..ny] *\/$/;"	v
chan_width_x	base/globals_declare.h	/^int *chan_width_x, *chan_width_y; \/* numerical form *\/$/;"	v
chan_width_y	base/globals.c	/^int *chan_width_y = NULL; \/* [0..nx] *\/$/;"	v
chan_width_y	base/globals_declare.h	/^int *chan_width_x, *chan_width_y; \/* numerical form *\/$/;"	v
chan_x_dist	../../libarchfpga/include/physical_types.h	/^	t_chan chan_x_dist;$/;"	m	struct:s_chan_width_dist
chan_y_dist	../../libarchfpga/include/physical_types.h	/^	t_chan chan_y_dist;$/;"	m	struct:s_chan_width_dist
change_button_text	base/graphics.c	/^void change_button_text(const char *button_name, const char *new_button_text) {$/;"	f
change_button_text	base/graphics.c	/^void change_button_text(const char *button_text, const char *new_button_text) { }$/;"	f
channel_width	power/power.h	/^	int channel_width;$/;"	m	struct:s_solution_inf
chanx_chany_adjacent	route/check_route.c	/^static int chanx_chany_adjacent(int chanx_node, int chany_node) {$/;"	f	file:
chanx_place_cost_fac	place/place.c	/^static float **chanx_place_cost_fac, **chany_place_cost_fac;$/;"	v	file:
chany_place_cost_fac	place/place.c	/^static float **chanx_place_cost_fac, **chany_place_cost_fac;$/;"	v	file:
checkTokenType	util/token.c	/^boolean checkTokenType(INP t_token token, OUTP enum e_token_type token_type) {$/;"	f
check_adjacent	route/check_route.c	/^static boolean check_adjacent(int from_node, int to_node) {$/;"	f	file:
check_all_tracks_reach_pins	route/rr_graph.c	/^static void check_all_tracks_reach_pins(t_type_ptr type,$/;"	f	file:
check_and_add_mux_to_linked_list	spice/spice_mux.c	/^void check_and_add_mux_to_linked_list(t_llist** muxes_head,$/;"	f
check_and_count_models	base/read_blif.c	/^static void check_and_count_models(int doall, const char* model_name,$/;"	f	file:
check_clb_conn	base/check_netlist.c	/^static int check_clb_conn(int iblk, int num_conn) {$/;"	f	file:
check_clb_internal_nets	base/check_netlist.c	/^static int check_clb_internal_nets(int iblk) {$/;"	f	file:
check_clocks	pack/cluster.c	/^static void check_clocks(boolean *is_clock) {$/;"	f	file:
check_cluster_logical_blocks	pack/cluster.c	/^static void check_cluster_logical_blocks(t_pb *pb, boolean *blocks_checked) {$/;"	f	file:
check_clustering	pack/cluster.c	/^static void check_clustering(int num_clb, t_block *clb, boolean *is_clock) {$/;"	f	file:
check_connections_to_global_clb_pins	base/check_netlist.c	/^static int check_connections_to_global_clb_pins(int inet) {$/;"	f	file:
check_des_blk_pin	clb_pin_remap/clb_pin_remap_util.c	/^int check_des_blk_pin(int n_blks, t_block* blk,$/;"	f
check_fontsize	base/graphics.c	/^static int check_fontsize(int pointsize,$/;"	f	file:
check_for_duplicated_names	base/check_netlist.c	/^static int check_for_duplicated_names(void) {$/;"	f	file:
check_keywords_conflict	spice/spice_api.c	/^void check_keywords_conflict(t_arch Arch) {$/;"	f
check_locally_used_clb_opins	route/check_route.c	/^static void check_locally_used_clb_opins(t_ivec ** clb_opins_used_locally,$/;"	f	file:
check_lookahead_pins_used	pack/cluster.c	/^static boolean check_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:
check_macro_can_be_placed	place/place.c	/^static int check_macro_can_be_placed(int imacro, int itype, int x, int y, int z) {$/;"	f	file:
check_net	base/read_blif.c	/^static void check_net(boolean sweep_hanging_nets_and_inputs) {$/;"	f	file:
check_netlist	base/check_netlist.c	/^void check_netlist() {$/;"	f
check_node	route/check_rr_graph.c	/^void check_node(int inode, enum e_route_type route_type) {$/;"	f
check_node_and_range	route/check_route.c	/^static void check_node_and_range(int inode, enum e_route_type route_type) {$/;"	f	file:
check_pass_transistors	route/check_rr_graph.c	/^static void check_pass_transistors(int from_node) {$/;"	f	file:
check_pb_graph	pack/pb_type_graph.c	/^static int check_pb_graph(void) {$/;"	f	file:
check_pb_graph_edge	spice/spice_utils.c	/^void check_pb_graph_edge(t_pb_graph_edge pb_graph_edge) {$/;"	f
check_pb_graph_pin_edges	spice/spice_utils.c	/^void check_pb_graph_pin_edges(t_pb_graph_pin pb_graph_pin) {$/;"	f
check_place	place/place.c	/^static void check_place(float bb_cost, float timing_cost, $/;"	f	file:
check_primitives	base/check_netlist.c	/^static int check_primitives(int iblk, int isub) {$/;"	f	file:
check_route	route/check_route.c	/^void check_route(enum e_route_type route_type, int num_switch,$/;"	f
check_rr_graph	route/check_rr_graph.c	/^void check_rr_graph(INP t_graph_type graph_type, INP t_type_ptr types,$/;"	f
check_sink	route/check_route.c	/^static void check_sink(int inode, int inet, boolean * pin_done) {$/;"	f	file:
check_source	route/check_route.c	/^static void check_source(int inode, int inet) {$/;"	f	file:
check_spice_models	../../libarchfpga/read_xml_spice.c	/^static void check_spice_models(int num_spice_model,$/;"	f	file:
check_src_blk_pin	clb_pin_remap/clb_pin_remap_util.c	/^int check_src_blk_pin(int n_blks, t_block* blk,$/;"	f
check_subblock_internal_nets	base/check_netlist.c	/^static int check_subblock_internal_nets(int iblk, int isub) {$/;"	f	file:
check_subblocks	base/check_netlist.c	/^static int check_subblocks(int iblk) {$/;"	f	file:
check_switch	route/check_route.c	/^static void check_switch(struct s_trace *tptr, int num_switch) {$/;"	f	file:
check_timing_graph	timing/path_delay2.c	/^void check_timing_graph(int num_sinks) {$/;"	f
child	../../libarchfpga/include/ezxml.h	/^	ezxml_t child; \/* head of sub tag list, NULL if none *\/$/;"	m	struct:ezxml
child	route/route_tree_timing.h	/^	struct s_rt_node *child;$/;"	m	struct:s_linked_rt_edge	typeref:struct:s_linked_rt_edge::s_rt_node
child	timing/net_delay_types.h	/^	struct s_rc_node *child;$/;"	m	struct:s_linked_rc_edge	typeref:struct:s_linked_rc_edge::s_rc_node
child_list	route/route_tree_timing.h	/^		t_linked_rt_edge *child_list;$/;"	m	union:s_rt_node::__anon16
child_list	timing/net_delay_types.h	/^		t_linked_rc_edge *child_list;$/;"	m	union:s_rc_node::__anon18
child_pb_graph_nodes	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_node ***child_pb_graph_nodes; \/* [0..num_modes-1][0..num_pb_type_in_mode-1][0..num_pb-1] *\/$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_pb_graph_node
child_pbs	base/vpr_types.h	/^	struct s_pb **child_pbs; \/* children pbs attached to this pb [0..num_child_pb_types - 1][0..child_type->num_pb - 1] *\/$/;"	m	struct:s_pb	typeref:struct:s_pb::s_pb
children	power/power.h	/^	t_mux_node * children; \/* Multiplexers that drive the inputs [0..num_inputs-1] *\/$/;"	m	struct:s_mux_node
chomp_file_name_postfix	spice/spice_utils.c	/^char* chomp_file_name_postfix(char* file_name) {$/;"	f
chomp_spice_node_prefix	spice/spice_utils.c	/^char* chomp_spice_node_prefix(char* spice_node_prefix) {$/;"	f
chunk_ptr_head	../../libarchfpga/include/util.h	/^	struct s_linked_vptr *chunk_ptr_head; $/;"	m	struct:s_chunk	typeref:struct:s_chunk::s_linked_vptr
circuit_p_io_removed	base/globals.c	/^struct s_linked_vptr *circuit_p_io_removed = NULL;$/;"	v	typeref:struct:s_linked_vptr
class_inf	../../libarchfpga/include/physical_types.h	/^	struct s_class *class_inf; \/* [0..num_class-1] *\/$/;"	m	struct:s_type_descriptor	typeref:struct:s_type_descriptor::s_class
class_type	../../libarchfpga/include/physical_types.h	/^	enum e_pb_type_class class_type;$/;"	m	struct:s_pb_type	typeref:enum:s_pb_type::e_pb_type_class
clay_logical_equivalence_handling	base/vpr_api.c	/^static void clay_logical_equivalence_handling(const t_arch *arch) {$/;"	f	file:
clay_lut_input_rebalancing	base/vpr_api.c	/^static void clay_lut_input_rebalancing(int iblock, t_pb *pb) {$/;"	f	file:
clay_reload_ble_locations	base/vpr_api.c	/^static void clay_reload_ble_locations(int iblock) {$/;"	f	file:
clb_grid	../../libarchfpga/include/physical_types.h	/^	struct s_clb_grid clb_grid;$/;"	m	struct:s_arch	typeref:struct:s_arch::s_clb_grid
clb_index	base/vpr_types.h	/^	int clb_index; \/* Complex block index that this logical block got mapped to *\/$/;"	m	struct:s_logical_block
clb_net	base/globals.c	/^struct s_net *clb_net = NULL;$/;"	v	typeref:struct:s_net
clb_net_density	power/power_util.c	/^float clb_net_density(int net_idx) {$/;"	f
clb_net_prob	power/power_util.c	/^float clb_net_prob(int net_idx) {$/;"	f
clb_opins_used_locally	place/timing_place_lookup.c	/^static t_ivec **clb_opins_used_locally;$/;"	v	file:
clb_to_vpack_net_mapping	base/globals.c	/^int *clb_to_vpack_net_mapping = NULL; \/* [0..num_clb_nets - 1] *\/$/;"	v
clear_buffer	mrfpga/buffer_insertion.c	/^void clear_buffer( )$/;"	f
clearscreen	base/graphics.c	/^clearscreen (void) $/;"	f
clearscreen	base/graphics.c	/^void clearscreen (void) { }$/;"	f
clock	../../libarchfpga/include/physical_types.h	/^	char * clock;$/;"	m	struct:s_pin_to_pin_annotation
clock_delay	base/vpr_types.h	/^	float clock_delay; \/* The time taken for a clock signal to get to the flip-flop or I\/O (assumed 0 for I\/Os). *\/$/;"	m	struct:s_tnode
clock_domain	base/vpr_types.h	/^	int clock_domain; \/* Index of the clock in g_sdc->constrained_clocks which this flip-flop or I\/O is constrained on. *\/$/;"	m	struct:s_tnode
clock_freq	../../libarchfpga/include/spice_types.h	/^  float clock_freq;$/;"	m	struct:s_spice_stimulate_params
clock_inf	../../libarchfpga/include/physical_types.h	/^	t_clock_network *clock_inf; \/* Details about each clock *\/$/;"	m	struct:s_clock_arch
clock_name	base/vpr_types.h	/^	char * clock_name; \/* Clock it was constrained on *\/$/;"	m	struct:s_io
clock_names	timing/read_sdc.c	/^	char ** clock_names;$/;"	m	struct:s_sdc_exclusive_group	file:
clock_net	base/vpr_types.h	/^	int clock_net; \/* Clock net connected to this logical_block. *\/$/;"	m	struct:s_logical_block
clock_net	base/vpr_types.h	/^	int clock_net; \/* Records clock net driving a flip-flop, valid only for lowest-level, flip-flop PBs *\/$/;"	m	struct:s_pb
clock_net_tnode	base/vpr_types.h	/^	struct s_tnode *clock_net_tnode; \/* correspnding clock net tnode *\/$/;"	m	struct:s_logical_block	typeref:struct:s_logical_block::s_tnode
clock_pins	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin **clock_pins; \/* [0..num_clock_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:s_pb_graph_node
clock_slew_pct_fall	../../libarchfpga/include/spice_types.h	/^  float clock_slew_pct_fall;  $/;"	m	struct:s_spice_stimulate_params
clock_slew_pct_rise	../../libarchfpga/include/spice_types.h	/^  float clock_slew_pct_rise;  $/;"	m	struct:s_spice_stimulate_params
clocks	../../libarchfpga/include/physical_types.h	/^	t_clock_arch * clocks;$/;"	m	struct:s_arch
close	../../libarchfpga/ezxml.c	61;"	d	file:
close_graphics	base/graphics.c	/^close_graphics (void) $/;"	f
close_graphics	base/graphics.c	/^void close_graphics (void) { }$/;"	f
close_postscript	base/graphics.c	/^void close_postscript (void) $/;"	f
close_postscript	base/graphics.c	/^void close_postscript (void) { }$/;"	f
cluster_placement_primitive	../../libarchfpga/include/physical_types.h	/^	struct s_cluster_placement_primitive *cluster_placement_primitive; \/* pointer to indexing structure useful during packing stage *\/$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_cluster_placement_primitive
cluster_seed_type	base/ReadOptions.h	/^	enum e_cluster_seed cluster_seed_type;$/;"	m	struct:s_options	typeref:enum:s_options::e_cluster_seed
cluster_seed_type	base/vpr_types.h	/^	enum e_cluster_seed cluster_seed_type;$/;"	m	struct:s_packer_opts	typeref:enum:s_packer_opts::e_cluster_seed
cluster_size	base/ReadOptions.h	/^	int cluster_size;$/;"	m	struct:s_options
cnt	../../libarchfpga/include/spice_types.h	/^  int cnt; \/* Used in mux_testbench only*\/$/;"	m	struct:s_spice_mux_model
cnt	../../libarchfpga/include/spice_types.h	/^  int cnt;$/;"	m	struct:s_spice_model
code	timing/slre.c	/^  unsigned char code[256];$/;"	m	struct:slre	file:
code_size	timing/slre.c	/^  int code_size;$/;"	m	struct:slre	file:
col_rel	../../libarchfpga/include/physical_types.h	/^	float col_rel;$/;"	m	struct:s_grid_loc_def
color_types	base/easygl_constants.h	/^enum color_types {WHITE, BLACK, DARKGREY, LIGHTGREY, BLUE, GREEN, YELLOW,$/;"	g
colors	base/graphics.c	/^static int colors[NUM_COLOR];$/;"	v	file:
combine_buffer_plan	mrfpga/buffer_insertion.c	/^static t_buffer_plan combine_buffer_plan( t_buffer_plan slow_branch, t_buffer_plan* plan_whole, int num_whole, int num_pins )$/;"	f	file:
commit_lookahead_pins_used	pack/cluster.c	/^static void commit_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:
commit_primitive	pack/cluster_placement.c	/^void commit_primitive(INOUTP t_cluster_placement_stats *cluster_placement_stats,$/;"	f
comp_bb_cost	place/place.c	/^static float comp_bb_cost(enum cost_methods method) {$/;"	f	file:
comp_delta_td_cost	place/place.c	/^static void comp_delta_td_cost(float *delta_timing, float *delta_delay) {$/;"	f	file:
comp_td_costs	place/place.c	/^static void comp_td_costs(float *timing_cost, float *connection_delay_sum) {$/;"	f	file:
comp_td_point_to_point_delay	place/place.c	/^static float comp_td_point_to_point_delay(int inet, int ipin) {$/;"	f	file:
comp_width	base/place_and_route.c	/^static float comp_width(t_chan * chan, float x, float separation) {$/;"	f	file:
compare_molecule_gain	pack/cluster.c	/^static int compare_molecule_gain(const void *a, const void *b) {$/;"	f	file:
compare_pack_pattern	pack/prepack.c	/^static int compare_pack_pattern(const t_pack_patterns *pattern_a, const t_pack_patterns *pattern_b) {$/;"	f	file:
compile	timing/slre.c	/^static void compile(struct slre *r, const char **re) {$/;"	f	file:
compile2	timing/slre.c	/^static const char *compile2(struct slre *r, const char *re) {$/;"	f	file:
complete_truth_table_line	spice/spice_lut.c	/^char* complete_truth_table_line(int lut_size,$/;"	f
component_callibration	power/power.h	/^	PowerSpicedComponent ** component_callibration;$/;"	m	struct:s_power_commonly_used
component_usage	power/PowerSpicedComponent.h	/^	float (*component_usage)(int num_inputs, float transistor_size);$/;"	m	class:PowerSpicedComponent
components	power/power_components.h	/^	t_power_usage * components;$/;"	m	struct:s_power_breakdown
compress_netlist	base/read_blif.c	/^static void compress_netlist(void) {$/;"	f	file:
compute_and_mark_lookahead_pins_used	pack/cluster.c	/^static void compute_and_mark_lookahead_pins_used(int ilogical_block) {$/;"	f	file:
compute_and_mark_lookahead_pins_used_for_pin	pack/cluster.c	/^static void compute_and_mark_lookahead_pins_used_for_pin($/;"	f	file:
compute_delay_lookup_tables	place/timing_place_lookup.c	/^void compute_delay_lookup_tables(struct s_router_opts router_opts,$/;"	f
compute_delta_arrays	place/timing_place_lookup.c	/^static void compute_delta_arrays(struct s_router_opts router_opts,$/;"	f	file:
compute_delta_clb_to_clb	place/timing_place_lookup.c	/^static void compute_delta_clb_to_clb(struct s_router_opts router_opts,$/;"	f	file:
compute_delta_clb_to_io	place/timing_place_lookup.c	/^static void compute_delta_clb_to_io(struct s_router_opts router_opts,$/;"	f	file:
compute_delta_io_to_clb	place/timing_place_lookup.c	/^static void compute_delta_io_to_clb(struct s_router_opts router_opts,$/;"	f	file:
compute_delta_io_to_io	place/timing_place_lookup.c	/^static void compute_delta_io_to_io(struct s_router_opts router_opts,$/;"	f	file:
compute_primitive_base_cost	util/vpr_utils.c	/^float compute_primitive_base_cost(INP t_pb_graph_node *primitive) {$/;"	f
configure_lut_sram_bits_per_line_rec	spice/spice_lut.c	/^void configure_lut_sram_bits_per_line_rec(int** sram_bits, $/;"	f
conn_list	base/verilog_writer.h	/^}conn_list;$/;"	t	typeref:struct:found_connectivity
connect_pb_des_pin_to_src_pin	clb_pin_remap/clb_pin_remap_util.c	/^void connect_pb_des_pin_to_src_pin(t_pb* src_pb,$/;"	f
connection_driven	base/ReadOptions.h	/^	boolean connection_driven;$/;"	m	struct:s_options
connection_driven	base/vpr_types.h	/^	boolean connection_driven;$/;"	m	struct:s_packer_opts
connectiongain	base/vpr_types.h	/^	std::map<int, float> connectiongain; \/* [0..num_logical_blocks-1] Weighted sum of connections to attraction function *\/$/;"	m	struct:s_pb_stats
connections	../../libarchfpga/include/cad_types.h	/^	struct s_pack_pattern_connections *connections; \/* linked list of connections of logic blocks in pattern *\/$/;"	m	struct:s_pack_pattern_block	typeref:struct:s_pack_pattern_block::s_pack_pattern_connections
constant_net_delay	base/ReadOptions.h	/^	float constant_net_delay;$/;"	m	struct:s_options
constant_net_delay	base/vpr_types.h	/^	float constant_net_delay; \/* timing information when place and route not run *\/$/;"	m	struct:s_vpr_setup
constrained_clocks	base/vpr_types.h	/^	t_clock * constrained_clocks; \/* [0..g_sdc->num_constrained_clocks - 1] array of clocks with timing constraints *\/$/;"	m	struct:s_timing_constraints
constrained_inputs	base/vpr_types.h	/^	t_io * constrained_inputs; \/* [0..num_constrained_inputs - 1] array of inputs with timing constraints *\/$/;"	m	struct:s_timing_constraints
constrained_outputs	base/vpr_types.h	/^	t_io * constrained_outputs; \/* [0..num_constrained_outputs - 1] array of outputs with timing constraints *\/$/;"	m	struct:s_timing_constraints
constraint	base/vpr_types.h	/^	float constraint;$/;"	m	struct:s_override_constraint
cont	../../libarchfpga/util.c	/^static int cont; \/* line continued? *\/$/;"	v	file:
convert_side_index_to_string	spice/spice_utils.c	/^char* convert_side_index_to_string(int side) {$/;"	f
copy_delay	mrfpga/buffer_insertion.c	/^static void copy_delay( float* base, float* source, t_linked_int* index )$/;"	f	file:
copy_from_float_array	mrfpga/buffer_insertion.c	/^static float* copy_from_float_array( float* source, int num )$/;"	f	file:
copy_from_list	mrfpga/mrfpga_util.c	/^t_linked_int* copy_from_list( t_linked_int* base, t_linked_int* target )$/;"	f
cost	base/vpr_types.h	/^	float cost;$/;"	m	struct:s_place_region
cost	route/route_common.h	/^	float cost;$/;"	m	struct:s_heap
cost_index	base/vpr_types.h	/^	short cost_index;$/;"	m	struct:s_rr_node
cost_methods	place/place.c	/^enum cost_methods {$/;"	g	file:
count	base/read_blif.c	/^	int count;$/;"	m	struct:s_model_stats	file:
count	util/hash.h	/^	int count;$/;"	m	struct:s_hash
count_bidir_routing_transistors	route/rr_graph_area.c	/^void count_bidir_routing_transistors(int num_switch, float R_minW_nmos,$/;"	f
count_blk_one_class_num_conflict	clb_pin_remap/clb_pin_remap_util.c	/^int count_blk_one_class_num_conflict(t_block* target_blk, int class_index,$/;"	f
count_connections	place/place.c	/^static int count_connections() {$/;"	f	file:
count_netlist_clocks	base/stats.c	/^int count_netlist_clocks(void) {$/;"	f
count_netlist_clocks_as_constrained_clocks	timing/read_sdc.c	/^static void count_netlist_clocks_as_constrained_clocks(void) {$/;"	f	file:
count_netlist_ios_as_constrained_ios	timing/read_sdc.c	/^static void count_netlist_ios_as_constrained_ios(char * clock_name, float io_delay) {$/;"	f	file:
count_routing_memristor_buffer	mrfpga/buffer_insertion.c	/^void count_routing_memristor_buffer( int num_per_channel, float buffer_size )$/;"	f
count_routing_transistors	route/rr_graph_area.c	/^void count_routing_transistors(enum e_directionality directionality,$/;"	f
count_sinks_internal_cb_rr_graph_net_nums	base/read_netlist.c	/^static int count_sinks_internal_cb_rr_graph_net_nums($/;"	f	file:
count_unidir_routing_transistors	route/rr_graph_area.c	/^void count_unidir_routing_transistors(t_segment_inf * segment_inf,$/;"	f
cpd	base/vpr_types.h	/^	float ** cpd;$/;"	m	struct:s_timing_stats
create_button	base/graphics.c	/^void create_button (const char *prev_button_text , const char *button_text, $/;"	f
create_button	base/graphics.c	/^void create_button (const char *prev_button_text , const char *button_text,$/;"	f
create_dir_path	spice/spice_utils.c	/^int create_dir_path(char* dir_path) {$/;"	f
create_llist	spice/linkedlist.c	/^t_llist* create_llist(int len) {$/;"	f
criticality_exp	base/ReadOptions.h	/^	float criticality_exp;$/;"	m	struct:s_options
criticality_exp	base/vpr_types.h	/^	float criticality_exp;$/;"	m	struct:s_router_opts
critindexarray	pack/cluster.c	/^static int *critindexarray = NULL;$/;"	v	file:
cross_count	place/place.c	/^static const float cross_count[50] = { \/* [0..49] *\/1.0, 1.0, 1.0, 1.0828, 1.1536, 1.2206, 1.2823, 1.3385, 1.3991, 1.4493, 1.4974,$/;"	v	file:
cur	../../libarchfpga/include/ezxml.h	/^	ezxml_t cur; \/* current xml tree insertion point *\/$/;"	m	struct:ezxml_root
curr_cluster_index	pack/cluster_legality.c	/^static int curr_cluster_index;$/;"	v	file:
curr_molecule	base/vpr_types.h	/^	t_pack_molecule *curr_molecule; \/* current molecule being considered for packing *\/$/;"	m	struct:s_cluster_placement_stats
current_draw_mode	base/graphics.c	/^static e_draw_mode current_draw_mode;$/;"	v	file:
current_gc	base/graphics.c	/^static GC gc, gcxor, gc_menus, current_gc;$/;"	v	file:
current_random	../../libarchfpga/util.c	/^static unsigned int current_random = 0;$/;"	v	file:
currentcolor	base/graphics.c	/^static int currentcolor;$/;"	v	file:
currentfontsize	base/graphics.c	/^static int currentfontsize;$/;"	v	file:
currentlinestyle	base/graphics.c	/^static int currentlinestyle;$/;"	v	file:
currentlinewidth	base/graphics.c	/^static int currentlinewidth;$/;"	v	file:
cxClient	base/graphics.c	/^static int cxClient, cyClient;$/;"	v	file:
cyClient	base/graphics.c	/^static int cxClient, cyClient;$/;"	v	file:
data	../../libarchfpga/include/util.h	/^	int data;$/;"	m	struct:s_linked_int
data	timing/slre.c	/^  unsigned char data[256];$/;"	m	struct:slre	file:
data	util/token.h	/^	char *data;$/;"	m	struct:s_token
data_size	timing/slre.c	/^  int data_size;$/;"	m	struct:slre	file:
data_vptr	../../libarchfpga/include/util.h	/^	void *data_vptr;$/;"	m	struct:s_linked_vptr
dc	../../libarchfpga/include/physical_types.h	/^	float dc;$/;"	m	struct:s_chan
dealloc_mux_graph	power/power.c	/^static void dealloc_mux_graph(t_mux_node * node) {$/;"	f	file:
dealloc_mux_graph_rec	power/power.c	/^static void dealloc_mux_graph_rec(t_mux_node * node) {$/;"	f	file:
decode_mux_sram_bits	spice/spice_utils.c	/^int* decode_mux_sram_bits(int fan_in,$/;"	f
default_message	base/draw.c	/^static char default_message[BUFSIZE]; \/* Default screen message on screen *\/$/;"	v	file:
default_output_name	base/globals.c	/^char *default_output_name = NULL;$/;"	v
default_spice_dir_path	spice/spice_api.c	/^static char* default_spice_dir_path = "spice_netlists\/";$/;"	v	file:
define_idle_mode	../../libarchfpga/include/physical_types.h	/^    int define_idle_mode;   $/;"	m	struct:s_mode
delay	base/vpr_types.h	/^	float delay; \/* Delay through the I\/O in this constraint *\/$/;"	m	struct:s_io
delay_max	../../libarchfpga/include/physical_types.h	/^	float delay_max;$/;"	m	struct:s_pb_graph_edge
delay_min	../../libarchfpga/include/physical_types.h	/^	float delay_min;$/;"	m	struct:s_pb_graph_edge
delayless_switch	base/vpr_types.h	/^	short delayless_switch;$/;"	m	struct:s_det_routing_arch
delete_in_vptr_list	../../libarchfpga/util.c	/^delete_in_vptr_list(struct s_linked_vptr *head) {$/;"	f
delta_clb_to_clb	place/timing_place_lookup.c	/^float **delta_clb_to_clb;$/;"	v
delta_clb_to_io	place/timing_place_lookup.c	/^float **delta_clb_to_io;$/;"	v
delta_io_to_clb	place/timing_place_lookup.c	/^float **delta_io_to_clb;$/;"	v
delta_io_to_io	place/timing_place_lookup.c	/^float **delta_io_to_io;$/;"	v
dens	../../libarchfpga/include/physical_types.h	/^	float dens; \/* Switching density of net assigned to this clock *\/$/;"	m	struct:s_clock_network
density	../../libarchfpga/include/spice_types.h	/^  float density;$/;"	m	struct:s_spice_net_info
density	base/vpr_types.h	/^	float density;$/;"	m	struct:s_net_power
depth	../../libarchfpga/include/physical_types.h	/^	int depth; \/* depth of pb_type *\/$/;"	m	struct:s_pb_type
deselect_all	base/draw.c	/^static void deselect_all(void) {$/;"	f	file:
design_tech	../../libarchfpga/include/spice_types.h	/^  e_spice_model_design_tech design_tech;$/;"	m	struct:s_spice_model
destroy_button	base/graphics.c	/^destroy_button (const char *button_text) $/;"	f
destroy_button	base/graphics.c	/^void destroy_button (const char *button_text) { }$/;"	f
determine_io_grid_side	spice/spice_utils.c	/^int determine_io_grid_side(int x,$/;"	f
determine_lut_path_id	spice/spice_utils.c	/^int determine_lut_path_id(int lut_size,$/;"	f
determine_mux_level	spice/spice_utils.c	/^int determine_mux_level(int mux_size) {$/;"	f
determine_src_chan_coordinate_switch_box	spice/spice_routing.c	/^void determine_src_chan_coordinate_switch_box(t_rr_node* src_rr_node,$/;"	f
dir	../../libarchfpga/include/logic_types.h	/^	enum PORTS dir; \/* port direction *\/$/;"	m	struct:s_model_ports	typeref:enum:s_model_ports::PORTS
direction	base/vpr_types.h	/^	enum e_direction direction; \/* UDSD by AY *\/$/;"	m	struct:s_rr_node	typeref:enum:s_rr_node::e_direction
direction	base/vpr_types.h	/^	enum e_direction direction; \/* UDSD by AY *\/$/;"	m	struct:s_seg_details	typeref:enum:s_seg_details::e_direction
directionality	../../libarchfpga/include/physical_types.h	/^	enum e_directionality directionality;$/;"	m	struct:s_segment_inf	typeref:enum:s_segment_inf::e_directionality
directionality	base/vpr_types.h	/^	enum e_directionality directionality; \/* UDSD by AY *\/$/;"	m	struct:s_det_routing_arch	typeref:enum:s_det_routing_arch::e_directionality
discover_all_forced_connections	pack/cluster_feasibility_filter.c	/^static void discover_all_forced_connections(INOUTP t_pb_graph_node *pb_graph_node) {$/;"	f	file:
discover_pattern_names_in_pb_graph_node	pack/prepack.c	/^static void discover_pattern_names_in_pb_graph_node($/;"	f	file:
disp_type	base/graphics.c	/^   int disp_type;$/;"	m	struct:__anon5	file:
display	base/graphics.c	/^static Display *display;$/;"	v	file:
display_height	base/graphics.c	/^static int display_width, display_height;  \/* screen size *\/$/;"	v	file:
display_width	base/graphics.c	/^static int display_width, display_height;  \/* screen size *\/$/;"	v	file:
displaybuffer	base/graphics.c	/^void displaybuffer(void) { }$/;"	f
displaybuffer	base/graphics.c	/^void displaybuffer(void) {$/;"	f
distr	route/rr_graph.c	/^	int *distr;$/;"	m	struct:s_mux_size_distribution	file:
doPacking	base/vpr_types.h	/^	boolean doPacking;$/;"	m	struct:s_packer_opts
doPlacement	base/vpr_types.h	/^	boolean doPlacement;$/;"	m	struct:s_placer_opts
doRouting	base/vpr_types.h	/^	boolean doRouting;$/;"	m	struct:s_router_opts
do_clustering	pack/cluster.c	/^void do_clustering(const t_arch *arch, t_pack_molecule *molecule_head,$/;"	f
do_constant_net_delay_timing_analysis	timing/path_delay.c	/^void do_constant_net_delay_timing_analysis(t_timing_inf timing_inf,$/;"	f
do_lut_rebalancing	timing/path_delay.c	/^static void do_lut_rebalancing() {$/;"	f	file:
do_path_counting	timing/path_delay.c	/^static void do_path_counting(float criticality_denom) {$/;"	f	file:
do_power	base/vpr_types.h	/^	boolean do_power; \/* Perform power estimation? *\/$/;"	m	struct:s_power_opts
do_spice	base/vpr_types.h	/^  boolean do_spice;$/;"	m	struct:s_spice_opts
do_timing_analysis	timing/path_delay.c	/^void do_timing_analysis(t_slack * slacks, boolean is_prepacked, boolean do_lut_input_balancing, boolean is_final_analysis) {$/;"	f
do_timing_analysis_for_constraint	timing/path_delay.c	/^static float do_timing_analysis_for_constraint(int source_clock_domain, int sink_clock_domain, $/;"	f	file:
domain_constraint	base/vpr_types.h	/^	float ** domain_constraint; \/* [0..num_constrained_clocks - 1 (source)][0..num_constrained_clocks - 1 (destination)] *\/$/;"	m	struct:s_timing_constraints
done_callibration	power/PowerSpicedComponent.h	/^	bool done_callibration;$/;"	m	class:PowerCallibInputs
done_callibration	power/PowerSpicedComponent.h	/^	bool done_callibration;$/;"	m	class:PowerSpicedComponent
dptr	spice/linkedlist.h	/^  void* dptr;$/;"	m	struct:s_llist
draw_chanx_to_chanx_edge	base/draw.c	/^static void draw_chanx_to_chanx_edge(int from_node, int from_track, int to_node,$/;"	f	file:
draw_chanx_to_chany_edge	base/draw.c	/^static void draw_chanx_to_chany_edge(int chanx_node, int chanx_track,$/;"	f	file:
draw_chany_to_chany_edge	base/draw.c	/^static void draw_chany_to_chany_edge(int from_node, int from_track, int to_node,$/;"	f	file:
draw_congestion	base/draw.c	/^static void draw_congestion(void) {$/;"	f	file:
draw_message	base/graphics.c	/^draw_message (void) $/;"	f
draw_message	base/graphics.c	/^void draw_message (void) { }$/;"	f
draw_pin_to_chan_edge	base/draw.c	/^static void draw_pin_to_chan_edge(int pin_node, int chan_node) {$/;"	f	file:
draw_pin_to_pin	base/draw.c	/^static void draw_pin_to_pin(int opin_node, int ipin_node) {$/;"	f	file:
draw_route_type	base/draw.c	/^static enum e_route_type draw_route_type;$/;"	v	typeref:enum:e_route_type	file:
draw_rr	base/draw.c	/^void draw_rr(void) {$/;"	f
draw_rr_chanx	base/draw.c	/^static void draw_rr_chanx(int inode, int itrack) {$/;"	f	file:
draw_rr_chany	base/draw.c	/^static void draw_rr_chany(int inode, int itrack) {$/;"	f	file:
draw_rr_edges	base/draw.c	/^static void draw_rr_edges(int inode) {$/;"	f	file:
draw_rr_pin	base/draw.c	/^static void draw_rr_pin(int inode, enum color_types color) {$/;"	f	file:
draw_rr_switch	base/draw.c	/^static void draw_rr_switch(float from_x, float from_y, float to_x, float to_y,$/;"	f	file:
draw_rr_toggle	base/draw.c	/^static enum e_draw_rr_toggle draw_rr_toggle = DRAW_NO_RR; \/* UDSD by AY *\/$/;"	v	typeref:enum:e_draw_rr_toggle	file:
draw_triangle_along_line	base/draw.c	/^static void draw_triangle_along_line(float xend, float yend, float x1, float x2,$/;"	f	file:
draw_x	base/draw.c	/^static void draw_x(float x, float y, float size) {$/;"	f	file:
drawarc	base/graphics.c	/^drawarc (float xc, float yc, float rad, float startang, $/;"	f
drawarc	base/graphics.c	/^void drawarc (float xcen, float ycen, float rad, float startang,$/;"	f
drawbut	base/graphics.c	/^static void drawbut (int bnum) $/;"	f	file:
drawcurve	base/graphics.c	/^void drawcurve(t_point *points, int npoints) { }$/;"	f
drawcurve	base/graphics.c	/^void drawcurve(t_point *points,$/;"	f
drawellipticarc	base/graphics.c	/^drawellipticarc (float xc, float yc, float radx, float rady, float startang, float angextent) $/;"	f
drawellipticarc	base/graphics.c	/^void drawellipticarc (float xc, float yc, float radx, float rady, float startang, float angextent) { }$/;"	f
drawline	base/graphics.c	/^drawline (float x1, float y1, float x2, float y2) $/;"	f
drawline	base/graphics.c	/^void drawline (float x1, float y1, float x2, float y2) { }$/;"	f
drawmenu	base/graphics.c	/^static void drawmenu(void) $/;"	f	file:
drawnets	base/draw.c	/^static void drawnets(void) {$/;"	f	file:
drawplace	base/draw.c	/^static void drawplace(void) {$/;"	f	file:
drawrect	base/graphics.c	/^drawrect (float x1, float y1, float x2, float y2) $/;"	f
drawrect	base/graphics.c	/^void drawrect (float x1, float y1, float x2, float y2) { }$/;"	f
drawroute	base/draw.c	/^static void drawroute(enum e_draw_net_type draw_net_type) {$/;"	f	file:
drawscreen	base/draw.c	/^static void drawscreen() {$/;"	f	file:
drawscreen_ptr	base/graphics.c	/^static void (*drawscreen_ptr)(void);$/;"	v	file:
drawtext	base/graphics.c	/^drawtext (float xc, float yc, const char *text, float boundx) $/;"	f
drawtext	base/graphics.c	/^void drawtext (float xc, float yc, const char *text, float boundx) { }$/;"	f
drawtobuffer	base/graphics.c	/^void drawtobuffer(void) { }$/;"	f
drawtobuffer	base/graphics.c	/^void drawtobuffer(void) {$/;"	f
drawtoscreen	base/graphics.c	/^void drawtoscreen(void) { }$/;"	f
drawtoscreen	base/graphics.c	/^void drawtoscreen(void) {$/;"	f
drive_rr_nodes	base/vpr_types.h	/^    t_rr_node** drive_rr_nodes;$/;"	m	struct:s_rr_node
drive_switches	base/vpr_types.h	/^    int* drive_switches;$/;"	m	struct:s_rr_node
driver_pb	base/verilog_writer.h	/^  t_pb *driver_pb;$/;"	m	struct:found_connectivity
driver_pin	../../libarchfpga/include/physical_types.h	/^	int driver_pin;$/;"	m	struct:s_pb_graph_edge
driver_pin	base/verilog_writer.h	/^  t_pb_graph_pin *driver_pin;$/;"	m	struct:found_connectivity
driver_set	../../libarchfpga/include/physical_types.h	/^	int driver_set;$/;"	m	struct:s_pb_graph_edge
driver_switch	base/vpr_types.h	/^    short driver_switch; \/* Xifan TANG: Switch Segment Pattern Support*\/$/;"	m	struct:s_rr_node
driver_switch_type	power/power.h	/^	short driver_switch_type; \/* Switch type that drives this resource *\/$/;"	m	struct:s_rr_node_power
driver_to_load_delay	base/verilog_writer.h	/^  float driver_to_load_delay;$/;"	m	struct:found_connectivity
drivers	base/vpr_types.h	/^	enum e_drivers drivers; \/* UDSD by AY *\/$/;"	m	struct:s_rr_node	typeref:enum:s_rr_node::e_drivers
drivers	base/vpr_types.h	/^	enum e_drivers drivers; \/* UDSD by AY *\/$/;"	m	struct:s_seg_details	typeref:enum:s_seg_details::e_drivers
dum_parse	base/read_blif.c	/^void dum_parse(char *buf) {$/;"	f
dummy_type_descriptors	place/timing_place_lookup.c	/^static t_type_descriptor dummy_type_descriptors[NUM_TYPES_USED];$/;"	v	file:
dump_rr_graph	route/rr_graph.c	/^void dump_rr_graph(INP const char *file_name) {$/;"	f
dump_seg_details	route/rr_graph2.c	/^void dump_seg_details(t_seg_details * seg_details, int nodes_per_chan,$/;"	f
dynamic	../../libarchfpga/include/physical_types.h	/^	float dynamic;$/;"	m	struct:s_power_usage
e	../../libarchfpga/include/ezxml.h	/^	char *e; \/* end of work area *\/$/;"	m	struct:ezxml_root
e_Fc_type	../../libarchfpga/include/physical_types.h	/^enum e_Fc_type {$/;"	g
e_OptionArgToken	base/OptionTokens.h	/^enum e_OptionArgToken {$/;"	g
e_OptionBaseToken	base/OptionTokens.h	/^enum e_OptionBaseToken {$/;"	g
e_base_cost_type	base/vpr_types.h	/^enum e_base_cost_type {$/;"	g
e_block_pack_status	base/vpr_types.h	/^enum e_block_pack_status {$/;"	g
e_cluster_seed	base/vpr_types.h	/^enum e_cluster_seed {$/;"	g
e_cost_indices	base/vpr_types.h	/^enum e_cost_indices {$/;"	g
e_detailed_routing_stages	pack/cluster.c	/^enum e_detailed_routing_stages {$/;"	g	file:
e_dir_err	spice/spice_utils.c	/^enum e_dir_err {$/;"	g	file:
e_direction	base/vpr_types.h	/^enum e_direction {$/;"	g
e_directionality	../../libarchfpga/include/physical_types.h	/^enum e_directionality {$/;"	g
e_draw_mode	base/graphics.h	/^enum e_draw_mode {DRAW_NORMAL = 0, DRAW_XOR};$/;"	g
e_draw_net_type	base/draw.c	/^enum e_draw_net_type {$/;"	g	file:
e_draw_rr_toggle	base/draw.c	/^enum e_draw_rr_toggle {$/;"	g	file:
e_drivers	base/vpr_types.h	/^enum e_drivers {$/;"	g
e_echo_files	base/ReadOptions.h	/^enum e_echo_files {$/;"	g
e_edge_dir	base/draw.c	/^enum e_edge_dir {$/;"	g	file:
e_feasibility	pack/cluster.c	/^enum e_feasibility {$/;"	g	file:
e_ff_trigger_type	spice/spice_primitives.c	/^enum e_ff_trigger_type {$/;"	g	file:
e_gain_type	pack/cluster.c	/^enum e_gain_type {$/;"	g	file:
e_gain_update	pack/cluster.c	/^enum e_gain_update {$/;"	g	file:
e_graph_type	route/rr_graph.h	/^enum e_graph_type {$/;"	g
e_grid_loc_type	../../libarchfpga/include/physical_types.h	/^enum e_grid_loc_type {$/;"	g
e_interconnect	../../libarchfpga/include/physical_types.h	/^enum e_interconnect {$/;"	g
e_measure_type	spice/spice_netlist_utils.h	/^enum e_measure_type {$/;"	g
e_net_relation_to_clustered_block	pack/cluster.c	/^enum e_net_relation_to_clustered_block {$/;"	g	file:
e_operation	base/vpr_types.h	/^enum e_operation {$/;"	g
e_output_files	base/ReadOptions.h	/^enum e_output_files {$/;"	g
e_pack_pattern_molecule_type	base/vpr_types.h	/^enum e_pack_pattern_molecule_type {$/;"	g
e_packer_algorithm	base/vpr_types.h	/^enum e_packer_algorithm {$/;"	g
e_pad_loc_type	base/vpr_types.h	/^enum e_pad_loc_type {$/;"	g
e_pb_graph_pin_type	../../libarchfpga/include/physical_types.h	/^enum e_pb_graph_pin_type {$/;"	g
e_pb_type_class	../../libarchfpga/include/physical_types.h	/^enum e_pb_type_class {$/;"	g
e_pin2pin_interc_type	spice/spice_globals.h	/^enum e_pin2pin_interc_type {$/;"	g
e_pin_location_distr	../../libarchfpga/include/physical_types.h	/^enum e_pin_location_distr {$/;"	g
e_pin_to_pin_annotation_format	../../libarchfpga/include/physical_types.h	/^enum e_pin_to_pin_annotation_format {$/;"	g
e_pin_to_pin_annotation_type	../../libarchfpga/include/physical_types.h	/^enum e_pin_to_pin_annotation_type {$/;"	g
e_pin_to_pin_capacitance_annotations	../../libarchfpga/include/physical_types.h	/^enum e_pin_to_pin_capacitance_annotations {$/;"	g
e_pin_to_pin_delay_annotations	../../libarchfpga/include/physical_types.h	/^enum e_pin_to_pin_delay_annotations {$/;"	g
e_pin_to_pin_pack_pattern_annotations	../../libarchfpga/include/physical_types.h	/^enum e_pin_to_pin_pack_pattern_annotations {$/;"	g
e_pin_type	../../libarchfpga/include/physical_types.h	/^enum e_pin_type {$/;"	g
e_place_algorithm	base/vpr_types.h	/^enum e_place_algorithm {$/;"	g
e_power_breakdown_entry_type	power/power.c	/^} e_power_breakdown_entry_type;$/;"	t	typeref:enum:__anon8	file:
e_power_buffer_type	../../libarchfpga/include/physical_types.h	/^} e_power_buffer_type;$/;"	t	typeref:enum:__anon21
e_power_callib_component	power/power_callibrate.h	/^} e_power_callib_component;$/;"	t	typeref:enum:__anon12
e_power_component_type	power/power_components.h	/^} e_power_component_type;$/;"	t	typeref:enum:__anon13
e_power_estimation_method	../../libarchfpga/include/physical_types.h	/^typedef enum e_power_estimation_method_ e_power_estimation_method;$/;"	t	typeref:enum:e_power_estimation_method_
e_power_estimation_method_	../../libarchfpga/include/physical_types.h	/^enum e_power_estimation_method_ {$/;"	g
e_power_log_type	power/power.h	/^} e_power_log_type;$/;"	t	typeref:enum:__anon10
e_power_ret_code	power/power.h	/^} e_power_ret_code;$/;"	t	typeref:enum:__anon9
e_power_wire_type	../../libarchfpga/include/physical_types.h	/^} e_power_wire_type;$/;"	t	typeref:enum:__anon20
e_removal_policy	pack/cluster.c	/^enum e_removal_policy {$/;"	g	file:
e_route_type	base/vpr_types.h	/^enum e_route_type {$/;"	g
e_router_algorithm	base/vpr_types.h	/^enum e_router_algorithm {$/;"	g
e_rr_type	base/vpr_types.h	/^typedef enum e_rr_type {$/;"	g
e_side	../../libarchfpga/include/physical_types.h	/^enum e_side {$/;"	g
e_spice_accuracy_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_accuracy_type {$/;"	g
e_spice_model_buffer_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_model_buffer_type {$/;"	g
e_spice_model_design_tech	../../libarchfpga/include/spice_types.h	/^enum e_spice_model_design_tech {$/;"	g
e_spice_model_pass_gate_logic_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_model_pass_gate_logic_type {$/;"	g
e_spice_model_port_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_model_port_type {$/;"	g
e_spice_model_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_model_type {$/;"	g
e_spice_mux_tb_type	spice/spice_mux_testbench.h	/^enum e_spice_mux_tb_type {$/;"	g
e_spice_tech_lib_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_tech_lib_type {$/;"	g
e_spice_trans_type	../../libarchfpga/include/spice_types.h	/^enum e_spice_trans_type {$/;"	g
e_stat	../../libarchfpga/include/physical_types.h	/^enum e_stat {$/;"	g
e_switch_block_type	../../libarchfpga/include/physical_types.h	/^enum e_switch_block_type {$/;"	g
e_swseg_pattern_type	../../libarchfpga/include/physical_types.h	/^enum e_swseg_pattern_type {$/;"	g
e_tech_comp	../../libarchfpga/include/arch_types_mrfpga.h	/^enum e_tech_comp { $/;"	g
e_tnode_type	base/vpr_types.h	/^} e_tnode_type;$/;"	t	typeref:enum:__anon7
e_token_type	util/token.h	/^enum e_token_type {$/;"	g
e_tx_type	power/power.h	/^} e_tx_type;$/;"	t	typeref:enum:__anon11
e_wire_model_type	../../libarchfpga/include/spice_types.h	/^enum e_wire_model_type {$/;"	g
echoFileEnabled	base/ReadOptions.c	/^static boolean *echoFileEnabled = NULL;$/;"	v	file:
echoFileNames	base/ReadOptions.c	/^static char **echoFileNames = NULL;$/;"	v	file:
echo_input	base/read_blif.c	/^void echo_input(char *blif_file, char *echo_file, t_model *library_models) {$/;"	f
echo_pb_graph	pack/pb_type_graph.c	/^void echo_pb_graph(char * filename) {$/;"	f
echo_pb_pins	pack/pb_type_graph.c	/^static void echo_pb_pins(INP t_pb_graph_pin **pb_graph_pins, INP int num_ports,$/;"	f	file:
echo_pb_rec	pack/pb_type_graph.c	/^static void echo_pb_rec(const INP t_pb_graph_node *pb_graph_node, INP int level,$/;"	f	file:
edge	route/rr_graph_util.h	/^	int edge;$/;"	m	struct:s_linked_edge
edges	base/vpr_types.h	/^	int *edges;$/;"	m	struct:s_rr_node
edges_head	pack/pb_type_graph.c	/^static struct s_linked_vptr *edges_head;$/;"	v	typeref:struct:s_linked_vptr	file:
emit	timing/slre.c	/^static void emit(struct slre *r, int code) {$/;"	f	file:
empty_heap	route/route_common.c	/^void empty_heap(void) {$/;"	f
enable_or_disable_button	base/graphics.c	/^void enable_or_disable_button (int ibutton, bool enabled) {$/;"	f
enable_or_disable_button	base/graphics.c	/^void enable_or_disable_button(int ibutton, bool enabled) { }$/;"	f
enable_timing_computations	base/vpr_types.h	/^	boolean enable_timing_computations;$/;"	m	struct:s_placer_opts
enabled	base/graphics.c	/^   bool enabled;$/;"	m	struct:__anon4	file:
endlines	base/read_blif.c	/^static int ilines, olines, model_lines, endlines;$/;"	v	file:
energy_per_toggle	../../libarchfpga/include/physical_types.h	/^	float energy_per_toggle;$/;"	m	struct:s_port_power
ent	../../libarchfpga/include/ezxml.h	/^	char **ent; \/* general entities (ampersand sequences) *\/$/;"	m	struct:ezxml_root
entries	power/PowerSpicedComponent.h	/^	std::vector<PowerCallibInputs*> entries;$/;"	m	class:PowerSpicedComponent
entries	power/PowerSpicedComponent.h	/^	std::vector<PowerCallibSize*> entries;$/;"	m	class:PowerCallibInputs
equivalent	../../libarchfpga/include/physical_types.h	/^	boolean equivalent;$/;"	m	struct:s_port
err	../../libarchfpga/include/ezxml.h	/^	char err[EZXML_ERRL]; \/* error string *\/$/;"	m	struct:ezxml_root
error_no_match	timing/slre.c	/^static const char *error_no_match = "No match";$/;"	v	file:
error_string	timing/slre.c	/^  const char *error_string;   \/\/ Error string$/;"	m	struct:slre	file:
esti_distance_num_seg_delay	clb_pin_remap/post_place_timing.c	/^float esti_distance_num_seg_delay(int distance,$/;"	f
esti_one_segment_net_delay	clb_pin_remap/post_place_timing.c	/^float esti_one_segment_net_delay(int distance, t_segment_inf segment_inf) {$/;"	f
esti_pin2pin_one_net_delay	clb_pin_remap/post_place_timing.c	/^float esti_pin2pin_one_net_delay(t_block src_blk,$/;"	f
esti_pin_chan_coordinate	clb_pin_remap/clb_pin_remap_util.c	/^void esti_pin_chan_coordinate(int* pin_x, int* pin_y,$/;"	f
estimate_post_place_one_net_sink_delay	clb_pin_remap/post_place_timing.c	/^float estimate_post_place_one_net_sink_delay(int net_index, $/;"	f
estimation_method	../../libarchfpga/include/physical_types.h	/^	e_power_estimation_method estimation_method;$/;"	m	struct:s_pb_type_power
event_loop	base/graphics.c	/^event_loop (void (*act_on_mousebutton)(float x, float y), $/;"	f
event_loop	base/graphics.c	/^void event_loop (void (*act_on_mousebutton) (float x, float y),$/;"	f
exact	timing/slre.c	/^static void exact(struct slre *r, const char **re) {$/;"	f	file:
exact_one_char	timing/slre.c	/^static void exact_one_char(struct slre *r, int ch) {$/;"	f	file:
exist	../../libarchfpga/include/spice_types.h	/^  int exist;$/;"	m	struct:s_spice_model_buffer
exists_free_primitive_for_logical_block	pack/cluster_placement.c	/^boolean exists_free_primitive_for_logical_block($/;"	f
exit_crit	place/place.c	/^static int exit_crit(float t, float cost,$/;"	f	file:
exit_t	base/vpr_types.h	/^	float exit_t;$/;"	m	struct:s_annealing_sched
expand_forced_pack_molecule_placement	pack/cluster_placement.c	/^static boolean expand_forced_pack_molecule_placement($/;"	f	file:
expand_pack_molecule_pin_edge	pack/cluster_placement.c	/^static t_pb_graph_pin *expand_pack_molecule_pin_edge(INP int pattern_id,$/;"	f	file:
expand_pb_graph_node_and_load_output_to_input_connections	pack/cluster_feasibility_filter.c	/^static void expand_pb_graph_node_and_load_output_to_input_connections($/;"	f	file:
expand_pb_graph_node_and_load_pin_class_by_depth	pack/cluster_feasibility_filter.c	/^static void expand_pb_graph_node_and_load_pin_class_by_depth($/;"	f	file:
expand_routing_trace	base/vpr_api.c	/^static t_trace *expand_routing_trace(t_trace *trace, int ivpack_net) {$/;"	f	file:
expected_lowest_cost_primitive	base/vpr_types.h	/^	t_pb_graph_node *expected_lowest_cost_primitive; \/* predicted ideal primitive to use for this logical block *\/$/;"	m	struct:s_logical_block
ext_clock_rr_node_index	pack/cluster_legality.c	/^		ext_clock_rr_node_index, max_ext_index;$/;"	v	file:
ext_input_rr_node_index	pack/cluster_legality.c	/^static int ext_input_rr_node_index, ext_output_rr_node_index,$/;"	v	file:
ext_output_rr_node_index	pack/cluster_legality.c	/^static int ext_input_rr_node_index, ext_output_rr_node_index,$/;"	v	file:
ezxml	../../libarchfpga/include/ezxml.h	/^struct ezxml {$/;"	s
ezxml_add_child	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_add_child(ezxml_t xml, char *name, size_t off) {$/;"	f
ezxml_add_child_d	../../libarchfpga/include/ezxml.h	149;"	d
ezxml_ampencode	../../libarchfpga/ezxml.c	/^ezxml_ampencode(const char *s, size_t len, char **dst, size_t * dlen,$/;"	f	file:
ezxml_attr	../../libarchfpga/ezxml.c	/^ezxml_attr(ezxml_t xml, const char *attr) {$/;"	f
ezxml_char_content	../../libarchfpga/ezxml.c	/^static void ezxml_char_content(ezxml_root_t root, char *s,$/;"	f	file:
ezxml_child	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_child(ezxml_t xml, const char *name) {$/;"	f
ezxml_close_tag	../../libarchfpga/ezxml.c	/^static ezxml_t ezxml_close_tag(ezxml_root_t root, char *name, char *s) {$/;"	f	file:
ezxml_cut	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_cut(ezxml_t xml) {$/;"	f
ezxml_decode	../../libarchfpga/ezxml.c	/^ezxml_decode(char *s, char **ent, char t) {$/;"	f	file:
ezxml_ent_ok	../../libarchfpga/ezxml.c	/^static int ezxml_ent_ok(char *name, char *s, char **ent) {$/;"	f	file:
ezxml_err	../../libarchfpga/ezxml.c	/^static ezxml_t ezxml_err(ezxml_root_t root, char *s, const char *err, ...) {$/;"	f	file:
ezxml_error	../../libarchfpga/ezxml.c	/^ezxml_error(ezxml_t xml) {$/;"	f
ezxml_free	../../libarchfpga/ezxml.c	/^void ezxml_free(ezxml_t xml) {$/;"	f
ezxml_free_attr	../../libarchfpga/ezxml.c	/^static void ezxml_free_attr(char **attr) {$/;"	f	file:
ezxml_get	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_get(ezxml_t xml, ...) {$/;"	f
ezxml_idx	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_idx(ezxml_t xml, int idx) {$/;"	f
ezxml_insert	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off) {$/;"	f
ezxml_internal_dtd	../../libarchfpga/ezxml.c	/^static short ezxml_internal_dtd(ezxml_root_t root, char *s,$/;"	f	file:
ezxml_move	../../libarchfpga/include/ezxml.h	178;"	d
ezxml_name	../../libarchfpga/include/ezxml.h	108;"	d
ezxml_new	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_new(char *name) {$/;"	f
ezxml_new_d	../../libarchfpga/include/ezxml.h	142;"	d
ezxml_next	../../libarchfpga/include/ezxml.h	101;"	d
ezxml_open_tag	../../libarchfpga/ezxml.c	/^static void ezxml_open_tag(ezxml_root_t root, int line, char *name, char **attr) {$/;"	f	file:
ezxml_parse_fd	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_parse_fd(int fd) {$/;"	f
ezxml_parse_file	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_parse_file(const char *file) {$/;"	f
ezxml_parse_fp	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_parse_fp(FILE * fp) {$/;"	f
ezxml_parse_str	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_parse_str(char *s, size_t len) {$/;"	f
ezxml_pi	../../libarchfpga/ezxml.c	/^ezxml_pi(ezxml_t xml, const char *target) {$/;"	f
ezxml_proc_inst	../../libarchfpga/ezxml.c	/^static void ezxml_proc_inst(ezxml_root_t root, char *s, size_t len) {$/;"	f	file:
ezxml_remove	../../libarchfpga/include/ezxml.h	181;"	d
ezxml_root	../../libarchfpga/include/ezxml.h	/^struct ezxml_root { \/* additional data for the root tag *\/$/;"	s
ezxml_root_t	../../libarchfpga/include/ezxml.h	/^typedef struct ezxml_root *ezxml_root_t;$/;"	t	typeref:struct:ezxml_root
ezxml_set_attr	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_set_attr(ezxml_t xml, char *name, char *value) {$/;"	f
ezxml_set_attr_d	../../libarchfpga/include/ezxml.h	164;"	d
ezxml_set_flag	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_set_flag(ezxml_t xml, short flag) {$/;"	f
ezxml_set_txt	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_set_txt(ezxml_t xml, char *txt) {$/;"	f
ezxml_set_txt_d	../../libarchfpga/include/ezxml.h	156;"	d
ezxml_str2utf8	../../libarchfpga/ezxml.c	/^ezxml_str2utf8(char **s, size_t * len) {$/;"	f	file:
ezxml_t	../../libarchfpga/include/ezxml.h	/^typedef struct ezxml *ezxml_t;$/;"	t	typeref:struct:ezxml
ezxml_toxml	../../libarchfpga/ezxml.c	/^ezxml_toxml(ezxml_t xml) {$/;"	f
ezxml_toxml_r	../../libarchfpga/ezxml.c	/^ezxml_toxml_r(ezxml_t xml, char **s, size_t * len, size_t * max, size_t start,$/;"	f	file:
ezxml_txt	../../libarchfpga/include/ezxml.h	111;"	d
ezxml_vget	../../libarchfpga/ezxml.c	/^ezxml_t ezxml_vget(ezxml_t xml, va_list ap) {$/;"	f
f_blk_pin_from_port_pin	util/vpr_utils.c	/^static int *** f_blk_pin_from_port_pin = NULL;$/;"	v	file:
f_direct_type_from_blk_pin	place/place_macro.c	/^static int ** f_direct_type_from_blk_pin = NULL;$/;"	v	file:
f_idirect_from_blk_pin	place/place_macro.c	/^static int ** f_idirect_from_blk_pin = NULL;$/;"	v	file:
f_imacro_from_iblk	place/place_macro.c	/^static int * f_imacro_from_iblk = NULL;$/;"	v	file:
f_net_to_driver_tnode	timing/path_delay.c	/^static int * f_net_to_driver_tnode; $/;"	v	file:
f_per_stage	../../libarchfpga/include/spice_types.h	/^  int f_per_stage;$/;"	m	struct:s_spice_model_buffer
f_port_from_blk_pin	util/vpr_utils.c	/^static int ** f_port_from_blk_pin = NULL;$/;"	v	file:
f_port_pin_from_blk_pin	util/vpr_utils.c	/^static int ** f_port_pin_from_blk_pin = NULL;$/;"	v	file:
f_timing_stats	timing/path_delay.c	/^static t_timing_stats * f_timing_stats = NULL; \/* Critical path delay and worst-case slack per constraint. *\/$/;"	v	file:
factor	power/PowerSpicedComponent.h	/^	float factor;$/;"	m	class:PowerCallibSize
falling_edge	timing/read_sdc.c	/^	float falling_edge;$/;"	m	struct:s_sdc_clock	file:
fan_in	../../libarchfpga/include/physical_types.h	/^    int fan_in;$/;"	m	struct:s_interconnect
fan_in	base/vpr_types.h	/^	short fan_in;$/;"	m	struct:s_rr_node
fan_out	../../libarchfpga/include/physical_types.h	/^    int fan_out;$/;"	m	struct:s_interconnect
fanout	base/vpr_types.h	/^	int fanout;$/;"	m	struct:s_clock
fast	../../libarchfpga/include/spice_types.h	/^  int fast;$/;"	m	struct:s_spice_params
fc	base/place_and_route.h	/^	int fc; \/* at this fc *\/$/;"	m	struct:s_fmap_cell
fc_constraints	base/vpr_types.h	/^	t_override_constraint * fc_constraints; \/*  [0..num_fc_constraints - 1] *\/$/;"	m	struct:s_timing_constraints
fcn	base/graphics.c	/^   void (*fcn) (void (*drawscreen) (void));$/;"	m	struct:__anon4	file:
feasible_blocks	base/vpr_types.h	/^	struct s_pack_molecule **feasible_blocks;$/;"	m	struct:s_pb_stats	typeref:struct:s_pb_stats::s_pack_molecule
feasible_routing	route/route_common.c	/^boolean feasible_routing(void) {$/;"	f
ff_constraints	base/vpr_types.h	/^	t_override_constraint * ff_constraints; \/*  [0..num_ff_constraints - 1] array of such constraints *\/$/;"	m	struct:s_timing_constraints
file_exists	../../libarchfpga/util.c	/^boolean file_exists(const char * filename) {$/;"	f
file_line_number	../../libarchfpga/util.c	/^int file_line_number; \/* file in line number being parsed *\/$/;"	v
file_line_number	base/vpr_types.h	/^	int file_line_number; \/* line in the SDC file I\/O was constrained on - used for error reporting *\/$/;"	m	struct:s_io
file_line_number	base/vpr_types.h	/^	int file_line_number; \/* line in the SDC file clock was constrained on - used for error reporting *\/$/;"	m	struct:s_override_constraint
fillarc	base/graphics.c	/^fillarc (float xc, float yc, float rad, float startang, float angextent) {$/;"	f
fillarc	base/graphics.c	/^void fillarc (float xcen, float ycen, float rad, float startang,$/;"	f
fillcurve	base/graphics.c	/^void fillcurve(t_point *points, int npoints) { }$/;"	f
fillcurve	base/graphics.c	/^void fillcurve(t_point *points,$/;"	f
fillellipticarc	base/graphics.c	/^fillellipticarc (float xc, float yc, float radx, float rady, float startang, $/;"	f
fillellipticarc	base/graphics.c	/^void fillellipticarc (float xc, float yc, float radx, float rady, float startang, float angextent) { }$/;"	f
fillpoly	base/graphics.c	/^fillpoly (t_point *points, int npoints) $/;"	f
fillpoly	base/graphics.c	/^void fillpoly (t_point *points, int npoints) { }$/;"	f
fillrect	base/graphics.c	/^fillrect (float x1, float y1, float x2, float y2) $/;"	f
fillrect	base/graphics.c	/^void fillrect (float x1, float y1, float x2, float y2) { }$/;"	f
findPortByName	../../libarchfpga/read_xml_arch_file.c	/^static t_port * findPortByName(const char * name, t_pb_type * pb_type,$/;"	f	file:
find_affected_blocks	place/place.c	/^static int find_affected_blocks(int b_from, int x_to, int y_to, int z_to) {$/;"	f	file:
find_affected_nets	place/place.c	/^static int find_affected_nets(int *nets_to_update) {$/;"	f	file:
find_all_the_macro	place/place_macro.c	/^static void find_all_the_macro (int * num_of_macro, int * pl_macro_member_blk_num_of_this_blk, $/;"	f	file:
find_blk_net_pin_side	clb_pin_remap/clb_pin_remap_util.c	/^int find_blk_net_pin_side(t_block target_blk,$/;"	f
find_blk_net_pin_sides	clb_pin_remap/clb_pin_remap_util.c	/^void find_blk_net_pin_sides(t_block target_blk,$/;"	f
find_blk_net_type_pins	clb_pin_remap/clb_pin_remap_util.c	/^void find_blk_net_type_pins(int n_blks, t_block* blk,$/;"	f
find_cc_constraint	timing/read_sdc.c	/^static int find_cc_constraint(char * source_clock_name, char * sink_clock_name) {$/;"	f	file:
find_cf_constraint	timing/path_delay.c	/^static int find_cf_constraint(char * source_clock_name, char * sink_ff_name) {$/;"	f	file:
find_clock	timing/path_delay.c	/^static int find_clock(char * net_name) {$/;"	f	file:
find_clock_name	base/verilog_writer.c	/^char *find_clock_name(void)$/;"	f
find_connected_primitives_downhill	base/verilog_writer.c	/^conn_list *find_connected_primitives_downhill(int block_num , t_pb *pb , conn_list*list)$/;"	f
find_constrained_clock	timing/read_sdc.c	/^static int find_constrained_clock(char * ptr) {$/;"	f	file:
find_drive_rr_nodes_switch_box	spice/spice_routing.c	/^void find_drive_rr_nodes_switch_box(int switch_box_x,$/;"	f
find_expansion_edge_of_pattern	pack/prepack.c	/^static t_pb_graph_edge * find_expansion_edge_of_pattern(INP int pattern_index,$/;"	f	file:
find_fanin_rr_node	pack/output_blif.c	/^static int find_fanin_rr_node(t_pb *cur_pb, enum PORTS type, int rr_node_index) {$/;"	f	file:
find_ff_clock_tnode	timing/path_delay.c	/^static t_tnode * find_ff_clock_tnode(int inode, boolean is_prepacked) {$/;"	f	file:
find_grid_mapped_logical_block	spice/spice_utils.c	/^int find_grid_mapped_logical_block(int x, int y,$/;"	f
find_index	base/verilog_writer.c	/^int find_index(char *row,int inputs)\/*returns the index of the 64bit truth table that this temporary truth table row corresponds to*\/$/;"	f
find_inpad_spice_model	spice/spice_utils.c	/^t_spice_model* find_inpad_spice_model(int num_spice_model,$/;"	f
find_input	timing/path_delay.c	/^static int find_input(char * net_name) {$/;"	f	file:
find_interc_fan_in_des_pb_graph_pin	spice/spice_pbtypes.c	/^void find_interc_fan_in_des_pb_graph_pin(t_pb_graph_pin* des_pb_graph_pin,$/;"	f
find_label_of_track	route/rr_graph2.c	/^static int find_label_of_track(int *wire_mux_on_track, int num_wire_muxes,$/;"	f	file:
find_mosfet_tech_lib	spice/spice_utils.c	/^t_spice_transistor_type* find_mosfet_tech_lib(t_spice_tech_lib tech_lib,$/;"	f
find_name_matched_spice_model	spice/spice_utils.c	/^t_spice_model* find_name_matched_spice_model(char* spice_model_name,$/;"	f
find_new_root_atom_for_chain	pack/prepack.c	/^static int find_new_root_atom_for_chain(INP int block_index, INP t_pack_patterns *list_of_pack_pattern) {$/;"	f	file:
find_number_of_inputs	base/verilog_writer.c	/^int find_number_of_inputs(t_pb *pb)$/;"	f
find_output	timing/path_delay.c	/^static int find_output(char * net_name) {$/;"	f	file:
find_parent_pb_type_child_index	spice/spice_utils.c	/^int find_parent_pb_type_child_index(t_pb_type* parent_pb_type,$/;"	f
find_path_id_between_pb_rr_nodes	spice/spice_pbtypes.c	/^int find_path_id_between_pb_rr_nodes(t_rr_node* local_rr_graph,$/;"	f
find_path_id_prev_rr_node	spice/spice_utils.c	/^int find_path_id_prev_rr_node(int num_drive_rr_nodes,$/;"	f
find_pb_graph_pin_in_edges_interc_spice_model	spice/spice_pbtypes.c	/^t_spice_model* find_pb_graph_pin_in_edges_interc_spice_model(t_pb_graph_pin pb_graph_pin) {$/;"	f
find_pb_graph_pin_in_edges_interc_type	spice/spice_pbtypes.c	/^enum e_interconnect find_pb_graph_pin_in_edges_interc_type(t_pb_graph_pin pb_graph_pin) {$/;"	f
find_pb_mapped_logical_block_rec	spice/spice_utils.c	/^int find_pb_mapped_logical_block_rec(t_pb* cur_pb,$/;"	f
find_pb_type_idle_mode_index	spice/spice_pbtypes.c	/^int find_pb_type_idle_mode_index(t_pb_type cur_pb_type) {$/;"	f
find_pb_type_port_match_spice_model_port	spice/spice_utils.c	/^t_port* find_pb_type_port_match_spice_model_port(t_pb_type* pb_type,$/;"	f
find_pb_type_ports_match_spice_model_port_type	spice/spice_utils.c	/^t_port** find_pb_type_ports_match_spice_model_port_type(t_pb_type* pb_type,$/;"	f
find_prev_rr_nodes_with_src	spice/spice_utils.c	/^void find_prev_rr_nodes_with_src(t_rr_node* src_rr_node,$/;"	f
find_spice_model_ports	spice/spice_utils.c	/^t_spice_model_port** find_spice_model_ports(t_spice_model* spice_model,$/;"	f
find_spice_mux_testbench_pb_pin_mux_load_inv_size	spice/spice_mux_testbench.c	/^float find_spice_mux_testbench_pb_pin_mux_load_inv_size(t_spice_model* fan_out_spice_model) {$/;"	f
find_spice_mux_testbench_rr_mux_load_inv_size	spice/spice_mux_testbench.c	/^float find_spice_mux_testbench_rr_mux_load_inv_size(t_rr_node* load_rr_node,$/;"	f
find_src_pb_pin_to_rr_nodes	clb_pin_remap/clb_pin_remap_util.c	/^void find_src_pb_pin_to_rr_nodes(t_pb* src_pb,$/;"	f
find_tnode_net_name	timing/path_delay.c	/^static char * find_tnode_net_name(int inode, boolean is_prepacked) {$/;"	f	file:
find_to	place/place.c	/^static boolean find_to(int x_from, int y_from, t_type_ptr type, float rlim, int *x_to, int *y_to) {$/;"	f	file:
find_type_col	base/SetupGrid.c	/^static t_type_ptr find_type_col(INP int x) {$/;"	f	file:
findfontsize	base/graphics.c	/^int findfontsize(float ymax) { }$/;"	f
findfontsize	base/graphics.c	/^int findfontsize(float ymax) {$/;"	f
first_iter_pres_fac	base/ReadOptions.h	/^	float first_iter_pres_fac;$/;"	m	struct:s_options
first_iter_pres_fac	base/vpr_types.h	/^	float first_iter_pres_fac;$/;"	m	struct:s_router_opts
fix_name	base/verilog_writer.c	/^char *fix_name(char *name)$/;"	f
fixed_channel_width	base/vpr_types.h	/^	int fixed_channel_width;$/;"	m	struct:s_router_opts
fixup_branch	timing/slre.c	/^static void fixup_branch(struct slre *r, int fixup) {$/;"	f	file:
flags	../../libarchfpga/include/ezxml.h	/^	short flags; \/* additional information *\/$/;"	m	struct:ezxml
flush_intermediate_queues	pack/cluster_placement.c	/^static void flush_intermediate_queues($/;"	f	file:
flushinput	base/graphics.c	/^flushinput (void) $/;"	f
flushinput	base/graphics.c	/^void flushinput (void) { }$/;"	f
font_info	base/graphics.c	/^static LOGFONT *font_info[MAX_FONT_SIZE+1]; \/* Data for each size *\/$/;"	v	file:
font_info	base/graphics.c	/^static XFontStruct *font_info[MAX_FONT_SIZE+1]; \/* Data for each size *\/$/;"	v	file:
font_is_loaded	base/graphics.c	/^static bool font_is_loaded[MAX_FONT_SIZE + 1];$/;"	v	file:
force_post_place_route_cb_input_pins	pack/cluster_legality.c	/^void force_post_place_route_cb_input_pins(int iblock) {$/;"	f
force_setcolor	base/graphics.c	/^static void force_setcolor (int cindex) $/;"	f	file:
force_setfontsize	base/graphics.c	/^static void force_setfontsize (int pointsize) $/;"	f	file:
force_setlinestyle	base/graphics.c	/^static void force_setlinestyle (int linestyle) $/;"	f	file:
force_setlinewidth	base/graphics.c	/^static void force_setlinewidth (int linewidth) $/;"	f	file:
format	../../libarchfpga/include/physical_types.h	/^	enum e_pin_to_pin_annotation_format format;$/;"	m	struct:s_pin_to_pin_annotation	typeref:enum:s_pin_to_pin_annotation::e_pin_to_pin_annotation_format
format_dir_path	spice/spice_utils.c	/^char* format_dir_path(char* dir_path) {$/;"	f
format_spice_node_prefix	spice/spice_utils.c	/^char* format_spice_node_prefix(char* spice_node_prefix) {$/;"	f
forward_expand_pack_pattern_from_edge	pack/prepack.c	/^static void forward_expand_pack_pattern_from_edge($/;"	f	file:
forward_infer_pattern	pack/prepack.c	/^static void forward_infer_pattern(INOUTP t_pb_graph_pin *pb_graph_pin) {$/;"	f	file:
forward_weight	base/vpr_types.h	/^	float forward_weight, backward_weight; \/* Weightings of the importance of paths $/;"	m	struct:s_tnode
found_connectivity	base/verilog_writer.h	/^typedef struct found_connectivity{$/;"	s
found_pins	base/verilog_writer.h	/^typedef struct found_pins{$/;"	s
fpga_spice_leakage_only	base/vpr_types.h	/^  boolean fpga_spice_leakage_only;$/;"	m	struct:s_spice_opts
fprint_call_defined_chan	spice/spice_netlist_utils.c	/^void fprint_call_defined_chan(FILE* fp,$/;"	f
fprint_call_defined_channels	spice/spice_netlist_utils.c	/^void fprint_call_defined_channels(FILE* fp) {$/;"	f
fprint_call_defined_connection_box	spice/spice_netlist_utils.c	/^void fprint_call_defined_connection_box(FILE* fp,$/;"	f
fprint_call_defined_connection_boxes	spice/spice_netlist_utils.c	/^void fprint_call_defined_connection_boxes(FILE* fp,$/;"	f
fprint_call_defined_grids	spice/spice_netlist_utils.c	/^void fprint_call_defined_grids(FILE* fp) {$/;"	f
fprint_call_defined_switch_box	spice/spice_netlist_utils.c	/^void fprint_call_defined_switch_box(FILE* fp,$/;"	f
fprint_call_defined_switch_boxes	spice/spice_netlist_utils.c	/^void fprint_call_defined_switch_boxes(FILE* fp) {$/;"	f
fprint_connection_box_interc	spice/spice_routing.c	/^void fprint_connection_box_interc(FILE* fp,$/;"	f
fprint_connection_box_mux	spice/spice_routing.c	/^void fprint_connection_box_mux(FILE* fp,$/;"	f
fprint_connection_box_short_interc	spice/spice_routing.c	/^void fprint_connection_box_short_interc(FILE* fp,$/;"	f
fprint_global_pad_ports_spice_model	spice/spice_netlist_utils.c	/^void fprint_global_pad_ports_spice_model(FILE* fp, $/;"	f
fprint_global_vdds_logical_block_spice_model	spice/spice_netlist_utils.c	/^void fprint_global_vdds_logical_block_spice_model(FILE* fp,$/;"	f
fprint_global_vdds_spice_model	spice/spice_netlist_utils.c	/^void fprint_global_vdds_spice_model(FILE* fp, $/;"	f
fprint_grid_block_subckt_pins	spice/spice_pbtypes.c	/^void fprint_grid_block_subckt_pins(FILE* fp,$/;"	f
fprint_grid_blocks	spice/spice_pbtypes.c	/^void fprint_grid_blocks(FILE* fp,$/;"	f
fprint_grid_float_port_stimulation	spice/spice_netlist_utils.c	/^void fprint_grid_float_port_stimulation(FILE* fp) {$/;"	f
fprint_grid_pins	spice/spice_pbtypes.c	/^void fprint_grid_pins(FILE* fp,$/;"	f
fprint_grid_side_in_with_given_index	spice/spice_routing.c	/^void fprint_grid_side_in_with_given_index(FILE* fp,$/;"	f
fprint_grid_side_pins	spice/spice_routing.c	/^void fprint_grid_side_pins(FILE* fp,$/;"	f
fprint_grid_splited_vdds_spice_model	spice/spice_netlist_utils.c	/^void fprint_grid_splited_vdds_spice_model(FILE* fp,$/;"	f
fprint_grid_testbench_one_grid_pin_loads	spice/spice_grid_testbench.c	/^void fprint_grid_testbench_one_grid_pin_loads(FILE* fp, int x, int y, $/;"	f
fprint_grid_testbench_one_grid_pin_stimulation	spice/spice_grid_testbench.c	/^void fprint_grid_testbench_one_grid_pin_stimulation(FILE* fp, int x, int y, $/;"	f
fprint_grid_testbench_one_grid_stimulation	spice/spice_grid_testbench.c	/^void fprint_grid_testbench_one_grid_stimulation(FILE* fp, $/;"	f
fprint_include_user_defined_netlists	spice/spice_netlist_utils.c	/^void fprint_include_user_defined_netlists(FILE* fp,$/;"	f
fprint_io_grid_block_subckt_pins	spice/spice_pbtypes.c	/^void fprint_io_grid_block_subckt_pins(FILE* fp,$/;"	f
fprint_io_grid_pins	spice/spice_pbtypes.c	/^void fprint_io_grid_pins(FILE* fp,$/;"	f
fprint_measure_vdds_cbs	spice/spice_top_netlist.c	/^void fprint_measure_vdds_cbs(FILE* fp,$/;"	f	file:
fprint_measure_vdds_logical_block_spice_model	spice/spice_netlist_utils.c	/^void fprint_measure_vdds_logical_block_spice_model(FILE* fp,$/;"	f
fprint_measure_vdds_sbs	spice/spice_top_netlist.c	/^void fprint_measure_vdds_sbs(FILE* fp,$/;"	f	file:
fprint_measure_vdds_spice_model	spice/spice_netlist_utils.c	/^void fprint_measure_vdds_spice_model(FILE* fp,$/;"	f
fprint_pb_primitive_ff	spice/spice_primitives.c	/^void fprint_pb_primitive_ff(FILE* fp,$/;"	f
fprint_pb_primitive_hardlogic	spice/spice_primitives.c	/^void fprint_pb_primitive_hardlogic(FILE* fp,$/;"	f
fprint_pb_primitive_io	spice/spice_primitives.c	/^void fprint_pb_primitive_io(FILE* fp,$/;"	f
fprint_pb_primitive_lut	spice/spice_lut.c	/^void fprint_pb_primitive_lut(FILE* fp,$/;"	f
fprint_pb_primitive_spice_model	spice/spice_pbtypes.c	/^void fprint_pb_primitive_spice_model(FILE* fp,$/;"	f
fprint_pb_type_ports	spice/spice_pbtypes.c	/^void fprint_pb_type_ports(FILE* fp,$/;"	f
fprint_routing_chan_subckt	spice/spice_routing.c	/^void fprint_routing_chan_subckt(FILE* fp,$/;"	f
fprint_routing_connection_box_subckt	spice/spice_routing.c	/^void fprint_routing_connection_box_subckt(FILE* fp,$/;"	f
fprint_routing_switch_box_subckt	spice/spice_routing.c	/^void fprint_routing_switch_box_subckt(FILE* fp, $/;"	f
fprint_run_hspice_shell_script	spice/spice_run_scripts.c	/^void fprint_run_hspice_shell_script(char* spice_dir_path,$/;"	f
fprint_spice_block	spice/spice_pbtypes.c	/^void fprint_spice_block(FILE* fp,$/;"	f
fprint_spice_dangling_des_pb_graph_pin_interc	spice/spice_pbtypes.c	/^void fprint_spice_dangling_des_pb_graph_pin_interc(FILE* fp,$/;"	f
fprint_spice_dff_testbench	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_dff_testbench_call_defined_dffs	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_call_defined_dffs(FILE* fp) {$/;"	f
fprint_spice_dff_testbench_call_one_grid_defined_dffs	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_call_one_grid_defined_dffs(FILE* fp,$/;"	f
fprint_spice_dff_testbench_global_ports	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_global_ports(FILE* fp, $/;"	f	file:
fprint_spice_dff_testbench_measurements	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_measurements(FILE* fp, $/;"	f
fprint_spice_dff_testbench_one_dff	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_one_dff(FILE* fp, $/;"	f
fprint_spice_dff_testbench_one_pb_graph_node_dff	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_one_pb_graph_node_dff(FILE* fp, $/;"	f
fprint_spice_dff_testbench_rec_pb_dffs	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_rec_pb_dffs(FILE* fp, $/;"	f
fprint_spice_dff_testbench_rec_pb_graph_node_dffs	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_rec_pb_graph_node_dffs(FILE* fp,$/;"	f
fprint_spice_dff_testbench_stimulations	spice/spice_dff_testbench.c	/^void fprint_spice_dff_testbench_stimulations(FILE* fp, $/;"	f
fprint_spice_global_vdd_connection_boxes	spice/spice_netlist_utils.c	/^void fprint_spice_global_vdd_connection_boxes(FILE* fp) {$/;"	f
fprint_spice_global_vdd_switch_boxes	spice/spice_netlist_utils.c	/^void fprint_spice_global_vdd_switch_boxes(FILE* fp) {$/;"	f
fprint_spice_grid_testbench	spice/spice_grid_testbench.c	/^void fprint_spice_grid_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_grid_testbench_call_defined_core_grids	spice/spice_grid_testbench.c	/^void fprint_spice_grid_testbench_call_defined_core_grids(FILE* fp) {$/;"	f
fprint_spice_grid_testbench_call_one_defined_grid	spice/spice_grid_testbench.c	/^void fprint_spice_grid_testbench_call_one_defined_grid(FILE* fp, int ix, int iy) {$/;"	f
fprint_spice_grid_testbench_global_ports	spice/spice_grid_testbench.c	/^void fprint_spice_grid_testbench_global_ports(FILE* fp, $/;"	f	file:
fprint_spice_grid_testbench_measurements	spice/spice_grid_testbench.c	/^void fprint_spice_grid_testbench_measurements(FILE* fp, $/;"	f	file:
fprint_spice_grid_testbench_stimulations	spice/spice_grid_testbench.c	/^void fprint_spice_grid_testbench_stimulations(FILE* fp, $/;"	f	file:
fprint_spice_head	spice/spice_utils.c	/^void fprint_spice_head(FILE* fp,$/;"	f
fprint_spice_headers	spice/spice_heads.c	/^void fprint_spice_headers(char* include_dir_path,$/;"	f
fprint_spice_idle_block	spice/spice_pbtypes.c	/^void fprint_spice_idle_block(FILE* fp,$/;"	f
fprint_spice_idle_pb_graph_node_rec	spice/spice_pbtypes.c	/^void fprint_spice_idle_pb_graph_node_rec(FILE* fp,$/;"	f
fprint_spice_include_key_subckts	spice/spice_netlist_utils.c	/^void fprint_spice_include_key_subckts(FILE* fp,$/;"	f
fprint_spice_include_param_headers	spice/spice_netlist_utils.c	/^void fprint_spice_include_param_headers(FILE* fp,$/;"	f
fprint_spice_lut_subckt	spice/spice_lut.c	/^void fprint_spice_lut_subckt(FILE* fp,$/;"	f
fprint_spice_lut_testbench	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_lut_testbench_call_defined_luts	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_call_defined_luts(FILE* fp) {$/;"	f
fprint_spice_lut_testbench_call_one_grid_defined_luts	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_call_one_grid_defined_luts(FILE* fp, int ix, int iy) {$/;"	f
fprint_spice_lut_testbench_global_ports	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_global_ports(FILE* fp, $/;"	f	file:
fprint_spice_lut_testbench_measurements	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_measurements(FILE* fp, $/;"	f
fprint_spice_lut_testbench_one_lut	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_one_lut(FILE* fp, $/;"	f
fprint_spice_lut_testbench_one_pb_graph_node_lut	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_one_pb_graph_node_lut(FILE* fp, $/;"	f
fprint_spice_lut_testbench_rec_pb_graph_node_luts	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_rec_pb_graph_node_luts(FILE* fp,$/;"	f
fprint_spice_lut_testbench_rec_pb_luts	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_rec_pb_luts(FILE* fp, $/;"	f
fprint_spice_lut_testbench_stimulations	spice/spice_lut_testbench.c	/^void fprint_spice_lut_testbench_stimulations(FILE* fp, $/;"	f
fprint_spice_meas_header	spice/spice_heads.c	/^void fprint_spice_meas_header(char* meas_file_name,$/;"	f	file:
fprint_spice_mux_basis_cmos_subckt	spice/spice_mux.c	/^void fprint_spice_mux_basis_cmos_subckt(FILE* fp,$/;"	f
fprint_spice_mux_basis_rram_subckt	spice/spice_mux.c	/^void fprint_spice_mux_basis_rram_subckt(FILE* fp,$/;"	f
fprint_spice_mux_basis_subckt	spice/spice_mux.c	/^void fprint_spice_mux_basis_subckt(FILE* fp, $/;"	f
fprint_spice_mux_model_cmos_subckt	spice/spice_mux.c	/^void fprint_spice_mux_model_cmos_subckt(FILE* fp,$/;"	f
fprint_spice_mux_model_rram_subckt	spice/spice_mux.c	/^void fprint_spice_mux_model_rram_subckt(FILE* fp,$/;"	f
fprint_spice_mux_model_subckt	spice/spice_mux.c	/^void fprint_spice_mux_model_subckt(FILE* fp,$/;"	f
fprint_spice_mux_testbench	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_mux_testbench_call_one_grid_pb_muxes	spice/spice_mux_testbench.c	/^int fprint_spice_mux_testbench_call_one_grid_pb_muxes(FILE* fp, int ix, int iy,$/;"	f	file:
fprint_spice_mux_testbench_call_one_grid_sb_muxes	spice/spice_mux_testbench.c	/^int fprint_spice_mux_testbench_call_one_grid_sb_muxes(FILE* fp, $/;"	f	file:
fprint_spice_mux_testbench_cb_interc	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_cb_interc(FILE* fp, $/;"	f
fprint_spice_mux_testbench_cb_mux_meas	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_cb_mux_meas(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_cb_one_mux	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_cb_one_mux(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_global_ports	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_global_ports(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_idle_pb_graph_node_muxes_rec	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_idle_pb_graph_node_muxes_rec(FILE* fp, $/;"	f
fprint_spice_mux_testbench_measurements	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_measurements(FILE* fp, $/;"	f	file:
fprint_spice_mux_testbench_one_cb_mux_loads	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_one_cb_mux_loads(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_one_grid_cb_muxes	spice/spice_mux_testbench.c	/^int fprint_spice_mux_testbench_one_grid_cb_muxes(FILE* fp, $/;"	f	file:
fprint_spice_mux_testbench_one_mux	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_one_mux(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_graph_node_interc	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_graph_node_interc(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_graph_node_pin_interc	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_graph_node_pin_interc(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_graph_node_pin_mux	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_graph_node_pin_mux(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_graph_pin_inv_loads_rec	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_graph_pin_inv_loads_rec(FILE* fp, $/;"	f
fprint_spice_mux_testbench_pb_interc	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_interc(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_mux_meas	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_mux_meas(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_muxes_rec	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_muxes_rec(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_pin_interc	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_pin_interc(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_pb_pin_mux	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_pb_pin_mux(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_rr_node_load_version	spice/spice_mux_testbench.c	/^char* fprint_spice_mux_testbench_rr_node_load_version(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_sb_mux_meas	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_sb_mux_meas(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_sb_one_mux	spice/spice_mux_testbench.c	/^int fprint_spice_mux_testbench_sb_one_mux(FILE* fp,$/;"	f	file:
fprint_spice_mux_testbench_stimulations	spice/spice_mux_testbench.c	/^void fprint_spice_mux_testbench_stimulations(FILE* fp, $/;"	f	file:
fprint_spice_netlist_transient_setting	spice/spice_netlist_utils.c	/^void fprint_spice_netlist_transient_setting(FILE* fp, $/;"	f
fprint_spice_one_dff_testbench	spice/spice_dff_testbench.c	/^int fprint_spice_one_dff_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_one_grid_testbench	spice/spice_grid_testbench.c	/^int fprint_spice_one_grid_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_one_lut_testbench	spice/spice_lut_testbench.c	/^int fprint_spice_one_lut_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_one_mux_testbench	spice/spice_mux_testbench.c	/^int fprint_spice_one_mux_testbench(char* formatted_spice_dir,$/;"	f
fprint_spice_options	spice/spice_netlist_utils.c	/^void fprint_spice_options(FILE* fp,$/;"	f
fprint_spice_pb_graph_interc	spice/spice_pbtypes.c	/^void fprint_spice_pb_graph_interc(FILE* fp, $/;"	f
fprint_spice_pb_graph_node_rec	spice/spice_pbtypes.c	/^void fprint_spice_pb_graph_node_rec(FILE* fp, $/;"	f
fprint_spice_pb_graph_primitive_node	spice/spice_pbtypes.c	/^void fprint_spice_pb_graph_primitive_node(FILE* fp,$/;"	f
fprint_spice_stimulate_header	spice/spice_heads.c	/^void fprint_spice_stimulate_header(char* stimulate_file_name,$/;"	f	file:
fprint_spice_top_netlist	spice/spice_top_netlist.c	/^void fprint_spice_top_netlist(char* circuit_name,$/;"	f
fprint_spice_wire_model	spice/spice_subckt.c	/^void fprint_spice_wire_model(FILE* fp,$/;"	f
fprint_splited_vdds_logical_block_spice_model	spice/spice_netlist_utils.c	/^void fprint_splited_vdds_logical_block_spice_model(FILE* fp,$/;"	f
fprint_splited_vdds_spice_model	spice/spice_netlist_utils.c	/^void fprint_splited_vdds_spice_model(FILE* fp,$/;"	f
fprint_stimulate_dangling_grid_pins	spice/spice_netlist_utils.c	/^void fprint_stimulate_dangling_grid_pins(FILE* fp) {$/;"	f
fprint_stimulate_dangling_io_grid_pins	spice/spice_netlist_utils.c	/^void fprint_stimulate_dangling_io_grid_pins(FILE* fp,$/;"	f
fprint_stimulate_dangling_normal_grid_pins	spice/spice_netlist_utils.c	/^void fprint_stimulate_dangling_normal_grid_pins(FILE* fp,$/;"	f
fprint_stimulate_dangling_one_grid_pin	spice/spice_netlist_utils.c	/^void fprint_stimulate_dangling_one_grid_pin(FILE* fp,$/;"	f
fprint_switch_box_chan_port	spice/spice_routing.c	/^void fprint_switch_box_chan_port(FILE* fp,$/;"	f
fprint_switch_box_interc	spice/spice_routing.c	/^void fprint_switch_box_interc(FILE* fp, $/;"	f
fprint_switch_box_mux	spice/spice_routing.c	/^void fprint_switch_box_mux(FILE* fp, $/;"	f
fprint_switch_box_short_interc	spice/spice_routing.c	/^void fprint_switch_box_short_interc(FILE* fp, $/;"	f
fprint_tech_lib	spice/spice_netlist_utils.c	/^void fprint_tech_lib(FILE* fp,$/;"	f
fprint_top_netlist_global_ports	spice/spice_top_netlist.c	/^void fprint_top_netlist_global_ports(FILE* fp,$/;"	f	file:
fprint_top_netlist_measurements	spice/spice_top_netlist.c	/^void fprint_top_netlist_measurements(FILE* fp, $/;"	f	file:
fprint_top_netlist_stimulations	spice/spice_top_netlist.c	/^void fprint_top_netlist_stimulations(FILE* fp,$/;"	f	file:
fprint_voltage_pulse_params	spice/spice_netlist_utils.c	/^void fprint_voltage_pulse_params(FILE* fp,$/;"	f
fprintf_spice_pb_graph_pin_interc	spice/spice_pbtypes.c	/^void fprintf_spice_pb_graph_pin_interc(FILE* fp,$/;"	f
fptr	base/vpr_types.h	/^	float *fptr;$/;"	m	struct:s_linked_f_pointer
frac_cb	../../libarchfpga/include/physical_types.h	/^	float frac_cb;$/;"	m	struct:s_segment_inf
frac_sb	../../libarchfpga/include/physical_types.h	/^	float frac_sb;$/;"	m	struct:s_segment_inf
freeGrid	base/SetupGrid.c	/^void freeGrid() {$/;"	f
freeTokens	util/token.c	/^void freeTokens(INP t_token *tokens, INP int num_tokens) {$/;"	f
free_all_pb_graph_nodes	pack/pb_type_graph.c	/^void free_all_pb_graph_nodes(void) {$/;"	f
free_and_reset_internal_structures	place/timing_place_lookup.c	/^static void free_and_reset_internal_structures(struct s_net *original_net,$/;"	f	file:
free_arch	base/vpr_api.c	/^void free_arch(t_arch* Arch) {$/;"	f
free_best_buffer_list	mrfpga/buffer_insertion.c	/^static void free_best_buffer_list( )$/;"	f	file:
free_blk_pin_from_port_pin	util/vpr_utils.c	/^void free_blk_pin_from_port_pin(void) {$/;"	f
free_buffer_list	mrfpga/buffer_insertion.c	/^static void free_buffer_list( t_buffer_plan_list list )$/;"	f	file:
free_cb	util/vpr_utils.c	/^void free_cb(t_pb *pb) {$/;"	f
free_chunk_memory	../../libarchfpga/util.c	/^void free_chunk_memory(t_chunk *chunk_info) {$/;"	f
free_chunk_memory_trace	route/route_common.c	/^void free_chunk_memory_trace(void) {$/;"	f
free_circuit	base/vpr_api.c	/^void free_circuit() {$/;"	f
free_clb_nets_spice_net_info	spice/spice_api.c	/^void free_clb_nets_spice_net_info() {$/;"	f	file:
free_clock_constraint	timing/read_sdc.c	/^static void free_clock_constraint(t_clock *& clock_array, int num_clocks) {$/;"	f	file:
free_cluster_legality_checker	pack/cluster_legality.c	/^void free_cluster_legality_checker(void) {$/;"	f
free_cluster_placement_stats	pack/cluster_placement.c	/^void free_cluster_placement_stats($/;"	f
free_complex_block_types	base/vpr_api.c	/^static void free_complex_block_types(void) {$/;"	f	file:
free_crit	place/timing_place.c	/^static void free_crit(t_chunk *chunk_list_ptr){$/;"	f	file:
free_delta_arrays	place/timing_place_lookup.c	/^static void free_delta_arrays(void) {$/;"	f	file:
free_draw_structs	base/draw.c	/^void free_draw_structs(void) {$/;"	f
free_echo_file_info	base/ReadOptions.c	/^void free_echo_file_info() {$/;"	f
free_edge_list_head	route/rr_graph2.c	/^t_linked_edge *free_edge_list_head = NULL;$/;"	v
free_fast_cost_update	place/place.c	/^static void free_fast_cost_update(void) {$/;"	f	file:
free_hash_table	util/hash.c	/^void free_hash_table(struct s_hash **hash_table) {$/;"	f
free_heap_data	route/route_common.c	/^void free_heap_data(struct s_heap *hptr) {$/;"	f
free_imacro_from_iblk	place/place_macro.c	/^static void free_imacro_from_iblk(void) {$/;"	f	file:
free_int_list	../../libarchfpga/util.c	/^void free_int_list(t_linked_int ** int_list_head_ptr) {$/;"	f
free_io_constraint	timing/read_sdc.c	/^static void free_io_constraint(t_io *& io_array, int num_ios) {$/;"	f	file:
free_ivec_matrix	../../libarchfpga/util.c	/^void free_ivec_matrix(struct s_ivec **ivec_matrix, int nrmin, int nrmax,$/;"	f
free_ivec_matrix3	../../libarchfpga/util.c	/^void free_ivec_matrix3(struct s_ivec ***ivec_matrix3, int nrmin, int nrmax,$/;"	f
free_ivec_vector	../../libarchfpga/util.c	/^void free_ivec_vector(struct s_ivec *ivec_vector, int nrmin, int nrmax) {$/;"	f
free_legal_placements	place/place.c	/^static void free_legal_placements() {$/;"	f	file:
free_legalizer_for_cluster	pack/cluster_legality.c	/^void free_legalizer_for_cluster(INP t_block* clb, boolean free_local_rr_graph) {$/;"	f
free_linked_list	base/verilog_writer.c	/^pb_list *free_linked_list(pb_list *list)$/;"	f
free_linked_list_conn	base/verilog_writer.c	/^conn_list *free_linked_list_conn(conn_list *list)$/;"	f
free_linked_rc_edge	timing/net_delay.c	/^void free_linked_rc_edge(t_linked_rc_edge * rc_edge,$/;"	f
free_linked_rt_edge	route/route_tree_timing.c	/^static void free_linked_rt_edge(t_linked_rt_edge * rt_edge) {$/;"	f	file:
free_list_of_pack_patterns	pack/prepack.c	/^void free_list_of_pack_patterns(INP t_pack_patterns *list_of_pack_patterns, INP int num_packing_patterns) {$/;"	f
free_llist	spice/linkedlist.c	/^void free_llist(t_llist* head) {$/;"	f
free_logical_blocks	base/read_netlist.c	/^void free_logical_blocks(void) {$/;"	f
free_logical_nets	base/read_netlist.c	/^void free_logical_nets(void) {$/;"	f
free_lookups_and_criticalities	place/timing_place.c	/^void free_lookups_and_criticalities(float ***net_delay, t_slack * slacks) {$/;"	f
free_matrix	../../libarchfpga/util.c	/^void free_matrix(void *vptr, int nrmin, int nrmax, int ncmin, size_t elsize) {$/;"	f
free_matrix3	../../libarchfpga/util.c	/^void free_matrix3(void *vptr, int nrmin, int nrmax, int ncmin, int ncmax,$/;"	f
free_matrix4	../../libarchfpga/util.c	/^void free_matrix4(void *vptr, int nrmin, int nrmax, int ncmin, int ncmax,$/;"	f
free_muxes_llist	spice/spice_mux.c	/^void free_muxes_llist(t_llist* muxes_head) {$/;"	f
free_net_delay	timing/net_delay.c	/^void free_net_delay(float **net_delay,$/;"	f
free_options	base/vpr_api.c	/^void free_options(t_options *options) {$/;"	f
free_output_file_names	base/ReadOptions.c	/^void free_output_file_names() {$/;"	f
free_override_constraint	timing/read_sdc.c	/^void free_override_constraint(t_override_constraint *& constraint_array, int num_constraints) {$/;"	f
free_pack_pattern	pack/prepack.c	/^static void free_pack_pattern(INOUTP t_pack_pattern_block *pattern_block, INOUTP t_pack_pattern_block **pattern_block_list) {$/;"	f	file:
free_parse	base/read_blif.c	/^static void free_parse(void) {$/;"	f	file:
free_pb	util/vpr_utils.c	/^void free_pb(t_pb *pb) {$/;"	f
free_pb_data	base/place_and_route.c	/^void free_pb_data(t_pb *pb) {$/;"	f
free_pb_graph	pack/pb_type_graph.c	/^static void free_pb_graph(INOUTP t_pb_graph_node *pb_graph_node) {$/;"	f	file:
free_pb_stats	util/vpr_utils.c	/^void free_pb_stats(t_pb *pb) {$/;"	f
free_pb_stats_recursive	pack/cluster.c	/^static void free_pb_stats_recursive(t_pb *pb) {$/;"	f	file:
free_pb_type	base/vpr_api.c	/^static void free_pb_type(t_pb_type *pb_type) {$/;"	f	file:
free_place_lookup_structs	place/timing_place_lookup.c	/^void free_place_lookup_structs(void) {$/;"	f
free_placement_macros_structs	place/place_macro.c	/^void free_placement_macros_structs(void) {$/;"	f
free_placement_structs	place/place.c	/^static void free_placement_structs($/;"	f	file:
free_port_pin_from_blk_pin	util/vpr_utils.c	/^void free_port_pin_from_blk_pin(void) {$/;"	f
free_rc_edge_free_list	timing/net_delay.c	/^void free_rc_edge_free_list(t_linked_rc_edge * rc_edge_free_list) {$/;"	f
free_rc_node	timing/net_delay.c	/^void free_rc_node(t_rc_node * rc_node,$/;"	f
free_rc_node_free_list	timing/net_delay.c	/^void free_rc_node_free_list(t_rc_node * rc_node_free_list) {$/;"	f
free_rc_tree	timing/net_delay.c	/^void free_rc_tree(t_rc_node * rc_root,$/;"	f
free_route_structs	route/route_common.c	/^void free_route_structs() {$/;"	f
free_route_tree	route/route_tree_timing.c	/^void free_route_tree(t_rt_node * rt_node) {$/;"	f
free_route_tree_timing_structs	route/route_tree_timing.c	/^void free_route_tree_timing_structs(void) {$/;"	f
free_routing_structs	place/timing_place_lookup.c	/^static void free_routing_structs(struct s_router_opts router_opts,$/;"	f	file:
free_rr_graph	route/rr_graph.c	/^void free_rr_graph(void) {$/;"	f
free_rr_node_indices	route/rr_graph2.c	/^void free_rr_node_indices(INP t_ivec *** L_rr_node_indices) {$/;"	f
free_rr_node_route_structs	route/route_common.c	/^void free_rr_node_route_structs(void) {$/;"	f
free_rt_node	route/route_tree_timing.c	/^static void free_rt_node(t_rt_node * rt_node) {$/;"	f	file:
free_saved_routing	route/route_common.c	/^void free_saved_routing(struct s_trace **best_routing,$/;"	f
free_sblock_pattern_lookup	route/rr_graph2.c	/^void free_sblock_pattern_lookup(INOUTP short *****sblock_pattern) {$/;"	f
free_sdc_related_structs	timing/read_sdc.c	/^void free_sdc_related_structs(void) {$/;"	f
free_seg_details	route/rr_graph2.c	/^void free_seg_details(t_seg_details * seg_details, int nodes_per_chan) {$/;"	f
free_spice_tb_llist	spice/spice_api.c	/^void free_spice_tb_llist() {$/;"	f	file:
free_switch_block_conn	route/rr_graph_sbox.c	/^void free_switch_block_conn(struct s_ivec ***switch_block_conn,$/;"	f
free_timing_driven_route_structs	route/route_timing.c	/^void free_timing_driven_route_structs(float *pin_criticality, int *sink_order,$/;"	f
free_timing_graph	timing/path_delay.c	/^void free_timing_graph(t_slack * slacks) {$/;"	f
free_timing_stats	timing/path_delay.c	/^void free_timing_stats(void) {$/;"	f
free_trace_data	route/route_common.c	/^static void free_trace_data(struct s_trace *tptr) {$/;"	f	file:
free_trace_structs	route/route_common.c	/^void free_trace_structs(void) {$/;"	f
free_traceback	route/route_common.c	/^void free_traceback(int inet) {$/;"	f
free_try_swap_arrays	place/place.c	/^static void free_try_swap_arrays(void) {$/;"	f	file:
free_type_pin_to_track_map	route/rr_graph.c	/^static void free_type_pin_to_track_map(int***** ipin_to_track_map,$/;"	f	file:
free_type_track_to_ipin_map	route/rr_graph.c	/^static void free_type_track_to_ipin_map(struct s_ivec**** track_to_pin_map,$/;"	f	file:
freq	../../libarchfpga/include/spice_types.h	/^  float freq; $/;"	m	struct:s_spice_net_info
frequency	../../libarchfpga/include/physical_types.h	/^	int frequency;$/;"	m	struct:s_segment_inf
from_block	../../libarchfpga/include/cad_types.h	/^	t_pack_pattern_block *from_block;$/;"	m	struct:s_pack_pattern_connections
from_clb_pin_end_index	route/rr_graph.c	/^	int from_clb_pin_end_index;$/;"	m	struct:s_clb_to_clb_directs	file:
from_clb_pin_start_index	route/rr_graph.c	/^	int from_clb_pin_start_index;$/;"	m	struct:s_clb_to_clb_directs	file:
from_clb_type	route/rr_graph.c	/^	t_type_descriptor *from_clb_type;$/;"	m	struct:s_clb_to_clb_directs	file:
from_pin	../../libarchfpga/include/cad_types.h	/^	t_pb_graph_pin *from_pin;$/;"	m	struct:s_pack_pattern_connections
from_pin	../../libarchfpga/include/physical_types.h	/^	char *from_pin;$/;"	m	struct:s_direct_inf
front	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_list { t_buffer_plan_node* front; } t_buffer_plan_list;$/;"	m	struct:s_buffer_plan_list	file:
fs	base/place_and_route.h	/^	int fs; \/* at this fs *\/$/;"	m	struct:s_fmap_cell
full_stats	base/vpr_types.h	/^	boolean full_stats;$/;"	m	struct:s_router_opts
g_MTA_area	power/power_sizing.c	/^static double g_MTA_area;$/;"	v	file:
g_buffer_strength_last_searched	power/power_cmos_tech.c	/^static t_power_buffer_strength_inf * g_buffer_strength_last_searched;$/;"	v	file:
g_clock_arch	base/globals.c	/^t_clock_arch * g_clock_arch;$/;"	v
g_mux_volt_last_searched	power/power_cmos_tech.c	/^static t_power_mux_volt_inf * g_mux_volt_last_searched;$/;"	v	file:
g_power_arch	power/power.c	/^t_power_arch * g_power_arch;$/;"	v
g_power_by_component	power/power_components.c	/^t_power_components g_power_by_component;$/;"	v
g_power_commonly_used	power/power.c	/^t_power_commonly_used * g_power_commonly_used;$/;"	v
g_power_output	power/power.c	/^t_power_output * g_power_output;$/;"	v
g_power_searching_nmos_leakage_info	power/power_cmos_tech.c	/^t_power_nmos_leakage_inf * g_power_searching_nmos_leakage_info;$/;"	v
g_power_tech	power/power.c	/^t_power_tech * g_power_tech;$/;"	v
g_sdc	timing/read_sdc.c	/^t_timing_constraints * g_sdc = NULL;$/;"	v
g_solution_inf	power/power.c	/^t_solution_inf g_solution_inf;$/;"	v
g_transistor_last_searched	power/power_cmos_tech.c	/^static t_transistor_inf * g_transistor_last_searched;$/;"	v	file:
gain	base/vpr_types.h	/^	std::map<int, float> gain; \/* Attraction (inverse of cost) function *\/$/;"	m	struct:s_pb_stats
gc	base/graphics.c	/^static GC gc, gcxor, gc_menus, current_gc;$/;"	v	file:
gc_menus	base/graphics.c	/^static GC gc, gcxor, gc_menus, current_gc;$/;"	v	file:
gcxor	base/graphics.c	/^static GC gc, gcxor, gc_menus, current_gc;$/;"	v	file:
gen_spice_name_tag_pb_rec	spice/spice_utils.c	/^void gen_spice_name_tag_pb_rec(t_pb* cur_pb,$/;"	f
gen_spice_name_tags_all_pbs	spice/spice_utils.c	/^void gen_spice_name_tags_all_pbs() {$/;"	f
generate_lut_sram_bits	spice/spice_lut.c	/^int* generate_lut_sram_bits(int truth_table_len,$/;"	f
generate_nets_sinks_prefer_sides	clb_pin_remap/place_clb_pin_remap.c	/^int generate_nets_sinks_prefer_sides(int n_nets, t_net* nets,$/;"	f
generate_spice_basics	spice/spice_subckt.c	/^int generate_spice_basics(char* subckt_dir, t_spice spice) {$/;"	f	file:
generate_spice_logic_blocks	spice/spice_pbtypes.c	/^void generate_spice_logic_blocks(char* subckt_dir) {$/;"	f
generate_spice_luts	spice/spice_lut.c	/^void generate_spice_luts(char* subckt_dir, $/;"	f
generate_spice_muxes	spice/spice_mux.c	/^void generate_spice_muxes(char* subckt_dir,$/;"	f
generate_spice_nmos_pmos	spice/spice_subckt.c	/^int generate_spice_nmos_pmos(char* subckt_dir,$/;"	f
generate_spice_routing_resources	spice/spice_routing.c	/^void generate_spice_routing_resources(char* subckt_dir,$/;"	f
generate_spice_rram_veriloga	spice/spice_subckt.c	/^void generate_spice_rram_veriloga(char* subckt_dir, $/;"	f
generate_spice_src_des_pb_graph_pin_prefix	spice/spice_pbtypes.c	/^void generate_spice_src_des_pb_graph_pin_prefix(t_pb_graph_node* src_pb_graph_node,$/;"	f
generate_spice_subckt_tapbuf	spice/spice_subckt.c	/^void generate_spice_subckt_tapbuf(FILE* fp, $/;"	f
generate_spice_subckts	spice/spice_subckt.c	/^void generate_spice_subckts(char* subckt_dir,$/;"	f
generate_spice_wires	spice/spice_subckt.c	/^void generate_spice_wires(char* subckt_dir,$/;"	f
generate_string_spice_model_type	spice/spice_utils.c	/^char* generate_string_spice_model_type(enum e_spice_model_type spice_model_type) {$/;"	f
generic_compute_matrix	place/timing_place_lookup.c	/^static void generic_compute_matrix(float ***matrix_ptr, t_type_ptr source_type,$/;"	f	file:
getEchoEnabled	base/ReadOptions.c	/^boolean getEchoEnabled(void) {$/;"	f
getEchoFileName	base/ReadOptions.c	/^char *getEchoFileName(enum e_echo_files echo_option) {$/;"	f
getOutputFileName	base/ReadOptions.c	/^char *getOutputFileName(enum e_output_files ename) {$/;"	f
get_array_size_of_molecule	pack/cluster_placement.c	/^int get_array_size_of_molecule(t_pack_molecule *molecule) {$/;"	f
get_average_opin_delay	route/rr_graph_indexed_data.c	/^static float get_average_opin_delay(t_ivec *** L_rr_node_indices,$/;"	f	file:
get_bb_from_scratch	place/place.c	/^static void get_bb_from_scratch(int inet, struct s_bb *coords,$/;"	f	file:
get_bidir_opin_connections	route/rr_graph2.c	/^int get_bidir_opin_connections(INP int i, INP int j, INP int ipin,$/;"	f
get_bidir_track_to_chan_seg	route/rr_graph2.c	/^static int get_bidir_track_to_chan_seg(INP struct s_ivec conn_tracks,$/;"	f	file:
get_blif_tok	base/read_blif.c	/^static void get_blif_tok(char *buffer, int doall, boolean *done,$/;"	f	file:
get_blk_pin_from_port_pin	util/vpr_utils.c	/^void get_blk_pin_from_port_pin(int blk_type_index, int port,int port_pin, $/;"	f
get_block_center	base/draw.c	/^static void get_block_center(int bnum, float *x, float *y) {$/;"	f	file:
get_cblock_trans	route/rr_graph_area.c	/^static float get_cblock_trans(int *num_inputs_to_cblock,$/;"	f	file:
get_channel_occupancy_stats	base/stats.c	/^static void get_channel_occupancy_stats(void) {$/;"	f	file:
get_class_range_for_block	util/vpr_utils.c	/^void get_class_range_for_block(INP int iblk, OUTP int *class_low,$/;"	f
get_critical_path_delay	timing/path_delay.c	/^float get_critical_path_delay(void) {$/;"	f
get_crossing_penalty	clb_pin_remap/post_place_timing.c	/^float get_crossing_penalty(int num_sinks) {$/;"	f
get_default_spice_model	spice/spice_utils.c	/^t_spice_model* get_default_spice_model(enum e_spice_model_type default_spice_model_type,$/;"	f
get_delay_normalization_fac	route/rr_graph_indexed_data.c	/^static float get_delay_normalization_fac(int nodes_per_chan,$/;"	f	file:
get_empty_buffer_plan_list	mrfpga/buffer_insertion.c	/^static t_buffer_plan_list get_empty_buffer_plan_list( )$/;"	f	file:
get_entry	power/PowerSpicedComponent.c	/^PowerCallibInputs * PowerSpicedComponent::get_entry(int num_inputs) {$/;"	f	class:PowerSpicedComponent
get_entry_bound	power/PowerSpicedComponent.c	/^PowerCallibInputs * PowerSpicedComponent::get_entry_bound(bool lower,$/;"	f	class:PowerSpicedComponent
get_entry_bound	power/PowerSpicedComponent.c	/^PowerCallibSize * PowerCallibInputs::get_entry_bound(bool lower,$/;"	f	class:PowerCallibInputs
get_escape_char	timing/slre.c	/^static int get_escape_char(const char **re) {$/;"	f	file:
get_expected_lowest_cost_primitive_for_logical_block	pack/prepack.c	/^static t_pb_graph_node *get_expected_lowest_cost_primitive_for_logical_block(INP int ilogical_block) {$/;"	f	file:
get_expected_lowest_cost_primitive_for_logical_block_in_pb_graph_node	pack/prepack.c	/^static t_pb_graph_node *get_expected_lowest_cost_primitive_for_logical_block_in_pb_graph_node(INP int ilogical_block, INP t_pb_graph_node *curr_pb_graph_node, OUTP float *cost) {$/;"	f	file:
get_expected_segs_to_target	route/route_timing.c	/^static int get_expected_segs_to_target(int inode, int target_node,$/;"	f	file:
get_first_pin	place/timing_place_lookup.c	/^static int get_first_pin(enum e_pin_type pintype, t_type_ptr type) {$/;"	f	file:
get_free_molecule_with_most_ext_inputs_for_cluster	pack/cluster.c	/^static t_pack_molecule *get_free_molecule_with_most_ext_inputs_for_cluster($/;"	f	file:
get_grid_block_subckt_name	spice/spice_pbtypes.c	/^char* get_grid_block_subckt_name(int x,$/;"	f
get_grid_side_pin_rr_nodes	spice/spice_routing.c	/^t_rr_node** get_grid_side_pin_rr_nodes(int* num_pin_rr_nodes,$/;"	f
get_hash_entry	util/hash.c	/^get_hash_entry(struct s_hash **hash_table, char *name) {$/;"	f
get_hash_stats	util/hash.c	/^void get_hash_stats(struct s_hash **hash_table, char *hash_table_name){$/;"	f
get_heap_head	route/route_common.c	/^get_heap_head(void) {$/;"	f
get_highest_gain_molecule	pack/cluster.c	/^static t_pack_molecule *get_highest_gain_molecule($/;"	f	file:
get_imacro_from_iblk	place/place_macro.c	/^void get_imacro_from_iblk(int * imacro, int iblk, t_pl_macro * macros, int num_macros) {$/;"	f
get_init_buffer_plan	mrfpga/buffer_insertion.c	/^static t_buffer_plan get_init_buffer_plan( int inode, int num_pins, int* isink_to_inode )$/;"	f	file:
get_init_buffer_plan_list	mrfpga/buffer_insertion.c	/^static t_buffer_plan_list get_init_buffer_plan_list( int inode, int num_pins, int* isink_to_inode )$/;"	f	file:
get_int_list_length	mrfpga/buffer_insertion.c	/^static int get_int_list_length( t_linked_int* list )$/;"	f	file:
get_keypress_input	base/graphics.c	/^static bool get_keypress_input, get_mouse_move_input;$/;"	v	file:
get_length_and_bends_stats	base/stats.c	/^void get_length_and_bends_stats(void) {$/;"	f
get_longest_segment_length	place/timing_place_lookup.c	/^static int get_longest_segment_length($/;"	f	file:
get_lut_output_init_val	spice/spice_lut.c	/^int get_lut_output_init_val(t_logical_block* lut_logical_block) {$/;"	f
get_max_depth_of_pb_graph_node	pack/cluster_feasibility_filter.c	/^static int get_max_depth_of_pb_graph_node(INP t_pb_graph_node *pb_graph_node) {$/;"	f	file:
get_max_depth_of_pb_type	util/vpr_utils.c	/^int get_max_depth_of_pb_type(t_pb_type *pb_type) {$/;"	f
get_max_nets_in_pb_type	util/vpr_utils.c	/^int get_max_nets_in_pb_type(const t_pb_type *pb_type) {$/;"	f
get_max_pins_per_net	route/route_timing.c	/^static int get_max_pins_per_net(void) {$/;"	f	file:
get_max_primitives_in_pb_type	util/vpr_utils.c	/^int get_max_primitives_in_pb_type(t_pb_type *pb_type) {$/;"	f
get_molecule_by_num_ext_inputs	pack/cluster.c	/^static t_pack_molecule *get_molecule_by_num_ext_inputs($/;"	f	file:
get_molecule_for_cluster	pack/cluster.c	/^static t_pack_molecule *get_molecule_for_cluster($/;"	f	file:
get_molecule_gain	pack/cluster.c	/^static float get_molecule_gain(t_pack_molecule *molecule, std::map<int, float> &blk_gain) {$/;"	f	file:
get_most_critical_seed_molecule	pack/cluster.c	/^static t_pack_molecule* get_most_critical_seed_molecule(int * indexofcrit) {$/;"	f	file:
get_mouse_move_input	base/graphics.c	/^static bool get_keypress_input, get_mouse_move_input;$/;"	v	file:
get_mrfpga_switch_type	mrfpga/mrfpga_api.c	/^void get_mrfpga_switch_type(boolean is_from_sbox,$/;"	f
get_net_corresponding_to_pb_graph_pin	pack/cluster.c	/^static int get_net_corresponding_to_pb_graph_pin(t_pb *cur_pb,$/;"	f	file:
get_net_cost	place/place.c	/^static float get_net_cost(int inet, struct s_bb *bbptr) {$/;"	f	file:
get_net_wirelength_estimate	place/place.c	/^static double get_net_wirelength_estimate(int inet, struct s_bb *bbptr) {$/;"	f	file:
get_next_hash	util/hash.c	/^get_next_hash(struct s_hash **hash_table, struct s_hash_iterator *hash_iterator) {$/;"	f
get_next_primitive_list	pack/cluster_placement.c	/^boolean get_next_primitive_list($/;"	f
get_non_updateable_bb	place/place.c	/^static void get_non_updateable_bb(int inet, struct s_bb *bb_coord_new) {$/;"	f	file:
get_num_bends_and_length	base/stats.c	/^void get_num_bends_and_length(int inet, int *bends_ptr, int *len_ptr,$/;"	f
get_num_conn	base/check_netlist.c	/^static int get_num_conn(int bnum) {$/;"	f	file:
get_opin_direct_connecions	route/rr_graph.c	/^static int get_opin_direct_connecions(int x, int y, int opin, INOUTP t_linked_edge ** edge_list_ptr, INP t_ivec *** L_rr_node_indices, $/;"	f	file:
get_pb_graph_node_pin_from_block_pin	util/vpr_utils.c	/^t_pb_graph_pin* get_pb_graph_node_pin_from_block_pin(int iblock, int ipin) {$/;"	f
get_pb_graph_node_pin_from_clb_net	util/vpr_utils.c	/^t_pb_graph_pin* get_pb_graph_node_pin_from_clb_net(int inet, int ipin) {$/;"	f
get_pb_graph_node_pin_from_model_port_pin	util/vpr_utils.c	/^t_pb_graph_pin* get_pb_graph_node_pin_from_model_port_pin(t_model_ports *model_port, int model_pin, t_pb_graph_node *pb_graph_node) {$/;"	f
get_pb_graph_node_pin_from_vpack_net	util/vpr_utils.c	/^t_pb_graph_pin* get_pb_graph_node_pin_from_vpack_net(int inet, int ipin) {$/;"	f
get_pb_graph_pin_from_name	pack/pb_type_graph.c	/^static t_pb_graph_pin * get_pb_graph_pin_from_name(INP const char * port_name,$/;"	f	file:
get_port_pin_from_blk_pin	util/vpr_utils.c	/^void get_port_pin_from_blk_pin(int blk_type_index, int blk_pin, int * port,$/;"	f
get_rr_cong_cost	route/route_common.c	/^float get_rr_cong_cost(int inode) {$/;"	f
get_rr_node_index	route/rr_graph2.c	/^int get_rr_node_index(int x, int y, t_rr_type rr_type, int ptc,$/;"	f
get_rr_node_net_density	spice/spice_utils.c	/^float get_rr_node_net_density(t_rr_node node) {$/;"	f
get_rr_node_net_init_value	spice/spice_utils.c	/^int get_rr_node_net_init_value(t_rr_node node) {$/;"	f
get_rr_node_net_probability	spice/spice_utils.c	/^float get_rr_node_net_probability(t_rr_node node) {$/;"	f
get_rr_pin_draw_coords	base/draw.c	/^static void get_rr_pin_draw_coords(int inode, int iside, int ioff, float *xcen,$/;"	f	file:
get_sdc_tok	timing/read_sdc.c	/^static boolean get_sdc_tok(char * buf) {$/;"	f	file:
get_seed_logical_molecule_with_most_ext_inputs	pack/cluster.c	/^static t_pack_molecule* get_seed_logical_molecule_with_most_ext_inputs($/;"	f	file:
get_seg_end	route/rr_graph2.c	/^int get_seg_end(INP t_seg_details * seg_details, INP int itrack, INP int istart,$/;"	f
get_seg_start	route/rr_graph2.c	/^int get_seg_start(INP t_seg_details * seg_details, INP int itrack,$/;"	f
get_seg_track_counts	route/rr_graph2.c	/^get_seg_track_counts(INP int num_sets, INP int num_seg_types,$/;"	f	file:
get_segment_usage_stats	route/segment_stats.c	/^void get_segment_usage_stats(int num_segment, t_segment_inf * segment_inf) {$/;"	f
get_serial_num	route/route_common.c	/^void get_serial_num(void) {$/;"	f
get_simple_switch_block_track	route/rr_graph_sbox.c	/^int get_simple_switch_block_track(INP enum e_side from_side,$/;"	f
get_std_dev	place/place.c	/^static double get_std_dev(int n, double sum_x_squared, double av_x) {$/;"	f	file:
get_switch_info	pack/pack.c	/^float get_switch_info(short switch_index, float &Tdel_switch, float &R_switch, float &Cout_switch) {$/;"	f
get_switch_type	route/rr_graph2.c	/^static void get_switch_type(boolean is_from_sbox, boolean is_to_sbox,$/;"	f	file:
get_timing_driven_expected_cost	route/route_timing.c	/^static float get_timing_driven_expected_cost(int inode, int target_node,$/;"	f	file:
get_tnode_block_and_output_net	timing/path_delay.c	/^void get_tnode_block_and_output_net(int inode, int *iblk_ptr, int *inet_ptr) {$/;"	f
get_tnode_index	timing/path_delay.c	/^static inline int get_tnode_index(t_tnode * node) {$/;"	f	file:
get_top_of_heap_index	util/heapsort.c	/^static int get_top_of_heap_index(int *heap, float *sort_values, int heap_tail,$/;"	f	file:
get_track_num	base/draw.c	/^static int get_track_num(int inode, int **chanx_track, int **chany_track) {$/;"	f	file:
get_track_to_ipins	route/rr_graph2.c	/^int get_track_to_ipins(int seg, int chan, int track,$/;"	f
get_track_to_tracks	route/rr_graph2.c	/^int get_track_to_tracks(INP int from_chan, INP int from_seg, INP int from_track,$/;"	f
get_unidir_opin_connections	route/rr_graph2.c	/^int get_unidir_opin_connections(INP int chan, INP int seg, INP int Fc,$/;"	f
get_unidir_track_to_chan_seg	route/rr_graph2.c	/^static int get_unidir_track_to_chan_seg(INP boolean is_end_sb,$/;"	f	file:
getcolor	base/graphics.c	/^int getcolor (void) { return 0; }$/;"	f
getcolor	base/graphics.c	/^int getcolor() {$/;"	f
gl_state	base/graphics.c	/^static t_gl_state gl_state = {false, SCREEN, 0};$/;"	v	file:
global_clocks	base/ReadOptions.h	/^	boolean global_clocks;$/;"	m	struct:s_options
global_clocks	base/vpr_types.h	/^	boolean global_clocks;$/;"	m	struct:s_packer_opts
global_route_switch	base/vpr_types.h	/^	short global_route_switch;$/;"	m	struct:s_det_routing_arch
gr_automode	base/draw.c	/^static int gr_automode; \/* Need user input after: 0: each t,   *$/;"	v	file:
grid	base/globals.c	/^struct s_grid_tile **grid = NULL; \/* [0..(nx+1)][0..(ny+1)] Physical block list *\/$/;"	v	typeref:struct:s_grid_tile
grid	base/globals_declare.h	/^struct s_grid_tile **grid;$/;"	v	typeref:struct:s_grid_tile
grid_backup	place/timing_place_lookup.c	/^static struct s_grid_tile **grid_backup;$/;"	v	typeref:struct:s_grid_tile	file:
grid_loc_def	../../libarchfpga/include/physical_types.h	/^	struct s_grid_loc_def *grid_loc_def; \/* [0..num_def-1] *\/$/;"	m	struct:s_type_descriptor	typeref:struct:s_type_descriptor::s_grid_loc_def
grid_loc_type	../../libarchfpga/include/physical_types.h	/^	enum e_grid_loc_type grid_loc_type;$/;"	m	struct:s_grid_loc_def	typeref:enum:s_grid_loc_def::e_grid_loc_type
grid_logic_tile_area	../../libarchfpga/include/physical_types.h	/^	float grid_logic_tile_area;$/;"	m	struct:s_arch
grid_logic_tile_area	base/globals.c	/^float grid_logic_tile_area = 0;$/;"	v
group_size	base/vpr_types.h	/^	int group_size;$/;"	m	struct:s_seg_details
group_start	base/vpr_types.h	/^	int group_start;$/;"	m	struct:s_seg_details
hAllObjtestDC	base/graphics.c	/^hObjtestDC, hAllObjtestDC; \/* object test *\/$/;"	v	file:
hBackgroundDC	base/graphics.c	/^static HDC hGraphicsDC, hForegroundDC, hBackgroundDC,$/;"	v	file:
hButtonsWnd	base/graphics.c	/^static HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd;$/;"	v	file:
hCurrentDC	base/graphics.c	/^hCurrentDC, \/* WC : double-buffer *\/$/;"	v	file:
hForegroundDC	base/graphics.c	/^static HDC hGraphicsDC, hForegroundDC, hBackgroundDC,$/;"	v	file:
hGraphicsBrush	base/graphics.c	/^static HBRUSH hGraphicsBrush, hGrayBrush;$/;"	v	file:
hGraphicsDC	base/graphics.c	/^static HDC hGraphicsDC, hForegroundDC, hBackgroundDC,$/;"	v	file:
hGraphicsFont	base/graphics.c	/^static HFONT hGraphicsFont;$/;"	v	file:
hGraphicsPen	base/graphics.c	/^static HPEN hGraphicsPen;$/;"	v	file:
hGraphicsWnd	base/graphics.c	/^static HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd;$/;"	v	file:
hGrayBrush	base/graphics.c	/^static HBRUSH hGraphicsBrush, hGrayBrush;$/;"	v	file:
hMainWnd	base/graphics.c	/^static HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd;$/;"	v	file:
hObjtestDC	base/graphics.c	/^hObjtestDC, hAllObjtestDC; \/* object test *\/$/;"	v	file:
hStatusWnd	base/graphics.c	/^static HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd;$/;"	v	file:
h_ptr	util/hash.h	/^	struct s_hash *h_ptr;$/;"	m	struct:s_hash_iterator	typeref:struct:s_hash_iterator::s_hash
hack_switch_to_rram	base/SetupVPR.c	/^static void hack_switch_to_rram(struct s_det_routing_arch *det_routing_arch) {$/;"	f	file:
has_printhandler_pre_vpr	base/vpr_api.c	/^static boolean has_printhandler_pre_vpr = FALSE;$/;"	v	file:
has_valid_T_arr	timing/path_delay.c	/^static inline boolean has_valid_T_arr(int inode) {$/;"	f	file:
has_valid_T_req	timing/path_delay.c	/^static inline boolean has_valid_T_req(int inode) {$/;"	f	file:
has_valid_normalized_T_arr	timing/path_delay.c	/^boolean has_valid_normalized_T_arr(int inode) {$/;"	f
hash_value	util/hash.c	/^int hash_value(char *name) {$/;"	f
heap	route/route_common.c	/^static struct s_heap **heap; \/* Indexed from [1..heap_size] *\/$/;"	v	typeref:struct:s_heap	file:
heap_ch	route/route_common.c	/^static t_chunk heap_ch = {NULL, 0, NULL};$/;"	v	file:
heap_free_head	route/route_common.c	/^static struct s_heap *heap_free_head = NULL;$/;"	v	typeref:struct:s_heap	file:
heap_size	route/route_common.c	/^static int heap_size; \/* Number of slots in the heap array *\/$/;"	v	file:
heap_tail	route/route_common.c	/^static int heap_tail; \/* Index of first unused slot in the heap array *\/$/;"	v	file:
heapsort	util/heapsort.c	/^void heapsort(int *sort_index, float *sort_values, int nelem, int start_index) {$/;"	f
height	../../libarchfpga/include/physical_types.h	/^	int height;$/;"	m	struct:s_type_descriptor
height	base/graphics.c	/^   int height; $/;"	m	struct:__anon4	file:
highlight_blocks	base/draw.c	/^static void highlight_blocks(float x, float y) {$/;"	f	file:
highlight_crit_path	base/draw.c	/^static void highlight_crit_path(void (*drawscreen_ptr)(void)) {$/;"	f	file:
highlight_nets	base/draw.c	/^static void highlight_nets(char *message) {$/;"	f	file:
highlight_rr_nodes	base/draw.c	/^static void highlight_rr_nodes(float x, float y) {$/;"	f	file:
hill_climbing_flag	base/ReadOptions.h	/^	boolean hill_climbing_flag;$/;"	m	struct:s_options
hill_climbing_flag	base/vpr_types.h	/^	boolean hill_climbing_flag;$/;"	m	struct:s_packer_opts
hillgain	base/vpr_types.h	/^	std::map<int, float> hillgain;$/;"	m	struct:s_pb_stats
hwnd	base/graphics.c	/^   HWND hwnd;$/;"	m	struct:__anon4	file:
i	util/hash.h	/^	int i;$/;"	m	struct:s_hash_iterator
i_ds	power/power.h	/^	float i_ds;$/;"	m	struct:s_power_nmos_leakage_pair
iblock	base/vpr_types.h	/^	int iblock;$/;"	m	struct:s_trace
idle_mode_name	../../libarchfpga/include/physical_types.h	/^    char* idle_mode_name;$/;"	m	struct:s_pb_type
ilines	base/read_blif.c	/^static int ilines, olines, model_lines, endlines;$/;"	v	file:
in_dens	power/power.h	/^	float * in_dens; \/* Switching density of inputs *\/$/;"	m	struct:s_rr_node_power
in_flight	base/vpr_types.h	/^	t_cluster_placement_primitive *in_flight; \/* ptrs to primitives currently being considered *\/$/;"	m	struct:s_cluster_placement_stats
in_prob	power/power.h	/^	float * in_prob; \/* Static probability of inputs *\/$/;"	m	struct:s_rr_node_power
include_dir	base/vpr_types.h	/^  char* include_dir;$/;"	m	struct:s_spice_opts
include_netlist	../../libarchfpga/include/spice_types.h	/^  t_spice_model_netlist* include_netlist;$/;"	m	struct:s_spice_model
include_netlists	../../libarchfpga/include/spice_types.h	/^  t_spice_model_netlist* include_netlists; $/;"	m	struct:s_spice
included	../../libarchfpga/include/spice_types.h	/^  int included;$/;"	m	struct:s_spice_model_netlist
incremental_cost	../../libarchfpga/include/cad_types.h	/^	float incremental_cost; \/* cost dependant on current status of packing *\/$/;"	m	struct:s_cluster_placement_primitive
index	../../libarchfpga/include/cad_types.h	/^	int index; \/* array index  for pattern*\/$/;"	m	struct:s_pack_patterns
index	../../libarchfpga/include/logic_types.h	/^	int index; \/* indexing for array look-up *\/$/;"	m	struct:s_model_ports
index	../../libarchfpga/include/logic_types.h	/^	int index;$/;"	m	struct:s_model
index	../../libarchfpga/include/physical_types.h	/^	int index; \/* index of type descriptor in array (allows for index referencing) *\/$/;"	m	struct:s_type_descriptor
index	../../libarchfpga/include/physical_types.h	/^	int index;$/;"	m	struct:s_mode
index	../../libarchfpga/include/physical_types.h	/^	int index;$/;"	m	struct:s_port
index	base/vpr_types.h	/^	int index; \/* Index in array that this block can be found *\/$/;"	m	struct:s_logical_block
index	base/vpr_types.h	/^	int index;$/;"	m	struct:s_seg_details
index	base/vpr_types.h	/^	int index;$/;"	m	struct:s_trace
index	route/route_common.h	/^	int index;$/;"	m	struct:s_heap
index	util/hash.h	/^	int index;$/;"	m	struct:s_hash
infer_annotations	../../libarchfpga/include/physical_types.h	/^	boolean infer_annotations;$/;"	m	struct:s_interconnect
infer_pattern	../../libarchfpga/include/physical_types.h	/^	boolean infer_pattern; \/*If TRUE, infer pattern based on patterns connected to it*\/$/;"	m	struct:s_pb_graph_edge
init_arch_mrfpga	../../libarchfpga/read_xml_mrfpga.c	/^void init_arch_mrfpga(t_arch_mrfpga* arch_mrfpga) {$/;"	f
init_buffer_inf	../../libarchfpga/read_xml_mrfpga.c	/^void init_buffer_inf(t_buffer_inf* buffer_inf) {$/;"	f
init_chan	base/place_and_route.c	/^void init_chan(int cfactor, t_chan_width_dist chan_width_dist) {$/;"	f
init_chan_seg_detail_params	route/rr_graph_swseg.c	/^static int init_chan_seg_detail_params(INP char* chan_type,$/;"	f	file:
init_check_arch_spice_models	spice/spice_api.c	/^void init_check_arch_spice_models(t_arch* arch,$/;"	f
init_draw_coords	base/draw.c	/^void init_draw_coords(float width_val) {$/;"	f
init_graphics	base/graphics.c	/^init_graphics (const char *window_name, int cindex) $/;"	f
init_graphics	base/graphics.c	/^void init_graphics (const char *window_name, int cindex) { }$/;"	f
init_include_user_defined_netlists	spice/spice_netlist_utils.c	/^void init_include_user_defined_netlists(t_spice spice) {$/;"	f
init_list_include_netlists	spice/spice_api.c	/^void init_list_include_netlists(t_spice* spice) { $/;"	f
init_logical_block_spice_model_temp_used	spice/spice_netlist_utils.c	/^void init_logical_block_spice_model_temp_used(t_spice_model* spice_model) {$/;"	f
init_logical_block_spice_model_type_temp_used	spice/spice_netlist_utils.c	/^void init_logical_block_spice_model_type_temp_used(int num_spice_models, t_spice_model* spice_model,$/;"	f
init_memristor_inf	../../libarchfpga/read_xml_mrfpga.c	/^void init_memristor_inf(t_memristor_inf* memristor_inf) {$/;"	f
init_mux_arch_default	power/power_util.c	/^static void init_mux_arch_default(t_mux_arch * mux_arch, int levels,$/;"	f	file:
init_parse	base/read_blif.c	/^static void init_parse(int doall) {$/;"	f	file:
init_postscript	base/graphics.c	/^int init_postscript (const char *fname) $/;"	f
init_postscript	base/graphics.c	/^int init_postscript (const char *fname) { $/;"	f
init_route_structs	route/route_common.c	/^void init_route_structs(int bb_factor) {$/;"	f
init_route_tree_to_source	route/route_tree_timing.c	/^init_route_tree_to_source(int inet) {$/;"	f
init_spice_dff_testbench_globals	spice/spice_dff_testbench.c	/^static void init_spice_dff_testbench_globals() {$/;"	f	file:
init_spice_grid_testbench_globals	spice/spice_grid_testbench.c	/^void init_spice_grid_testbench_globals() {$/;"	f	file:
init_spice_lut_testbench_globals	spice/spice_lut_testbench.c	/^void init_spice_lut_testbench_globals() {$/;"	f	file:
init_spice_mux_arch	spice/spice_mux.c	/^void init_spice_mux_arch(t_spice_mux_arch* spice_mux_arch,$/;"	f
init_spice_mux_testbench_globals	spice/spice_mux_testbench.c	/^static void init_spice_mux_testbench_globals(t_spice spice) {$/;"	f	file:
init_spice_net_info	spice/spice_utils.c	/^void init_spice_net_info(t_spice_net_info* spice_net_info) {$/;"	f
init_t	base/vpr_types.h	/^	float init_t;$/;"	m	struct:s_annealing_sched
init_val	../../libarchfpga/include/spice_types.h	/^  int init_val;$/;"	m	struct:s_spice_net_info
init_val	base/vpr_types.h	/^    int init_val;$/;"	m	struct:s_logical_block
init_world	base/graphics.c	/^init_world (float x1, float y1, float x2, float y2) $/;"	f
init_world	base/graphics.c	/^void init_world (float xl, float yt, float xr, float yb) { }$/;"	f
initial_placement	place/place.c	/^static void initial_placement(enum e_pad_loc_type pad_loc_type,$/;"	f	file:
initial_placement_blocks	place/place.c	/^static void initial_placement_blocks(int * free_locations, enum e_pad_loc_type pad_loc_type) {$/;"	f	file:
initial_placement_pl_macros	place/place.c	/^static void initial_placement_pl_macros(int macros_max_num_tries, int * free_locations) {$/;"	f	file:
initial_pres_fac	base/ReadOptions.h	/^	float initial_pres_fac;$/;"	m	struct:s_options
initial_pres_fac	base/vpr_types.h	/^	float initial_pres_fac;$/;"	m	struct:s_router_opts
initialized	base/graphics.c	/^   bool initialized;$/;"	m	struct:__anon5	file:
inner_loop_recompute_divider	base/ReadOptions.h	/^	int inner_loop_recompute_divider;$/;"	m	struct:s_options
inner_loop_recompute_divider	base/vpr_types.h	/^	int inner_loop_recompute_divider;$/;"	m	struct:s_placer_opts
inner_num	base/vpr_types.h	/^	float inner_num;$/;"	m	struct:s_annealing_sched
inode	route/route_tree_timing.h	/^	int inode;$/;"	m	struct:s_rt_node
inode	timing/net_delay_types.h	/^	int inode;$/;"	m	struct:s_rc_node
inode_head	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	m	struct:s_buffer_plan	file:
inport_link_pin	../../libarchfpga/include/cad_types.h	/^	int inport_link_pin; \/* applicable pin of chain input port *\/$/;"	m	struct:s_model_chain_pattern
input_buffer	../../libarchfpga/include/spice_types.h	/^  t_spice_model_buffer* input_buffer;$/;"	m	struct:s_spice_model
input_edges	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_edge** input_edges; \/* [0..num_input_edges] *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_edge
input_level	../../libarchfpga/include/spice_types.h	/^  int* input_level;  \/* [0...num_input] *\/$/;"	m	struct:s_spice_mux_arch
input_link_port	../../libarchfpga/include/cad_types.h	/^	t_model_ports *input_link_port; \/* pointer to port of chain input *\/$/;"	m	struct:s_model_chain_pattern
input_net_tnodes	base/vpr_types.h	/^	struct s_tnode ***input_net_tnodes; \/* [0..num_input_ports-1][0..num_pins -1] correspnding input net tnode *\/$/;"	m	struct:s_logical_block	typeref:struct:s_logical_block::s_tnode
input_nets	base/vpr_types.h	/^	int **input_nets; \/* [0..num_input_ports-1][0..num_port_pins-1] List of input nets connected to this logical_block. *\/$/;"	m	struct:s_logical_block
input_offset	../../libarchfpga/include/spice_types.h	/^  int* input_offset; \/* [0...num_input] *\/ $/;"	m	struct:s_spice_mux_arch
input_pin_class_size	../../libarchfpga/include/physical_types.h	/^	int *input_pin_class_size; \/* Stores the number of pins that belong to a particular input pin class *\/$/;"	m	struct:s_pb_graph_node
input_pins	../../libarchfpga/include/physical_types.h	/^	char * input_pins;$/;"	m	struct:s_pin_to_pin_annotation
input_pins	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_pin *** input_pins; \/\/ [0..num_input_ports-1][0..num_pins_per_port-1]$/;"	m	struct:s_interconnect_pins	typeref:struct:s_interconnect_pins::s_pb_graph_pin
input_pins	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin **input_pins; \/* [0..num_input_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:s_pb_graph_node
input_pins	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin **input_pins;$/;"	m	struct:s_pb_graph_edge
input_pins_used	base/vpr_types.h	/^	int **input_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of input pins of this class that are used *\/$/;"	m	struct:s_pb_stats
input_slew_pct_fall	../../libarchfpga/include/spice_types.h	/^  float input_slew_pct_fall;  $/;"	m	struct:s_spice_stimulate_params
input_slew_pct_rise	../../libarchfpga/include/spice_types.h	/^  float input_slew_pct_rise;  $/;"	m	struct:s_spice_stimulate_params
input_string	../../libarchfpga/include/physical_types.h	/^	char *input_string;$/;"	m	struct:s_interconnect
input_thres_pct_fall	../../libarchfpga/include/spice_types.h	/^  float input_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
input_thres_pct_rise	../../libarchfpga/include/spice_types.h	/^  float input_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
inputs	../../libarchfpga/include/logic_types.h	/^	t_model_ports *inputs; \/* linked list of input\/clock ports *\/$/;"	m	struct:s_model
inputs_per_cluster	base/ReadOptions.h	/^	int inputs_per_cluster;$/;"	m	struct:s_options
insert_buffer	mrfpga/buffer_insertion.c	/^static t_buffer_plan_list insert_buffer( t_buffer_plan_list list, int inode, float C, float R, float Tdel, int num_pins )$/;"	f	file:
insert_buffer_plan_to_list	mrfpga/buffer_insertion.c	/^static t_buffer_plan_list insert_buffer_plan_to_list( t_buffer_plan plan, t_buffer_plan_list list ) {$/;"	f	file:
insert_in_edge_list	route/rr_graph_util.c	/^insert_in_edge_list(INP t_linked_edge * head, INP int edge, INP short iswitch) {$/;"	f
insert_in_hash_table	util/hash.c	/^insert_in_hash_table(struct s_hash **hash_table, char *name,$/;"	f
insert_in_int_list	../../libarchfpga/util.c	/^insert_in_int_list(t_linked_int * head, int data,$/;"	f
insert_in_int_list2	mrfpga/mrfpga_util.c	/^t_linked_int* insert_in_int_list2 (t_linked_int *head, int data )$/;"	f
insert_in_vptr_list	../../libarchfpga/util.c	/^insert_in_vptr_list(struct s_linked_vptr *head, void *vptr_to_add) {$/;"	f
insert_llist_node	spice/linkedlist.c	/^t_llist* insert_llist_node(t_llist* cur) {$/;"	f
insert_switch_to_buffer_list	mrfpga/buffer_insertion.c	/^static void insert_switch_to_buffer_list( t_buffer_plan_list list, struct s_switch_inf switch_inf_local)$/;"	f	file:
insert_switch_to_buffer_plan	mrfpga/buffer_insertion.c	/^static t_buffer_plan insert_switch_to_buffer_plan( t_buffer_plan plan, struct s_switch_inf switch_inf_local)$/;"	f	file:
insert_to_linked_list	base/verilog_writer.c	/^pb_list *insert_to_linked_list(t_pb *pb_new , pb_list *list)$/;"	f
insert_to_linked_list_conn	base/verilog_writer.c	/^conn_list *insert_to_linked_list_conn(t_pb *driver_new , t_pb *load_new , t_pb_graph_pin *driver_pin_ , t_pb_graph_pin *load_pin_ , float path_delay , conn_list *list)$/;"	f
insert_wire_to_buffer_list	mrfpga/buffer_insertion.c	/^static void insert_wire_to_buffer_list( t_buffer_plan_list list, float C,float R )$/;"	f	file:
insert_wire_to_buffer_plan	mrfpga/buffer_insertion.c	/^static t_buffer_plan insert_wire_to_buffer_plan( t_buffer_plan plan, float C, float R )$/;"	f	file:
instances	../../libarchfpga/include/logic_types.h	/^	void *instances;$/;"	m	struct:s_model
instantiate_SDF_header	base/verilog_writer.c	/^void instantiate_SDF_header(FILE *SDF)$/;"	f
instantiate_input_interconnect	base/verilog_writer.c	/^void instantiate_input_interconnect(FILE *verilog , FILE *SDF , char *clock_name)$/;"	f
instantiate_interconnect	base/verilog_writer.c	/^void instantiate_interconnect(FILE *verilog , int block_num , t_pb *pb , FILE *SDF)$/;"	f
instantiate_primitive_modules	base/verilog_writer.c	/^void instantiate_primitive_modules(FILE *fp, char *clock_name , FILE *SDF)$/;"	f
instantiate_top_level_module	base/verilog_writer.c	/^void instantiate_top_level_module(FILE *verilog)$/;"	f
instantiate_wires	base/verilog_writer.c	/^void instantiate_wires(FILE *verilog)$/;"	f
int_2_binary_str	power/power_util.c	/^static void int_2_binary_str(char * binary_str, int value, int str_length) {$/;"	f	file:
inter_cluster_net_delay	base/ReadOptions.h	/^	float inter_cluster_net_delay;$/;"	m	struct:s_options
inter_cluster_net_delay	base/vpr_types.h	/^	float inter_cluster_net_delay;$/;"	m	struct:s_packer_opts
interconnect	../../libarchfpga/include/physical_types.h	/^	t_interconnect * interconnect;$/;"	m	struct:s_interconnect_pins
interconnect	../../libarchfpga/include/physical_types.h	/^	t_interconnect * interconnect;$/;"	m	struct:s_pb_graph_edge
interconnect	../../libarchfpga/include/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:s_mode
interconnect_pins	../../libarchfpga/include/physical_types.h	/^	t_interconnect_pins ** interconnect_pins; \/* [0..num_modes-1][0..num_interconnect_in_mode] *\/$/;"	m	struct:s_pb_graph_node
interconnect_power	../../libarchfpga/include/physical_types.h	/^	t_interconnect_power * interconnect_power;$/;"	m	struct:s_interconnect
interconnect_printing	base/verilog_writer.c	/^void interconnect_printing(FILE *fp , conn_list *downhill)$/;"	f
interconnect_type_name	power/power_util.c	/^char * interconnect_type_name(enum e_interconnect type) {$/;"	f
intra_cluster_net_delay	base/ReadOptions.h	/^	float intra_cluster_net_delay;$/;"	m	struct:s_options
intra_cluster_net_delay	base/vpr_types.h	/^	float intra_cluster_net_delay;$/;"	m	struct:s_packer_opts
inv_capacity	base/vpr_types.h	/^	float inv_capacity;$/;"	m	struct:s_place_region
inv_length	base/vpr_types.h	/^	float inv_length;$/;"	m	struct:s_rr_indexed_data
invalid	base/vpr_types.h	/^	t_cluster_placement_primitive *invalid; \/* ptrs to primitives that are invalid *\/$/;"	m	struct:s_cluster_placement_stats
invalidate_heap_entries	route/route_common.c	/^void invalidate_heap_entries(int sink_node, int ipin_node) {$/;"	f
invalidate_screen	base/graphics.c	/^static void invalidate_screen(void)$/;"	f	file:
io_line	base/read_blif.c	/^static void io_line(int in_or_out, int doall, t_model *io_model) {$/;"	f	file:
ipin_mux_trans_size	../../libarchfpga/include/physical_types.h	/^	float ipin_mux_trans_size;$/;"	m	struct:s_arch
ipin_mux_trans_size	base/globals.c	/^float ipin_mux_trans_size = 0;$/;"	v
ipow	../../libarchfpga/util.c	/^int ipow(int base, int exp) {$/;"	f
isEchoFileEnabled	base/ReadOptions.c	/^boolean isEchoFileEnabled(enum e_echo_files echo_option) {$/;"	f
isFixed	base/vpr_types.h	/^	boolean isFixed;$/;"	m	struct:s_block
is_Fc_frac	../../libarchfpga/include/physical_types.h	/^	boolean *is_Fc_frac; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
is_Fc_full_flex	../../libarchfpga/include/physical_types.h	/^	boolean *is_Fc_full_flex; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
is_accurate	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_accurate;$/;"	m	struct:s_arch_mrfpga
is_any_but	timing/slre.c	/^static int is_any_but(const unsigned char *p, int len, const char *s,$/;"	f	file:
is_any_of	timing/slre.c	/^static int is_any_of(const unsigned char *p, int len, const char *s, int *ofs) {$/;"	f	file:
is_block_optional	../../libarchfpga/include/cad_types.h	/^	boolean *is_block_optional; \/* [0..num_blocks-1] is the block_id in this pattern mandatory or optional to form a molecule *\/$/;"	m	struct:s_pack_patterns
is_cbox	route/rr_graph2.c	/^boolean is_cbox(INP int chan, INP int seg, INP int track,$/;"	f
is_chain	../../libarchfpga/include/cad_types.h	/^	boolean is_chain; \/* Does this pattern chain across logic blocks *\/$/;"	m	struct:s_pack_patterns
is_clock	../../libarchfpga/include/logic_types.h	/^	boolean is_clock; \/* clock? *\/$/;"	m	struct:s_model_ports
is_clock	../../libarchfpga/include/physical_types.h	/^	boolean is_clock;$/;"	m	struct:s_port
is_const_gen	base/vpr_types.h	/^	boolean is_const_gen;$/;"	m	struct:s_net
is_default	../../libarchfpga/include/spice_types.h	/^  int is_default;$/;"	m	struct:s_spice_model
is_done_callibration	power/PowerSpicedComponent.c	/^bool PowerSpicedComponent::is_done_callibration(void) {$/;"	f	class:PowerSpicedComponent
is_empty_heap	route/route_common.c	/^boolean is_empty_heap(void) {$/;"	f
is_forced_connection	../../libarchfpga/include/physical_types.h	/^	boolean is_forced_connection; \/* This output pin connects to one and only one input pin *\/$/;"	m	struct:s_pb_graph_pin
is_forced_connection	pack/cluster_feasibility_filter.c	/^static boolean is_forced_connection(INP t_pb_graph_pin *pb_graph_pin) {$/;"	f	file:
is_global	base/globals_declare.h	/^boolean *is_global;$/;"	v
is_global	base/vpr_types.h	/^	boolean is_global;$/;"	m	struct:s_net
is_global_pin	../../libarchfpga/include/physical_types.h	/^	boolean *is_global_pin; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
is_isolation	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_isolation;$/;"	m	struct:s_arch_mrfpga
is_isolation	mrfpga/mrfpga_globals.c	/^boolean is_isolation = FALSE;$/;"	v
is_junction	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_junction;$/;"	m	struct:s_arch_mrfpga
is_junction	mrfpga/mrfpga_globals.c	/^boolean is_junction = FALSE;$/;"	v
is_logical_blk_in_pb	pack/cluster.c	/^static boolean is_logical_blk_in_pb(int iblk, t_pb *pb) {$/;"	f	file:
is_mrFPGA	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_mrFPGA;$/;"	m	struct:s_arch_mrfpga
is_mrFPGA	mrfpga/mrfpga_globals.c	/^boolean is_mrFPGA = FALSE;$/;"	v
is_net_in_cluster	pack/cluster_legality.c	/^static boolean is_net_in_cluster(INP int inet) {$/;"	f	file:
is_netlist_clock	base/vpr_types.h	/^	boolean is_netlist_clock; \/* Is this a netlist or virtual (external) clock? *\/$/;"	m	struct:s_clock
is_non_clock_global	../../libarchfpga/include/logic_types.h	/^	boolean is_non_clock_global; \/* not a clock but is a special, global, control signal (eg global asynchronous reset, etc) *\/$/;"	m	struct:s_model_ports
is_non_clock_global	../../libarchfpga/include/physical_types.h	/^	boolean is_non_clock_global;$/;"	m	struct:s_port
is_number	timing/read_sdc.c	/^static boolean is_number(char * ptr) {$/;"	f	file:
is_opin	util/vpr_utils.c	/^boolean is_opin(int ipin, t_type_ptr type) {$/;"	f
is_opin_cblock_defined	../../libarchfpga/include/arch_types_mrfpga.h	/^  int is_opin_cblock_defined;$/;"	m	struct:s_arch_mrfpga
is_pin_open	pack/cluster_legality.c	/^boolean is_pin_open(int i) {$/;"	f
is_sbox	route/rr_graph2.c	/^boolean is_sbox(INP int chan, INP int wire_seg, INP int sb_seg, INP int track,$/;"	f
is_show_pass_trans	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_show_pass_trans;$/;"	m	struct:s_arch_mrfpga
is_show_pass_trans	mrfpga/mrfpga_globals.c	/^boolean is_show_sram = FALSE, is_show_pass_trans = FALSE;$/;"	v
is_show_sram	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_show_sram;$/;"	m	struct:s_arch_mrfpga
is_show_sram	mrfpga/mrfpga_globals.c	/^boolean is_show_sram = FALSE, is_show_pass_trans = FALSE;$/;"	v
is_stack	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_stack;$/;"	m	struct:s_arch_mrfpga
is_stack	mrfpga/mrfpga_globals.c	/^boolean is_stack = FALSE;$/;"	v
is_swap2pins_match_prefer_side	clb_pin_remap/clb_pin_remap_util.c	/^int is_swap2pins_match_prefer_side(int pin0_cur_side, int* pin0_prefer_side,$/;"	f
is_type_pin_in_class	clb_pin_remap/clb_pin_remap_util.c	/^int is_type_pin_in_class(t_type_ptr type,$/;"	f
is_wire_buffer	../../libarchfpga/include/arch_types_mrfpga.h	/^  boolean is_wire_buffer;$/;"	m	struct:s_arch_mrfpga
is_wire_buffer	mrfpga/mrfpga_globals.c	/^boolean is_wire_buffer = FALSE;$/;"	v
ispressed	base/graphics.c	/^   bool ispressed;$/;"	m	struct:__anon4	file:
iswitch	base/vpr_types.h	/^	short iswitch;$/;"	m	struct:s_trace
iswitch	route/route_tree_timing.h	/^	short iswitch;$/;"	m	struct:s_linked_rt_edge
iswitch	route/rr_graph_util.h	/^	short iswitch;$/;"	m	struct:s_linked_edge
iswitch	timing/net_delay_types.h	/^	short iswitch;$/;"	m	struct:s_linked_rc_edge
join_left_plan_list_into_whole	mrfpga/buffer_insertion.c	/^static t_buffer_plan_list join_left_plan_list_into_whole( t_buffer_plan_list left, t_buffer_plan_list* whole, int num_whole, t_buffer_plan_list current, int num_pins )$/;"	f	file:
keypress_ptr	base/graphics.c	/^static void (*keypress_ptr)(char entered_char);$/;"	v	file:
label_incoming_wires	route/rr_graph2.c	/^label_incoming_wires(INP int chan_num, INP int seg_num, INP int sb_seg,$/;"	f	file:
label_wire_muxes	route/rr_graph2.c	/^label_wire_muxes(INP int chan_num, INP int seg_num,$/;"	f	file:
label_wire_muxes_for_balance	route/rr_graph2.c	/^label_wire_muxes_for_balance(INP int chan_num, INP int seg_num,$/;"	f	file:
leakage	../../libarchfpga/include/physical_types.h	/^	float leakage;$/;"	m	struct:s_power_usage
leakage_default_mode	../../libarchfpga/include/physical_types.h	/^	int leakage_default_mode; \/* Default mode for leakage analysis, if block has no set mode *\/$/;"	m	struct:s_pb_type_power
leakage_gate	power/power.h	/^	float leakage_gate;$/;"	m	struct:s_transistor_size_inf
leakage_pairs	power/power.h	/^	t_power_nmos_leakage_pair * leakage_pairs;$/;"	m	struct:s_power_nmos_leakage_inf
leakage_subthreshold	power/power.h	/^	float leakage_subthreshold;$/;"	m	struct:s_transistor_size_inf
least_slack	base/vpr_types.h	/^	float ** least_slack;$/;"	m	struct:s_timing_stats
legal_pos	place/place.c	/^static t_legal_pos **legal_pos = NULL; \/* [0..num_types-1][0..type_tsize - 1] *\/$/;"	v	file:
len	../../libarchfpga/include/ezxml.h	/^	size_t len; \/* length of allocated memory for mmap, -1 for malloc *\/$/;"	m	struct:ezxml_root
len	timing/slre.c	/^  int len;          \/\/ Substring length$/;"	m	struct:cap	file:
length	../../libarchfpga/include/physical_types.h	/^	int length;$/;"	m	struct:s_segment_inf
length	base/vpr_types.h	/^	int length;$/;"	m	struct:s_seg_details
level	../../libarchfpga/include/spice_types.h	/^  int level;$/;"	m	struct:s_spice_model_wire_param
level	power/power.h	/^	int level; \/* Level in the full multilevel mux - 0 = primary inputs to mux *\/$/;"	m	struct:s_mux_node
level_restorer	power/power.h	/^	boolean level_restorer; \/* Whether the output of this mux is level restored *\/$/;"	m	struct:s_mux_node
levels	power/power.h	/^	int levels;$/;"	m	struct:s_mux_arch
library_models	base/vpr_types.h	/^	t_model * library_models; \/* blif models in VPR *\/$/;"	m	struct:s_vpr_setup
limit_value	../../libarchfpga/util.c	/^int limit_value(int cur, int max, const char *name) {$/;"	f
line	../../libarchfpga/include/ezxml.h	/^	int line;$/;"	m	struct:ezxml
line	../../libarchfpga/include/physical_types.h	/^	int line;$/;"	m	struct:s_direct_inf
line_fuz	base/draw.c	/^static float line_fuz = 0.3;$/;"	v	file:
line_num	../../libarchfpga/include/physical_types.h	/^	int line_num; \/* Interconnect is processed later, need to know what line number it messed up on to give proper error message *\/$/;"	m	struct:s_interconnect
line_num	../../libarchfpga/include/physical_types.h	/^	int line_num; \/* used to report what line number this annotation is found in architecture file *\/$/;"	m	struct:s_pin_to_pin_annotation
line_types	base/easygl_constants.h	/^enum line_types {SOLID, DASHED};$/;"	g
linked_f_pointer_ch	route/route_common.c	/^static t_chunk linked_f_pointer_ch = {NULL, 0, NULL};$/;"	v	file:
linked_f_pointer_free_head	route/route_common.c	/^static struct s_linked_f_pointer *linked_f_pointer_free_head = NULL;$/;"	v	typeref:struct:s_linked_f_pointer	file:
list	../../libarchfpga/include/util.h	/^	int *list;$/;"	m	struct:s_ivec
list_of_connectable_input_pin_ptrs	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_pin ***list_of_connectable_input_pin_ptrs; \/* [0..depth-1][0..num_connectable_primtive_input_pins-1] what input pins this output can connect to without exiting cluster at given depth *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_pin
load_best_buffer_list	mrfpga/buffer_insertion.c	/^void load_best_buffer_list( )$/;"	f
load_chan_rr_indices	route/rr_graph2.c	/^static void load_chan_rr_indices(INP int nodes_per_chan, INP int chan_len,$/;"	f	file:
load_channel_occupancies	base/stats.c	/^static void load_channel_occupancies(int **chanx_occ, int **chany_occ) {$/;"	f	file:
load_clock_domain_and_clock_and_io_delay	timing/path_delay.c	/^static void load_clock_domain_and_clock_and_io_delay(boolean is_prepacked) {$/;"	f	file:
load_cluster_placement_stats_for_pb_graph_node	pack/cluster_placement.c	/^static void load_cluster_placement_stats_for_pb_graph_node($/;"	f	file:
load_constant_net_delay	timing/net_delay.c	/^void load_constant_net_delay(float **net_delay, float delay_value,$/;"	f
load_critical_path_annotations	pack/pb_type_graph_annotations.c	/^static void load_critical_path_annotations(INP int line_num, $/;"	f	file:
load_criticalities	place/timing_place.c	/^void load_criticalities(t_slack * slacks, float crit_exponent) {$/;"	f
load_default_models	base/read_blif.c	/^static void load_default_models(INP t_model *library_models,$/;"	f	file:
load_expected_remapped_net_delay	clb_pin_remap/post_place_timing.c	/^void load_expected_remapped_net_delay(float** net_delay,                                       $/;"	f
load_external_nets_and_cb	base/read_netlist.c	/^static void load_external_nets_and_cb(INP int L_num_blocks,$/;"	f	file:
load_font	base/graphics.c	/^load_font(int pointsize) $/;"	f	file:
load_internal_cb_nets	base/read_netlist.c	/^static void load_internal_cb_nets(INOUTP t_pb *top_level,$/;"	f	file:
load_internal_cb_rr_graph_net_nums	base/read_netlist.c	/^static void load_internal_cb_rr_graph_net_nums(INP t_rr_node * cur_rr_node,$/;"	f	file:
load_legal_placements	place/place.c	/^static void load_legal_placements() {$/;"	f	file:
load_list_of_connectable_input_pin_ptrs	pack/cluster_feasibility_filter.c	/^static void load_list_of_connectable_input_pin_ptrs($/;"	f	file:
load_net_delay_from_routing	timing/net_delay.c	/^void load_net_delay_from_routing(float **net_delay, struct s_net *nets,$/;"	f
load_net_rr_terminals	route/rr_graph.c	/^void load_net_rr_terminals(t_ivec *** L_rr_node_indices) {$/;"	f
load_new_path_R_upstream	route/route_tree_timing.c	/^static void load_new_path_R_upstream(t_rt_node * start_of_new_path_rt_node) {$/;"	f	file:
load_one_constant_net_delay	timing/net_delay.c	/^void load_one_constant_net_delay(float **net_delay, int inet,$/;"	f
load_one_net_delay	timing/net_delay.c	/^void load_one_net_delay(float **net_delay, int inet, struct s_net* nets,$/;"	f
load_pack_pattern_annotations	pack/pb_type_graph_annotations.c	/^static void load_pack_pattern_annotations(INP int line_num, INOUTP t_pb_graph_node *pb_graph_node,$/;"	f	file:
load_pb	base/verilog_writer.h	/^  t_pb *load_pb;$/;"	m	struct:found_connectivity
load_pb_graph_pin_to_pin_annotations	pack/pb_type_graph_annotations.c	/^void load_pb_graph_pin_to_pin_annotations(INOUTP t_pb_graph_node *pb_graph_node) {$/;"	f
load_perturbed_switch_pattern	route/rr_graph.c	/^static void load_perturbed_switch_pattern(INP t_type_ptr type,$/;"	f	file:
load_pin	base/verilog_writer.h	/^  t_pb_graph_pin *load_pin;$/;"	m	struct:found_connectivity
load_pin_class_by_depth	pack/cluster_feasibility_filter.c	/^static void load_pin_class_by_depth(INOUTP t_pb_graph_node *pb_graph_node,$/;"	f	file:
load_pin_classes_in_pb_graph_head	pack/cluster_feasibility_filter.c	/^void load_pin_classes_in_pb_graph_head(INOUTP t_pb_graph_node *pb_graph_node) {$/;"	f
load_post_place_net_delay	clb_pin_remap/post_place_timing.c	/^void load_post_place_net_delay(float** net_delay,$/;"	f
load_rc_tree_C	timing/net_delay.c	/^float load_rc_tree_C(t_rc_node * rc_node) {$/;"	f
load_rc_tree_Ctotal	mrfpga/cal_capacitance.c	/^static float load_rc_tree_Ctotal (t_rc_node *rc_node) {$/;"	f	file:
load_rc_tree_T	timing/net_delay.c	/^void load_rc_tree_T(t_rc_node * rc_node, float T_arrival) {$/;"	f
load_route_bb	route/route_common.c	/^static void load_route_bb(int bb_factor) {$/;"	f	file:
load_rr_indexed_data_T_values	route/rr_graph_indexed_data.c	/^static void load_rr_indexed_data_T_values(int index_start,$/;"	f	file:
load_rr_indexed_data_base_costs	route/rr_graph_indexed_data.c	/^static void load_rr_indexed_data_base_costs(int nodes_per_chan,$/;"	f	file:
load_rt_subtree_Tdel	route/route_tree_timing.c	/^static void load_rt_subtree_Tdel(t_rt_node * subtree_rt_root, float Tarrival) {$/;"	f	file:
load_sblock_pattern_lookup	route/rr_graph2.c	/^void load_sblock_pattern_lookup(INP int i, INP int j, INP int nodes_per_chan,$/;"	f
load_simplified_device	place/timing_place_lookup.c	/^static void load_simplified_device(void) {$/;"	f	file:
load_timing_graph_net_delays	timing/path_delay.c	/^void load_timing_graph_net_delays(float **net_delay) {$/;"	f
load_tnode	timing/path_delay.c	/^static void load_tnode(INP t_pb_graph_pin *pb_graph_pin, INP int iblock,$/;"	f	file:
load_truth_table	base/verilog_writer.c	/^char *load_truth_table(int inputs , t_pb *pb)$/;"	f
load_uniform_switch_pattern	route/rr_graph.c	/^static void load_uniform_switch_pattern(INP t_type_ptr type,$/;"	f	file:
local_cross_count	clb_pin_remap/post_place_timing.c	/^static const float local_cross_count[50] = { \/* [0..49] *\/1.0, 1.0, 1.0, 1.0828, 1.1536, 1.2206, 1.2823, 1.3385, 1.3991, 1.4493, 1.4974,$/;"	v	file:
local_interc_factor	../../libarchfpga/include/physical_types.h	/^	float local_interc_factor;$/;"	m	struct:s_power_arch
local_nets	base/vpr_types.h	/^	struct s_net *local_nets; \/* Records post-packing connections, valid only for top-level *\/$/;"	m	struct:s_pb	typeref:struct:s_pb::s_net
log_msg	power/power_util.c	/^static void log_msg(t_log * log_ptr, char * msg) {$/;"	f	file:
logic_block_spice_file_name	spice/spice_globals.c	/^char* logic_block_spice_file_name = "logic_blocks.sp";$/;"	v
logical_block	base/globals.c	/^struct s_logical_block *logical_block = NULL;$/;"	v	typeref:struct:s_logical_block
logical_block	base/vpr_types.h	/^	int logical_block; \/* If this is a terminating pb, gives the logical (netlist) block that it contains *\/$/;"	m	struct:s_pb
logical_block_input_count	base/read_blif.c	/^static int *logical_block_input_count, *logical_block_output_count;$/;"	v	file:
logical_block_output_count	base/read_blif.c	/^static int *logical_block_input_count, *logical_block_output_count;$/;"	v	file:
logical_block_ptrs	base/vpr_types.h	/^	t_logical_block **logical_block_ptrs; \/* [0..num_blocks-1] ptrs to logical blocks that implements this molecule, index on pack_pattern_block->index of pack pattern *\/$/;"	m	struct:s_pack_molecule
logical_block_types	base/vpr_types.h	/^enum logical_block_types {$/;"	g
logical_effort_factor	../../libarchfpga/include/physical_types.h	/^	float logical_effort_factor;$/;"	m	struct:s_power_arch
logs	power/power.h	/^	t_log * logs;$/;"	m	struct:s_power_output
long_trans_inf	power/power.h	/^	t_transistor_size_inf * long_trans_inf; \/* Long transistor (W=1,L=2) *\/$/;"	m	struct:s_transistor_inf
longline	../../libarchfpga/include/physical_types.h	/^	boolean longline;$/;"	m	struct:s_segment_inf
longline	base/vpr_types.h	/^	boolean longline;$/;"	m	struct:s_seg_details
lookahead_input_pins_used	base/vpr_types.h	/^	int **lookahead_input_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of input pins of this class that are speculatively used *\/$/;"	m	struct:s_pb_stats
lookahead_output_pins_used	base/vpr_types.h	/^	int **lookahead_output_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of output pins of this class that are speculatively used *\/$/;"	m	struct:s_pb_stats
lookup_dump	place/timing_place_lookup.c	/^static FILE *lookup_dump; \/* If debugging mode is on, print out to$/;"	v	file:
loop_greedy	timing/slre.c	/^static void loop_greedy(const struct slre *r, int pc, const char *s, int len,$/;"	f	file:
loop_non_greedy	timing/slre.c	/^static void loop_non_greedy(const struct slre *r, int pc, const char *s,$/;"	f	file:
lowercase	timing/slre.c	/^static int lowercase(const char *s) {$/;"	f	file:
lut_pin_remap	base/vpr_types.h	/^	int *lut_pin_remap; \/* [0..num_lut_inputs-1] applies only to LUT primitives, stores how LUT inputs were swapped during CAD flow, $/;"	m	struct:s_pb
lut_size	base/ReadOptions.h	/^	int lut_size;$/;"	m	struct:s_options
luts_spice_file_name	spice/spice_globals.c	/^char* luts_spice_file_name = "luts.sp";$/;"	v
m	../../libarchfpga/include/ezxml.h	/^	char *m; \/* original xml string *\/$/;"	m	struct:ezxml_root
main	../../libarchfpga/ezxml.c	/^main(int argc,$/;"	f
main	../../libarchfpga/main.c	/^int main(int argc, char **argv) {$/;"	f
main	main.c	/^int main(int argc, char **argv) {$/;"	f
main_best_buffer_list	../../libarchfpga/include/arch_types_mrfpga.h	/^  t_linked_int* main_best_buffer_list;$/;"	m	struct:s_arch_mrfpga
main_best_buffer_list	mrfpga/mrfpga_globals.c	/^t_linked_int* main_best_buffer_list;$/;"	v
map_button	base/graphics.c	/^static void map_button (int bnum) $/;"	f	file:
mapped_spice_model	base/vpr_types.h	/^    t_spice_model* mapped_spice_model;$/;"	m	struct:s_logical_block
mapped_spice_model_index	base/vpr_types.h	/^    int mapped_spice_model_index; \/* index of spice_model in completed FPGA netlist *\/$/;"	m	struct:s_logical_block
mark_and_update_partial_gain	pack/cluster.c	/^static void mark_and_update_partial_gain(int inet, enum e_gain_update gain_flag,$/;"	f	file:
mark_blk_pins_nets_sink_index	clb_pin_remap/clb_pin_remap_util.c	/^void mark_blk_pins_nets_sink_index(int n_nets, t_net* nets,$/;"	f
mark_constant_generators	base/read_netlist.c	/^static void mark_constant_generators(INP int L_num_blocks,$/;"	f	file:
mark_constant_generators_rec	base/read_netlist.c	/^static void mark_constant_generators_rec(INP t_pb *pb, INP t_rr_node *rr_graph,$/;"	f	file:
mark_direct_of_pins	util/vpr_utils.c	/^static void mark_direct_of_pins(int start_pin_index, int end_pin_index, int itype, $/;"	f	file:
mark_direct_of_ports	util/vpr_utils.c	/^static void mark_direct_of_ports (int idirect, int direct_type, char * pb_type_name, $/;"	f	file:
mark_ends	route/route_common.c	/^void mark_ends(int inet) {$/;"	f
mark_ends_cluster	pack/cluster_legality.c	/^static void mark_ends_cluster(int inet) {$/;"	f	file:
mark_node_expansion_by_bin	route/route_timing.c	/^static int mark_node_expansion_by_bin(int inet, int target_node,$/;"	f	file:
marked_blocks	base/vpr_types.h	/^	int *marked_nets, *marked_blocks;$/;"	m	struct:s_pb_stats
marked_nets	base/vpr_types.h	/^	int *marked_nets, *marked_blocks;$/;"	m	struct:s_pb_stats
match	timing/slre.c	/^static const char *match(const struct slre *r, int pc, const char *s, int len,$/;"	f	file:
match2	timing/slre.c	/^static const char *match2(const struct slre *r, const char *buf, int len,$/;"	f	file:
match_pb_types_spice_model_rec	spice/spice_pbtypes.c	/^void match_pb_types_spice_model_rec(t_pb_type* cur_pb_type,$/;"	f
max	base/graphics.c	171;"	d	file:
max	mrfpga/mrfpga_util.h	6;"	d
max_IPIN_fanin	power/power.h	/^	int max_IPIN_fanin;$/;"	m	struct:s_power_commonly_used
max_buffer_size	power/power.h	/^	int max_buffer_size;$/;"	m	struct:s_power_tech
max_criticality	base/ReadOptions.h	/^	float max_criticality;$/;"	m	struct:s_options
max_criticality	base/vpr_types.h	/^	float max_criticality;$/;"	m	struct:s_router_opts
max_ext_index	pack/cluster_legality.c	/^		ext_clock_rr_node_index, max_ext_index;$/;"	v	file:
max_index	route/rr_graph.c	/^	int max_index;$/;"	m	struct:s_mux_size_distribution	file:
max_internal_delay	../../libarchfpga/include/physical_types.h	/^	float max_internal_delay;$/;"	m	struct:s_pb_type
max_mux_sl_size	power/power.h	/^	int max_mux_sl_size;$/;"	m	struct:s_power_nmos_mux_inf
max_pins_per_side	../../libarchfpga/include/arch_types_mrfpga.h	/^  int max_pins_per_side;$/;"	m	struct:s_arch_mrfpga
max_pins_per_side	mrfpga/mrfpga_globals.c	/^int max_pins_per_side;$/;"	v
max_router_iterations	base/ReadOptions.h	/^	int max_router_iterations;$/;"	m	struct:s_options
max_router_iterations	base/vpr_types.h	/^	int max_router_iterations;$/;"	m	struct:s_router_opts
max_routing_mux_size	power/power.h	/^	int max_routing_mux_size;$/;"	m	struct:s_power_commonly_used
max_seg_fanout	power/power.h	/^	int max_seg_fanout;$/;"	m	struct:s_power_commonly_used
max_seg_to_IPIN_fanout	power/power.h	/^	int max_seg_to_IPIN_fanout;$/;"	m	struct:s_power_commonly_used
max_seg_to_seg_fanout	power/power.h	/^	int max_seg_to_seg_fanout;$/;"	m	struct:s_power_commonly_used
meas_header_file_name	spice/spice_globals.c	/^char* meas_header_file_name = "meas_params.sp";$/;"	v
meas_params	../../libarchfpga/include/spice_types.h	/^  t_spice_meas_params meas_params;$/;"	m	struct:s_spice_params
mem_avail	../../libarchfpga/include/util.h	/^	int mem_avail; \/* number of bytes left in the current chunk *\/$/;"	m	struct:s_chunk
members	place/place_macro.h	/^	t_pl_macro_member* members;$/;"	m	struct:s_pl_macro
memory_pool	pack/cluster.c	/^static struct s_molecule_link *memory_pool; \/*Declared here so I can free easily.*\/$/;"	v	typeref:struct:s_molecule_link	file:
memristor_inf	../../libarchfpga/include/arch_types_mrfpga.h	/^  t_memristor_inf memristor_inf;$/;"	m	struct:s_arch_mrfpga
memristor_inf	mrfpga/mrfpga_globals.c	/^t_memristor_inf memristor_inf;$/;"	v
menu	base/graphics.c	/^static Window toplevel, menu, textarea;  \/* various windows *\/$/;"	v	file:
menu_font_size	base/graphics.c	/^static const int menu_font_size = 12;   \/* Font for menus and dialog boxes. *\/$/;"	v	file:
menutext	base/graphics.c	/^static void menutext(Window win, int xc, int yc, const char *text) $/;"	f	file:
messagelogger	../../libarchfpga/include/util.h	/^typedef unsigned char (*messagelogger)( TIO_MessageMode_t messageMode,$/;"	t
messages	power/power.h	/^	char ** messages;$/;"	m	struct:s_log
meta_characters	timing/slre.c	/^static const char *meta_characters = "|.*+?()[\\\\";$/;"	v	file:
min	base/graphics.c	174;"	d	file:
min	mrfpga/mrfpga_util.h	10;"	d
min_size	../../libarchfpga/include/logic_types.h	/^	int min_size; \/* minimum number of pins *\/$/;"	m	struct:s_model_ports
min_width	../../libarchfpga/include/spice_types.h	/^  float min_width;$/;"	m	struct:s_spice_transistor_type
mode	base/vpr_types.h	/^	int mode; \/* mode that this pb is set to *\/$/;"	m	struct:s_pb
mode_power	../../libarchfpga/include/physical_types.h	/^	t_mode_power * mode_power;$/;"	m	struct:s_mode
model	../../libarchfpga/include/cad_types.h	/^	t_model *model; \/* block associated with chain *\/$/;"	m	struct:s_model_chain_pattern
model	../../libarchfpga/include/physical_types.h	/^	t_model *model;$/;"	m	struct:s_pb_type
model	base/read_blif.c	/^	t_model * model;$/;"	m	struct:s_model_stats	file:
model	base/read_blif.c	/^static char *model = NULL;$/;"	v	file:
model	base/vpr_types.h	/^	t_model* model; \/* Technology-mapped type (eg. LUT, Flip-flop, memory slice, inpad, etc) *\/$/;"	m	struct:s_logical_block
model_library	../../libarchfpga/include/physical_types.h	/^	t_model *model_library;$/;"	m	struct:s_arch
model_lines	base/read_blif.c	/^static int ilines, olines, model_lines, endlines;$/;"	v	file:
model_name	../../libarchfpga/include/spice_types.h	/^  char* model_name;$/;"	m	struct:s_spice_transistor_type
model_netlist	../../libarchfpga/include/spice_types.h	/^  char* model_netlist;$/;"	m	struct:s_spice_model
model_pin	base/vpr_types.h	/^	int model_port, model_pin; \/* technology mapped model pin *\/$/;"	m	struct:s_prepacked_tnode_data
model_port	../../libarchfpga/include/physical_types.h	/^	t_model_ports *model_port;$/;"	m	struct:s_port
model_port	base/vpr_types.h	/^	int model_port, model_pin; \/* technology mapped model pin *\/$/;"	m	struct:s_prepacked_tnode_data
model_port_ptr	base/vpr_types.h	/^	t_model_ports *model_port_ptr;$/;"	m	struct:s_prepacked_tnode_data
model_ref	../../libarchfpga/include/spice_types.h	/^  char* model_ref;$/;"	m	struct:s_spice_tech_lib
models	../../libarchfpga/include/physical_types.h	/^	t_model *models;$/;"	m	struct:s_arch
modes	../../libarchfpga/include/physical_types.h	/^	t_mode *modes; \/* [0..num_modes-1] *\/$/;"	m	struct:s_pb_type
moleculeptr	pack/cluster.c	/^	t_pack_molecule *moleculeptr;$/;"	m	struct:s_molecule_link	file:
mouseclick_ptr	base/graphics.c	/^static void (*mouseclick_ptr)(float x, float y);$/;"	v	file:
mousemove_ptr	base/graphics.c	/^static void (*mousemove_ptr)(float x, float y);$/;"	v	file:
moved_blocks	place/place.c	/^	t_pl_moved_block * moved_blocks;$/;"	m	struct:s_pl_blocks_to_be_moved	file:
mux_arch	power/power.h	/^	t_mux_arch * mux_arch;$/;"	m	struct:s_power_mux_info
mux_arch_fix_levels	power/power_util.c	/^void mux_arch_fix_levels(t_mux_arch * mux_arch) {$/;"	f
mux_arch_max_size	power/power.h	/^	int mux_arch_max_size;$/;"	m	struct:s_power_mux_info
mux_basis_posfix	spice/spice_globals.c	/^char* mux_basis_posfix = "_basis";$/;"	v
mux_count	route/rr_graph.c	/^	int mux_count;$/;"	m	struct:s_mux_size_distribution	file:
mux_find_selector_values	power/power_util.c	/^boolean mux_find_selector_values(int * selector_values, t_mux_node * mux_node,$/;"	f
mux_graph_head	power/power.h	/^	t_mux_node * mux_graph_head;$/;"	m	struct:s_mux_arch
mux_info	power/power.h	/^	std::map<float, t_power_mux_info*> mux_info;$/;"	m	struct:s_power_commonly_used
mux_last_level_input_num	spice/spice_utils.c	/^int mux_last_level_input_num(int num_level,$/;"	f
mux_size	power/power.h	/^	int mux_size;$/;"	m	struct:s_power_buffer_sc_levr_inf
mux_trans_size	../../libarchfpga/include/physical_types.h	/^	float mux_trans_size;$/;"	m	struct:s_switch_inf
mux_transistor_size	../../libarchfpga/include/physical_types.h	/^	float mux_transistor_size;$/;"	m	struct:s_power_arch
mux_voltage_inf	power/power.h	/^	t_power_mux_volt_inf * mux_voltage_inf;$/;"	m	struct:s_power_nmos_mux_inf
mux_voltage_pairs	power/power.h	/^	t_power_mux_volt_pair * mux_voltage_pairs;$/;"	m	struct:s_power_mux_volt_inf
muxes_spice_file_name	spice/spice_globals.c	/^char* muxes_spice_file_name = "muxes.sp";$/;"	v
my_atof_2D	util/token.c	/^void my_atof_2D(INOUTP float **matrix, INP int max_i, INP int max_j,$/;"	f
my_atoi	../../libarchfpga/util.c	/^int my_atoi(const char *str) {$/;"	f
my_calloc	../../libarchfpga/util.c	/^my_calloc(size_t nelem, size_t size) {$/;"	f
my_chunk_malloc	../../libarchfpga/util.c	/^my_chunk_malloc(size_t size, t_chunk *chunk_info) {$/;"	f
my_decimal2binary	spice/spice_utils.c	/^int* my_decimal2binary(int decimal,$/;"	f
my_fgets	../../libarchfpga/util.c	/^my_fgets(char *buf, int max_size, FILE * fp) {$/;"	f
my_fopen	../../libarchfpga/util.c	/^my_fopen(const char *fname, const char *flag, int prompt) {$/;"	f
my_frand	../../libarchfpga/util.c	/^float my_frand(void) {$/;"	f
my_free	../../libarchfpga/read_xml_spice_util.c	/^void my_free(void* ptr) {$/;"	f
my_gettime	spice/spice_utils.c	/^char* my_gettime() {$/;"	f
my_irand	../../libarchfpga/util.c	/^int my_irand(int imax) {$/;"	f
my_itoa	spice/spice_utils.c	/^char* my_itoa(int input) {$/;"	f
my_malloc	../../libarchfpga/util.c	/^my_malloc(size_t size) {$/;"	f
my_malloc	base/graphics.c	/^static void *my_malloc(int ibytes) {$/;"	f	file:
my_realloc	../../libarchfpga/util.c	/^my_realloc(void *ptr, size_t size) {$/;"	f
my_realloc	base/graphics.c	/^static void *my_realloc(void *memblk, int ibytes) {$/;"	f	file:
my_remove_file	spice/spice_utils.c	/^void my_remove_file(char* file_path) {$/;"	f
my_srandom	../../libarchfpga/util.c	/^void my_srandom(int seed) {$/;"	f
my_strcat	spice/spice_utils.c	/^char* my_strcat(char* str1,$/;"	f
my_strdup	../../libarchfpga/util.c	/^my_strdup(const char *str) {$/;"	f
my_strncpy	../../libarchfpga/util.c	/^my_strncpy(char *dest, const char *src, size_t size) {$/;"	f
my_strtok	../../libarchfpga/util.c	/^my_strtok(char *ptr, const char *tokens, FILE * fp, char *buf) {$/;"	f
my_strtok	spice/spice_utils.c	/^char** my_strtok(char* str, $/;"	f
name	../../libarchfpga/include/cad_types.h	/^	char *name; \/* name of this chain of logic *\/$/;"	m	struct:s_model_chain_pattern
name	../../libarchfpga/include/cad_types.h	/^	char *name; \/* name of this logic model pattern *\/$/;"	m	struct:s_pack_patterns
name	../../libarchfpga/include/ezxml.h	/^	char *name; \/* tag name *\/$/;"	m	struct:ezxml
name	../../libarchfpga/include/logic_types.h	/^	char *name; \/* name of this logic model *\/$/;"	m	struct:s_model
name	../../libarchfpga/include/logic_types.h	/^	char *name; \/* name of this port *\/$/;"	m	struct:s_model_ports
name	../../libarchfpga/include/physical_types.h	/^	char *name;$/;"	m	struct:s_direct_inf
name	../../libarchfpga/include/physical_types.h	/^	char *name;$/;"	m	struct:s_interconnect
name	../../libarchfpga/include/physical_types.h	/^	char *name;$/;"	m	struct:s_switch_inf
name	../../libarchfpga/include/physical_types.h	/^	char *name;$/;"	m	struct:s_type_descriptor
name	../../libarchfpga/include/physical_types.h	/^	char* name;$/;"	m	struct:s_mode
name	../../libarchfpga/include/physical_types.h	/^	char* name;$/;"	m	struct:s_pb_type
name	../../libarchfpga/include/physical_types.h	/^	char* name;$/;"	m	struct:s_port
name	../../libarchfpga/include/spice_types.h	/^  char* name;$/;"	m	struct:s_spice_model
name	base/vpr_types.h	/^	char * name; \/* I\/O port name with an SDC constraint *\/$/;"	m	struct:s_io
name	base/vpr_types.h	/^	char * name;$/;"	m	struct:s_clock
name	base/vpr_types.h	/^	char *name; \/* Name of this physical block *\/$/;"	m	struct:s_pb
name	base/vpr_types.h	/^	char *name; \/* Taken from the first vpack_net which it drives. *\/$/;"	m	struct:s_logical_block
name	base/vpr_types.h	/^	char *name;$/;"	m	struct:s_block
name	base/vpr_types.h	/^	char *name;$/;"	m	struct:s_net
name	power/power.h	/^	char * name;$/;"	m	struct:s_log
name	timing/read_sdc.c	/^	char * name;$/;"	m	struct:s_sdc_clock	file:
name	util/hash.h	/^	char *name;$/;"	m	struct:s_hash
name_type	base/draw.c	/^static const char *name_type[] = { "SOURCE", "SINK", "IPIN", "OPIN", "CHANX", "CHANY",$/;"	v	file:
nelem	../../libarchfpga/include/util.h	/^	int nelem;$/;"	m	struct:s_ivec
net	base/globals_declare.h	/^struct s_net *net;$/;"	v	typeref:struct:s_net
net_color	base/draw.c	/^static enum color_types *net_color, *block_color;$/;"	v	typeref:enum:color_types	file:
net_cost	place/place.c	/^static float *net_cost = NULL, *temp_net_cost = NULL; \/* [0..num_nets-1] *\/$/;"	v	file:
net_delay	place/timing_place_lookup.c	/^static float **net_delay;$/;"	v	file:
net_delay_ch	place/timing_place.c	/^static t_chunk net_delay_ch = {NULL, 0, NULL};$/;"	v	file:
net_num	base/vpr_types.h	/^	int net_num;$/;"	m	struct:s_rr_node
net_num_in_pack	base/vpr_types.h	/^	int net_num_in_pack;$/;"	m	struct:s_rr_node
net_output_feeds_driving_block_input	pack/cluster.c	/^static int *net_output_feeds_driving_block_input;$/;"	v	file:
net_pin_index	place/place.c	/^static int **net_pin_index = NULL;$/;"	v	file:
net_power	base/vpr_types.h	/^	t_net_power * net_power;$/;"	m	struct:s_net
net_rr_terminals	base/globals.c	/^int **net_rr_terminals = NULL; \/* [0..num_nets-1][0..num_pins-1] *\/$/;"	v
net_rr_terminals	base/globals_declare.h	/^int **net_rr_terminals; \/* [0..num_nets-1][0..num_pins-1] *\/$/;"	v
netlist_clocks	timing/read_sdc.c	/^char ** netlist_clocks; \/* [0..num_netlist_clocks - 1] array of names of clocks in netlist *\/$/;"	v
netlist_ios	timing/read_sdc.c	/^char ** netlist_ios; \/* [0..num_netlist_clocks - 1] array of names of ios in netlist *\/$/;"	v
nets	base/vpr_types.h	/^	int *nets;$/;"	m	struct:s_block
nets_in_cluster	pack/cluster_legality.c	/^static int *nets_in_cluster; \/* [0..num_nets_in_cluster-1] *\/$/;"	v	file:
nets_sink_index	base/vpr_types.h	/^    int* nets_sink_index;$/;"	m	struct:s_block
next	../../libarchfpga/include/cad_types.h	/^	struct s_model_chain_pattern *next; \/* next chain (linked list) *\/$/;"	m	struct:s_model_chain_pattern	typeref:struct:s_model_chain_pattern::s_model_chain_pattern
next	../../libarchfpga/include/cad_types.h	/^	struct s_pack_pattern_connections *next;$/;"	m	struct:s_pack_pattern_connections	typeref:struct:s_pack_pattern_connections::s_pack_pattern_connections
next	../../libarchfpga/include/ezxml.h	/^	ezxml_t next; \/* next tag with same name in this section at this depth *\/$/;"	m	struct:ezxml
next	../../libarchfpga/include/logic_types.h	/^	struct s_model *next; \/* next model (linked list) *\/$/;"	m	struct:s_model	typeref:struct:s_model::s_model
next	../../libarchfpga/include/logic_types.h	/^	struct s_model_ports *next; \/* next port *\/$/;"	m	struct:s_model_ports	typeref:struct:s_model_ports::s_model_ports
next	../../libarchfpga/include/util.h	/^	struct s_linked_int *next;$/;"	m	struct:s_linked_int	typeref:struct:s_linked_int::s_linked_int
next	../../libarchfpga/include/util.h	/^	struct s_linked_vptr *next;$/;"	m	struct:s_linked_vptr	typeref:struct:s_linked_vptr::s_linked_vptr
next	base/place_and_route.h	/^	struct s_fmap_cell *next;$/;"	m	struct:s_fmap_cell	typeref:struct:s_fmap_cell::s_fmap_cell
next	base/verilog_writer.h	/^  struct found_connectivity *next;$/;"	m	struct:found_connectivity	typeref:struct:found_connectivity::found_connectivity
next	base/verilog_writer.h	/^  struct found_pins *next;$/;"	m	struct:found_pins	typeref:struct:found_pins::found_pins
next	base/vpr_types.h	/^	struct s_linked_f_pointer *next;$/;"	m	struct:s_linked_f_pointer	typeref:struct:s_linked_f_pointer::s_linked_f_pointer
next	base/vpr_types.h	/^	struct s_pack_molecule *next;$/;"	m	struct:s_pack_molecule	typeref:struct:s_pack_molecule::s_pack_molecule
next	base/vpr_types.h	/^	struct s_trace *next;$/;"	m	struct:s_trace	typeref:struct:s_trace::s_trace
next	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_node { t_buffer_plan value; struct s_buffer_plan_node* next;} t_buffer_plan_node;$/;"	m	struct:s_buffer_plan_node	typeref:struct:s_buffer_plan_node::s_buffer_plan_node	file:
next	pack/cluster.c	/^	struct s_molecule_link *next;$/;"	m	struct:s_molecule_link	typeref:struct:s_molecule_link::s_molecule_link	file:
next	route/route_common.h	/^		struct s_heap *next;$/;"	m	union:s_heap::__anon14	typeref:struct:s_heap::__anon14::s_heap
next	route/route_tree_timing.h	/^		struct s_rt_node *next;$/;"	m	union:s_rt_node::__anon16	typeref:struct:s_rt_node::__anon16::s_rt_node
next	route/route_tree_timing.h	/^	struct s_linked_rt_edge *next;$/;"	m	struct:s_linked_rt_edge	typeref:struct:s_linked_rt_edge::s_linked_rt_edge
next	route/rr_graph.c	/^	struct s_mux *next;$/;"	m	struct:s_mux	typeref:struct:s_mux::s_mux	file:
next	route/rr_graph.c	/^	struct s_mux_size_distribution *next;$/;"	m	struct:s_mux_size_distribution	typeref:struct:s_mux_size_distribution::s_mux_size_distribution	file:
next	route/rr_graph_util.h	/^	struct s_linked_edge *next;$/;"	m	struct:s_linked_edge	typeref:struct:s_linked_edge::s_linked_edge
next	spice/linkedlist.h	/^  t_llist* next;$/;"	m	struct:s_llist
next	timing/net_delay_types.h	/^		struct s_rc_node *next;$/;"	m	union:s_rc_node::__anon18	typeref:struct:s_rc_node::__anon18::s_rc_node
next	timing/net_delay_types.h	/^	struct s_linked_rc_edge *next;$/;"	m	struct:s_linked_rc_edge	typeref:struct:s_linked_rc_edge::s_linked_rc_edge
next	timing/net_delay_types.h	/^	struct s_linked_rc_ptr *next;$/;"	m	struct:s_linked_rc_ptr	typeref:struct:s_linked_rc_ptr::s_linked_rc_ptr
next	util/hash.h	/^	struct s_hash *next;$/;"	m	struct:s_hash	typeref:struct:s_hash::s_hash
next_mem_loc_ptr	../../libarchfpga/include/util.h	/^	char *next_mem_loc_ptr;\/* pointer to the first available (free) *$/;"	m	struct:s_chunk
next_primitive	../../libarchfpga/include/cad_types.h	/^	struct s_cluster_placement_primitive *next_primitive;$/;"	m	struct:s_cluster_placement_primitive	typeref:struct:s_cluster_placement_primitive::s_cluster_placement_primitive
nint	../../libarchfpga/include/util.h	24;"	d
nmos_leakage_info	power/power.h	/^	t_power_nmos_leakage_inf * nmos_leakage_info;$/;"	m	struct:s_power_tech
nmos_mux_info	power/power.h	/^	t_power_nmos_mux_inf * nmos_mux_info;$/;"	m	struct:s_power_tech
nmos_pmos_spice_file_name	spice/spice_globals.c	/^char* nmos_pmos_spice_file_name = "nmos_pmos.sp";$/;"	v
nmos_size	../../libarchfpga/include/spice_types.h	/^  float nmos_size;$/;"	m	struct:s_spice_model_pass_gate_logic
nmos_size	power/power.h	/^	float nmos_size;$/;"	m	struct:s_power_nmos_leakage_inf
nmos_size	power/power.h	/^	float nmos_size;$/;"	m	struct:s_power_nmos_mux_inf
nmos_subckt_name	spice/spice_globals.c	/^char* nmos_subckt_name = "vpr_nmos";$/;"	v
node_block	base/vpr_types.h	/^	int *node_block;$/;"	m	struct:s_net
node_block_pin	base/vpr_types.h	/^	int *node_block_pin;$/;"	m	struct:s_net
node_block_port	base/vpr_types.h	/^	int *node_block_port;$/;"	m	struct:s_net
node_to_heap	route/route_common.c	/^void node_to_heap(int inode, float cost, int prev_node, int prev_edge,$/;"	f
nominal_vdd	../../libarchfpga/include/spice_types.h	/^  float nominal_vdd;$/;"	m	struct:s_spice_tech_lib
normalized_T_arr	base/vpr_types.h	/^	float normalized_T_arr; \/* arrival time (normalized with respect to max time) *\/$/;"	m	struct:s_prepacked_tnode_data
normalized_slack	base/vpr_types.h	/^	float normalized_slack; \/* slack (normalized with respect to max slack) *\/$/;"	m	struct:s_prepacked_tnode_data
normalized_total_critical_paths	base/vpr_types.h	/^	float normalized_total_critical_paths; \/* critical path count (normalized with respect to max count) *\/$/;"	m	struct:s_prepacked_tnode_data
num_annotations	../../libarchfpga/include/physical_types.h	/^	int num_annotations;$/;"	m	struct:s_interconnect
num_annotations	../../libarchfpga/include/physical_types.h	/^	int num_annotations;$/;"	m	struct:s_pb_type
num_blif_models	base/read_blif.c	/^static int num_blif_models;$/;"	v	file:
num_blocks	../../libarchfpga/include/cad_types.h	/^	int num_blocks; \/* number of blocks in pattern *\/$/;"	m	struct:s_pack_patterns
num_blocks	base/globals.c	/^int num_blocks = 0;$/;"	v
num_blocks	base/globals_declare.h	/^int num_nets, num_blocks;$/;"	v
num_blocks	base/vpr_types.h	/^	int num_blocks; \/* number of logical blocks of molecule *\/$/;"	m	struct:s_pack_molecule
num_blocks	place/place_macro.h	/^	int num_blocks;$/;"	m	struct:s_pl_macro
num_buttons	base/graphics.c	/^static int num_buttons = 0;                  \/* Number of menu buttons *\/$/;"	v	file:
num_caps	timing/slre.c	/^  int num_caps;   \/\/ Number of bracket pairs$/;"	m	struct:slre	file:
num_cb_buffers	power/power.h	/^	int num_cb_buffers;$/;"	m	struct:s_power_commonly_used
num_cb_switch	../../libarchfpga/include/physical_types.h	/^    int num_cb_switch;$/;"	m	struct:s_arch
num_cc_constraints	base/vpr_types.h	/^	int num_cc_constraints; \/* number of special-case clock-to-clock constraints overriding default, calculated, timing constraints *\/$/;"	m	struct:s_timing_constraints
num_cf_constraints	base/vpr_types.h	/^	int num_cf_constraints; \/* number of special-case clock-to-flipflop constraints *\/$/;"	m	struct:s_timing_constraints
num_child_blocks_in_pb	base/vpr_types.h	/^	int num_child_blocks_in_pb;$/;"	m	struct:s_pb_stats
num_class	../../libarchfpga/include/physical_types.h	/^	int num_class;$/;"	m	struct:s_type_descriptor
num_clock_names	timing/read_sdc.c	/^	int num_clock_names;$/;"	m	struct:s_sdc_exclusive_group	file:
num_clock_pins	../../libarchfpga/include/physical_types.h	/^	int *num_clock_pins; \/* [0..num_clock_ports - 1] *\/$/;"	m	struct:s_pb_graph_node
num_clock_pins	../../libarchfpga/include/physical_types.h	/^	int num_clock_pins;$/;"	m	struct:s_pb_type
num_clock_ports	../../libarchfpga/include/physical_types.h	/^	int num_clock_ports;$/;"	m	struct:s_pb_graph_node
num_connectable_primtive_input_pins	../../libarchfpga/include/physical_types.h	/^	int *num_connectable_primtive_input_pins; \/* [0..depth-1] number of input pins that this output pin can reach without exiting cluster at given depth *\/$/;"	m	struct:s_pb_graph_pin
num_constrained_clocks	base/vpr_types.h	/^	int num_constrained_clocks; \/* number of clocks with timing constraints *\/$/;"	m	struct:s_timing_constraints
num_constrained_inputs	base/vpr_types.h	/^	int num_constrained_inputs; \/* number of inputs with timing constraints *\/$/;"	m	struct:s_timing_constraints
num_constrained_outputs	base/vpr_types.h	/^	int num_constrained_outputs; \/* number of outputs with timing constraints *\/$/;"	m	struct:s_timing_constraints
num_critical_input_paths	base/vpr_types.h	/^	long num_critical_input_paths, num_critical_output_paths; \/* count of critical paths fanning into\/out of this tnode *\/$/;"	m	struct:s_prepacked_tnode_data
num_critical_output_paths	base/vpr_types.h	/^	long num_critical_input_paths, num_critical_output_paths; \/* count of critical paths fanning into\/out of this tnode *\/$/;"	m	struct:s_prepacked_tnode_data
num_directs	../../libarchfpga/include/physical_types.h	/^	int num_directs;$/;"	m	struct:s_arch
num_drive_rr_nodes	base/vpr_types.h	/^    int num_drive_rr_nodes;$/;"	m	struct:s_rr_node
num_driver	base/read_blif.c	/^static int *num_driver, *temp_num_pins;$/;"	v	file:
num_drivers	../../libarchfpga/include/physical_types.h	/^	int num_drivers;$/;"	m	struct:s_type_descriptor
num_edges	base/vpr_types.h	/^	int num_edges;$/;"	m	struct:s_tnode
num_edges	base/vpr_types.h	/^	short num_edges;$/;"	m	struct:s_rr_node
num_edges_head	pack/pb_type_graph.c	/^static struct s_linked_vptr *num_edges_head;$/;"	v	typeref:struct:s_linked_vptr	file:
num_ext_inputs	base/vpr_types.h	/^	int num_ext_inputs; \/* number of input pins used by molecule that are not self-contained by pattern molecule matches *\/$/;"	m	struct:s_pack_molecule
num_ext_inputs_logical_block	util/vpr_utils.c	/^int num_ext_inputs_logical_block(int iblk) {$/;"	f
num_fc_constraints	base/vpr_types.h	/^	int num_fc_constraints; \/* number of special-case flipflop-to-clock constraints *\/$/;"	m	struct:s_timing_constraints
num_feasible_blocks	base/vpr_types.h	/^	int num_feasible_blocks; \/* [0..num_marked_models-1] *\/$/;"	m	struct:s_pb_stats
num_ff_constraints	base/vpr_types.h	/^	int num_ff_constraints; \/* number of special-case flipflop-to-flipflop constraints *\/$/;"	m	struct:s_timing_constraints
num_global_clocks	../../libarchfpga/include/physical_types.h	/^	int num_global_clocks;$/;"	m	struct:s_clock_arch
num_grid_loc_def	../../libarchfpga/include/physical_types.h	/^	int num_grid_loc_def;$/;"	m	struct:s_type_descriptor
num_heap_allocated	route/route_common.c	/^static int num_heap_allocated = 0;$/;"	v	file:
num_include_netlist	../../libarchfpga/include/spice_types.h	/^  int num_include_netlist;$/;"	m	struct:s_spice
num_input	../../libarchfpga/include/spice_types.h	/^  int num_input;$/;"	m	struct:s_spice_mux_arch
num_input_edges	../../libarchfpga/include/physical_types.h	/^	int num_input_edges;$/;"	m	struct:s_pb_graph_pin
num_input_last_level	../../libarchfpga/include/spice_types.h	/^  int num_input_last_level;$/;"	m	struct:s_spice_mux_arch
num_input_per_level	../../libarchfpga/include/spice_types.h	/^  int* num_input_per_level; \/* [0...num_level] *\/$/;"	m	struct:s_spice_mux_arch
num_input_pin_class	../../libarchfpga/include/physical_types.h	/^	int num_input_pin_class; \/* number of pin classes that this input pb_graph_node has *\/$/;"	m	struct:s_pb_graph_node
num_input_pins	../../libarchfpga/include/physical_types.h	/^	int *num_input_pins; \/* [0..num_input_ports - 1] *\/$/;"	m	struct:s_pb_graph_node
num_input_pins	../../libarchfpga/include/physical_types.h	/^	int num_input_pins; \/* inputs not including clock pins *\/$/;"	m	struct:s_pb_type
num_input_pins	../../libarchfpga/include/physical_types.h	/^	int num_input_pins;$/;"	m	struct:s_pb_graph_edge
num_input_ports	../../libarchfpga/include/physical_types.h	/^	int num_input_ports;$/;"	m	struct:s_interconnect_power
num_input_ports	../../libarchfpga/include/physical_types.h	/^	int num_input_ports;$/;"	m	struct:s_pb_graph_node
num_inputs	power/PowerSpicedComponent.h	/^	int num_inputs;$/;"	m	class:PowerCallibInputs
num_inputs	power/power.h	/^	int num_inputs; \/* Number of inputs *\/$/;"	m	struct:s_mux_node
num_inputs	power/power.h	/^	int num_inputs;$/;"	m	struct:s_mux_arch
num_inputs	power/power.h	/^	short num_inputs; \/* Number of inputs *\/$/;"	m	struct:s_rr_node_power
num_interconnect	../../libarchfpga/include/physical_types.h	/^	int num_interconnect;$/;"	m	struct:s_mode
num_latches	base/read_blif.c	/^static int num_luts = 0, num_latches = 0, num_subckts = 0;$/;"	v	file:
num_leakage_pairs	power/power.h	/^	int num_leakage_pairs;$/;"	m	struct:s_power_nmos_leakage_inf
num_legal_pos	place/place.c	/^static int *num_legal_pos = NULL; \/* [0..num_legal_pos-1] *\/$/;"	v	file:
num_level	../../libarchfpga/include/spice_types.h	/^  int num_level;$/;"	m	struct:s_spice_mux_arch
num_levr_entries	power/power.h	/^	int num_levr_entries;$/;"	m	struct:s_power_buffer_strength_inf
num_linked_f_pointer_allocated	route/route_common.c	/^static int num_linked_f_pointer_allocated = 0;$/;"	v	file:
num_local_nets	base/vpr_types.h	/^	int num_local_nets; \/* Records post-packing connections, valid only for top-level *\/$/;"	m	struct:s_pb
num_logical_blocks	base/globals.c	/^int num_logical_nets = 0, num_logical_blocks = 0;$/;"	v
num_logical_nets	base/globals.c	/^int num_logical_nets = 0, num_logical_blocks = 0;$/;"	v
num_logs	power/power.h	/^	int num_logs;$/;"	m	struct:s_power_output
num_luts	base/read_blif.c	/^static int num_luts = 0, num_latches = 0, num_subckts = 0;$/;"	v	file:
num_marked_blocks	base/vpr_types.h	/^	int num_marked_nets, num_marked_blocks;$/;"	m	struct:s_pb_stats
num_marked_nets	base/vpr_types.h	/^	int num_marked_nets, num_marked_blocks;$/;"	m	struct:s_pb_stats
num_messages	power/power.h	/^	int num_messages;$/;"	m	struct:s_log
num_modes	../../libarchfpga/include/physical_types.h	/^	int num_modes;$/;"	m	struct:s_pb_type
num_moved_blocks	place/place.c	/^	int num_moved_blocks;$/;"	m	struct:s_pl_blocks_to_be_moved	file:
num_multicycles	base/vpr_types.h	/^	int num_multicycles;$/;"	m	struct:s_override_constraint
num_mux	../../libarchfpga/include/physical_types.h	/^    int num_mux;$/;"	m	struct:s_interconnect
num_netlist_clocks	timing/read_sdc.c	/^int num_netlist_clocks = 0; \/* number of clocks in netlist *\/$/;"	v
num_netlist_ios	timing/read_sdc.c	/^int num_netlist_ios = 0; \/* number of clocks in netlist *\/$/;"	v
num_nets	base/globals.c	/^int num_nets = 0;$/;"	v
num_nets	base/globals_declare.h	/^int num_nets, num_blocks;$/;"	v
num_nets_in_cluster	pack/cluster_legality.c	/^static int num_nets_in_cluster;$/;"	v	file:
num_nmos_leakage_info	power/power.h	/^	int num_nmos_leakage_info;$/;"	m	struct:s_power_tech
num_nmos_mux_info	power/power.h	/^	int num_nmos_mux_info;$/;"	m	struct:s_power_tech
num_normal_switch	../../libarchfpga/include/arch_types_mrfpga.h	/^  short num_normal_switch;$/;"	m	struct:s_arch_mrfpga
num_normal_switch	mrfpga/mrfpga_globals.c	/^short num_normal_switch;$/;"	v
num_opin_drivers	base/vpr_types.h	/^	int num_opin_drivers; \/* UDSD by WMF (could use "short") *\/$/;"	m	struct:s_rr_node
num_output_edges	../../libarchfpga/include/physical_types.h	/^	int num_output_edges;$/;"	m	struct:s_pb_graph_pin
num_output_pin_class	../../libarchfpga/include/physical_types.h	/^	int num_output_pin_class; \/* number of output pin classes that this pb_graph_node has *\/$/;"	m	struct:s_pb_graph_node
num_output_pins	../../libarchfpga/include/physical_types.h	/^	int *num_output_pins; \/* [0..num_output_ports - 1] *\/$/;"	m	struct:s_pb_graph_node
num_output_pins	../../libarchfpga/include/physical_types.h	/^	int num_output_pins;$/;"	m	struct:s_pb_graph_edge
num_output_pins	../../libarchfpga/include/physical_types.h	/^	int num_output_pins;$/;"	m	struct:s_pb_type
num_output_ports	../../libarchfpga/include/physical_types.h	/^	int num_output_ports;$/;"	m	struct:s_interconnect_power
num_output_ports	../../libarchfpga/include/physical_types.h	/^	int num_output_ports;$/;"	m	struct:s_pb_graph_node
num_p_inputs	base/globals.c	/^int num_p_inputs = 0, num_p_outputs = 0;$/;"	v
num_p_outputs	base/globals.c	/^int num_p_inputs = 0, num_p_outputs = 0;$/;"	v
num_pack_patterns	../../libarchfpga/include/physical_types.h	/^	int num_pack_patterns;$/;"	m	struct:s_pb_graph_edge
num_pb	../../libarchfpga/include/physical_types.h	/^	int num_pb;$/;"	m	struct:s_pb_type
num_pb_type_children	../../libarchfpga/include/physical_types.h	/^	int num_pb_type_children;$/;"	m	struct:s_mode
num_pb_types	base/vpr_types.h	/^	int num_pb_types; \/* num primitive pb_types inside complex block *\/$/;"	m	struct:s_cluster_placement_stats
num_pin_loc_assignments	../../libarchfpga/include/physical_types.h	/^	int **num_pin_loc_assignments; \/* [0..height-1][0..3] *\/$/;"	m	struct:s_type_descriptor
num_pin_timing	../../libarchfpga/include/physical_types.h	/^	int num_pin_timing; \/* primitive ipin to opin timing *\/$/;"	m	struct:s_pb_graph_pin
num_pins	../../libarchfpga/include/physical_types.h	/^	int num_pins;$/;"	m	struct:s_class
num_pins	../../libarchfpga/include/physical_types.h	/^	int num_pins;$/;"	m	struct:s_port
num_pins	../../libarchfpga/include/physical_types.h	/^	int num_pins;$/;"	m	struct:s_type_descriptor
num_pins_of_net_in_pb	base/vpr_types.h	/^	std::map<int, int> num_pins_of_net_in_pb;$/;"	m	struct:s_pb_stats
num_pins_per_port	../../libarchfpga/include/physical_types.h	/^	int num_pins_per_port;$/;"	m	struct:s_interconnect_power
num_pl_macros	place/place.c	/^static int num_pl_macros;$/;"	v	file:
num_port	../../libarchfpga/include/spice_types.h	/^  int num_port;$/;"	m	struct:s_spice_model
num_ports	../../libarchfpga/include/physical_types.h	/^	int num_ports;$/;"	m	struct:s_pb_type
num_receivers	../../libarchfpga/include/physical_types.h	/^	int num_receivers;$/;"	m	struct:s_type_descriptor
num_rp	place/place_stats.c	/^	int num_rp[MAX_LEN];$/;"	m	struct:relapos_rec_s	file:
num_rr_indexed_data	base/globals.c	/^int num_rr_indexed_data = 0;$/;"	v
num_rr_indexed_data	base/globals_declare.h	/^int num_rr_indexed_data;$/;"	v
num_rr_nodes	base/globals.c	/^int num_rr_nodes = 0;$/;"	v
num_rr_nodes	base/globals_declare.h	/^int num_rr_nodes;$/;"	v
num_sb_buffers	power/power.h	/^	int num_sb_buffers;$/;"	m	struct:s_power_commonly_used
num_segment	base/vpr_types.h	/^	int num_segment;$/;"	m	struct:s_det_routing_arch
num_segments	../../libarchfpga/include/physical_types.h	/^	int num_segments;$/;"	m	struct:s_arch
num_segments	spice/spice_mux_testbench.c	/^static int num_segments = 0;$/;"	v	file:
num_siblings	base/vpr_types.h	/^	int num_siblings;$/;"	m	struct:s_trace
num_sink	base/vpr_types.h	/^	int num_sink;$/;"	m	struct:s_override_constraint
num_sinks	base/vpr_types.h	/^	int num_sinks;$/;"	m	struct:s_net
num_size_entries	power/power.h	/^	int num_size_entries;$/;"	m	struct:s_transistor_inf
num_source	base/vpr_types.h	/^	int num_source;$/;"	m	struct:s_override_constraint
num_spice_model	../../libarchfpga/include/spice_types.h	/^  int num_spice_model;$/;"	m	struct:s_spice
num_strengths	power/power.h	/^	int num_strengths;$/;"	m	struct:s_power_buffer_size_inf
num_subckts	base/read_blif.c	/^static int num_luts = 0, num_latches = 0, num_subckts = 0;$/;"	v	file:
num_swap_aborted	place/place.c	/^static int num_swap_aborted = 0;$/;"	v	file:
num_swap_accepted	place/place.c	/^static int num_swap_accepted = 0;$/;"	v	file:
num_swap_rejected	place/place.c	/^static int num_swap_rejected = 0;$/;"	v	file:
num_switch	base/vpr_types.h	/^	short num_switch;$/;"	m	struct:s_det_routing_arch
num_switches	../../libarchfpga/include/physical_types.h	/^	int num_switches;$/;"	m	struct:s_arch
num_swseg_pattern	../../libarchfpga/include/physical_types.h	/^    int num_swseg_pattern;$/;"	m	struct:s_arch
num_swseg_pattern	base/vpr_types.h	/^    int num_swseg_pattern; \/*Xifan TANG: Switch Segment Pattern Support*\/$/;"	m	struct:s_det_routing_arch
num_timing_nets	timing/path_delay.c	/^static int num_timing_nets = 0;$/;"	v	file:
num_tnode_levels	timing/path_delay2.c	/^int num_tnode_levels; \/* Number of levels in the timing graph. *\/$/;"	v
num_tnodes	timing/path_delay.c	/^int num_tnodes = 0; \/* Number of nodes (pins) in the timing graph *\/$/;"	v
num_trace_allocated	route/route_common.c	/^static int num_trace_allocated = 0; \/* To watch for memory leaks. *\/$/;"	v	file:
num_transistor_type	../../libarchfpga/include/spice_types.h	/^  int num_transistor_type;$/;"	m	struct:s_spice_tech_lib
num_ts_called	place/place.c	/^static int num_ts_called = 0;$/;"	v	file:
num_types	base/globals.c	/^int num_types = 0;$/;"	v
num_types_backup	place/timing_place_lookup.c	/^static int num_types_backup;$/;"	v	file:
num_used_cb_tb	spice/spice_globals.c	/^int num_used_cb_tb = 0;$/;"	v
num_used_dff_tb	spice/spice_globals.c	/^int num_used_dff_tb = 0;$/;"	v
num_used_grid_tb	spice/spice_globals.c	/^int num_used_grid_tb = 0;$/;"	v
num_used_lut_tb	spice/spice_globals.c	/^int num_used_lut_tb = 0;$/;"	v
num_used_sb_tb	spice/spice_globals.c	/^int num_used_sb_tb = 0;$/;"	v
num_value_prop_pairs	../../libarchfpga/include/physical_types.h	/^	int num_value_prop_pairs;$/;"	m	struct:s_pin_to_pin_annotation
num_voltage_pairs	power/power.h	/^	int num_voltage_pairs;$/;"	m	struct:s_power_mux_volt_inf
num_wire_drivers	base/vpr_types.h	/^	int num_wire_drivers; \/* UDSD by WMF *\/$/;"	m	struct:s_rr_node
nx	base/globals.c	/^int nx = 0;$/;"	v
nx	base/globals_declare.h	/^int nx, ny;$/;"	v
ny	base/globals.c	/^int ny = 0;$/;"	v
ny	base/globals_declare.h	/^int nx, ny;$/;"	v
object_end	base/graphics.c	/^void object_end() { }$/;"	f
object_end	base/graphics.c	/^void object_end() {$/;"	f
object_start	base/graphics.c	/^void object_start(int all) { }$/;"	f
object_start	base/graphics.c	/^void object_start(int all) {$/;"	f
occ	base/vpr_types.h	/^	short occ;$/;"	m	struct:s_rr_node
occupancy	base/vpr_types.h	/^	float occupancy;$/;"	m	struct:s_place_region
off	../../libarchfpga/include/ezxml.h	/^	size_t off; \/* tag offset from start of parent tag character content *\/$/;"	m	struct:ezxml
offset	base/vpr_types.h	/^	int offset;$/;"	m	struct:s_grid_tile
old_num_rr_nodes	base/draw.c	/^static int old_num_rr_nodes = 0;$/;"	v	file:
olines	base/read_blif.c	/^static int ilines, olines, model_lines, endlines;$/;"	v	file:
open	../../libarchfpga/ezxml.c	58;"	d	file:
operator <	power/PowerSpicedComponent.h	/^	const bool operator<(const PowerCallibSize & rhs) {$/;"	f	class:PowerCallibSize
opin_switch	../../libarchfpga/include/physical_types.h	/^	short opin_switch;$/;"	m	struct:s_segment_inf
opin_switch	base/vpr_types.h	/^	short opin_switch;$/;"	m	struct:s_seg_details
opin_to_wire_switch	base/vpr_types.h	/^    short opin_to_wire_switch; \/* mrFPGA: Xifan TANG*\/$/;"	m	struct:s_det_routing_arch
options	timing/slre.c	/^  enum slre_option options;$/;"	m	struct:slre	typeref:enum:slre::slre_option	file:
ordered	../../libarchfpga/include/ezxml.h	/^	ezxml_t ordered; \/* next tag, same section and depth, in original order *\/$/;"	m	struct:ezxml
ortho_cost_index	base/vpr_types.h	/^	int ortho_cost_index;$/;"	m	struct:s_rr_indexed_data
out	power/power.h	/^	FILE * out;$/;"	m	struct:s_power_output
out_edges	base/vpr_types.h	/^	t_tedge *out_edges; \/* [0..num_edges - 1] array of edges fanning out from this tnode.$/;"	m	struct:s_tnode
out_file_prefix	../../libarchfpga/util.c	/^char *out_file_prefix = NULL;$/;"	v
out_file_prefix	base/ReadOptions.h	/^	char *out_file_prefix;$/;"	m	struct:s_options
out_file_prefix	base/vpr_types.h	/^	char *out_file_prefix;$/;"	m	struct:s_file_name_opts
outport_link_pin	../../libarchfpga/include/cad_types.h	/^	int outport_link_pin; \/* applicable pin of chain output port *\/$/;"	m	struct:s_model_chain_pattern
outputFileNames	base/ReadOptions.c	/^static char **outputFileNames = NULL;$/;"	v	file:
output_blif	pack/output_blif.c	/^void output_blif (t_block *clb, int num_clusters, boolean global_clocks,$/;"	f
output_buffer	../../libarchfpga/include/spice_types.h	/^  t_spice_model_buffer* output_buffer;$/;"	m	struct:s_spice_model
output_clustering	pack/output_clustering.c	/^void output_clustering(t_block *clb, int num_clusters, boolean global_clocks,$/;"	f
output_edges	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_edge** output_edges; \/* [0..num_output_edges] *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_edge
output_file	base/vpr_types.h	/^	char *output_file;$/;"	m	struct:s_packer_opts
output_link_port	../../libarchfpga/include/cad_types.h	/^	t_model_ports *output_link_port; \/* pointer to port of chain output *\/$/;"	m	struct:s_model_chain_pattern
output_log	power/power_util.c	/^void output_log(t_log * log_ptr, FILE * fp) {$/;"	f
output_logs	power/power_util.c	/^void output_logs(FILE * fp, t_log * logs, int num_logs) {$/;"	f
output_net_tnodes	base/vpr_types.h	/^	struct s_tnode ***output_net_tnodes; \/* [0..num_output_ports-1][0..num_pins -1] correspnding output net tnode *\/$/;"	m	struct:s_logical_block	typeref:struct:s_logical_block::s_tnode
output_nets	base/vpr_types.h	/^	int **output_nets; \/* [0..num_output_ports-1][0..num_port_pins-1] List of output nets connected to this logical_block. *\/$/;"	m	struct:s_logical_block
output_pin_class_size	../../libarchfpga/include/physical_types.h	/^	int *output_pin_class_size; \/* Stores the number of pins that belong to a particular output pin class *\/$/;"	m	struct:s_pb_graph_node
output_pins	../../libarchfpga/include/physical_types.h	/^	char * output_pins;$/;"	m	struct:s_pin_to_pin_annotation
output_pins	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_pin *** output_pins; \/\/ [0..num_output_ports-1][0..num_pins_per_port-1]$/;"	m	struct:s_interconnect_pins	typeref:struct:s_interconnect_pins::s_pb_graph_pin
output_pins	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin **output_pins; \/* [0..num_output_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:s_pb_graph_node
output_pins	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin **output_pins;$/;"	m	struct:s_pb_graph_edge
output_pins_used	base/vpr_types.h	/^	int **output_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of output pins of this class that are used *\/$/;"	m	struct:s_pb_stats
output_string	../../libarchfpga/include/physical_types.h	/^	char *output_string;$/;"	m	struct:s_interconnect
output_thres_pct_fall	../../libarchfpga/include/spice_types.h	/^  float output_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
output_thres_pct_rise	../../libarchfpga/include/spice_types.h	/^  float output_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
outputs	../../libarchfpga/include/logic_types.h	/^	t_model_ports *outputs; \/* linked list of output ports *\/$/;"	m	struct:s_model
pack_clb_pin_remap	base/vpr_types.h	/^    boolean pack_clb_pin_remap;$/;"	m	struct:s_packer_opts
pack_intrinsic_cost	base/vpr_types.h	/^	float pack_intrinsic_cost;$/;"	m	struct:s_rr_node
pack_pattern	base/vpr_types.h	/^	t_pack_patterns *pack_pattern; \/* If this is a forced_pack molecule, pattern this molecule matches *\/$/;"	m	struct:s_pack_molecule
pack_pattern_indices	../../libarchfpga/include/physical_types.h	/^	int *pack_pattern_indices; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:s_pb_graph_edge
pack_pattern_names	../../libarchfpga/include/physical_types.h	/^	char **pack_pattern_names; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:s_pb_graph_edge
packed_molecules	base/vpr_types.h	/^	struct s_linked_vptr *packed_molecules; \/* List of t_pack_molecules that this logical block is a part of *\/$/;"	m	struct:s_logical_block	typeref:struct:s_logical_block::s_linked_vptr
packer_algorithm	base/ReadOptions.h	/^	enum e_packer_algorithm packer_algorithm;$/;"	m	struct:s_options	typeref:enum:s_options::e_packer_algorithm
packer_algorithm	base/vpr_types.h	/^	enum e_packer_algorithm packer_algorithm;$/;"	m	struct:s_packer_opts	typeref:enum:s_packer_opts::e_packer_algorithm
pad_loc_file	base/vpr_types.h	/^	char *pad_loc_file;$/;"	m	struct:s_placer_opts
pad_loc_type	base/vpr_types.h	/^	enum e_pad_loc_type pad_loc_type;$/;"	m	struct:s_placer_opts	typeref:enum:s_placer_opts::e_pad_loc_type
parent	../../libarchfpga/include/ezxml.h	/^	ezxml_t parent; \/* parent tag, NULL if current tag is root tag *\/$/;"	m	struct:ezxml
parent	power/PowerSpicedComponent.h	/^	PowerSpicedComponent * parent;$/;"	m	class:PowerCallibInputs
parent_mode	../../libarchfpga/include/physical_types.h	/^	t_mode * parent_mode;$/;"	m	struct:s_interconnect
parent_mode	../../libarchfpga/include/physical_types.h	/^	t_mode *parent_mode;$/;"	m	struct:s_pb_type
parent_mode_index	../../libarchfpga/include/physical_types.h	/^	int parent_mode_index;$/;"	m	struct:s_interconnect
parent_node	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_node *parent_node;$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_node
parent_node	route/route_tree_timing.h	/^	struct s_rt_node *parent_node;$/;"	m	struct:s_rt_node	typeref:struct:s_rt_node::s_rt_node
parent_pb	base/vpr_types.h	/^	struct s_pb *parent_pb; \/* pointer to parent node *\/$/;"	m	struct:s_pb	typeref:struct:s_pb::s_pb
parent_pb_graph_node	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_node *parent_pb_graph_node;$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_pb_graph_node
parent_pb_type	../../libarchfpga/include/physical_types.h	/^	struct s_pb_type *parent_pb_type;$/;"	m	struct:s_mode	typeref:struct:s_mode::s_pb_type
parent_pb_type	../../libarchfpga/include/physical_types.h	/^	struct s_pb_type *parent_pb_type;$/;"	m	struct:s_port	typeref:struct:s_port::s_pb_type
parent_pin_class	../../libarchfpga/include/physical_types.h	/^	int *parent_pin_class; \/* [0..depth-1] the grouping of pins that this particular pin belongs to *\/$/;"	m	struct:s_pb_graph_pin
parent_switch	route/route_tree_timing.h	/^	short parent_switch;$/;"	m	struct:s_rt_node
parse_direct_pin_name	util/vpr_utils.c	/^void parse_direct_pin_name(char * src_string, int line, int * start_pin_index, $/;"	f
pass_gate_logic	../../libarchfpga/include/spice_types.h	/^  t_spice_model_pass_gate_logic* pass_gate_logic;$/;"	m	struct:s_spice_model
path	../../libarchfpga/include/spice_types.h	/^  char* path;$/;"	m	struct:s_spice_model_netlist
path	../../libarchfpga/include/spice_types.h	/^  char* path;$/;"	m	struct:s_spice_tech_lib
path_cost	route/route_common.h	/^	float path_cost;$/;"	m	struct:__anon15
path_criticality	base/vpr_types.h	/^	float ** path_criticality;$/;"	m	struct:s_slack
pathfinder_update_cost	route/route_common.c	/^void pathfinder_update_cost(float pres_fac, float acc_fac) {$/;"	f
pathfinder_update_one_cost	route/route_common.c	/^void pathfinder_update_one_cost(struct s_trace *route_segment_start,$/;"	f
pattern_index	../../libarchfpga/include/cad_types.h	/^	int pattern_index; \/* index of pattern that this block is a part of *\/$/;"	m	struct:s_pack_pattern_block
pattern_length	../../libarchfpga/include/physical_types.h	/^  int pattern_length;$/;"	m	struct:s_swseg_pattern_inf
patterns	../../libarchfpga/include/physical_types.h	/^  boolean* patterns;$/;"	m	struct:s_swseg_pattern_inf
pb	base/verilog_writer.h	/^  t_pb *pb;$/;"	m	struct:found_pins
pb	base/vpr_types.h	/^	t_pb *pb;$/;"	m	struct:s_block
pb	base/vpr_types.h	/^	t_pb* pb; \/* pb primitive that this block is packed into *\/$/;"	m	struct:s_logical_block
pb	base/vpr_types.h	/^    t_pb* pb;$/;"	m	struct:s_rr_node
pb_graph_head	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_node *pb_graph_head;$/;"	m	struct:s_type_descriptor
pb_graph_node	../../libarchfpga/include/cad_types.h	/^	t_pb_graph_node *pb_graph_node;$/;"	m	struct:s_cluster_placement_primitive
pb_graph_node	base/vpr_types.h	/^	t_pb_graph_node *pb_graph_node; \/* pointer to pb_graph_node this pb corresponds to *\/$/;"	m	struct:s_pb
pb_graph_pin	base/vpr_types.h	/^	t_pb_graph_pin *pb_graph_pin; \/* pb_graph_pin that this block is connected to *\/$/;"	m	struct:s_tnode
pb_graph_pin	base/vpr_types.h	/^	t_pb_graph_pin *pb_graph_pin;$/;"	m	struct:s_rr_node
pb_list	base/verilog_writer.h	/^}pb_list;$/;"	t	typeref:struct:found_pins
pb_max_internal_delay	base/globals.c	/^float pb_max_internal_delay = UNDEFINED; \/* biggest internal delay of physical block *\/$/;"	v
pb_node_power	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_node_power * pb_node_power;$/;"	m	struct:s_pb_graph_node
pb_pin_density	spice/spice_utils.c	/^float pb_pin_density(t_rr_node* pb_rr_graph, $/;"	f
pb_pin_init_value	spice/spice_utils.c	/^int pb_pin_init_value(t_rr_node* pb_rr_graph, $/;"	f
pb_pin_probability	spice/spice_utils.c	/^float pb_pin_probability(t_rr_node* pb_rr_graph, $/;"	f
pb_stats	base/vpr_types.h	/^	struct s_pb_stats *pb_stats; \/* statistics for current pb *\/$/;"	m	struct:s_pb	typeref:struct:s_pb::s_pb_stats
pb_type	../../libarchfpga/include/cad_types.h	/^	const t_pb_type *pb_type; \/* pb_type that this block is an instance of *\/$/;"	m	struct:s_pack_pattern_block
pb_type	../../libarchfpga/include/physical_types.h	/^	struct s_pb_type *pb_type;$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_pb_type
pb_type	../../libarchfpga/include/physical_types.h	/^	struct s_pb_type *pb_type;$/;"	m	struct:s_type_descriptor	typeref:struct:s_type_descriptor::s_pb_type
pb_type_children	../../libarchfpga/include/physical_types.h	/^	struct s_pb_type *pb_type_children; \/* [0..num_child_pb_types] *\/$/;"	m	struct:s_mode	typeref:struct:s_mode::s_pb_type
pb_type_power	../../libarchfpga/include/physical_types.h	/^	t_pb_type_power * pb_type_power;$/;"	m	struct:s_pb_type
pb_types	../../libarchfpga/include/logic_types.h	/^	struct s_linked_vptr *pb_types; \/* Physical block types that implement this model *\/$/;"	m	struct:s_model	typeref:struct:s_model::s_linked_vptr
pbtype_max_internal_delay	base/globals.c	/^const t_pb_type *pbtype_max_internal_delay = NULL; \/* physical block type with highest internal delay *\/$/;"	v
peak	../../libarchfpga/include/physical_types.h	/^	float peak;$/;"	m	struct:s_chan
period	../../libarchfpga/include/physical_types.h	/^	float period; \/* Period of clock *\/$/;"	m	struct:s_clock_network
period	timing/read_sdc.c	/^	float period;$/;"	m	struct:s_sdc_clock	file:
pfreq	base/vpr_types.h	/^enum pfreq {$/;"	g
pi	../../libarchfpga/include/ezxml.h	/^	char ***pi; \/* processing instructions *\/$/;"	m	struct:ezxml_root
pic_on_screen	base/draw.c	/^static enum pic_type pic_on_screen = NO_PICTURE; \/* What do I draw? *\/$/;"	v	typeref:enum:pic_type	file:
pic_type	base/vpr_types.h	/^enum pic_type {$/;"	g
pin_and_chan_adjacent	route/check_route.c	/^static int pin_and_chan_adjacent(int pin_node, int chan_node) {$/;"	f	file:
pin_class	../../libarchfpga/include/physical_types.h	/^	int *pin_class; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
pin_class	../../libarchfpga/include/physical_types.h	/^	int pin_class;$/;"	m	struct:s_pb_graph_pin
pin_count_in_cluster	../../libarchfpga/include/physical_types.h	/^	int pin_count_in_cluster;$/;"	m	struct:s_pb_graph_pin
pin_count_in_cluster	pack/pb_type_graph.c	/^static int pin_count_in_cluster;$/;"	v	file:
pin_criticality	place/timing_place_lookup.c	/^static float *pin_criticality;$/;"	v	file:
pin_dens	power/power_util.c	/^float pin_dens(t_pb * pb, t_pb_graph_pin * pin) {$/;"	f
pin_height	../../libarchfpga/include/physical_types.h	/^	int *pin_height; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
pin_index_per_side	../../libarchfpga/include/physical_types.h	/^    int* pin_index_per_side;$/;"	m	struct:s_type_descriptor
pin_loc_assignments	../../libarchfpga/include/physical_types.h	/^	char ****pin_loc_assignments; \/* [0..height-1][0..3][0..num_tokens-1][0..string_name] *\/$/;"	m	struct:s_type_descriptor
pin_location_distribution	../../libarchfpga/include/physical_types.h	/^	enum e_pin_location_distr pin_location_distribution;$/;"	m	struct:s_type_descriptor	typeref:enum:s_type_descriptor::e_pin_location_distr
pin_number	../../libarchfpga/include/physical_types.h	/^	int pin_number;$/;"	m	struct:s_pb_graph_pin
pin_power	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin_power * pin_power;$/;"	m	struct:s_pb_graph_pin
pin_prefer_side	base/vpr_types.h	/^    int** pin_prefer_side; \/* [0..num_pins-1][0..3] *\/$/;"	m	struct:s_block
pin_prob	power/power_util.c	/^float pin_prob(t_pb * pb, t_pb_graph_pin * pin) {$/;"	f
pin_ptc_to_side	../../libarchfpga/include/physical_types.h	/^    int* pin_ptc_to_side;$/;"	m	struct:s_type_descriptor
pin_side_count	clb_pin_remap/clb_pin_remap_util.c	/^int pin_side_count(int pin_side[]) {$/;"	f
pin_size	base/draw.c	/^static float tile_width, pin_size;$/;"	v	file:
pin_timing	../../libarchfpga/include/physical_types.h	/^	struct s_pb_graph_pin** pin_timing; \/* primitive ipin to opin timing *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_pin
pin_timing_del_max	../../libarchfpga/include/physical_types.h	/^	float *pin_timing_del_max; \/* primitive ipin to opin timing *\/$/;"	m	struct:s_pb_graph_pin
pin_toggle_initialized	../../libarchfpga/include/physical_types.h	/^	boolean pin_toggle_initialized;$/;"	m	struct:s_port_power
pinlist	../../libarchfpga/include/physical_types.h	/^	int *pinlist; \/* [0..num_pins - 1] *\/$/;"	m	struct:s_class
pinloc	../../libarchfpga/include/physical_types.h	/^	int ***pinloc; \/* [0..height-1][0..3][0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
pl_macros	place/place.c	/^static t_pl_macro * pl_macros = NULL;$/;"	v	file:
place_algorithm	base/vpr_types.h	/^	enum e_place_algorithm place_algorithm;$/;"	m	struct:s_placer_opts	typeref:enum:s_placer_opts::e_place_algorithm
place_and_route	base/place_and_route.c	/^void place_and_route(enum e_operation operation,$/;"	f
place_chan_width	base/vpr_types.h	/^	int place_chan_width;$/;"	m	struct:s_placer_opts
place_clb_pin_remap	base/vpr_types.h	/^    boolean place_clb_pin_remap;$/;"	m	struct:s_placer_opts
place_cost_exp	base/ReadOptions.h	/^	float place_cost_exp;$/;"	m	struct:s_options
place_cost_exp	base/vpr_types.h	/^	float place_cost_exp;$/;"	m	struct:s_placer_opts
place_exp_first	base/ReadOptions.h	/^	float place_exp_first;$/;"	m	struct:s_options
place_exp_last	base/ReadOptions.h	/^	float place_exp_last;$/;"	m	struct:s_options
place_freq	base/vpr_types.h	/^	enum pfreq place_freq;$/;"	m	struct:s_placer_opts	typeref:enum:s_placer_opts::pfreq
placement_index	../../libarchfpga/include/physical_types.h	/^	int placement_index;$/;"	m	struct:s_pb_graph_node
pmos_size	../../libarchfpga/include/spice_types.h	/^  float pmos_size;$/;"	m	struct:s_spice_model_pass_gate_logic
pmos_subckt_name	spice/spice_globals.c	/^char* pmos_subckt_name = "vpr_pmos";$/;"	v
pn_ratio	../../libarchfpga/include/spice_types.h	/^  float pn_ratio;$/;"	m	struct:s_spice_tech_lib
point_to_point_delay_cost	place/place.c	/^static float **point_to_point_delay_cost = NULL;$/;"	v	file:
point_to_point_timing_cost	place/place.c	/^static float **point_to_point_timing_cost = NULL;$/;"	v	file:
poly	base/graphics.c	/^   int poly[3][2]; $/;"	m	struct:__anon4	file:
port	../../libarchfpga/include/physical_types.h	/^	t_port *port;$/;"	m	struct:s_pb_graph_pin
port_class	../../libarchfpga/include/physical_types.h	/^	char * port_class;$/;"	m	struct:s_port
port_index_by_type	../../libarchfpga/include/physical_types.h	/^	int port_index_by_type;$/;"	m	struct:s_port
port_info_initialized	../../libarchfpga/include/physical_types.h	/^	boolean port_info_initialized;$/;"	m	struct:s_interconnect_power
port_power	../../libarchfpga/include/physical_types.h	/^	t_port_power * port_power;$/;"	m	struct:s_port
ports	../../libarchfpga/include/physical_types.h	/^	t_port *ports; \/* [0..num_ports] *\/$/;"	m	struct:s_pb_type
ports	../../libarchfpga/include/spice_types.h	/^  t_spice_model_port* ports;$/;"	m	struct:s_spice_model
post	../../libarchfpga/include/spice_types.h	/^  int post;$/;"	m	struct:s_spice_params
post_place_sync	base/place_and_route.c	/^void post_place_sync(INP int L_num_blocks,$/;"	f
postscript	base/graphics.c	/^postscript (void (*drawscreen) (void)) $/;"	f	file:
power	../../libarchfpga/include/physical_types.h	/^	t_power_arch * power;$/;"	m	struct:s_arch
power	power/PowerSpicedComponent.h	/^	float power;$/;"	m	class:PowerCallibSize
power_MTAs	power/power_sizing.c	/^static double power_MTAs(float W_size) {$/;"	f	file:
power_MTAs_L	power/power_sizing.c	/^static double power_MTAs_L(float L_size) {$/;"	f	file:
power_add_usage	power/power_util.c	/^void power_add_usage(t_power_usage * dest, const t_power_usage * src) {$/;"	f
power_alloc_and_init_pb_pin	power/power.c	/^void power_alloc_and_init_pb_pin(t_pb_graph_pin * pin) {$/;"	f
power_buffer_size	../../libarchfpga/include/physical_types.h	/^	float power_buffer_size;$/;"	m	struct:s_switch_inf
power_buffer_size_from_logical_effort	power/power_util.c	/^float power_buffer_size_from_logical_effort(float C_load) {$/;"	f
power_buffer_type	../../libarchfpga/include/physical_types.h	/^	e_power_buffer_type power_buffer_type;$/;"	m	struct:s_switch_inf
power_calc_buffer_num_stages	power/power_util.c	/^int power_calc_buffer_num_stages(float final_stage_size,$/;"	f
power_calc_buffer_size_from_Cout	power/power_lowlevel.c	/^float power_calc_buffer_size_from_Cout(float C_out) {$/;"	f
power_calc_leakage_gate	power/power_lowlevel.c	/^static float power_calc_leakage_gate(e_tx_type transistor_type, float size) {$/;"	f	file:
power_calc_leakage_st	power/power_lowlevel.c	/^static float power_calc_leakage_st(e_tx_type transistor_type, float size) {$/;"	f	file:
power_calc_leakage_st_pass_transistor	power/power_lowlevel.c	/^static float power_calc_leakage_st_pass_transistor(float size, float v_ds) {$/;"	f	file:
power_calc_mux_v_out	power/power_lowlevel.c	/^float power_calc_mux_v_out(int num_inputs, float transistor_size, float v_in,$/;"	f
power_calc_node_switching	power/power_lowlevel.c	/^float power_calc_node_switching(float capacitance, float density,$/;"	f
power_calc_node_switching_v	power/power_lowlevel.c	/^static float power_calc_node_switching_v(float capacitance, float density,$/;"	f	file:
power_calc_transistor_capacitance	power/power_lowlevel.c	/^static void power_calc_transistor_capacitance(float *C_d, float *C_s,$/;"	f	file:
power_callib_period	power/power_callibrate.h	/^const float power_callib_period = 5e-9;$/;"	v
power_callibrate	power/power_callibrate.c	/^void power_callibrate(void) {$/;"	f
power_compare_buffer_sc_levr	power/power_cmos_tech.c	/^static int power_compare_buffer_sc_levr(const void * key_void,$/;"	f	file:
power_compare_buffer_strength	power/power_cmos_tech.c	/^static int power_compare_buffer_strength(const void * key_void,$/;"	f	file:
power_compare_leakage_pair	power/power_cmos_tech.c	/^static int power_compare_leakage_pair(const void * key_void,$/;"	f	file:
power_compare_transistor_size	power/power_cmos_tech.c	/^static int power_compare_transistor_size(const void * key_void,$/;"	f	file:
power_compare_voltage_pair	power/power_cmos_tech.c	/^static int power_compare_voltage_pair(const void * key_void,$/;"	f	file:
power_component_add_usage	power/power_components.c	/^void power_component_add_usage(t_power_usage * power_usage,$/;"	f
power_component_get_usage	power/power_components.c	/^void power_component_get_usage(t_power_usage * power_usage,$/;"	f
power_component_get_usage_sum	power/power_components.c	/^float power_component_get_usage_sum(e_power_component_type component_idx) {$/;"	f
power_components_init	power/power_components.c	/^void power_components_init(void) {$/;"	f
power_components_uninit	power/power_components.c	/^void power_components_uninit(void) {$/;"	f
power_count_transistor_SRAM_bit	power/power_sizing.c	/^static double power_count_transistor_SRAM_bit(void) {$/;"	f	file:
power_count_transistors_FF	power/power_sizing.c	/^static double power_count_transistors_FF(float size) {$/;"	f	file:
power_count_transistors_LUT	power/power_sizing.c	/^static double power_count_transistors_LUT(int LUT_inputs,$/;"	f	file:
power_count_transistors_buffer	power/power_sizing.c	/^double power_count_transistors_buffer(float buffer_size) {$/;"	f
power_count_transistors_connectionbox	power/power_sizing.c	/^static double power_count_transistors_connectionbox(void) {$/;"	f	file:
power_count_transistors_interc	power/power_sizing.c	/^static double power_count_transistors_interc(t_interconnect * interc) {$/;"	f	file:
power_count_transistors_inv	power/power_sizing.c	/^static double power_count_transistors_inv(float size) {$/;"	f	file:
power_count_transistors_levr	power/power_sizing.c	/^static double power_count_transistors_levr() {$/;"	f	file:
power_count_transistors_mux	power/power_sizing.c	/^static double power_count_transistors_mux(t_mux_arch * mux_arch) {$/;"	f	file:
power_count_transistors_mux_node	power/power_sizing.c	/^static double power_count_transistors_mux_node(t_mux_node * mux_node,$/;"	f	file:
power_count_transistors_pb_node	power/power_sizing.c	/^static double power_count_transistors_pb_node(t_pb_graph_node * pb_node) {$/;"	f	file:
power_count_transistors_primitive	power/power_sizing.c	/^static double power_count_transistors_primitive(t_pb_type * pb_type) {$/;"	f	file:
power_count_transistors_switchbox	power/power_sizing.c	/^static double power_count_transistors_switchbox(t_arch * arch) {$/;"	f	file:
power_count_transistors_trans_gate	power/power_sizing.c	/^static double power_count_transistors_trans_gate(float size) {$/;"	f	file:
power_estimation_method_name	power/power.c	/^static char * power_estimation_method_name($/;"	f	file:
power_find_buffer_sc_levr	power/power_cmos_tech.c	/^void power_find_buffer_sc_levr(t_power_buffer_sc_levr_inf ** lower,$/;"	f
power_find_buffer_strength_inf	power/power_cmos_tech.c	/^void power_find_buffer_strength_inf(t_power_buffer_strength_inf ** lower,$/;"	f
power_find_mux_volt_inf	power/power_cmos_tech.c	/^void power_find_mux_volt_inf(t_power_mux_volt_pair ** lower,$/;"	f
power_find_nmos_leakage	power/power_cmos_tech.c	/^void power_find_nmos_leakage(t_power_nmos_leakage_inf * nmos_leakage_info,$/;"	f
power_find_transistor_info	power/power_cmos_tech.c	/^boolean power_find_transistor_info(t_transistor_size_inf ** lower,$/;"	f
power_get_mux_arch	power/power_util.c	/^t_mux_arch * power_get_mux_arch(int num_mux_inputs, float transistor_size) {$/;"	f
power_init	power/power.c	/^boolean power_init(char * power_out_filepath,$/;"	f
power_init_pb_pins_rec	power/power.c	/^void power_init_pb_pins_rec(t_pb_graph_node * pb_node) {$/;"	f
power_log_msg	power/power_util.c	/^void power_log_msg(e_power_log_type log_type, char * msg) {$/;"	f
power_lowlevel_init	power/power_lowlevel.c	/^void power_lowlevel_init() {$/;"	f
power_method_inherited	../../libarchfpga/read_xml_arch_file.c	/^e_power_estimation_method power_method_inherited($/;"	f
power_method_is_recursive	power/power_util.c	/^boolean power_method_is_recursive(e_power_estimation_method method) {$/;"	f
power_method_is_transistor_level	power/power_util.c	/^boolean power_method_is_transistor_level($/;"	f
power_mux_node_max_inputs	power/power_sizing.c	/^static void power_mux_node_max_inputs(t_mux_node * mux_node,$/;"	f	file:
power_pb_pins_init	power/power.c	/^void power_pb_pins_init() {$/;"	f
power_perc_dynamic	power/power_util.c	/^float power_perc_dynamic(t_power_usage * power_usage) {$/;"	f
power_print_breakdown_component	power/power.c	/^static void power_print_breakdown_component(FILE * fp, char * name,$/;"	f	file:
power_print_breakdown_entry	power/power.c	/^static void power_print_breakdown_entry(FILE * fp, int indent,$/;"	f	file:
power_print_breakdown_pb	power/power.c	/^static void power_print_breakdown_pb(FILE * fp) {$/;"	f	file:
power_print_breakdown_pb_rec	power/power.c	/^static void power_print_breakdown_pb_rec(FILE * fp, t_pb_type * pb_type,$/;"	f	file:
power_print_breakdown_summary	power/power.c	/^static void power_print_breakdown_summary(FILE * fp) {$/;"	f	file:
power_print_spice_comparison	power/power_callibrate.c	/^void power_print_spice_comparison(void) {$/;"	f
power_print_summary	power/power.c	/^static void power_print_summary(FILE * fp, t_vpr_setup vpr_setup) {$/;"	f	file:
power_print_title	power/power_util.c	/^void power_print_title(FILE * fp, char * title) {$/;"	f
power_reset_pb_type	power/power.c	/^static void power_reset_pb_type(t_pb_type * pb_type) {$/;"	f	file:
power_reset_tile_usage	power/power.c	/^static void power_reset_tile_usage(void) {$/;"	f	file:
power_routing_init	power/power.c	/^void power_routing_init(t_det_routing_arch * routing_arch) {$/;"	f
power_scale_usage	power/power_util.c	/^void power_scale_usage(t_power_usage * power_usage, float scale_factor) {$/;"	f
power_size_pb	power/power_sizing.c	/^static void power_size_pb(void) {$/;"	f	file:
power_size_pb_rec	power/power_sizing.c	/^static void power_size_pb_rec(t_pb_graph_node * pb_node) {$/;"	f	file:
power_size_pin_buffers_and_wires	power/power_sizing.c	/^static void power_size_pin_buffers_and_wires(t_pb_graph_pin * pin,$/;"	f	file:
power_size_pin_to_interconnect	power/power_sizing.c	/^static void power_size_pin_to_interconnect(t_interconnect * interc,$/;"	f	file:
power_sizing_init	power/power_sizing.c	/^void power_sizing_init(t_arch * arch) {$/;"	f
power_sum_usage	power/power_util.c	/^float power_sum_usage(t_power_usage * power_usage) {$/;"	f
power_tech_init	power/power_cmos_tech.c	/^void power_tech_init(char * cmos_tech_behavior_filepath) {$/;"	f
power_tech_load_xml_file	power/power_cmos_tech.c	/^void power_tech_load_xml_file(char * cmos_tech_behavior_filepath) {$/;"	f
power_tech_xml_load_component	power/power_cmos_tech.c	/^static void power_tech_xml_load_component(ezxml_t parent,$/;"	f	file:
power_tech_xml_load_components	power/power_cmos_tech.c	/^static void power_tech_xml_load_components(ezxml_t parent) {$/;"	f	file:
power_tech_xml_load_multiplexer_info	power/power_cmos_tech.c	/^static void power_tech_xml_load_multiplexer_info(ezxml_t parent) {$/;"	f	file:
power_tech_xml_load_nmos_st_leakages	power/power_cmos_tech.c	/^static void power_tech_xml_load_nmos_st_leakages(ezxml_t parent) {$/;"	f	file:
power_total	power/power.c	/^e_power_ret_code power_total(float * run_time_s, t_vpr_setup vpr_setup,$/;"	f
power_transistor_area	power/power_sizing.c	/^double power_transistor_area(double num_MTAs) {$/;"	f
power_transistors_for_pb_node	power/power_sizing.c	/^static double power_transistors_for_pb_node(t_pb_graph_node * pb_node) {$/;"	f	file:
power_transistors_per_tile	power/power_sizing.c	/^static double power_transistors_per_tile(t_arch * arch) {$/;"	f	file:
power_uninit	power/power.c	/^boolean power_uninit(void) {$/;"	f
power_usage	../../libarchfpga/include/physical_types.h	/^	t_power_usage power_usage; \/* Power usage of this mode *\/$/;"	m	struct:s_mode_power
power_usage	../../libarchfpga/include/physical_types.h	/^	t_power_usage power_usage; \/* Total power usage of this pb type *\/$/;"	m	struct:s_pb_type_power
power_usage	../../libarchfpga/include/physical_types.h	/^	t_power_usage power_usage;$/;"	m	struct:s_interconnect_power
power_usage_MUX2_transmission	power/power_lowlevel.c	/^void power_usage_MUX2_transmission(t_power_usage * power_usage, float size,$/;"	f
power_usage_blocks	power/power.c	/^static void power_usage_blocks(t_power_usage * power_usage) {$/;"	f	file:
power_usage_buf_for_callibration	power/power_callibrate.c	/^float power_usage_buf_for_callibration(int num_inputs, float transistor_size) {$/;"	f
power_usage_buf_levr_for_callibration	power/power_callibrate.c	/^float power_usage_buf_levr_for_callibration(int num_inputs,$/;"	f
power_usage_buffer	power/power_components.c	/^void power_usage_buffer(t_power_usage * power_usage, float size, float in_prob,$/;"	f
power_usage_bufs_wires	../../libarchfpga/include/physical_types.h	/^	t_power_usage power_usage_bufs_wires; \/* Power dissipated in local buffers and wire switching (Subset of total power) *\/$/;"	m	struct:s_pb_type_power
power_usage_clock	power/power.c	/^static void power_usage_clock(t_power_usage * power_usage,$/;"	f	file:
power_usage_clock_single	power/power.c	/^static void power_usage_clock_single(t_power_usage * power_usage,$/;"	f	file:
power_usage_ff	power/power_components.c	/^void power_usage_ff(t_power_usage * power_usage, float size, float D_prob,$/;"	f
power_usage_ff_for_callibration	power/power_callibrate.c	/^float power_usage_ff_for_callibration(int num_inputs, float transistor_size) {$/;"	f
power_usage_inverter	power/power_lowlevel.c	/^void power_usage_inverter(t_power_usage * power_usage, float in_dens,$/;"	f
power_usage_inverter_irregular	power/power_lowlevel.c	/^void power_usage_inverter_irregular(t_power_usage * power_usage,$/;"	f
power_usage_level_restorer	power/power_lowlevel.c	/^void power_usage_level_restorer(t_power_usage * power_usage,$/;"	f
power_usage_local_buffers_and_wires	power/power.c	/^static void power_usage_local_buffers_and_wires(t_power_usage * power_usage,$/;"	f	file:
power_usage_local_interc_mux	power/power_components.c	/^void power_usage_local_interc_mux(t_power_usage * power_usage, t_pb * pb,$/;"	f
power_usage_local_pin_buffer_and_wire	power/power.c	/^void power_usage_local_pin_buffer_and_wire(t_power_usage * power_usage,$/;"	f
power_usage_local_pin_toggle	power/power.c	/^void power_usage_local_pin_toggle(t_power_usage * power_usage, t_pb * pb,$/;"	f
power_usage_lut	power/power_components.c	/^void power_usage_lut(t_power_usage * power_usage, int lut_size,$/;"	f
power_usage_lut_for_callibration	power/power_callibrate.c	/^float power_usage_lut_for_callibration(int num_inputs, float transistor_size) {$/;"	f
power_usage_mux_for_callibration	power/power_callibrate.c	/^float power_usage_mux_for_callibration(int num_inputs, float transistor_size) {$/;"	f
power_usage_mux_multilevel	power/power_components.c	/^void power_usage_mux_multilevel(t_power_usage * power_usage,$/;"	f
power_usage_mux_rec	power/power_components.c	/^static void power_usage_mux_rec(t_power_usage * power_usage, float * out_prob,$/;"	f	file:
power_usage_mux_singlelevel_dynamic	power/power_lowlevel.c	/^void power_usage_mux_singlelevel_dynamic(t_power_usage * power_usage,$/;"	f
power_usage_mux_singlelevel_static	power/power_lowlevel.c	/^void power_usage_mux_singlelevel_static(t_power_usage * power_usage,$/;"	f
power_usage_pb	power/power.c	/^static void power_usage_pb(t_power_usage * power_usage, t_pb * pb,$/;"	f	file:
power_usage_primitive	power/power.c	/^static void power_usage_primitive(t_power_usage * power_usage, t_pb * pb,$/;"	f	file:
power_usage_routing	power/power.c	/^static void power_usage_routing(t_power_usage * power_usage,$/;"	f	file:
power_usage_wire	power/power_lowlevel.c	/^void power_usage_wire(t_power_usage * power_usage, float capacitance,$/;"	f
power_zero_usage	power/power_util.c	/^void power_zero_usage(t_power_usage * power_usage) {$/;"	f
prefer_side	base/vpr_types.h	/^    int** prefer_side; \/* [0..num_sinks][0..3] *\/$/;"	m	struct:s_net
prefix	../../libarchfpga/include/spice_types.h	/^  char* prefix; $/;"	m	struct:s_spice_model_port
prefix	../../libarchfpga/include/spice_types.h	/^  char* prefix; \/* Prefix when it show up in the spice netlist *\/$/;"	m	struct:s_spice_model
prepacked_data	base/vpr_types.h	/^	t_prepacked_tnode_data * prepacked_data;$/;"	m	struct:s_tnode
pres_cost	route/route_common.h	/^	float pres_cost;$/;"	m	struct:__anon15
pres_fac	pack/cluster_legality.c	/^static float pres_fac;$/;"	v	file:
pres_fac_mult	base/ReadOptions.h	/^	float pres_fac_mult;$/;"	m	struct:s_options
pres_fac_mult	base/vpr_types.h	/^	float pres_fac_mult;$/;"	m	struct:s_router_opts
prev_edge	base/vpr_types.h	/^	int prev_edge;$/;"	m	struct:s_rr_node
prev_edge	route/route_common.h	/^	int prev_edge;$/;"	m	struct:s_heap
prev_edge	route/route_common.h	/^	short prev_edge;$/;"	m	struct:__anon15
prev_edge_in_pack	base/vpr_types.h	/^	int prev_edge_in_pack;$/;"	m	struct:s_rr_node
prev_node	base/vpr_types.h	/^	int prev_node;$/;"	m	struct:s_rr_node
prev_node	route/route_common.h	/^		int prev_node;$/;"	m	union:s_heap::__anon14
prev_node	route/route_common.h	/^	int prev_node;$/;"	m	struct:__anon15
prev_node_in_pack	base/vpr_types.h	/^	int prev_node_in_pack; $/;"	m	struct:s_rr_node
prevconnectiongainincr	base/vpr_types.h	/^	std::map<int, float> prevconnectiongainincr; \/* [0..num_logical_blocks-1] Prev sum to weighted sum of connections to attraction function *\/$/;"	m	struct:s_pb_stats
primitive_feasible	pack/cluster.c	/^static boolean primitive_feasible(int iblk, t_pb *cur_pb) {$/;"	f	file:
primitive_type_and_memory_feasible	pack/cluster.c	/^static boolean primitive_type_and_memory_feasible(int iblk,$/;"	f	file:
primitive_type_feasible	util/vpr_utils.c	/^boolean primitive_type_feasible(int iblk, const t_pb_type *cur_pb_type) {$/;"	f
printClusteredNetlistStats	base/ShowSetup.c	/^void printClusteredNetlistStats() {$/;"	f
print_array	place/timing_place_lookup.c	/^print_array(float **array_to_print,$/;"	f	file:
print_block_criticalities	pack/cluster.c	/^static void print_block_criticalities(const char * fname) {$/;"	f	file:
print_clb_placement	place/place.c	/^static void print_clb_placement(const char *fname) {$/;"	f	file:
print_clustering_timing_info	timing/path_delay.c	/^void print_clustering_timing_info(const char *fname) {$/;"	f
print_clusters	pack/output_blif.c	/^static void print_clusters(t_block *clb, int num_clusters, FILE * fpout) {$/;"	f	file:
print_clusters	pack/output_clustering.c	/^static void print_clusters(t_block *clb, int num_clusters, FILE * fpout) {$/;"	f	file:
print_complete_net_trace	base/vpr_api.c	/^static void print_complete_net_trace(t_trace* trace, const char *file_name) {$/;"	f	file:
print_critical_path	timing/path_delay.c	/^void print_critical_path(const char *fname) {$/;"	f
print_critical_path_node	timing/path_delay2.c	/^float print_critical_path_node(FILE * fp, t_linked_int * critical_path_node) {$/;"	f
print_criticality	timing/path_delay.c	/^void print_criticality(t_slack * slacks, boolean criticality_is_normalized, const char *fname) {$/;"	f
print_distribution	route/rr_graph.c	/^print_distribution(FILE * fptr,$/;"	f	file:
print_global_criticality_stats	timing/path_delay.c	/^static void print_global_criticality_stats(FILE * fp, float ** criticality, const char * singular_name, const char * capitalized_plural_name) {$/;"	f	file:
print_help	../../libarchfpga/main.c	/^void print_help() {$/;"	f
print_int_matrix3	../../libarchfpga/util.c	/^void print_int_matrix3(int ***vptr, int nrmin, int nrmax, int ncmin, int ncmax,$/;"	f
print_interconnect	pack/output_clustering.c	/^static void print_interconnect(int inode, int *column, int num_tabs,$/;"	f	file:
print_lambda	base/stats.c	/^void print_lambda(void) {$/;"	f
print_lut_remapping	timing/path_delay.c	/^void print_lut_remapping(const char *fname) {$/;"	f
print_net_delay	timing/path_delay.c	/^void print_net_delay(float **net_delay, const char *fname) {$/;"	f
print_net_name	pack/output_blif.c	/^static void print_net_name(int inet, int *column, FILE * fpout) {$/;"	f	file:
print_net_name	pack/output_clustering.c	/^static void print_net_name(int inet, int *column, int num_tabs, FILE * fpout) {$/;"	f	file:
print_netlist	pack/print_netlist.c	/^void print_netlist(char *foutput, char *net_file) {$/;"	f
print_open_pb_graph_node	pack/output_clustering.c	/^static void print_open_pb_graph_node(t_pb_graph_node * pb_graph_node,$/;"	f	file:
print_pack_molecules	pack/prepack.c	/^static void print_pack_molecules(INP const char *fname,$/;"	f	file:
print_pb	pack/output_blif.c	/^static void print_pb(FILE *fpout, t_pb * pb, int clb_index) {$/;"	f	file:
print_pb	pack/output_clustering.c	/^static void print_pb(FILE *fpout, t_pb * pb, int pb_index, int tab_depth) {$/;"	f	file:
print_pinnum	pack/print_netlist.c	/^static void print_pinnum(FILE * fp, int pinnum) {$/;"	f	file:
print_place	base/read_place.c	/^void print_place(char *place_file, char *net_file, char *arch_file) {$/;"	f
print_primitive	pack/output_blif.c	/^static void print_primitive(FILE *fpout, int iblk) {$/;"	f	file:
print_primitive_as_blif	timing/path_delay.c	/^static void print_primitive_as_blif (FILE *fpout, int iblk) {$/;"	f	file:
print_relative_pos_distr	place/place_stats.c	/^print_relative_pos_distr(void)$/;"	f
print_route	route/route_common.c	/^void print_route(char *route_file) {$/;"	f
print_rr_indexed_data	route/rr_graph.c	/^void print_rr_indexed_data(FILE * fp, int index) {$/;"	f
print_rr_node	route/rr_graph.c	/^void print_rr_node(FILE * fp, t_rr_node * L_rr_node, int inode) {$/;"	f
print_sink_delays	place/timing_place.c	/^void print_sink_delays(const char *fname) {$/;"	f
print_slack	timing/path_delay.c	/^void print_slack(float ** slack, boolean slack_is_normalized, const char *fname) {$/;"	f
print_spaces	timing/path_delay.c	/^static void print_spaces(FILE * fp, int num_spaces) {$/;"	f	file:
print_spice_cb_mux_testbench	base/vpr_types.h	/^  boolean print_spice_cb_mux_testbench; $/;"	m	struct:s_spice_opts
print_spice_dff_testbench	base/vpr_types.h	/^  boolean print_spice_dff_testbench; $/;"	m	struct:s_spice_opts
print_spice_grid_testbench	base/vpr_types.h	/^  boolean print_spice_grid_testbench; $/;"	m	struct:s_spice_opts
print_spice_lut_testbench	base/vpr_types.h	/^  boolean print_spice_lut_testbench; $/;"	m	struct:s_spice_opts
print_spice_pb_mux_testbench	base/vpr_types.h	/^  boolean print_spice_pb_mux_testbench; $/;"	m	struct:s_spice_opts
print_spice_sb_mux_testbench	base/vpr_types.h	/^  boolean print_spice_sb_mux_testbench; $/;"	m	struct:s_spice_opts
print_spice_top_testbench	base/vpr_types.h	/^  boolean print_spice_top_testbench; $/;"	m	struct:s_spice_opts
print_stat_memristor_buffer	mrfpga/buffer_insertion.c	/^int print_stat_memristor_buffer( char* fname, float buffer_size )$/;"	f
print_stats	pack/output_clustering.c	/^static void print_stats(t_block *clb, int num_clusters) {$/;"	f	file:
print_string	pack/output_blif.c	/^static void print_string(const char *str_ptr, int *column, FILE * fpout) {$/;"	f	file:
print_string	pack/output_clustering.c	/^static void print_string(const char *str_ptr, int *column, int num_tabs, FILE * fpout) {$/;"	f	file:
print_tabs	pack/output_clustering.c	/^static void print_tabs(FILE *fpout, int num_tabs) {$/;"	f	file:
print_tabs	util/vpr_utils.c	/^void print_tabs(FILE * fpout, int num_tab) {$/;"	f
print_timing_constraint_info	timing/path_delay.c	/^static void print_timing_constraint_info(const char *fname) {$/;"	f	file:
print_timing_graph	timing/path_delay.c	/^void print_timing_graph(const char *fname) {$/;"	f
print_timing_graph_as_blif	timing/path_delay.c	/^void print_timing_graph_as_blif (const char *fname, t_model *models) {$/;"	f
print_timing_stats	timing/path_delay.c	/^void print_timing_stats(void) {$/;"	f
print_wirelen_prob_dist	base/stats.c	/^void print_wirelen_prob_dist(void) {$/;"	f
priority	../../libarchfpga/include/physical_types.h	/^	int priority;$/;"	m	struct:s_grid_loc_def
private_cmap	base/graphics.c	/^static Colormap private_cmap; \/* "None" unless a private cmap was allocated. *\/$/;"	v	file:
prob	../../libarchfpga/include/physical_types.h	/^	float prob; \/* Static probability of net assigned to this clock *\/$/;"	m	struct:s_clock_network
probability	../../libarchfpga/include/spice_types.h	/^  float probability;$/;"	m	struct:s_spice_net_info
probability	base/vpr_types.h	/^	float probability;$/;"	m	struct:s_net_power
proc_time	base/place_and_route.h	/^	int proc_time;$/;"	m	struct:s_fmap_cell
proceed	base/graphics.c	/^proceed (void (*drawscreen) (void)) $/;"	f	file:
processComplexBlock	base/read_netlist.c	/^static void processComplexBlock(INOUTP ezxml_t Parent, INOUTP t_block *cb,$/;"	f	file:
processPb	base/read_netlist.c	/^static void processPb(INOUTP ezxml_t Parent, INOUTP t_pb* pb,$/;"	f	file:
processPorts	base/read_netlist.c	/^static void processPorts(INOUTP ezxml_t Parent, INOUTP t_pb* pb,$/;"	f	file:
process_constraints	timing/path_delay.c	/^static void process_constraints(void) {$/;"	f	file:
process_settings	base/read_settings.c	/^static int process_settings(ezxml_t Cur, char ** outv)$/;"	f	file:
process_tech_xml_load_transistor_info	power/power_cmos_tech.c	/^static void process_tech_xml_load_transistor_info(ezxml_t parent) {$/;"	f	file:
prog_trans_size	../../libarchfpga/include/spice_types.h	/^  float prog_trans_size;$/;"	m	struct:s_spice_model
prop	../../libarchfpga/include/physical_types.h	/^	int * prop; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:s_pin_to_pin_annotation
propagate_clock_domain_and_skew	timing/path_delay.c	/^static void propagate_clock_domain_and_skew(int inode) {$/;"	f	file:
ps	base/graphics.c	/^static FILE *ps;$/;"	v	file:
ps_bot	base/graphics.c	/^static float ps_left, ps_right, ps_top, ps_bot; \/* Figure boundaries for *$/;"	v	file:
ps_cnames	base/graphics.c	/^static const char *ps_cnames[NUM_COLOR] = {"white", "black", "grey55", "grey75",$/;"	v	file:
ps_left	base/graphics.c	/^static float ps_left, ps_right, ps_top, ps_bot; \/* Figure boundaries for *$/;"	v	file:
ps_right	base/graphics.c	/^static float ps_left, ps_right, ps_top, ps_bot; \/* Figure boundaries for *$/;"	v	file:
ps_top	base/graphics.c	/^static float ps_left, ps_right, ps_top, ps_bot; \/* Figure boundaries for *$/;"	v	file:
ps_xmult	base/graphics.c	/^static float ps_xmult, ps_ymult;     \/* Transformation for PostScript. *\/$/;"	v	file:
ps_xmult	base/graphics.h	/^	float ps_xmult, ps_ymult;$/;"	m	struct:__anon6
ps_ymult	base/graphics.c	/^static float ps_xmult, ps_ymult;     \/* Transformation for PostScript. *\/$/;"	v	file:
ps_ymult	base/graphics.h	/^	float ps_xmult, ps_ymult;$/;"	m	struct:__anon6
pt_on_object	base/graphics.c	/^int pt_on_object(float x, float y) { }$/;"	f
pt_on_object	base/graphics.c	/^int pt_on_object(int all, float x, float y) {$/;"	f
ptc_num	base/vpr_types.h	/^	short ptc_num;$/;"	m	struct:s_rr_node
ptr	timing/slre.c	/^  const char *ptr;  \/\/ Pointer to the substring$/;"	m	struct:cap	file:
pwh	../../libarchfpga/include/spice_types.h	/^  float pwh;$/;"	m	struct:s_spice_net_info
pwl	../../libarchfpga/include/spice_types.h	/^  float pwl;$/;"	m	struct:s_spice_net_info
quantifier	timing/slre.c	/^static void quantifier(struct slre *r, int prev, int op) {$/;"	f	file:
quit	base/graphics.c	/^quit (void (*drawscreen) (void)) $/;"	f	file:
rc_node	timing/net_delay_types.h	/^	struct s_rc_node *rc_node;$/;"	m	struct:s_linked_rc_ptr	typeref:struct:s_linked_rc_ptr::s_rc_node
re_expand	route/route_tree_timing.h	/^	short re_expand;$/;"	m	struct:s_rt_node
read	../../libarchfpga/ezxml.c	59;"	d	file:
read_activity	base/read_blif.c	/^static void read_activity(char * activity_file) {$/;"	f	file:
read_and_process_blif	base/read_blif.c	/^void read_and_process_blif(char *blif_file,$/;"	f
read_blif	base/read_blif.c	/^static void read_blif(char *blif_file, boolean sweep_hanging_nets_and_inputs,$/;"	f	file:
read_netlist	base/read_netlist.c	/^void read_netlist(INP const char *net_file, INP const t_arch *arch,$/;"	f
read_place	base/read_place.c	/^void read_place(INP const char *place_file, INP const char *arch_file,$/;"	f
read_sdc	timing/read_sdc.c	/^void read_sdc(t_timing_inf timing_inf) {$/;"	f
read_settings	base/ReadOptions.h	/^	int read_settings;$/;"	m	struct:s_options
read_settings_file	base/read_settings.c	/^int read_settings_file(char * file_name, char *** outv)$/;"	f
read_user_pad_loc	base/read_place.c	/^void read_user_pad_loc(char *pad_loc_file) {$/;"	f
read_xml_spice	../../libarchfpga/include/physical_types.h	/^    boolean read_xml_spice;$/;"	m	struct:s_arch
realloc_and_load_pb_graph_pin_ptrs_at_var	pack/pb_type_graph.c	/^static boolean realloc_and_load_pb_graph_pin_ptrs_at_var(INP int line_num,$/;"	f	file:
rec_add_pb_type_keywords_to_list	spice/spice_api.c	/^void rec_add_pb_type_keywords_to_list(t_pb_type* cur_pb_type,$/;"	f	file:
rec_backannotate_rr_node_net_num	spice/spice_api.c	/^void rec_backannotate_rr_node_net_num(int LL_num_rr_nodes,$/;"	f
rec_stat_pb_type_keywords	spice/spice_api.c	/^void rec_stat_pb_type_keywords(t_pb_type* cur_pb_type,$/;"	f	file:
rec_update_net_info_local_rr_node_tree	clb_pin_remap/clb_pin_remap_util.c	/^void rec_update_net_info_local_rr_node_tree(t_pb* src_pb,$/;"	f
recompute_bb_cost	place/place.c	/^static float recompute_bb_cost(void) {$/;"	f	file:
recompute_crit_iter	base/vpr_types.h	/^	int recompute_crit_iter;$/;"	m	struct:s_placer_opts
recompute_occupancy_from_scratch	route/check_route.c	/^static void recompute_occupancy_from_scratch(t_ivec ** clb_opins_used_locally) {$/;"	f	file:
recompute_timing_after	base/ReadOptions.h	/^	int recompute_timing_after;$/;"	m	struct:s_options
recompute_timing_after	base/vpr_types.h	/^	int recompute_timing_after;$/;"	m	struct:s_packer_opts
rect_off_screen	base/graphics.c	/^rect_off_screen (float x1, float y1, float x2, float y2) $/;"	f	file:
redraw_screen	base/draw.c	/^static void redraw_screen() {$/;"	f	file:
regex_match	timing/read_sdc.c	/^static boolean regex_match (char * string, char * regular_expression) {$/;"	f	file:
relapos_rec_s	place/place_stats.c	/^typedef struct relapos_rec_s {$/;"	s	file:
relapos_rec_t	place/place_stats.c	/^} relapos_rec_t;$/;"	t	typeref:struct:relapos_rec_s	file:
relative_length	../../libarchfpga/include/physical_types.h	/^		float relative_length;$/;"	m	union:s_port_power::__anon22
reload_ext_net_rr_terminal_cluster	pack/cluster_legality.c	/^void reload_ext_net_rr_terminal_cluster(void) {$/;"	f
reload_intra_cluster_nets	base/vpr_api.c	/^static void reload_intra_cluster_nets(t_pb *pb) {$/;"	f	file:
relocate	timing/slre.c	/^static void relocate(struct slre *r, int begin, int shift) {$/;"	f	file:
remove_llist_node	spice/linkedlist.c	/^void remove_llist_node(t_llist* cur) { $/;"	f
repeat	../../libarchfpga/include/physical_types.h	/^	int repeat;$/;"	m	struct:s_grid_loc_def
report_structure	base/graphics.c	/^void report_structure(t_report *report) {$/;"	f
report_structure	base/graphics.c	/^void report_structure(t_report*) { }$/;"	f
requeue_primitive	pack/cluster_placement.c	/^static void requeue_primitive($/;"	f	file:
res_val	../../libarchfpga/include/spice_types.h	/^  float res_val;$/;"	m	struct:s_spice_model_wire_param
reserve_locally_used_opins	route/route_common.c	/^void reserve_locally_used_opins(float pres_fac, boolean rip_up_local_opins,$/;"	f
reset_cluster_placement_stats	pack/cluster_placement.c	/^void reset_cluster_placement_stats($/;"	f
reset_common_state	base/graphics.c	/^static void reset_common_state () {$/;"	f	file:
reset_flags	route/check_route.c	/^static void reset_flags(int inet, boolean * connected_to_route) {$/;"	f	file:
reset_legalizer_for_cluster	pack/cluster_legality.c	/^void reset_legalizer_for_cluster(t_block *clb) {$/;"	f
reset_lookahead_pins_used	pack/cluster.c	/^static void reset_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:
reset_path_costs	route/route_common.c	/^void reset_path_costs(void) {$/;"	f
reset_pin_class_scratch_pad_rec	pack/cluster_feasibility_filter.c	/^static void reset_pin_class_scratch_pad_rec($/;"	f	file:
reset_placement	place/timing_place_lookup.c	/^static void reset_placement(void) {$/;"	f	file:
reset_rr_node_route_structs	route/route_common.c	/^void reset_rr_node_route_structs(void) {$/;"	f
reset_rr_node_to_rc_node	timing/net_delay.c	/^void reset_rr_node_to_rc_node(t_linked_rc_ptr * rr_node_to_rc_node,$/;"	f
reset_tried_but_unused_cluster_placements	pack/cluster_placement.c	/^void reset_tried_but_unused_cluster_placements($/;"	f
reset_win32_state	base/graphics.c	/^void reset_win32_state () {$/;"	f
restore_original_device	place/timing_place_lookup.c	/^static void restore_original_device(void) {$/;"	f	file:
restore_routing	route/route_common.c	/^void restore_routing(struct s_trace **best_routing,$/;"	f
restore_routing_cluster	pack/cluster_legality.c	/^void restore_routing_cluster(void) {$/;"	f
resync_pb_graph_nodes_in_pb	base/vpr_api.c	/^static void resync_pb_graph_nodes_in_pb(t_pb_graph_node *pb_graph_node,$/;"	f	file:
resync_post_route_netlist	base/vpr_api.c	/^void resync_post_route_netlist() {$/;"	f
ret_track_swseg_pattern	route/rr_graph_swseg.c	/^enum ret_track_swseg_pattern {$/;"	g	file:
reverse_scaled	../../libarchfpga/include/physical_types.h	/^	boolean reverse_scaled;  \/* Scale by (1-prob) *\/$/;"	m	struct:s_port_power
revert_place_logical_block	pack/cluster.c	/^static void revert_place_logical_block(INP int iblock, INP int max_models) {$/;"	f	file:
rising_edge	timing/read_sdc.c	/^	float rising_edge;$/;"	m	struct:s_sdc_clock	file:
roff	../../libarchfpga/include/spice_types.h	/^  float roff;$/;"	m	struct:s_spice_model
ron	../../libarchfpga/include/spice_types.h	/^  float ron;$/;"	m	struct:s_spice_model
root	base/vpr_types.h	/^	int root; \/* root index of molecule, logical_block_ptrs[root] is ptr to root logical block *\/$/;"	m	struct:s_pack_molecule
root_block	../../libarchfpga/include/cad_types.h	/^	t_pack_pattern_block *root_block; \/* root block used by this pattern *\/$/;"	m	struct:s_pack_patterns
root_passes_early_filter	pack/cluster_placement.c	/^static boolean root_passes_early_filter(INP t_pb_graph_node *root, INP t_pack_molecule *molecule, INP int clb_index) {$/;"	f	file:
rotate_shift_swseg_pattern	route/rr_graph_swseg.c	/^boolean* rotate_shift_swseg_pattern(int pattern_length,$/;"	f	file:
route_bb	route/route_common.c	/^struct s_bb *route_bb = NULL; \/* [0..num_nets-1]. Limits area in which each  *\/$/;"	v	typeref:struct:s_bb
route_type	base/vpr_types.h	/^	enum e_route_type route_type;$/;"	m	struct:s_router_opts	typeref:enum:s_router_opts::e_route_type
router_algorithm	base/vpr_types.h	/^	enum e_router_algorithm router_algorithm;$/;"	m	struct:s_router_opts	typeref:enum:s_router_opts::e_router_algorithm
routing_spice_file_name	spice/spice_globals.c	/^char* routing_spice_file_name = "routing.sp";$/;"	v
routing_stats	base/stats.c	/^void routing_stats(boolean full_stats, enum e_route_type route_type,$/;"	f
rr_blk_source	base/globals.c	/^int **rr_blk_source = NULL; \/* [0..(num_blocks-1)][0..(num_class-1)] *\/$/;"	v
rr_blk_source	base/globals_declare.h	/^int **rr_blk_source; \/* [0..num_blocks-1][0..num_class-1] *\/$/;"	v
rr_graph	base/vpr_types.h	/^	struct s_rr_node *rr_graph; \/* pointer to rr_graph connecting pbs of cluster *\/$/;"	m	struct:s_pb	typeref:struct:s_pb::s_rr_node
rr_graph_externals	route/rr_graph.c	/^static void rr_graph_externals(t_timing_inf timing_inf,$/;"	f	file:
rr_indexed_data	base/globals.c	/^t_rr_indexed_data *rr_indexed_data = NULL; \/* [0..(num_rr_indexed_data-1)] *\/$/;"	v
rr_indexed_data	base/globals_declare.h	/^t_rr_indexed_data *rr_indexed_data; \/* [0 .. num_rr_indexed_data-1] *\/$/;"	v
rr_mem_ch	pack/cluster_legality.c	/^static t_chunk rr_mem_ch = {NULL, 0, NULL};$/;"	v	file:
rr_mem_ch	route/rr_graph.c	/^static t_chunk rr_mem_ch = {NULL, 0, NULL};$/;"	v	file:
rr_modified_head	route/route_common.c	/^static struct s_linked_f_pointer *rr_modified_head = NULL;$/;"	v	typeref:struct:s_linked_f_pointer	file:
rr_node	base/globals.c	/^t_rr_node *rr_node = NULL; \/* [0..(num_rr_nodes-1)] *\/$/;"	v
rr_node	base/globals_declare.h	/^t_rr_node *rr_node; \/* [0..num_rr_nodes-1]          *\/$/;"	v
rr_node_color	base/draw.c	/^static enum color_types *rr_node_color = NULL;$/;"	v	typeref:enum:color_types	file:
rr_node_drive_switch_box	spice/spice_routing.c	/^int rr_node_drive_switch_box(t_rr_node* src_rr_node,$/;"	f
rr_node_indices	base/globals.c	/^t_ivec ***rr_node_indices = NULL;$/;"	v
rr_node_indices	base/globals_declare.h	/^t_ivec ***rr_node_indices;$/;"	v
rr_node_intrinsic_cost	pack/cluster_legality.c	/^static float rr_node_intrinsic_cost(int inode) {$/;"	f	file:
rr_node_is_global_clb_ipin	route/check_rr_graph.c	/^static boolean rr_node_is_global_clb_ipin(int inode) {$/;"	f	file:
rr_node_power	power/power.c	/^static t_rr_node_power * rr_node_power;$/;"	v	file:
rr_node_route_inf	route/route_common.c	/^t_rr_node_route_inf *rr_node_route_inf = NULL; \/* [0..num_rr_nodes-1] *\/$/;"	v
rr_node_to_pb_mapping	base/vpr_types.h	/^	struct s_pb **rr_node_to_pb_mapping; \/* [0..num_local_rr_nodes-1] pointer look-up of which pb this rr_node belongs based on index, NULL if pb does not exist  *\/$/;"	m	struct:s_pb	typeref:struct:s_pb::s_pb
rr_node_to_rt_node	route/route_tree_timing.c	/^static t_rt_node **rr_node_to_rt_node = NULL; \/* [0..num_rr_nodes-1] *\/$/;"	v	file:
rram_design_tech	spice/spice_globals.c	/^int rram_design_tech = 0;$/;"	v
rram_pass_tran_value	../../libarchfpga/include/arch_types_mrfpga.h	/^  float rram_pass_tran_value;$/;"	m	struct:s_arch_mrfpga
rram_pass_tran_value	mrfpga/mrfpga_globals.c	/^float rram_pass_tran_value = 0;$/;"	v
rram_veriloga_file_name	spice/spice_globals.c	/^char* rram_veriloga_file_name = "rram_behavior.va";$/;"	v
rt_edge_free_list	route/route_tree_timing.c	/^static t_linked_rt_edge *rt_edge_free_list = NULL;$/;"	v	file:
rt_node_free_list	route/route_tree_timing.c	/^static t_rt_node *rt_node_free_list = NULL;$/;"	v	file:
rt_node_of_sink	place/timing_place_lookup.c	/^static t_rt_node **rt_node_of_sink;$/;"	v	file:
run_hspice_shell_script_name	spice/spice_run_scripts.c	/^static char* run_hspice_shell_script_name = "run_hspice_sim.sh";$/;"	v	file:
s	../../libarchfpga/include/ezxml.h	/^	char *s; \/* start of work area *\/$/;"	m	struct:ezxml_root
s_TokenPair	base/vpr_types.h	/^struct s_TokenPair {$/;"	s
s_annealing_sched	base/vpr_types.h	/^struct s_annealing_sched {$/;"	s
s_arch	../../libarchfpga/include/physical_types.h	/^struct s_arch {$/;"	s
s_arch_mrfpga	../../libarchfpga/include/arch_types_mrfpga.h	/^struct s_arch_mrfpga {$/;"	s
s_bb	base/vpr_types.h	/^struct s_bb {$/;"	s
s_block	base/vpr_types.h	/^struct s_block {$/;"	s
s_buffer_inf	../../libarchfpga/include/arch_types_mrfpga.h	/^struct s_buffer_inf { $/;"	s
s_buffer_plan	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	s	file:
s_buffer_plan_list	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_list { t_buffer_plan_node* front; } t_buffer_plan_list;$/;"	s	file:
s_buffer_plan_node	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_node { t_buffer_plan value; struct s_buffer_plan_node* next;} t_buffer_plan_node;$/;"	s	file:
s_chan	../../libarchfpga/include/physical_types.h	/^typedef struct s_chan {$/;"	s
s_chan_width_dist	../../libarchfpga/include/physical_types.h	/^typedef struct s_chan_width_dist {$/;"	s
s_chunk	../../libarchfpga/include/util.h	/^typedef struct s_chunk {$/;"	s
s_class	../../libarchfpga/include/physical_types.h	/^struct s_class {$/;"	s
s_clb_grid	../../libarchfpga/include/physical_types.h	/^struct s_clb_grid {$/;"	s
s_clb_to_clb_directs	route/rr_graph.c	/^typedef struct s_clb_to_clb_directs {$/;"	s	file:
s_clock	base/vpr_types.h	/^typedef struct s_clock {$/;"	s
s_clock_arch	../../libarchfpga/include/physical_types.h	/^struct s_clock_arch {$/;"	s
s_clock_network	../../libarchfpga/include/physical_types.h	/^struct s_clock_network {$/;"	s
s_cluster_placement_primitive	../../libarchfpga/include/cad_types.h	/^typedef struct s_cluster_placement_primitive {$/;"	s
s_cluster_placement_stats	base/vpr_types.h	/^typedef struct s_cluster_placement_stats {$/;"	s
s_det_routing_arch	base/vpr_types.h	/^struct s_det_routing_arch {$/;"	s
s_direct_inf	../../libarchfpga/include/physical_types.h	/^typedef struct s_direct_inf {$/;"	s
s_file_name_opts	base/vpr_types.h	/^struct s_file_name_opts {$/;"	s
s_fmap_cell	base/place_and_route.h	/^typedef struct s_fmap_cell {$/;"	s
s_grid_loc_def	../../libarchfpga/include/physical_types.h	/^typedef struct s_grid_loc_def {$/;"	s
s_grid_tile	base/vpr_types.h	/^typedef struct s_grid_tile {$/;"	s
s_hash	util/hash.h	/^struct s_hash {$/;"	s
s_hash_iterator	util/hash.h	/^struct s_hash_iterator {$/;"	s
s_heap	route/route_common.h	/^struct s_heap {$/;"	s
s_interconnect	../../libarchfpga/include/physical_types.h	/^struct s_interconnect {$/;"	s
s_interconnect_pins	../../libarchfpga/include/physical_types.h	/^struct s_interconnect_pins {$/;"	s
s_interconnect_power	../../libarchfpga/include/physical_types.h	/^struct s_interconnect_power {$/;"	s
s_io	base/vpr_types.h	/^typedef struct s_io {$/;"	s
s_ivec	../../libarchfpga/include/util.h	/^typedef struct s_ivec {$/;"	s
s_legal_pos	place/place.c	/^typedef struct s_legal_pos {$/;"	s	file:
s_linked_edge	route/rr_graph_util.h	/^struct s_linked_edge {$/;"	s
s_linked_f_pointer	base/vpr_types.h	/^struct s_linked_f_pointer {$/;"	s
s_linked_int	../../libarchfpga/include/util.h	/^typedef struct s_linked_int {$/;"	s
s_linked_rc_edge	timing/net_delay_types.h	/^struct s_linked_rc_edge {$/;"	s
s_linked_rc_ptr	timing/net_delay_types.h	/^struct s_linked_rc_ptr {$/;"	s
s_linked_rt_edge	route/route_tree_timing.h	/^struct s_linked_rt_edge {$/;"	s
s_linked_vptr	../../libarchfpga/include/util.h	/^typedef struct s_linked_vptr {$/;"	s
s_llist	spice/linkedlist.h	/^struct s_llist$/;"	s
s_log	power/power.h	/^struct s_log {$/;"	s
s_logical_block	base/vpr_types.h	/^typedef struct s_logical_block {$/;"	s
s_memristor_inf	../../libarchfpga/include/arch_types_mrfpga.h	/^struct s_memristor_inf { $/;"	s
s_mode	../../libarchfpga/include/physical_types.h	/^struct s_mode {$/;"	s
s_mode_power	../../libarchfpga/include/physical_types.h	/^struct s_mode_power {$/;"	s
s_model	../../libarchfpga/include/logic_types.h	/^typedef struct s_model {$/;"	s
s_model_chain_pattern	../../libarchfpga/include/cad_types.h	/^typedef struct s_model_chain_pattern {$/;"	s
s_model_ports	../../libarchfpga/include/logic_types.h	/^typedef struct s_model_ports {$/;"	s
s_model_stats	base/read_blif.c	/^struct s_model_stats {$/;"	s	file:
s_molecule_link	pack/cluster.c	/^struct s_molecule_link {$/;"	s	file:
s_mux	route/rr_graph.c	/^typedef struct s_mux {$/;"	s	file:
s_mux_arch	power/power.h	/^struct s_mux_arch {$/;"	s
s_mux_node	power/power.h	/^struct s_mux_node {$/;"	s
s_mux_size_distribution	route/rr_graph.c	/^typedef struct s_mux_size_distribution {$/;"	s	file:
s_net	base/vpr_types.h	/^typedef struct s_net {$/;"	s
s_net_power	base/vpr_types.h	/^struct s_net_power {$/;"	s
s_options	base/ReadOptions.h	/^struct s_options {$/;"	s
s_override_constraint	base/vpr_types.h	/^typedef struct s_override_constraint {$/;"	s
s_pack_molecule	base/vpr_types.h	/^typedef struct s_pack_molecule {$/;"	s
s_pack_pattern_block	../../libarchfpga/include/cad_types.h	/^typedef struct s_pack_pattern_block {$/;"	s
s_pack_pattern_connections	../../libarchfpga/include/cad_types.h	/^typedef struct s_pack_pattern_connections {$/;"	s
s_pack_patterns	../../libarchfpga/include/cad_types.h	/^typedef struct s_pack_patterns {$/;"	s
s_packer_opts	base/vpr_types.h	/^struct s_packer_opts {$/;"	s
s_pb	base/vpr_types.h	/^typedef struct s_pb {$/;"	s
s_pb_graph_edge	../../libarchfpga/include/physical_types.h	/^struct s_pb_graph_edge {$/;"	s
s_pb_graph_node	../../libarchfpga/include/physical_types.h	/^struct s_pb_graph_node {$/;"	s
s_pb_graph_node_power	../../libarchfpga/include/physical_types.h	/^struct s_pb_graph_node_power {$/;"	s
s_pb_graph_pin	../../libarchfpga/include/physical_types.h	/^struct s_pb_graph_pin {$/;"	s
s_pb_graph_pin_power	../../libarchfpga/include/physical_types.h	/^struct s_pb_graph_pin_power {$/;"	s
s_pb_stats	base/vpr_types.h	/^typedef struct s_pb_stats {$/;"	s
s_pb_type	../../libarchfpga/include/physical_types.h	/^struct s_pb_type {$/;"	s
s_pb_type_power	../../libarchfpga/include/physical_types.h	/^struct s_pb_type_power {$/;"	s
s_pin_to_pin_annotation	../../libarchfpga/include/physical_types.h	/^struct s_pin_to_pin_annotation {$/;"	s
s_pl_blocks_to_be_moved	place/place.c	/^typedef struct s_pl_blocks_to_be_moved {$/;"	s	file:
s_pl_macro	place/place_macro.h	/^typedef struct s_pl_macro{$/;"	s
s_pl_macro_member	place/place_macro.h	/^typedef struct s_pl_macro_member{$/;"	s
s_pl_moved_block	place/place.c	/^typedef struct s_pl_moved_block {$/;"	s	file:
s_place_region	base/vpr_types.h	/^struct s_place_region {$/;"	s
s_placer_opts	base/vpr_types.h	/^struct s_placer_opts {$/;"	s
s_port	../../libarchfpga/include/physical_types.h	/^struct s_port {$/;"	s
s_port_power	../../libarchfpga/include/physical_types.h	/^struct s_port_power {$/;"	s
s_power_arch	../../libarchfpga/include/physical_types.h	/^struct s_power_arch {$/;"	s
s_power_breakdown	power/power_components.h	/^struct s_power_breakdown {$/;"	s
s_power_buffer_sc_levr_inf	power/power.h	/^struct s_power_buffer_sc_levr_inf {$/;"	s
s_power_buffer_size_inf	power/power.h	/^struct s_power_buffer_size_inf {$/;"	s
s_power_buffer_strength_inf	power/power.h	/^struct s_power_buffer_strength_inf {$/;"	s
s_power_commonly_used	power/power.h	/^struct s_power_commonly_used {$/;"	s
s_power_mux_info	power/power.h	/^struct s_power_mux_info {$/;"	s
s_power_mux_volt_inf	power/power.h	/^struct s_power_mux_volt_inf {$/;"	s
s_power_mux_volt_pair	power/power.h	/^struct s_power_mux_volt_pair {$/;"	s
s_power_nmos_leakage_inf	power/power.h	/^struct s_power_nmos_leakage_inf {$/;"	s
s_power_nmos_leakage_pair	power/power.h	/^struct s_power_nmos_leakage_pair {$/;"	s
s_power_nmos_mux_inf	power/power.h	/^struct s_power_nmos_mux_inf {$/;"	s
s_power_opts	base/vpr_types.h	/^struct s_power_opts {$/;"	s
s_power_output	power/power.h	/^struct s_power_output {$/;"	s
s_power_tech	power/power.h	/^struct s_power_tech {$/;"	s
s_power_usage	../../libarchfpga/include/physical_types.h	/^struct s_power_usage {$/;"	s
s_prepacked_tnode_data	base/vpr_types.h	/^typedef struct s_prepacked_tnode_data {$/;"	s
s_rc_node	timing/net_delay_types.h	/^struct s_rc_node {$/;"	s
s_router_opts	base/vpr_types.h	/^struct s_router_opts {$/;"	s
s_rr_indexed_data	base/vpr_types.h	/^typedef struct s_rr_indexed_data {$/;"	s
s_rr_node	base/vpr_types.h	/^struct s_rr_node {$/;"	s
s_rr_node_power	power/power.h	/^struct s_rr_node_power {$/;"	s
s_rt_node	route/route_tree_timing.h	/^struct s_rt_node {$/;"	s
s_sdc_clock	timing/read_sdc.c	/^typedef struct s_sdc_clock {$/;"	s	file:
s_sdc_exclusive_group	timing/read_sdc.c	/^typedef struct s_sdc_exclusive_group {$/;"	s	file:
s_seg_details	base/vpr_types.h	/^typedef struct s_seg_details {$/;"	s
s_segment_inf	../../libarchfpga/include/physical_types.h	/^typedef struct s_segment_inf {$/;"	s
s_slack	base/vpr_types.h	/^typedef struct s_slack {$/;"	s
s_solution_inf	power/power.h	/^struct s_solution_inf {$/;"	s
s_spice	../../libarchfpga/include/spice_types.h	/^struct s_spice {$/;"	s
s_spice_meas_params	../../libarchfpga/include/spice_types.h	/^struct s_spice_meas_params {$/;"	s
s_spice_model	../../libarchfpga/include/spice_types.h	/^struct s_spice_model {$/;"	s
s_spice_model_buffer	../../libarchfpga/include/spice_types.h	/^struct s_spice_model_buffer {$/;"	s
s_spice_model_netlist	../../libarchfpga/include/spice_types.h	/^struct s_spice_model_netlist {$/;"	s
s_spice_model_pass_gate_logic	../../libarchfpga/include/spice_types.h	/^struct s_spice_model_pass_gate_logic {$/;"	s
s_spice_model_port	../../libarchfpga/include/spice_types.h	/^struct s_spice_model_port {$/;"	s
s_spice_model_wire_param	../../libarchfpga/include/spice_types.h	/^struct s_spice_model_wire_param {$/;"	s
s_spice_mux_arch	../../libarchfpga/include/spice_types.h	/^struct s_spice_mux_arch {$/;"	s
s_spice_mux_model	../../libarchfpga/include/spice_types.h	/^struct s_spice_mux_model {$/;"	s
s_spice_net_info	../../libarchfpga/include/spice_types.h	/^struct s_spice_net_info {$/;"	s
s_spice_opts	base/vpr_types.h	/^struct s_spice_opts {$/;"	s
s_spice_params	../../libarchfpga/include/spice_types.h	/^struct s_spice_params {$/;"	s
s_spice_stimulate_params	../../libarchfpga/include/spice_types.h	/^struct s_spice_stimulate_params {$/;"	s
s_spice_tech_lib	../../libarchfpga/include/spice_types.h	/^struct s_spice_tech_lib {$/;"	s
s_spice_transistor_type	../../libarchfpga/include/spice_types.h	/^struct s_spice_transistor_type {$/;"	s
s_sram_inf	../../libarchfpga/include/spice_types.h	/^struct s_sram_inf {$/;"	s
s_switch_inf	../../libarchfpga/include/physical_types.h	/^typedef struct s_switch_inf {$/;"	s
s_swseg_pattern_inf	../../libarchfpga/include/physical_types.h	/^struct s_swseg_pattern_inf {$/;"	s
s_tedge	base/vpr_types.h	/^typedef struct s_tedge {$/;"	s
s_timing_constraints	base/vpr_types.h	/^typedef struct s_timing_constraints { \/* Container structure for all SDC timing constraints. $/;"	s
s_timing_inf	../../libarchfpga/include/physical_types.h	/^typedef struct s_timing_inf {$/;"	s
s_timing_stats	base/vpr_types.h	/^typedef struct s_timing_stats {$/;"	s
s_tnode	base/vpr_types.h	/^typedef struct s_tnode {$/;"	s
s_token	util/token.h	/^struct s_token {$/;"	s
s_trace	base/vpr_types.h	/^typedef struct s_trace {$/;"	s
s_transistor_inf	power/power.h	/^struct s_transistor_inf {$/;"	s
s_transistor_size_inf	power/power.h	/^struct s_transistor_size_inf {$/;"	s
s_type_descriptor	../../libarchfpga/include/physical_types.h	/^struct s_type_descriptor \/* TODO rename this.  maybe physical type descriptor or complex logic block or physical logic block*\/$/;"	s
s_vpr_setup	base/vpr_types.h	/^typedef struct s_vpr_setup {$/;"	s
sat_blks_pins_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^int sat_blks_pins_prefer_side(int n_nets, t_net* nets, $/;"	f
sat_one_blk_pins_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^int sat_one_blk_pins_prefer_side(int n_nets, t_net* nets, $/;"	f
save_and_reset_routing_cluster	pack/cluster_legality.c	/^void save_and_reset_routing_cluster(void) {$/;"	f
save_best_buffer_list	mrfpga/buffer_insertion.c	/^static void save_best_buffer_list( t_linked_int* best_list )$/;"	f	file:
save_best_timing	mrfpga/buffer_insertion.c	/^static void save_best_timing( float* sink_delay, t_linked_int* index, float* net_delay )$/;"	f	file:
save_cluster_solution	pack/cluster_legality.c	/^void save_cluster_solution(void) {$/;"	f
save_routing	route/route_common.c	/^void save_routing(struct s_trace **best_routing,$/;"	f
saved_base_cost	base/vpr_types.h	/^	float saved_base_cost;$/;"	m	struct:s_rr_indexed_data
saved_net_rr_terminals	pack/cluster_legality.c	/^static int **saved_net_rr_terminals;$/;"	v	file:
saved_num_nets_in_cluster	pack/cluster_legality.c	/^static int saved_num_nets_in_cluster;$/;"	v	file:
saved_xleft	base/graphics.c	/^static float saved_xleft, saved_xright, saved_ytop, saved_ybot; $/;"	v	file:
saved_xright	base/graphics.c	/^static float saved_xleft, saved_xright, saved_ytop, saved_ybot; $/;"	v	file:
saved_ybot	base/graphics.c	/^static float saved_xleft, saved_xright, saved_ytop, saved_ybot; $/;"	v	file:
saved_ytop	base/graphics.c	/^static float saved_xleft, saved_xright, saved_ytop, saved_ybot; $/;"	v	file:
sb	../../libarchfpga/include/physical_types.h	/^	boolean *sb;$/;"	m	struct:s_segment_inf
sb	base/vpr_types.h	/^	boolean *sb;$/;"	m	struct:s_seg_details
sb_len	../../libarchfpga/include/physical_types.h	/^	int sb_len;$/;"	m	struct:s_segment_inf
sc_levr	power/power.h	/^	float sc_levr;$/;"	m	struct:s_power_buffer_sc_levr_inf
sc_levr_inf	power/power.h	/^	t_power_buffer_sc_levr_inf * sc_levr_inf;$/;"	m	struct:s_power_buffer_strength_inf
sc_no_levr	power/power.h	/^	float sc_no_levr;$/;"	m	struct:s_power_buffer_strength_inf
scale_factor	power/PowerSpicedComponent.c	/^float PowerSpicedComponent::scale_factor(int num_inputs,$/;"	f	class:PowerSpicedComponent
scaled_by_pin	../../libarchfpga/include/physical_types.h	/^	t_pb_graph_pin * scaled_by_pin;$/;"	m	struct:s_pb_graph_pin_power
scaled_by_port	../../libarchfpga/include/physical_types.h	/^	t_port * scaled_by_port;$/;"	m	struct:s_port_power
scaled_by_port_pin_idx	../../libarchfpga/include/physical_types.h	/^	int scaled_by_port_pin_idx;$/;"	m	struct:s_port_power
sched_type	base/vpr_types.h	/^enum sched_type {$/;"	g
scratch_pad	../../libarchfpga/include/physical_types.h	/^	int scratch_pad; \/* temporary data structure useful to store traversal info *\/$/;"	m	struct:s_pb_graph_pin
screen_num	base/graphics.c	/^static int screen_num;$/;"	v	file:
sdc	timing/read_sdc.c	/^static FILE *sdc;$/;"	v	file:
sdc_clocks	timing/read_sdc.c	/^t_sdc_clock * sdc_clocks = NULL; \/* List of clock periods and offsets from create_clock commands *\/$/;"	v
sdc_file_name	base/vpr_types.h	/^	char *sdc_file_name;$/;"	m	struct:s_packer_opts
sdf_DFF_delay_printing	base/verilog_writer.c	/^void sdf_DFF_delay_printing(FILE *SDF , t_pb *pb)$/;"	f
sdf_LUT_delay_printing	base/verilog_writer.c	/^void sdf_LUT_delay_printing(FILE *SDF , t_pb *pb)$/;"	f
search_llist_tail	spice/linkedlist.c	/^t_llist* search_llist_tail(t_llist* head) {$/;"	f
search_mapped_block	spice/spice_utils.c	/^t_block* search_mapped_block(int x, int y, int z) {$/;"	f
search_mux_linked_list	spice/spice_mux.c	/^t_llist* search_mux_linked_list(t_llist* mux_head,$/;"	f
search_swseg_pattern_seg_len	route/rr_graph_swseg.c	/^t_swseg_pattern_inf* search_swseg_pattern_seg_len(INP int num_swseg_pattern,$/;"	f	file:
search_tapbuf_llist_same_settings	spice/spice_subckt.c	/^int search_tapbuf_llist_same_settings(t_llist* head,$/;"	f	file:
seed	base/vpr_types.h	/^	int seed;$/;"	m	struct:s_placer_opts
seg_direction_type	../../libarchfpga/include/physical_types.h	/^  enum e_directionality seg_direction_type;$/;"	m	struct:s_swseg_pattern_inf	typeref:enum:s_swseg_pattern_inf::e_directionality
seg_index	base/vpr_types.h	/^	int seg_index;$/;"	m	struct:s_rr_indexed_data
seg_index_of_cblock	route/rr_graph_util.c	/^int seg_index_of_cblock(t_rr_type from_rr_type, int to_node) {$/;"	f
seg_index_of_sblock	route/rr_graph_util.c	/^int seg_index_of_sblock(int from_node, int to_node) {$/;"	f
seg_length	../../libarchfpga/include/physical_types.h	/^  int seg_length;$/;"	m	struct:s_swseg_pattern_inf
seg_switch	../../libarchfpga/include/physical_types.h	/^    short seg_switch;$/;"	m	struct:s_segment_inf
seg_switch	base/vpr_types.h	/^    short seg_switch;$/;"	m	struct:s_seg_details
segments	spice/spice_mux_testbench.c	/^static t_segment_inf* segments = NULL;$/;"	v	file:
selected_input	power/power.h	/^	short selected_input; \/* Input index that is selected *\/$/;"	m	struct:s_rr_node_power
setAllEchoFileEnabled	base/ReadOptions.c	/^void setAllEchoFileEnabled(boolean value) {$/;"	f
setEchoEnabled	base/ReadOptions.c	/^void setEchoEnabled(boolean echo_enabled) {$/;"	f
setEchoFileEnabled	base/ReadOptions.c	/^void setEchoFileEnabled(enum e_echo_files echo_option, boolean value) {$/;"	f
setEchoFileName	base/ReadOptions.c	/^void setEchoFileName(enum e_echo_files echo_option, const char *name) {$/;"	f
setOutputFileName	base/ReadOptions.c	/^void setOutputFileName(enum e_output_files ename, const char *name, const char *default_name) {$/;"	f
set_and_balance_arrival_time	timing/path_delay.c	/^static void set_and_balance_arrival_time(int to_node, int from_node, float Tdel, boolean do_lut_input_balancing) {$/;"	f	file:
set_blk_net_one_sink_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^void set_blk_net_one_sink_prefer_side(int* prefer_side, \/* [0..3] array, should be allocated before *\/$/;"	f
set_draw_mode	base/graphics.c	/^void set_draw_mode (enum e_draw_mode draw_mode) { }$/;"	f
set_draw_mode	base/graphics.c	/^void set_draw_mode (enum e_draw_mode draw_mode) {$/;"	f
set_graphics_state	base/draw.c	/^void set_graphics_state(boolean show_graphics_val, int gr_automode_val,$/;"	f
set_jump_offset	timing/slre.c	/^static void set_jump_offset(struct slre *r, int pc, int offset) {$/;"	f	file:
set_keypress_input	base/graphics.c	/^void set_keypress_input (bool enable) {$/;"	f
set_keypress_input	base/graphics.c	/^void set_keypress_input (bool) { }$/;"	f
set_max_pins_per_side	base/SetupVPR.c	/^static void set_max_pins_per_side() {$/;"	f	file:
set_mode_cluster_placement_stats	pack/cluster_placement.c	/^void set_mode_cluster_placement_stats(INP t_pb_graph_node *pb_graph_node,$/;"	f
set_mouse_move_input	base/graphics.c	/^void set_mouse_move_input (bool enable) {$/;"	f
set_mouse_move_input	base/graphics.c	/^void set_mouse_move_input (bool) { }$/;"	f
set_pb_graph_mode	pack/cluster_legality.c	/^void set_pb_graph_mode(t_pb_graph_node *pb_graph_node, int mode, int isOn) {$/;"	f
set_src_bottom_side_net_one_sink_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^void set_src_bottom_side_net_one_sink_prefer_side(int* prefer_side, $/;"	f
set_src_left_side_net_one_sink_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^void set_src_left_side_net_one_sink_prefer_side(int* prefer_side, $/;"	f
set_src_right_side_net_one_sink_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^void set_src_right_side_net_one_sink_prefer_side(int* prefer_side, $/;"	f
set_src_top_side_net_one_sink_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^void set_src_top_side_net_one_sink_prefer_side(int* prefer_side, $/;"	f
set_unroute_blk_pins_prefer_sides	clb_pin_remap/place_clb_pin_remap.c	/^int set_unroute_blk_pins_prefer_sides(int n_blk, t_block* blk) {$/;"	f
setcolor	base/graphics.c	/^void setcolor (int cindex) $/;"	f
setcolor	base/graphics.c	/^void setcolor (int cindex) { }$/;"	f
setcolor	base/graphics.c	/^void setcolor (string cname) {$/;"	f
setfontsize	base/graphics.c	/^void setfontsize (int pointsize) $/;"	f
setfontsize	base/graphics.c	/^void setfontsize (int pointsize) { }$/;"	f
setlinestyle	base/graphics.c	/^void setlinestyle (int linestyle) $/;"	f
setlinestyle	base/graphics.c	/^void setlinestyle (int linestyle) { }$/;"	f
setlinewidth	base/graphics.c	/^void setlinewidth (int linewidth) $/;"	f
setlinewidth	base/graphics.c	/^void setlinewidth (int linewidth) { }$/;"	f
setpoly	base/graphics.c	/^static void setpoly (int bnum, int xc, int yc, int r, float theta) $/;"	f	file:
setup_blocks_affected	place/place.c	/^static int setup_blocks_affected(int b_from, int x_to, int y_to, int z_to) {$/;"	f	file:
setup_chan_width	place/timing_place_lookup.c	/^static void setup_chan_width(struct s_router_opts router_opts,$/;"	f	file:
setup_intracluster_routing_for_logical_block	pack/cluster_legality.c	/^void setup_intracluster_routing_for_logical_block(INP int iblock,$/;"	f
setup_intracluster_routing_for_molecule	pack/cluster_legality.c	/^void setup_intracluster_routing_for_molecule(INP t_pack_molecule *molecule,$/;"	f
setup_junction_switch	base/SetupVPR.c	/^static void setup_junction_switch(struct s_det_routing_arch *det_routing_arch) {$/;"	f	file:
sharinggain	base/vpr_types.h	/^	std::map<int, float> sharinggain; \/* [0..num_logical_blocks-1]. How many nets on this logical_block are already in the pb under consideration *\/$/;"	m	struct:s_pb_stats
show_blif_stats	base/read_blif.c	/^static void show_blif_stats(t_model *user_models, t_model *library_models) {$/;"	f	file:
show_combinational_cycle_candidates	timing/path_delay2.c	/^static void show_combinational_cycle_candidates() {$/;"	f	file:
show_congestion	base/draw.c	/^static boolean show_congestion = FALSE;$/;"	v	file:
show_defects	base/draw.c	/^static boolean show_defects = FALSE; \/* Show defective stuff *\/$/;"	v	file:
show_graphics	base/draw.c	/^static boolean show_graphics; \/* Graphics enabled or not? *\/$/;"	v	file:
show_nets	base/draw.c	/^static boolean show_nets = FALSE; \/* Show nets of placement or routing? *\/$/;"	v	file:
sibling	../../libarchfpga/include/ezxml.h	/^	ezxml_t sibling; \/* next tag with different name in same section and depth *\/$/;"	m	struct:ezxml
sim_clock_freq_slack	../../libarchfpga/include/spice_types.h	/^  float sim_clock_freq_slack;$/;"	m	struct:s_spice_stimulate_params
sim_num_clock_cycle	../../libarchfpga/include/spice_types.h	/^  int sim_num_clock_cycle; \/* Number of clock cycle in simulation *\/$/;"	m	struct:s_spice_meas_params
sim_num_clock_cycle	spice/spice_mux_testbench.c	/^static int sim_num_clock_cycle = 0.;$/;"	v	file:
sim_results_dir_name	spice/spice_run_scripts.c	/^static char* sim_results_dir_name = "results\/";$/;"	v	file:
sim_temp	../../libarchfpga/include/spice_types.h	/^  int sim_temp; \/* Simulation Temperature*\/$/;"	m	struct:s_spice_params
sink_delay	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	m	struct:s_buffer_plan	file:
sink_head	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	m	struct:s_buffer_plan	file:
sink_list	base/vpr_types.h	/^	char ** sink_list;$/;"	m	struct:s_override_constraint
sink_order	place/timing_place_lookup.c	/^static int *sink_order;$/;"	v	file:
size	../../libarchfpga/include/logic_types.h	/^	int size; \/* maximum number of pins *\/$/;"	m	struct:s_model_ports
size	../../libarchfpga/include/spice_types.h	/^  float size;$/;"	m	struct:s_spice_model_buffer
size	../../libarchfpga/include/spice_types.h	/^  int size;$/;"	m	struct:s_spice_model_port
size	../../libarchfpga/include/spice_types.h	/^  int size;$/;"	m	struct:s_spice_mux_model
size	power/power.h	/^	float size;$/;"	m	struct:s_transistor_size_inf
size	route/rr_graph.c	/^	int size;$/;"	m	struct:s_mux	file:
size_inf	power/power.h	/^	t_transistor_size_inf * size_inf; \/* Array of transistor sizes *\/$/;"	m	struct:s_transistor_inf
skip_clustering	base/ReadOptions.h	/^	boolean skip_clustering;$/;"	m	struct:s_options
skip_clustering	base/vpr_types.h	/^	boolean skip_clustering;$/;"	m	struct:s_packer_opts
slack	base/vpr_types.h	/^	float ** slack;$/;"	m	struct:s_slack
slew_fall	../../libarchfpga/include/spice_types.h	/^  float slew_fall;$/;"	m	struct:s_spice_net_info
slew_lower_thres_pct_fall	../../libarchfpga/include/spice_types.h	/^  float slew_lower_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
slew_lower_thres_pct_rise	../../libarchfpga/include/spice_types.h	/^  float slew_lower_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
slew_rise	../../libarchfpga/include/spice_types.h	/^  float slew_rise;$/;"	m	struct:s_spice_net_info
slew_upper_thres_pct_fall	../../libarchfpga/include/spice_types.h	/^  float slew_upper_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
slew_upper_thres_pct_rise	../../libarchfpga/include/spice_types.h	/^  float slew_upper_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
slre	timing/slre.c	/^struct slre {$/;"	s	file:
slre_capture	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	g
slre_match	timing/slre.c	/^const char *slre_match(enum slre_option options, const char *re,$/;"	f
slre_option	timing/slre.h	/^enum slre_option {SLRE_CASE_INSENSITIVE = 1};$/;"	g
snprintf	../../libarchfpga/ezxml.c	57;"	d	file:
sort_me	power/PowerSpicedComponent.c	/^void PowerCallibInputs::sort_me() {$/;"	f	class:PowerCallibInputs
sort_me	power/PowerSpicedComponent.c	/^void PowerSpicedComponent::sort_me(void) {$/;"	f	class:PowerSpicedComponent
sort_one_class_conflict_pins_by_low_slack	clb_pin_remap/clb_pin_remap_util.c	/^int* sort_one_class_conflict_pins_by_low_slack(t_block* target_blk, int class_index,$/;"	f
sorted	power/PowerSpicedComponent.h	/^	bool sorted;$/;"	m	class:PowerCallibInputs
sorted	power/PowerSpicedComponent.h	/^	bool sorted;$/;"	m	class:PowerSpicedComponent
sorter_PowerCallibInputs	power/PowerSpicedComponent.c	/^bool sorter_PowerCallibInputs(PowerCallibInputs * a, PowerCallibInputs * b) {$/;"	f
sorter_PowerCallibSize	power/PowerSpicedComponent.c	/^bool sorter_PowerCallibSize(PowerCallibSize * a, PowerCallibSize * b) {$/;"	f
source_list	base/vpr_types.h	/^	char ** source_list; \/* Array of net names of flip-flops or clocks *\/$/;"	m	struct:s_override_constraint
spice	../../libarchfpga/include/physical_types.h	/^    t_spice* spice;$/;"	m	struct:s_arch
spice_cb_mux_tb_dir_name	spice/spice_api.c	/^static char* spice_cb_mux_tb_dir_name = "cb_mux_tb\/";$/;"	v	file:
spice_cb_mux_testbench_postfix	spice/spice_globals.c	/^char* spice_cb_mux_testbench_postfix = "_cbmux_testbench.sp";$/;"	v
spice_dff_tb_dir_name	spice/spice_api.c	/^static char* spice_dff_tb_dir_name = "dff_tb\/";$/;"	v	file:
spice_dff_testbench_postfix	spice/spice_globals.c	/^char* spice_dff_testbench_postfix = "_dff_testbench.sp";$/;"	v
spice_dir	base/ReadOptions.h	/^    char* spice_dir;$/;"	m	struct:s_options
spice_dir	base/vpr_types.h	/^  char* spice_dir;$/;"	m	struct:s_spice_opts
spice_grid_tb_dir_name	spice/spice_api.c	/^static char* spice_grid_tb_dir_name = "grid_tb\/";$/;"	v	file:
spice_grid_testbench_postfix	spice/spice_globals.c	/^char* spice_grid_testbench_postfix = "_grid_testbench.sp";$/;"	v
spice_lut_tb_dir_name	spice/spice_api.c	/^static char* spice_lut_tb_dir_name = "lut_tb\/";$/;"	v	file:
spice_lut_testbench_postfix	spice/spice_globals.c	/^char* spice_lut_testbench_postfix = "_lut_testbench.sp";$/;"	v
spice_model	../../libarchfpga/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_interconnect
spice_model	../../libarchfpga/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_pb_type
spice_model	../../libarchfpga/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_segment_inf
spice_model	../../libarchfpga/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_switch_inf
spice_model	../../libarchfpga/include/spice_types.h	/^  t_spice_model* spice_model; \/\/ Xifan TANG: Spice Support$/;"	m	struct:s_sram_inf
spice_model	../../libarchfpga/include/spice_types.h	/^  t_spice_model* spice_model;$/;"	m	struct:s_spice_mux_model
spice_model_name	../../libarchfpga/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_interconnect
spice_model_name	../../libarchfpga/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_pb_type
spice_model_name	../../libarchfpga/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_segment_inf
spice_model_name	../../libarchfpga/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_switch_inf
spice_model_name	../../libarchfpga/include/spice_types.h	/^  char* spice_model_name; \/\/ Xifan TANG: Spice Support$/;"	m	struct:s_sram_inf
spice_models	../../libarchfpga/include/spice_types.h	/^  t_spice_model* spice_models;$/;"	m	struct:s_spice
spice_mux_arch	../../libarchfpga/include/spice_types.h	/^  t_spice_mux_arch* spice_mux_arch;$/;"	m	struct:s_spice_mux_model
spice_name_tag	base/vpr_types.h	/^    char* spice_name_tag;$/;"	m	struct:s_pb
spice_net_info	base/vpr_types.h	/^    t_spice_net_info* spice_net_info;$/;"	m	struct:s_net
spice_params	../../libarchfpga/include/spice_types.h	/^  t_spice_params spice_params;$/;"	m	struct:s_spice
spice_pb_mux_tb_dir_name	spice/spice_api.c	/^static char* spice_pb_mux_tb_dir_name = "pb_mux_tb\/";$/;"	v	file:
spice_pb_mux_testbench_postfix	spice/spice_globals.c	/^char* spice_pb_mux_testbench_postfix = "_pbmux_testbench.sp";$/;"	v
spice_sb_mux_tb_dir_name	spice/spice_api.c	/^static char* spice_sb_mux_tb_dir_name = "sb_mux_tb\/";$/;"	v	file:
spice_sb_mux_testbench_postfix	spice/spice_globals.c	/^char* spice_sb_mux_testbench_postfix = "_sbmux_testbench.sp";$/;"	v
spice_top_tb_dir_name	spice/spice_api.c	/^static char* spice_top_tb_dir_name = "top_tb\/";$/;"	v	file:
spice_top_testbench_postfix	spice/spice_globals.c	/^char* spice_top_testbench_postfix = "_top.sp";$/;"	v
split_path_prog_name	spice/spice_utils.c	/^int split_path_prog_name(char* prog_path,$/;"	f
sram_inf	../../libarchfpga/include/physical_types.h	/^    t_sram_inf sram_inf;$/;"	m	struct:s_arch
sram_spice_model	spice/spice_globals.c	/^t_spice_model* sram_spice_model = NULL;$/;"	v
stage_gain	power/power.h	/^	float stage_gain;$/;"	m	struct:s_power_buffer_strength_inf
standalone	../../libarchfpga/include/ezxml.h	/^	short standalone; \/* non-zero if <?xml standalone="yes"?> *\/$/;"	m	struct:ezxml_root
start	base/vpr_types.h	/^	int start;$/;"	m	struct:s_seg_details
start_col	../../libarchfpga/include/physical_types.h	/^	int start_col;$/;"	m	struct:s_grid_loc_def
start_hash_table_iterator	util/hash.c	/^struct s_hash_iterator start_hash_table_iterator(void) {$/;"	f
start_new_cluster	pack/cluster.c	/^static void start_new_cluster($/;"	f	file:
start_seg_switch	../../libarchfpga/include/arch_types_mrfpga.h	/^  short start_seg_switch;$/;"	m	struct:s_arch_mrfpga
start_seg_switch	mrfpga/mrfpga_globals.c	/^short start_seg_switch;$/;"	v
starting_pin_idx	power/power.h	/^	int starting_pin_idx; \/* Applicable to level 0 only, the overall mux primary input index *\/$/;"	m	struct:s_mux_node
starting_t	place/place.c	/^static float starting_t(float *cost_ptr, float *bb_cost_ptr,$/;"	f	file:
stats_lut_spice_mux	spice/spice_lut.c	/^void stats_lut_spice_mux(t_llist** muxes_head,$/;"	f
stats_mux_spice_model_pb_node_rec	spice/spice_pbtypes.c	/^void stats_mux_spice_model_pb_node_rec(t_llist** muxes_head,$/;"	f
stats_mux_spice_model_pb_type_rec	spice/spice_pbtypes.c	/^void stats_mux_spice_model_pb_type_rec(t_llist** muxes_head,$/;"	f
stats_pb_graph_node_port_pin_numbers	spice/spice_utils.c	/^void stats_pb_graph_node_port_pin_numbers(t_pb_graph_node* cur_pb_graph_node,$/;"	f
stats_spice_muxes	spice/spice_mux.c	/^t_llist* stats_spice_muxes(int num_switch,$/;"	f
statusMessage	base/graphics.c	/^static char statusMessage[BUFSIZE] = ""; \/* User message to display *\/$/;"	v	file:
std	base/graphics.c	/^using namespace std;$/;"	v
std	power/PowerSpicedComponent.c	/^using namespace std;$/;"	v
std	power/power.c	/^using namespace std;$/;"	v
std	power/power_cmos_tech.c	/^using namespace std;$/;"	v
std	power/power_components.c	/^using namespace std;$/;"	v
std	power/power_sizing.c	/^using namespace std;$/;"	v
std	power/power_util.c	/^using namespace std;$/;"	v
stimu_header_file_name	spice/spice_globals.c	/^char* stimu_header_file_name = "stimulate_params.sp";$/;"	v
stimulate_params	../../libarchfpga/include/spice_types.h	/^  t_spice_stimulate_params stimulate_params;$/;"	m	struct:s_spice_params
store_char_in_data	timing/slre.c	/^static void store_char_in_data(struct slre *r, int ch) {$/;"	f	file:
strength_inf	power/power.h	/^	t_power_buffer_strength_inf * strength_inf;$/;"	m	struct:s_power_buffer_size_inf
subckt_dir	base/vpr_types.h	/^  char* subckt_dir;$/;"	m	struct:s_spice_opts
sum_pin_class	pack/cluster_feasibility_filter.c	/^static void sum_pin_class(INOUTP t_pb_graph_node *pb_graph_node) {$/;"	f	file:
swap_blk_same_class_2pins	clb_pin_remap/clb_pin_remap_util.c	/^void swap_blk_same_class_2pins(t_block* target_blk, int n_nets, t_net* nets,$/;"	f
swap_result	place/place.c	/^enum swap_result {$/;"	g	file:
swapped_to_empty	place/place.c	/^	int swapped_to_empty;$/;"	m	struct:s_pl_moved_block	file:
sweep_hanging_nets_and_inputs	base/ReadOptions.h	/^	boolean sweep_hanging_nets_and_inputs;$/;"	m	struct:s_options
sweep_hanging_nets_and_inputs	base/vpr_types.h	/^	boolean sweep_hanging_nets_and_inputs;$/;"	m	struct:s_packer_opts
switch_block_type	base/vpr_types.h	/^	enum e_switch_block_type switch_block_type;$/;"	m	struct:s_det_routing_arch	typeref:enum:s_det_routing_arch::e_switch_block_type
switch_inf	base/globals.c	/^struct s_switch_inf *switch_inf = NULL; \/* [0..(det_routing_arch.num_switch-1)] *\/$/;"	v	typeref:struct:s_switch_inf
switch_inf	base/globals_declare.h	/^struct s_switch_inf *switch_inf; \/* [0..det_routing_arch.num_switch-1] *\/$/;"	v	typeref:struct:s_switch_inf
switches	base/vpr_types.h	/^	short *switches;$/;"	m	struct:s_rr_node
swseg_pattern_change_switch_type	route/rr_graph_swseg.c	/^int swseg_pattern_change_switch_type(int cur_node,$/;"	f	file:
swseg_patterns	../../libarchfpga/include/physical_types.h	/^    t_swseg_pattern_inf* swseg_patterns;$/;"	m	struct:s_arch
swseg_patterns	base/vpr_types.h	/^    t_swseg_pattern_inf* swseg_patterns; \/* Xifan TANG: Switch Segment Pattern Support *\/$/;"	m	struct:s_vpr_setup
sync_arch_mrfpga_globals	mrfpga/mrfpga_api.c	/^void sync_arch_mrfpga_globals(t_arch_mrfpga arch_mrfpga) {$/;"	f
sync_grid_to_blocks	util/vpr_utils.c	/^void sync_grid_to_blocks(INP int L_num_blocks,$/;"	f
szAppName	base/graphics.c	/^static TCHAR szAppName[256], $/;"	v	file:
szButtonsName	base/graphics.c	/^szButtonsName[] = TEXT("VPR Buttons");$/;"	v	file:
szGraphicsName	base/graphics.c	/^szGraphicsName[] = TEXT("VPR Graphics"), $/;"	v	file:
szStatusName	base/graphics.c	/^szStatusName[] = TEXT("VPR Status"),$/;"	v	file:
t_arch	../../libarchfpga/include/physical_types.h	/^typedef struct s_arch t_arch;$/;"	t	typeref:struct:s_arch
t_arch_mrfpga	../../libarchfpga/include/arch_types_mrfpga.h	/^typedef struct s_arch_mrfpga t_arch_mrfpga;$/;"	t	typeref:struct:s_arch_mrfpga
t_block	base/vpr_types.h	/^typedef struct s_block t_block;$/;"	t	typeref:struct:s_block
t_buffer_inf	../../libarchfpga/include/arch_types_mrfpga.h	/^typedef struct s_buffer_inf t_buffer_inf;$/;"	t	typeref:struct:s_buffer_inf
t_buffer_plan	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan {t_linked_int* inode_head; t_linked_int* sink_head; float* sink_delay; float C_downstream; float Tdel;} t_buffer_plan;$/;"	t	typeref:struct:s_buffer_plan	file:
t_buffer_plan_list	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_list { t_buffer_plan_node* front; } t_buffer_plan_list;$/;"	t	typeref:struct:s_buffer_plan_list	file:
t_buffer_plan_node	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_node { t_buffer_plan value; struct s_buffer_plan_node* next;} t_buffer_plan_node;$/;"	t	typeref:struct:s_buffer_plan_node	file:
t_button	base/graphics.c	/^} t_button;$/;"	t	typeref:struct:__anon4	file:
t_button_type	base/graphics.c	/^} t_button_type;$/;"	t	typeref:enum:__anon3	file:
t_chan	../../libarchfpga/include/physical_types.h	/^} t_chan;$/;"	t	typeref:struct:s_chan
t_chan_width_dist	../../libarchfpga/include/physical_types.h	/^} t_chan_width_dist;$/;"	t	typeref:struct:s_chan_width_dist
t_chunk	../../libarchfpga/include/util.h	/^} t_chunk;$/;"	t	typeref:struct:s_chunk
t_class	../../libarchfpga/include/physical_types.h	/^typedef struct s_class t_class;$/;"	t	typeref:struct:s_class
t_clb_to_clb_directs	route/rr_graph.c	/^} t_clb_to_clb_directs;$/;"	t	typeref:struct:s_clb_to_clb_directs	file:
t_clock	base/vpr_types.h	/^} t_clock;$/;"	t	typeref:struct:s_clock
t_clock_arch	../../libarchfpga/include/physical_types.h	/^typedef struct s_clock_arch t_clock_arch;$/;"	t	typeref:struct:s_clock_arch
t_clock_network	../../libarchfpga/include/physical_types.h	/^typedef struct s_clock_network t_clock_network;$/;"	t	typeref:struct:s_clock_network
t_cluster_placement_primitive	../../libarchfpga/include/cad_types.h	/^} t_cluster_placement_primitive;$/;"	t	typeref:struct:s_cluster_placement_primitive
t_cluster_placement_stats	base/vpr_types.h	/^} t_cluster_placement_stats;$/;"	t	typeref:struct:s_cluster_placement_stats
t_det_routing_arch	base/vpr_types.h	/^typedef struct s_det_routing_arch t_det_routing_arch;$/;"	t	typeref:struct:s_det_routing_arch
t_direct_inf	../../libarchfpga/include/physical_types.h	/^} t_direct_inf;$/;"	t	typeref:struct:s_direct_inf
t_display_type	base/graphics.c	/^} t_display_type;$/;"	t	typeref:enum:__anon2	file:
t_fmap_cell	base/place_and_route.h	/^} t_fmap_cell;$/;"	t	typeref:struct:s_fmap_cell
t_gl_state	base/graphics.c	/^} t_gl_state;$/;"	t	typeref:struct:__anon5	file:
t_graph_type	route/rr_graph.h	/^typedef enum e_graph_type t_graph_type;$/;"	t	typeref:enum:e_graph_type
t_grid_loc_def	../../libarchfpga/include/physical_types.h	/^} t_grid_loc_def;$/;"	t	typeref:struct:s_grid_loc_def
t_grid_tile	base/vpr_types.h	/^} t_grid_tile;$/;"	t	typeref:struct:s_grid_tile
t_interconnect	../../libarchfpga/include/physical_types.h	/^typedef struct s_interconnect t_interconnect;$/;"	t	typeref:struct:s_interconnect
t_interconnect_pins	../../libarchfpga/include/physical_types.h	/^typedef struct s_interconnect_pins t_interconnect_pins;$/;"	t	typeref:struct:s_interconnect_pins
t_interconnect_power	../../libarchfpga/include/physical_types.h	/^typedef struct s_interconnect_power t_interconnect_power;$/;"	t	typeref:struct:s_interconnect_power
t_io	base/vpr_types.h	/^} t_io;$/;"	t	typeref:struct:s_io
t_ivec	../../libarchfpga/include/util.h	/^} t_ivec;$/;"	t	typeref:struct:s_ivec
t_legal_pos	place/place.c	/^}t_legal_pos;$/;"	t	typeref:struct:s_legal_pos	file:
t_linked_edge	route/rr_graph_util.h	/^typedef struct s_linked_edge t_linked_edge;$/;"	t	typeref:struct:s_linked_edge
t_linked_int	../../libarchfpga/include/util.h	/^} t_linked_int;$/;"	t	typeref:struct:s_linked_int
t_linked_rc_edge	timing/net_delay_types.h	/^typedef struct s_linked_rc_edge t_linked_rc_edge;$/;"	t	typeref:struct:s_linked_rc_edge
t_linked_rc_ptr	timing/net_delay_types.h	/^typedef struct s_linked_rc_ptr t_linked_rc_ptr;$/;"	t	typeref:struct:s_linked_rc_ptr
t_linked_rt_edge	route/route_tree_timing.h	/^typedef struct s_linked_rt_edge t_linked_rt_edge;$/;"	t	typeref:struct:s_linked_rt_edge
t_linked_vptr	../../libarchfpga/include/util.h	/^} t_linked_vptr;$/;"	t	typeref:struct:s_linked_vptr
t_llist	spice/linkedlist.h	/^typedef struct s_llist t_llist;$/;"	t	typeref:struct:s_llist
t_log	power/power.h	/^typedef struct s_log t_log;$/;"	t	typeref:struct:s_log
t_logical_block	base/vpr_types.h	/^} t_logical_block;$/;"	t	typeref:struct:s_logical_block
t_memristor_inf	../../libarchfpga/include/arch_types_mrfpga.h	/^typedef struct s_memristor_inf t_memristor_inf;$/;"	t	typeref:struct:s_memristor_inf
t_mode	../../libarchfpga/include/physical_types.h	/^typedef struct s_mode t_mode;$/;"	t	typeref:struct:s_mode
t_mode_power	../../libarchfpga/include/physical_types.h	/^typedef struct s_mode_power t_mode_power;$/;"	t	typeref:struct:s_mode_power
t_model	../../libarchfpga/include/logic_types.h	/^} t_model;$/;"	t	typeref:struct:s_model
t_model_chain_pattern	../../libarchfpga/include/cad_types.h	/^} t_model_chain_pattern;$/;"	t	typeref:struct:s_model_chain_pattern
t_model_ports	../../libarchfpga/include/logic_types.h	/^} t_model_ports;$/;"	t	typeref:struct:s_model_ports
t_mux	route/rr_graph.c	/^} t_mux;$/;"	t	typeref:struct:s_mux	file:
t_mux_arch	power/power.h	/^typedef struct s_mux_arch t_mux_arch;$/;"	t	typeref:struct:s_mux_arch
t_mux_node	power/power.h	/^typedef struct s_mux_node t_mux_node;$/;"	t	typeref:struct:s_mux_node
t_mux_size_distribution	route/rr_graph.c	/^} t_mux_size_distribution;$/;"	t	typeref:struct:s_mux_size_distribution	file:
t_net	base/vpr_types.h	/^} t_net;$/;"	t	typeref:struct:s_net
t_net_power	base/vpr_types.h	/^typedef struct s_net_power t_net_power;$/;"	t	typeref:struct:s_net_power
t_options	base/ReadOptions.h	/^typedef struct s_options t_options;$/;"	t	typeref:struct:s_options
t_override_constraint	base/vpr_types.h	/^} t_override_constraint;$/;"	t	typeref:struct:s_override_constraint
t_pack_molecule	base/vpr_types.h	/^} t_pack_molecule;$/;"	t	typeref:struct:s_pack_molecule
t_pack_pattern_block	../../libarchfpga/include/cad_types.h	/^} t_pack_pattern_block;$/;"	t	typeref:struct:s_pack_pattern_block
t_pack_pattern_connections	../../libarchfpga/include/cad_types.h	/^} t_pack_pattern_connections;$/;"	t	typeref:struct:s_pack_pattern_connections
t_pack_patterns	../../libarchfpga/include/cad_types.h	/^} t_pack_patterns;$/;"	t	typeref:struct:s_pack_patterns
t_pb	base/vpr_types.h	/^} t_pb;$/;"	t	typeref:struct:s_pb
t_pb_graph_edge	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_graph_edge t_pb_graph_edge;$/;"	t	typeref:struct:s_pb_graph_edge
t_pb_graph_node	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_graph_node t_pb_graph_node;$/;"	t	typeref:struct:s_pb_graph_node
t_pb_graph_node_power	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_graph_node_power t_pb_graph_node_power;$/;"	t	typeref:struct:s_pb_graph_node_power
t_pb_graph_pin	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_graph_pin t_pb_graph_pin;$/;"	t	typeref:struct:s_pb_graph_pin
t_pb_graph_pin_power	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_graph_pin_power t_pb_graph_pin_power;$/;"	t	typeref:struct:s_pb_graph_pin_power
t_pb_stats	base/vpr_types.h	/^} t_pb_stats;$/;"	t	typeref:struct:s_pb_stats
t_pb_type	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_type t_pb_type;$/;"	t	typeref:struct:s_pb_type
t_pb_type_power	../../libarchfpga/include/physical_types.h	/^typedef struct s_pb_type_power t_pb_type_power;$/;"	t	typeref:struct:s_pb_type_power
t_pin_to_pin_annotation	../../libarchfpga/include/physical_types.h	/^typedef struct s_pin_to_pin_annotation t_pin_to_pin_annotation;$/;"	t	typeref:struct:s_pin_to_pin_annotation
t_pl_blocks_to_be_moved	place/place.c	/^}t_pl_blocks_to_be_moved;$/;"	t	typeref:struct:s_pl_blocks_to_be_moved	file:
t_pl_macro	place/place_macro.h	/^} t_pl_macro;$/;"	t	typeref:struct:s_pl_macro
t_pl_macro_member	place/place_macro.h	/^} t_pl_macro_member;$/;"	t	typeref:struct:s_pl_macro_member
t_pl_moved_block	place/place.c	/^}t_pl_moved_block;$/;"	t	typeref:struct:s_pl_moved_block	file:
t_point	base/easygl_constants.h	/^} t_point; \/* Used in calls to fillpoly *\/$/;"	t	typeref:struct:__anon1
t_port	../../libarchfpga/include/physical_types.h	/^typedef struct s_port t_port;$/;"	t	typeref:struct:s_port
t_port_power	../../libarchfpga/include/physical_types.h	/^typedef struct s_port_power t_port_power;$/;"	t	typeref:struct:s_port_power
t_power_arch	../../libarchfpga/include/physical_types.h	/^typedef struct s_power_arch t_power_arch;$/;"	t	typeref:struct:s_power_arch
t_power_buffer_sc_levr_inf	power/power.h	/^typedef struct s_power_buffer_sc_levr_inf t_power_buffer_sc_levr_inf;$/;"	t	typeref:struct:s_power_buffer_sc_levr_inf
t_power_buffer_size_inf	power/power.h	/^typedef struct s_power_buffer_size_inf t_power_buffer_size_inf;$/;"	t	typeref:struct:s_power_buffer_size_inf
t_power_buffer_strength_inf	power/power.h	/^typedef struct s_power_buffer_strength_inf t_power_buffer_strength_inf;$/;"	t	typeref:struct:s_power_buffer_strength_inf
t_power_commonly_used	power/power.h	/^typedef struct s_power_commonly_used t_power_commonly_used;$/;"	t	typeref:struct:s_power_commonly_used
t_power_components	power/power_components.h	/^typedef struct s_power_breakdown t_power_components;$/;"	t	typeref:struct:s_power_breakdown
t_power_estimation_method	../../libarchfpga/include/physical_types.h	/^typedef enum e_power_estimation_method_ t_power_estimation_method;$/;"	t	typeref:enum:e_power_estimation_method_
t_power_mux_info	power/power.h	/^typedef struct s_power_mux_info t_power_mux_info;$/;"	t	typeref:struct:s_power_mux_info
t_power_mux_volt_inf	power/power.h	/^typedef struct s_power_mux_volt_inf t_power_mux_volt_inf;$/;"	t	typeref:struct:s_power_mux_volt_inf
t_power_mux_volt_pair	power/power.h	/^typedef struct s_power_mux_volt_pair t_power_mux_volt_pair;$/;"	t	typeref:struct:s_power_mux_volt_pair
t_power_nmos_leakage_inf	power/power.h	/^typedef struct s_power_nmos_leakage_inf t_power_nmos_leakage_inf;$/;"	t	typeref:struct:s_power_nmos_leakage_inf
t_power_nmos_leakage_pair	power/power.h	/^typedef struct s_power_nmos_leakage_pair t_power_nmos_leakage_pair;$/;"	t	typeref:struct:s_power_nmos_leakage_pair
t_power_nmos_leakages	power/power.h	/^typedef struct s_power_nmos_leakages t_power_nmos_leakages;$/;"	t	typeref:struct:s_power_nmos_leakages
t_power_nmos_mux_inf	power/power.h	/^typedef struct s_power_nmos_mux_inf t_power_nmos_mux_inf;$/;"	t	typeref:struct:s_power_nmos_mux_inf
t_power_opts	base/vpr_types.h	/^typedef struct s_power_opts t_power_opts;$/;"	t	typeref:struct:s_power_opts
t_power_output	power/power.h	/^typedef struct s_power_output t_power_output;$/;"	t	typeref:struct:s_power_output
t_power_tech	power/power.h	/^typedef struct s_power_tech t_power_tech;$/;"	t	typeref:struct:s_power_tech
t_power_usage	../../libarchfpga/include/physical_types.h	/^typedef struct s_power_usage t_power_usage;$/;"	t	typeref:struct:s_power_usage
t_prepacked_tnode_data	base/vpr_types.h	/^} t_prepacked_tnode_data;$/;"	t	typeref:struct:s_prepacked_tnode_data
t_rc_node	timing/net_delay_types.h	/^typedef struct s_rc_node t_rc_node;$/;"	t	typeref:struct:s_rc_node
t_report	base/graphics.h	/^} t_report;$/;"	t	typeref:struct:__anon6
t_router_opts	base/vpr_types.h	/^typedef struct s_router_opts t_router_opts;$/;"	t	typeref:struct:s_router_opts
t_rr_indexed_data	base/vpr_types.h	/^} t_rr_indexed_data;$/;"	t	typeref:struct:s_rr_indexed_data
t_rr_node	base/vpr_types.h	/^typedef struct s_rr_node t_rr_node;$/;"	t	typeref:struct:s_rr_node
t_rr_node_power	power/power.h	/^typedef struct s_rr_node_power t_rr_node_power;$/;"	t	typeref:struct:s_rr_node_power
t_rr_node_route_inf	route/route_common.h	/^} t_rr_node_route_inf;$/;"	t	typeref:struct:__anon15
t_rr_type	base/vpr_types.h	/^} t_rr_type;$/;"	t	typeref:enum:e_rr_type
t_rt_node	route/route_tree_timing.h	/^typedef struct s_rt_node t_rt_node;$/;"	t	typeref:struct:s_rt_node
t_sdc_clock	timing/read_sdc.c	/^} t_sdc_clock;$/;"	t	typeref:struct:s_sdc_clock	file:
t_sdc_exclusive_group	timing/read_sdc.c	/^} t_sdc_exclusive_group;$/;"	t	typeref:struct:s_sdc_exclusive_group	file:
t_seg_details	base/vpr_types.h	/^} t_seg_details;$/;"	t	typeref:struct:s_seg_details
t_segment_inf	../../libarchfpga/include/physical_types.h	/^} t_segment_inf;$/;"	t	typeref:struct:s_segment_inf
t_slack	base/vpr_types.h	/^} t_slack;$/;"	t	typeref:struct:s_slack
t_solution_inf	power/power.h	/^typedef struct s_solution_inf t_solution_inf;$/;"	t	typeref:struct:s_solution_inf
t_spice	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice t_spice;$/;"	t	typeref:struct:s_spice
t_spice_meas_params	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_meas_params t_spice_meas_params;$/;"	t	typeref:struct:s_spice_meas_params
t_spice_model	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_model t_spice_model;$/;"	t	typeref:struct:s_spice_model
t_spice_model_buffer	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_model_buffer t_spice_model_buffer;$/;"	t	typeref:struct:s_spice_model_buffer
t_spice_model_netlist	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_model_netlist t_spice_model_netlist;$/;"	t	typeref:struct:s_spice_model_netlist
t_spice_model_pass_gate_logic	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_model_pass_gate_logic t_spice_model_pass_gate_logic;$/;"	t	typeref:struct:s_spice_model_pass_gate_logic
t_spice_model_port	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_model_port t_spice_model_port;$/;"	t	typeref:struct:s_spice_model_port
t_spice_model_wire_param	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_model_wire_param t_spice_model_wire_param;$/;"	t	typeref:struct:s_spice_model_wire_param
t_spice_mux_arch	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_mux_arch t_spice_mux_arch;$/;"	t	typeref:struct:s_spice_mux_arch
t_spice_mux_model	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_mux_model t_spice_mux_model;$/;"	t	typeref:struct:s_spice_mux_model
t_spice_net_info	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_net_info t_spice_net_info;$/;"	t	typeref:struct:s_spice_net_info
t_spice_opts	base/vpr_types.h	/^typedef struct s_spice_opts t_spice_opts;$/;"	t	typeref:struct:s_spice_opts
t_spice_params	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_params t_spice_params;$/;"	t	typeref:struct:s_spice_params
t_spice_stimulate_params	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_stimulate_params t_spice_stimulate_params;$/;"	t	typeref:struct:s_spice_stimulate_params
t_spice_tech_lib	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_tech_lib t_spice_tech_lib;$/;"	t	typeref:struct:s_spice_tech_lib
t_spice_transistor_type	../../libarchfpga/include/spice_types.h	/^typedef struct s_spice_transistor_type t_spice_transistor_type;$/;"	t	typeref:struct:s_spice_transistor_type
t_sram_inf	../../libarchfpga/include/spice_types.h	/^typedef struct s_sram_inf t_sram_inf;$/;"	t	typeref:struct:s_sram_inf
t_switch_block_type	../../libarchfpga/include/physical_types.h	/^typedef enum e_switch_block_type t_switch_block_type;$/;"	t	typeref:enum:e_switch_block_type
t_switch_inf	../../libarchfpga/include/physical_types.h	/^} t_switch_inf;$/;"	t	typeref:struct:s_switch_inf
t_swseg_pattern_inf	../../libarchfpga/include/physical_types.h	/^typedef struct s_swseg_pattern_inf t_swseg_pattern_inf;$/;"	t	typeref:struct:s_swseg_pattern_inf
t_tedge	base/vpr_types.h	/^} t_tedge;$/;"	t	typeref:struct:s_tedge
t_timing_constraints	base/vpr_types.h	/^} t_timing_constraints;$/;"	t	typeref:struct:s_timing_constraints
t_timing_inf	../../libarchfpga/include/physical_types.h	/^} t_timing_inf;$/;"	t	typeref:struct:s_timing_inf
t_timing_stats	base/vpr_types.h	/^} t_timing_stats;$/;"	t	typeref:struct:s_timing_stats
t_tnode	base/vpr_types.h	/^} t_tnode;$/;"	t	typeref:struct:s_tnode
t_token	util/token.h	/^typedef struct s_token t_token;$/;"	t	typeref:struct:s_token
t_trace	base/vpr_types.h	/^} t_trace;$/;"	t	typeref:struct:s_trace
t_transistor_inf	power/power.h	/^typedef struct s_transistor_inf t_transistor_inf;$/;"	t	typeref:struct:s_transistor_inf
t_transistor_size_inf	power/power.h	/^typedef struct s_transistor_size_inf t_transistor_size_inf;$/;"	t	typeref:struct:s_transistor_size_inf
t_type_descriptor	../../libarchfpga/include/physical_types.h	/^typedef struct s_type_descriptor t_type_descriptor;$/;"	t	typeref:struct:s_type_descriptor
t_type_ptr	../../libarchfpga/include/physical_types.h	/^typedef const struct s_type_descriptor *t_type_ptr;$/;"	t	typeref:struct:s_type_descriptor
t_vpr_setup	base/vpr_types.h	/^} t_vpr_setup;$/;"	t	typeref:struct:s_vpr_setup
tap_buf_level	../../libarchfpga/include/spice_types.h	/^  int tap_buf_level;$/;"	m	struct:s_spice_model_buffer
tapered_buf	../../libarchfpga/include/spice_types.h	/^  int tapered_buf; \/*Valid only when this is a buffer*\/$/;"	m	struct:s_spice_model_buffer
target_flag	route/route_common.h	/^	short target_flag;$/;"	m	struct:__anon15
tb_cnt	../../libarchfpga/include/spice_types.h	/^  int tb_cnt;$/;"	m	struct:s_spice_model
tb_head	spice/spice_globals.c	/^t_llist* tb_head = NULL;$/;"	v
tb_num_dffs	spice/spice_dff_testbench.c	/^static int tb_num_dffs = 0;$/;"	v	file:
tb_num_grid	spice/spice_grid_testbench.c	/^static int tb_num_grid = 0;$/;"	v	file:
tb_num_luts	spice/spice_lut_testbench.c	/^static int tb_num_luts = 0;$/;"	v	file:
td_place_exp_first	base/vpr_types.h	/^	float td_place_exp_first;$/;"	m	struct:s_placer_opts
td_place_exp_last	base/vpr_types.h	/^	float td_place_exp_last;$/;"	m	struct:s_placer_opts
tech_comp	../../libarchfpga/include/arch_types_mrfpga.h	/^  enum e_tech_comp tech_comp;$/;"	m	struct:s_arch_mrfpga	typeref:enum:s_arch_mrfpga::e_tech_comp
tech_lib	../../libarchfpga/include/spice_types.h	/^  t_spice_tech_lib tech_lib;$/;"	m	struct:s_spice
tech_size	power/power.h	/^	float tech_size; \/* Tech size in nm, for example 90e-9 for 90nm *\/$/;"	m	struct:s_power_tech
tedge_ch	timing/path_delay.c	/^static t_chunk tedge_ch = {NULL, 0, NULL};$/;"	v	file:
temp_net_cost	place/place.c	/^static float *net_cost = NULL, *temp_net_cost = NULL; \/* [0..num_nets-1] *\/$/;"	v	file:
temp_num_pins	base/read_blif.c	/^static int *num_driver, *temp_num_pins;$/;"	v	file:
temp_point_to_point_delay_cost	place/place.c	/^static float **temp_point_to_point_delay_cost = NULL;$/;"	v	file:
temp_point_to_point_timing_cost	place/place.c	/^static float **temp_point_to_point_timing_cost = NULL;$/;"	v	file:
temp_scratch_pad	../../libarchfpga/include/physical_types.h	/^	void *temp_scratch_pad; \/* temporary data, useful for keeping track of things when traversing data structure *\/$/;"	m	struct:s_pb_graph_node
temp_used	base/vpr_types.h	/^    int temp_used;$/;"	m	struct:s_logical_block
temperature	power/power.h	/^	float temperature; \/* Temp in C *\/$/;"	m	struct:s_power_tech
test_if_exposed	base/graphics.c	/^static Bool test_if_exposed (Display *disp, XEvent *event_ptr, XPointer dummy) $/;"	f	file:
testbench_cb_mux_cnt	spice/spice_mux_testbench.c	/^static int testbench_cb_mux_cnt = 0;$/;"	v	file:
testbench_load_cnt	spice/spice_mux_testbench.c	/^static int testbench_load_cnt = 0;$/;"	v	file:
testbench_mux_cnt	spice/spice_mux_testbench.c	/^static int testbench_mux_cnt = 0;$/;"	v	file:
testbench_muxes_head	spice/spice_mux_testbench.c	/^static t_llist* testbench_muxes_head = NULL; $/;"	v	file:
testbench_pb_mux_cnt	spice/spice_mux_testbench.c	/^static int testbench_pb_mux_cnt = 0;$/;"	v	file:
testbench_sb_mux_cnt	spice/spice_mux_testbench.c	/^static int testbench_sb_mux_cnt = 0;$/;"	v	file:
testbench_sram_cnt	spice/spice_mux_testbench.c	/^static int testbench_sram_cnt = 0;$/;"	v	file:
text	base/graphics.c	/^   char text[BUTTON_TEXT_LEN]; $/;"	m	struct:__anon4	file:
textarea	base/graphics.c	/^static Window toplevel, menu, textarea;  \/* various windows *\/$/;"	v	file:
tie_break_high_fanout_net	base/vpr_types.h	/^	int tie_break_high_fanout_net; \/* If no marked candidate atoms, use this high fanout net to determine the next candidate atom *\/$/;"	m	struct:s_pb_stats
tile_length	power/power.h	/^	float tile_length;$/;"	m	struct:s_power_commonly_used
tile_width	base/draw.c	/^static float tile_width, pin_size;$/;"	v	file:
tile_x	base/draw.c	/^static float *tile_x, *tile_y;$/;"	v	file:
tile_y	base/draw.c	/^static float *tile_x, *tile_y;$/;"	v	file:
timing_analysis_enabled	../../libarchfpga/include/physical_types.h	/^	boolean timing_analysis_enabled;$/;"	m	struct:s_timing_inf
timing_criticality	base/vpr_types.h	/^	float ** timing_criticality;$/;"	m	struct:s_slack
timing_driven	base/ReadOptions.h	/^	boolean timing_driven;$/;"	m	struct:s_options
timing_driven	base/vpr_types.h	/^	boolean timing_driven;$/;"	m	struct:s_packer_opts
timing_driven_check_net_delays	route/route_timing.c	/^static void timing_driven_check_net_delays(float **net_delay) {$/;"	f	file:
timing_driven_expand_neighbours	route/route_timing.c	/^static void timing_driven_expand_neighbours(struct s_heap *current, int inet,$/;"	f	file:
timing_driven_route_net	route/route_timing.c	/^boolean timing_driven_route_net(int inet, float pres_fac, float max_criticality,$/;"	f
timing_nets	timing/path_delay.c	/^static struct s_net *timing_nets = NULL;$/;"	v	typeref:struct:s_net	file:
timing_place_crit	place/timing_place.c	/^float **timing_place_crit; \/*available externally *\/$/;"	v
timing_place_crit_ch	place/timing_place.c	/^static t_chunk timing_place_crit_ch = {NULL, 0, NULL};$/;"	v	file:
timing_tradeoff	base/vpr_types.h	/^	float timing_tradeoff;$/;"	m	struct:s_placer_opts
timinggain	base/vpr_types.h	/^	std::map<int, float> timinggain; \/* [0..num_logical_blocks-1]. The timing criticality score of this logical_block. $/;"	m	struct:s_pb_stats
tnode	base/vpr_types.h	/^	t_tnode *tnode;$/;"	m	struct:s_rr_node
tnode	timing/path_delay.c	/^t_tnode *tnode = NULL; \/* [0..num_tnodes - 1] *\/$/;"	v
tnodes_at_level	timing/path_delay2.c	/^struct s_ivec *tnodes_at_level;$/;"	v	typeref:struct:s_ivec
to_block	../../libarchfpga/include/cad_types.h	/^	t_pack_pattern_block *to_block;$/;"	m	struct:s_pack_pattern_connections
to_clb_pin_end_index	route/rr_graph.c	/^	int to_clb_pin_end_index;$/;"	m	struct:s_clb_to_clb_directs	file:
to_clb_pin_start_index	route/rr_graph.c	/^	int to_clb_pin_start_index;$/;"	m	struct:s_clb_to_clb_directs	file:
to_clb_type	route/rr_graph.c	/^	t_type_descriptor *to_clb_type;$/;"	m	struct:s_clb_to_clb_directs	file:
to_node	base/vpr_types.h	/^	int to_node; \/* index of node at the sink end of this edge *\/$/;"	m	struct:s_tedge
to_pin	../../libarchfpga/include/cad_types.h	/^	t_pb_graph_pin *to_pin;$/;"	m	struct:s_pack_pattern_connections
to_pin	../../libarchfpga/include/physical_types.h	/^	char *to_pin;$/;"	m	struct:s_direct_inf
toggle_congestion	base/draw.c	/^static void toggle_congestion(void (*drawscreen_ptr)(void)) {$/;"	f	file:
toggle_defects	base/draw.c	/^static void toggle_defects(void (*drawscreen_ptr)(void)) {$/;"	f	file:
toggle_nets	base/draw.c	/^static void toggle_nets(void (*drawscreen_ptr)(void)) {$/;"	f	file:
toggle_rr	base/draw.c	/^static void toggle_rr(void (*drawscreen_ptr)(void)) {$/;"	f	file:
top_height	base/graphics.c	/^static int top_width, top_height;      \/* window size *\/$/;"	v	file:
top_height	base/graphics.h	/^	int top_width, top_height;$/;"	m	struct:__anon6
top_width	base/graphics.c	/^static int top_width, top_height;      \/* window size *\/$/;"	v	file:
top_width	base/graphics.h	/^	int top_width, top_height;$/;"	m	struct:__anon6
toplevel	base/graphics.c	/^static Window toplevel, menu, textarea;  \/* various windows *\/$/;"	v	file:
total_cb_buffer_size	power/power.h	/^	float total_cb_buffer_size;$/;"	m	struct:s_power_commonly_used
total_pb_pins	../../libarchfpga/include/physical_types.h	/^	int total_pb_pins; \/* only valid for top-level *\/$/;"	m	struct:s_pb_graph_node
total_sb_buffer_size	power/power.h	/^	float total_sb_buffer_size;$/;"	m	struct:s_power_commonly_used
trace_ch	route/route_common.c	/^static t_chunk trace_ch = {NULL, 0, NULL};$/;"	v	file:
trace_free_head	route/route_common.c	/^static struct s_trace *trace_free_head = NULL;$/;"	v	typeref:struct:s_trace	file:
trace_head	base/globals.c	/^struct s_trace **trace_head = NULL; \/* [0..(num_nets-1)] *\/$/;"	v	typeref:struct:s_trace
trace_head	base/globals_declare.h	/^struct s_trace **trace_head, **trace_tail;$/;"	v	typeref:struct:s_trace
trace_tail	base/globals.c	/^struct s_trace **trace_tail = NULL; \/* [0..(num_nets-1)] *\/$/;"	v	typeref:struct:s_trace
trace_tail	base/globals_declare.h	/^struct s_trace **trace_head, **trace_tail;$/;"	v	typeref:struct:
trans_per_R	route/rr_graph_area.c	/^static float trans_per_R(float Rtrans, float R_minW_trans) {$/;"	f	file:
trans_per_buf	route/rr_graph_area.c	/^float trans_per_buf(float Rbuf, float R_minW_nmos, float R_minW_pmos) {$/;"	f
trans_per_mux	route/rr_graph_area.c	/^static float trans_per_mux(int num_inputs, float trans_sram_bit,$/;"	f	file:
transistor_cnt	../../libarchfpga/include/physical_types.h	/^	float transistor_cnt;$/;"	m	struct:s_interconnect_power
transistor_cnt_buffers	../../libarchfpga/include/physical_types.h	/^	float transistor_cnt_buffers;$/;"	m	struct:s_pb_graph_node_power
transistor_cnt_interc	../../libarchfpga/include/physical_types.h	/^	float transistor_cnt_interc; \/* Total transistor size of the interconnect in this pb *\/$/;"	m	struct:s_pb_graph_node_power
transistor_cnt_pb_children	../../libarchfpga/include/physical_types.h	/^	float transistor_cnt_pb_children; \/* Total transistor size of this pb *\/$/;"	m	struct:s_pb_graph_node_power
transistor_size	power/PowerSpicedComponent.h	/^	float transistor_size;$/;"	m	class:PowerCallibSize
transistor_size	power/power.h	/^	float transistor_size;$/;"	m	struct:s_mux_arch
transistor_type	../../libarchfpga/include/spice_types.h	/^  char* transistor_type;$/;"	m	struct:s_spice_tech_lib
transistor_type_name	power/power_util.c	/^char * transistor_type_name(e_tx_type type) {$/;"	f
transistor_types	../../libarchfpga/include/spice_types.h	/^  t_spice_transistor_type* transistor_types;$/;"	m	struct:s_spice_tech_lib
transistors_per_SRAM_bit	../../libarchfpga/include/physical_types.h	/^	float transistors_per_SRAM_bit;$/;"	m	struct:s_power_arch
translate_down	base/graphics.c	/^translate_down (void (*drawscreen) (void)) $/;"	f	file:
translate_left	base/graphics.c	/^translate_left (void (*drawscreen) (void)) $/;"	f	file:
translate_right	base/graphics.c	/^translate_right (void (*drawscreen) (void)) $/;"	f	file:
translate_up	base/graphics.c	/^translate_up (void (*drawscreen) (void)) $/;"	f	file:
traverse_clb	base/verilog_writer.c	/^pb_list *traverse_clb(t_pb *pb , pb_list *prim_list)$/;"	f
traverse_linked_list	base/verilog_writer.c	/^void traverse_linked_list(pb_list *list)$/;"	f
traverse_linked_list_conn	base/verilog_writer.c	/^void traverse_linked_list_conn(conn_list *list)$/;"	f
tried	base/vpr_types.h	/^	t_cluster_placement_primitive *tried; \/* ptrs to primitives that are open but current logic block unable to pack to *\/$/;"	m	struct:s_cluster_placement_stats
trigger_type	base/vpr_types.h	/^    char* trigger_type;$/;"	m	struct:s_logical_block
truth_table	base/vpr_types.h	/^	struct s_linked_vptr *truth_table; \/* If this is a LUT (.names), then this is the logic that the LUT implements *\/$/;"	m	struct:s_logical_block	typeref:struct:s_logical_block::s_linked_vptr
try_access_dir	spice/spice_utils.c	/^enum e_dir_err try_access_dir(char* dir_path) {$/;"	f
try_access_file	spice/spice_utils.c	/^int try_access_file(char* file_path) {$/;"	f
try_breadth_first_route	route/route_breadth_first.c	/^boolean try_breadth_first_route(struct s_router_opts router_opts,$/;"	f
try_breadth_first_route_cluster	pack/cluster_legality.c	/^boolean try_breadth_first_route_cluster(void) {$/;"	f
try_buffer_for_net	mrfpga/buffer_insertion.c	/^void try_buffer_for_net( int inet, t_rc_node** rc_node_free_list, t_linked_rc_edge** rc_edge_free_list, t_linked_rc_ptr* rr_node_to_rc_node, float* net_delay ) {$/;"	f
try_buffer_for_routing	mrfpga/buffer_insertion.c	/^void try_buffer_for_routing ( float** net_delay ) {$/;"	f
try_buffer_rc_tree	mrfpga/buffer_insertion.c	/^static t_buffer_plan_list try_buffer_rc_tree (t_rc_node *rc_node, int num_pins, int* isink_to_inode) {$/;"	f	file:
try_clb_pin_remap_after_placement	clb_pin_remap/place_clb_pin_remap.c	/^void try_clb_pin_remap_after_placement(t_det_routing_arch det_routing_arch,$/;"	f
try_create_molecule	pack/prepack.c	/^static t_pack_molecule *try_create_molecule($/;"	f	file:
try_expand_molecule	pack/prepack.c	/^static boolean try_expand_molecule(INOUTP t_pack_molecule *molecule,$/;"	f	file:
try_pack	pack/pack.c	/^void try_pack(INP struct s_packer_opts *packer_opts, INP const t_arch * arch,$/;"	f
try_pack_molecule	pack/cluster.c	/^static enum e_block_pack_status try_pack_molecule($/;"	f	file:
try_place	place/place.c	/^void try_place(struct s_placer_opts placer_opts,$/;"	f
try_place_logical_block_rec	pack/cluster.c	/^static enum e_block_pack_status try_place_logical_block_rec($/;"	f	file:
try_place_macro	place/place.c	/^static int try_place_macro(int itype, int ichoice, int imacro, int * free_locations){$/;"	f	file:
try_place_molecule	pack/cluster_placement.c	/^static float try_place_molecule(INP t_pack_molecule *molecule,$/;"	f	file:
try_remap_blk_class_one_conflict_pin	clb_pin_remap/place_clb_pin_remap.c	/^int try_remap_blk_class_one_conflict_pin(t_block* target_blk, int class_index, int pin_index,$/;"	f
try_route	route/route_common.c	/^boolean try_route(int width_fac, struct s_router_opts router_opts,$/;"	f
try_sat_one_blk_pin_class_prefer_side	clb_pin_remap/place_clb_pin_remap.c	/^int try_sat_one_blk_pin_class_prefer_side(t_block* target_blk,$/;"	f
try_swap	place/place.c	/^static enum swap_result try_swap(float t, float *cost, float *bb_cost, float *timing_cost,$/;"	f	file:
try_timing_driven_route	route/route_timing.c	/^boolean try_timing_driven_route(struct s_router_opts router_opts,$/;"	f
try_update_lookahead_pins_used	pack/cluster.c	/^static void try_update_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:
ts_bb_coord_new	place/place.c	/^static struct s_bb *ts_bb_coord_new = NULL;$/;"	v	typeref:struct:s_bb	file:
ts_bb_edge_new	place/place.c	/^static struct s_bb *ts_bb_edge_new = NULL;$/;"	v	typeref:struct:s_bb	file:
ts_nets_to_update	place/place.c	/^static int *ts_nets_to_update = NULL;$/;"	v	file:
tsu_tco	../../libarchfpga/include/physical_types.h	/^	float tsu_tco; \/* For sequential logic elements, this is the setup time (if input) or clock-to-q time (if output) *\/$/;"	m	struct:s_pb_graph_pin
turn_on_off	base/graphics.c	/^static void turn_on_off (int pressed) {$/;"	f	file:
twisted	base/vpr_types.h	/^	boolean twisted;$/;"	m	struct:s_seg_details
txt	../../libarchfpga/include/ezxml.h	/^	char *txt; \/* tag character content, empty string if none *\/$/;"	m	struct:ezxml
type	../../libarchfpga/include/physical_types.h	/^	enum PORTS type;$/;"	m	struct:s_port	typeref:enum:s_port::PORTS
type	../../libarchfpga/include/physical_types.h	/^	enum e_interconnect type;$/;"	m	struct:s_interconnect	typeref:enum:s_interconnect::e_interconnect
type	../../libarchfpga/include/physical_types.h	/^	enum e_pb_graph_pin_type type; \/* Is a sequential logic element (TRUE), inpad\/outpad (TRUE), or neither (FALSE) *\/$/;"	m	struct:s_pb_graph_pin	typeref:enum:s_pb_graph_pin::e_pb_graph_pin_type
type	../../libarchfpga/include/physical_types.h	/^	enum e_pin_to_pin_annotation_type type;$/;"	m	struct:s_pin_to_pin_annotation	typeref:enum:s_pin_to_pin_annotation::e_pin_to_pin_annotation_type
type	../../libarchfpga/include/physical_types.h	/^	enum e_pin_type type;$/;"	m	struct:s_class	typeref:enum:s_class::e_pin_type
type	../../libarchfpga/include/physical_types.h	/^	enum e_stat type;$/;"	m	struct:s_chan	typeref:enum:s_chan::e_stat
type	../../libarchfpga/include/physical_types.h	/^    char* type;$/;"	m	struct:s_switch_inf
type	../../libarchfpga/include/physical_types.h	/^  enum e_swseg_pattern_type type;$/;"	m	struct:s_swseg_pattern_inf	typeref:enum:s_swseg_pattern_inf::e_swseg_pattern_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_model_buffer_type type;$/;"	m	struct:s_spice_model_buffer	typeref:enum:s_spice_model_buffer::e_spice_model_buffer_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_model_pass_gate_logic_type type;$/;"	m	struct:s_spice_model_pass_gate_logic	typeref:enum:s_spice_model_pass_gate_logic::e_spice_model_pass_gate_logic_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_model_port_type type;$/;"	m	struct:s_spice_model_port	typeref:enum:s_spice_model_port::e_spice_model_port_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_model_type type;$/;"	m	struct:s_spice_model	typeref:enum:s_spice_model::e_spice_model_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_tech_lib_type type;$/;"	m	struct:s_spice_tech_lib	typeref:enum:s_spice_tech_lib::e_spice_tech_lib_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_spice_trans_type type;$/;"	m	struct:s_spice_transistor_type	typeref:enum:s_spice_transistor_type::e_spice_trans_type
type	../../libarchfpga/include/spice_types.h	/^  enum e_wire_model_type type;$/;"	m	struct:s_spice_model_wire_param	typeref:enum:s_spice_model_wire_param::e_wire_model_type
type	base/graphics.c	/^   t_button_type type;$/;"	m	struct:__anon4	file:
type	base/vpr_types.h	/^	e_tnode_type type; \/* see the above enum *\/$/;"	m	struct:s_tnode
type	base/vpr_types.h	/^	enum e_pack_pattern_molecule_type type; \/* what kind of molecule is this? *\/$/;"	m	struct:s_pack_molecule	typeref:enum:s_pack_molecule::e_pack_pattern_molecule_type
type	base/vpr_types.h	/^	enum logical_block_types type; \/* I\/O, combinational logic, or latch *\/$/;"	m	struct:s_logical_block	typeref:enum:s_logical_block::logical_block_types
type	base/vpr_types.h	/^	enum sched_type type;$/;"	m	struct:s_annealing_sched	typeref:enum:s_annealing_sched::sched_type
type	base/vpr_types.h	/^	t_rr_type type;$/;"	m	struct:s_rr_node
type	base/vpr_types.h	/^	t_type_ptr type;$/;"	m	struct:s_block
type	base/vpr_types.h	/^	t_type_ptr type;$/;"	m	struct:s_grid_tile
type	util/token.h	/^	enum e_token_type type;$/;"	m	struct:s_token	typeref:enum:s_token::e_token_type
type_descriptors	base/globals.c	/^struct s_type_descriptor *type_descriptors = NULL;$/;"	v	typeref:struct:s_type_descriptor
type_descriptors_backup	place/timing_place_lookup.c	/^static t_type_descriptor *type_descriptors_backup;$/;"	v	file:
u	../../libarchfpga/include/ezxml.h	/^	char *u; \/* UTF-8 conversion of string if original was UTF-16 *\/$/;"	m	struct:ezxml_root
u	route/route_common.h	/^	} u;$/;"	m	struct:s_heap	typeref:union:s_heap::__anon14
u	route/route_tree_timing.h	/^	} u;$/;"	m	struct:s_rt_node	typeref:union:s_rt_node::__anon16
u	timing/net_delay_types.h	/^	} u;$/;"	m	struct:s_rc_node	typeref:union:s_rc_node::__anon18
unbuf_switch	../../libarchfpga/include/physical_types.h	/^  short unbuf_switch;$/;"	m	struct:s_swseg_pattern_inf
unbuf_switched	base/vpr_types.h	/^    int unbuf_switched; \/* Xifan TANG: Switch Segment Pattern Support*\/$/;"	m	struct:s_rr_node
unclustered_list_head	pack/cluster.c	/^static struct s_molecule_link *unclustered_list_head;$/;"	v	typeref:struct:s_molecule_link	file:
unclustered_list_head_size	pack/cluster.c	/^int unclustered_list_head_size;$/;"	v
unmap_button	base/graphics.c	/^static void unmap_button (int bnum) $/;"	f	file:
unmark_fanout_intermediate_nodes	pack/cluster_feasibility_filter.c	/^static void unmark_fanout_intermediate_nodes($/;"	f	file:
updateRect	base/graphics.c	/^static RECT adjustRect, updateRect;$/;"	v	file:
update_bb	place/place.c	/^static void update_bb(int inet, struct s_bb *bb_coord_new,$/;"	f	file:
update_cluster_stats	pack/cluster.c	/^static void update_cluster_stats( INP t_pack_molecule *molecule,$/;"	f	file:
update_connection_gain_values	pack/cluster.c	/^static void update_connection_gain_values(int inet, int clustered_block,$/;"	f	file:
update_grid_pbs_post_route_rr_graph	spice/spice_utils.c	/^void update_grid_pbs_post_route_rr_graph() {$/;"	f
update_message	base/graphics.c	/^update_message (const char *msg) $/;"	f
update_message	base/graphics.c	/^void update_message (const char *msg) { }$/;"	f
update_net_delays_from_route_tree	route/route_tree_timing.c	/^void update_net_delays_from_route_tree(float *net_delay,$/;"	f
update_normalized_costs	timing/path_delay.c	/^static void update_normalized_costs(float criticality_denom, long max_critical_input_paths,$/;"	f	file:
update_one_grid_pack_prev_node_edge	spice/spice_utils.c	/^void update_one_grid_pack_prev_node_edge(int x, int y) {$/;"	f
update_primitive_cost_or_status	pack/cluster_placement.c	/^static void update_primitive_cost_or_status(INP t_pb_graph_node *pb_graph_node,$/;"	f	file:
update_ps_transform	base/graphics.c	/^update_ps_transform (void) $/;"	f	file:
update_rlim	place/place.c	/^static void update_rlim(float *rlim, float success_rat) {$/;"	f	file:
update_route_tree	route/route_tree_timing.c	/^update_route_tree(struct s_heap * hptr) {$/;"	f
update_rr_base_costs	route/route_timing.c	/^static void update_rr_base_costs(int inet, float largest_criticality) {$/;"	f	file:
update_rr_nodes_driver_switch	route/rr_graph_swseg.c	/^void update_rr_nodes_driver_switch(enum e_directionality directionality) {$/;"	f
update_screen	base/draw.c	/^void update_screen(int priority, char *msg, enum pic_type pic_on_screen_val,$/;"	f
update_slacks	timing/path_delay.c	/^static void update_slacks(t_slack * slacks, int source_clock_domain, int sink_clock_domain, float criticality_denom,$/;"	f	file:
update_t	place/place.c	/^static void update_t(float *t, float std_dev, float rlim, float success_rat,$/;"	f	file:
update_td_cost	place/place.c	/^static void update_td_cost(void) {$/;"	f	file:
update_timing_gain_values	pack/cluster.c	/^static void update_timing_gain_values(int inet, int clustered_block,$/;"	f	file:
update_total_gain	pack/cluster.c	/^static void update_total_gain(float alpha, float beta, boolean timing_driven,$/;"	f	file:
update_traceback	route/route_common.c	/^update_traceback(struct s_heap *hptr, int inet) {$/;"	f
update_transform	base/graphics.c	/^update_transform (void) $/;"	f	file:
update_unbuffered_ancestors_C_downstream	route/route_tree_timing.c	/^update_unbuffered_ancestors_C_downstream(t_rt_node * start_of_new_path_rt_node) {$/;"	f	file:
update_win	base/graphics.c	/^update_win (int x[2], int y[2], void (*drawscreen)(void)) $/;"	f	file:
usage	base/vpr_types.h	/^	int usage;$/;"	m	struct:s_grid_tile
use_default_timing_constraints	timing/read_sdc.c	/^static void use_default_timing_constraints(void) {$/;"	f	file:
used	../../libarchfpga/include/logic_types.h	/^	int used;$/;"	m	struct:s_model
used_input_pins	base/vpr_types.h	/^	int used_input_pins; \/* Number of used input pins *\/$/;"	m	struct:s_logical_block
user_models	base/vpr_types.h	/^	t_model * user_models; \/* blif models defined by the user *\/$/;"	m	struct:s_vpr_setup
v_ds	power/power.h	/^	float v_ds;$/;"	m	struct:s_power_nmos_leakage_pair
v_in	power/power.h	/^	float v_in;$/;"	m	struct:s_power_mux_volt_pair
v_out_max	power/power.h	/^	float v_out_max;$/;"	m	struct:s_power_mux_volt_pair
v_out_min	power/power.h	/^	float v_out_min;$/;"	m	struct:s_power_mux_volt_pair
valid	../../libarchfpga/include/cad_types.h	/^	boolean valid;$/;"	m	struct:s_cluster_placement_primitive
valid	base/vpr_types.h	/^	boolean valid; \/* Whether or not this molecule is still valid *\/$/;"	m	struct:s_pack_molecule
valid_primitives	base/vpr_types.h	/^	t_cluster_placement_primitive **valid_primitives; \/* [0..num_pb_types-1] ptrs to linked list of valid primitives, for convenience, each linked list head is empty *\/$/;"	m	struct:s_cluster_placement_stats
value	../../libarchfpga/include/physical_types.h	/^	char ** value; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:s_pin_to_pin_annotation
value	mrfpga/buffer_insertion.c	/^typedef struct s_buffer_plan_node { t_buffer_plan value; struct s_buffer_plan_node* next;} t_buffer_plan_node;$/;"	m	struct:s_buffer_plan_node	file:
verify_binary_search	base/vpr_types.h	/^	boolean verify_binary_search;$/;"	m	struct:s_router_opts
verilog_writer	base/verilog_writer.c	/^void verilog_writer(void)$/;"	f
view_mux_size_distribution	route/rr_graph.c	/^view_mux_size_distribution(t_ivec *** L_rr_node_indices,$/;"	f	file:
visited	power/power.h	/^	boolean visited; \/* When traversing netlist, need to track whether the node has been processed *\/$/;"	m	struct:s_rr_node_power
vpack_net	base/globals.c	/^struct s_net *vpack_net = NULL;$/;"	v	typeref:struct:s_net
vpack_to_clb_net_mapping	base/globals.c	/^int *vpack_to_clb_net_mapping = NULL; \/* [0..num_vpack_nets - 1] *\/$/;"	v
vpr_alloc_and_load_output_file_names	base/vpr_api.c	/^void vpr_alloc_and_load_output_file_names(const char* default_name) {$/;"	f
vpr_check_arch	base/vpr_api.c	/^void vpr_check_arch(INP t_arch Arch, INP boolean TimingEnabled) {$/;"	f
vpr_check_options	base/vpr_api.c	/^void vpr_check_options(INP t_options Options, INP boolean TimingEnabled) {$/;"	f
vpr_check_setup	base/vpr_api.c	/^void vpr_check_setup(INP enum e_operation Operation,$/;"	f
vpr_free_all	base/vpr_api.c	/^void vpr_free_all(INOUTP t_arch Arch, INOUTP t_options options,$/;"	f
vpr_free_vpr_data_structures	base/vpr_api.c	/^void vpr_free_vpr_data_structures(INOUTP t_arch Arch, INOUTP t_options options,$/;"	f
vpr_get_output_file_name	base/vpr_api.c	/^char *vpr_get_output_file_name(enum e_output_files ename) {$/;"	f
vpr_init	base/vpr_api.c	/^void vpr_init(INP int argc, INP char **argv, OUTP t_options *options,$/;"	f
vpr_init_pre_place_and_route	base/vpr_api.c	/^void vpr_init_pre_place_and_route(INP t_vpr_setup vpr_setup, INP t_arch Arch) {$/;"	f
vpr_pack	base/vpr_api.c	/^void vpr_pack(INP t_vpr_setup vpr_setup, INP t_arch arch) {$/;"	f
vpr_place_and_route	base/vpr_api.c	/^void vpr_place_and_route(INP t_vpr_setup vpr_setup, INP t_arch arch) {$/;"	f
vpr_power_estimation	base/vpr_api.c	/^void vpr_power_estimation(t_vpr_setup vpr_setup, t_arch Arch) {$/;"	f
vpr_print_spice_netlists	spice/spice_api.c	/^void vpr_print_spice_netlists(t_vpr_setup vpr_setup,$/;"	f
vpr_print_title	base/vpr_api.c	/^void vpr_print_title(void) {$/;"	f
vpr_print_usage	base/vpr_api.c	/^void vpr_print_usage(void) {$/;"	f
vpr_printf	../../libarchfpga/util.c	/^messagelogger vpr_printf = PrintHandlerMessage;$/;"	v
vpr_read_and_process_blif	base/vpr_api.c	/^void vpr_read_and_process_blif(INP char *blif_file,$/;"	f
vpr_read_options	base/vpr_api.c	/^void vpr_read_options(INP int argc, INP char **argv, OUTP t_options * options) {$/;"	f
vpr_resync_post_route_netlist_to_TI_CLAY_v1_architecture	base/vpr_api.c	/^t_trace* vpr_resync_post_route_netlist_to_TI_CLAY_v1_architecture($/;"	f
vpr_set_output_file_name	base/vpr_api.c	/^void vpr_set_output_file_name(enum e_output_files ename, const char *name,$/;"	f
vpr_setup_vpr	base/vpr_api.c	/^void vpr_setup_vpr(INP t_options *Options, INP boolean TimingEnabled,$/;"	f
vpr_show_setup	base/vpr_api.c	/^void vpr_show_setup(INP t_options options, INP t_vpr_setup vpr_setup) {$/;"	f
vpr_to_phy_track	route/rr_graph2.c	/^static int vpr_to_phy_track(INP int itrack, INP int chan_num, INP int seg_num,$/;"	f	file:
watch_edges	route/rr_graph.c	/^void watch_edges(int inode, t_linked_edge * edge_list_head) {$/;"	f
which_button	base/graphics.c	/^static int which_button (Window win) $/;"	f	file:
width	../../libarchfpga/include/physical_types.h	/^	float width;$/;"	m	struct:s_chan
width	base/graphics.c	/^   int width; $/;"	m	struct:__anon4	file:
win	base/graphics.c	/^   Window win; $/;"	m	struct:__anon4	file:
win32_colors	base/graphics.c	/^static const COLORREF win32_colors[NUM_COLOR] = { RGB(255, 255, 255),$/;"	v	file:
win32_drain_message_queue	base/graphics.c	/^void win32_drain_message_queue () {$/;"	f
win32_line_styles	base/graphics.c	/^static const int win32_line_styles[2] = { PS_SOLID, PS_DASH };$/;"	v	file:
windowAdjustFlag	base/graphics.c	/^static int windowAdjustFlag = 0, adjustButton = -1;$/;"	v	file:
wire	../../libarchfpga/include/physical_types.h	/^	} wire;$/;"	m	struct:s_port_power	typeref:union:s_port_power::__anon22
wire_buffer_inf	../../libarchfpga/include/arch_types_mrfpga.h	/^  t_buffer_inf wire_buffer_inf;$/;"	m	struct:s_arch_mrfpga
wire_buffer_inf	mrfpga/mrfpga_globals.c	/^t_buffer_inf wire_buffer_inf;$/;"	v
wire_param	../../libarchfpga/include/spice_types.h	/^  t_spice_model_wire_param* wire_param;$/;"	m	struct:s_spice_model
wire_switch	../../libarchfpga/include/physical_types.h	/^	short wire_switch;$/;"	m	struct:s_segment_inf
wire_switch	base/vpr_types.h	/^	short wire_switch;$/;"	m	struct:s_seg_details
wire_to_ipin_switch	base/vpr_types.h	/^	short wire_to_ipin_switch;$/;"	m	struct:s_det_routing_arch
wire_type	../../libarchfpga/include/physical_types.h	/^	e_power_wire_type wire_type;$/;"	m	struct:s_port_power
wirelength	base/place_and_route.h	/^	int wirelength; \/* corresponding wirelength of successful routing at wneed *\/$/;"	m	struct:s_fmap_cell
wires_spice_file_name	spice/spice_globals.c	/^char* wires_spice_file_name = "wires.sp";$/;"	v
wneed	base/place_and_route.h	/^	int wneed; \/* need wneed to route *\/$/;"	m	struct:s_fmap_cell
write	../../libarchfpga/ezxml.c	60;"	d	file:
x	base/easygl_constants.h	/^	float x; $/;"	m	struct:__anon1
x	base/vpr_types.h	/^	int x;$/;"	m	struct:s_block
x	place/place.c	/^	int x;$/;"	m	struct:s_legal_pos	file:
x_offset	../../libarchfpga/include/physical_types.h	/^	int x_offset;$/;"	m	struct:s_direct_inf
x_offset	place/place_macro.h	/^	int x_offset;$/;"	m	struct:s_pl_macro_member
x_rr_node_left	base/draw.c	/^static float *x_rr_node_left = NULL;$/;"	v	file:
x_rr_node_right	base/draw.c	/^static float *x_rr_node_right = NULL;$/;"	v	file:
xcoord	base/graphics.c	/^static int xcoord (float worldx) $/;"	f	file:
xdiv	base/graphics.c	/^static float xdiv, ydiv;$/;"	v	file:
xhigh	base/vpr_types.h	/^	short xhigh;$/;"	m	struct:s_rr_node
xleft	base/graphics.c	/^   int xleft; $/;"	m	struct:__anon4	file:
xleft	base/graphics.c	/^static float xleft, xright, ytop, ybot;         \/* world coordinates *\/$/;"	v	file:
xleft	base/graphics.h	/^	float xleft, xright, ytop, ybot;$/;"	m	struct:__anon6
xlow	base/vpr_types.h	/^	short xlow;$/;"	m	struct:s_rr_node
xmax	base/vpr_types.h	/^	int xmax;$/;"	m	struct:s_bb
xmin	base/vpr_types.h	/^	int xmin;$/;"	m	struct:s_bb
xml	../../libarchfpga/include/ezxml.h	/^	struct ezxml xml; \/* is a super-struct built on top of ezxml struct *\/$/;"	m	struct:ezxml_root	typeref:struct:ezxml_root::ezxml
xmult	base/graphics.c	/^static float xmult, ymult;                  \/* Transformation factors *\/$/;"	v	file:
xmult	base/graphics.h	/^	float xmult, ymult;$/;"	m	struct:__anon6
xnew	place/place.c	/^	int xnew;$/;"	m	struct:s_pl_moved_block	file:
xold	place/place.c	/^	int xold;$/;"	m	struct:s_pl_moved_block	file:
xpeak	../../libarchfpga/include/physical_types.h	/^	float xpeak;$/;"	m	struct:s_chan
xright	base/graphics.c	/^static float xleft, xright, ytop, ybot;         \/* world coordinates *\/$/;"	v	file:
xright	base/graphics.h	/^	float xleft, xright, ytop, ybot;$/;"	m	struct:__anon6
y	base/easygl_constants.h	/^	float y;$/;"	m	struct:__anon1
y	base/vpr_types.h	/^	int y;$/;"	m	struct:s_block
y	place/place.c	/^	int y;$/;"	m	struct:s_legal_pos	file:
y_offset	../../libarchfpga/include/physical_types.h	/^	int y_offset;$/;"	m	struct:s_direct_inf
y_offset	place/place_macro.h	/^	int y_offset;	 $/;"	m	struct:s_pl_macro_member
y_rr_node_bottom	base/draw.c	/^static float *y_rr_node_bottom = NULL;$/;"	v	file:
y_rr_node_top	base/draw.c	/^static float *y_rr_node_top = NULL;$/;"	v	file:
ybot	base/graphics.c	/^static float xleft, xright, ytop, ybot;         \/* world coordinates *\/$/;"	v	file:
ybot	base/graphics.h	/^	float xleft, xright, ytop, ybot;$/;"	m	struct:__anon6
ycoord	base/graphics.c	/^static int ycoord (float worldy) $/;"	f	file:
ydiv	base/graphics.c	/^static float xdiv, ydiv;$/;"	v	file:
yhigh	base/vpr_types.h	/^	short yhigh;$/;"	m	struct:s_rr_node
ylow	base/vpr_types.h	/^	short ylow;$/;"	m	struct:s_rr_node
ymax	base/vpr_types.h	/^	int ymax;$/;"	m	struct:s_bb
ymin	base/vpr_types.h	/^	int ymin;$/;"	m	struct:s_bb
ymult	base/graphics.c	/^static float xmult, ymult;                  \/* Transformation factors *\/$/;"	v	file:
ymult	base/graphics.h	/^	float xmult, ymult;$/;"	m	struct:__anon6
ynew	place/place.c	/^	int ynew;$/;"	m	struct:s_pl_moved_block	file:
yold	place/place.c	/^	int yold;$/;"	m	struct:s_pl_moved_block	file:
ytop	base/graphics.c	/^   int ytop;$/;"	m	struct:__anon4	file:
ytop	base/graphics.c	/^static float xleft, xright, ytop, ybot;         \/* world coordinates *\/$/;"	v	file:
ytop	base/graphics.h	/^	float xleft, xright, ytop, ybot;$/;"	m	struct:__anon6
z	base/vpr_types.h	/^	int z; \/* For IPIN, source, and sink nodes, helps identify which location this rr_node belongs to *\/$/;"	m	struct:s_rr_node
z	base/vpr_types.h	/^	int z;$/;"	m	struct:s_block
z	place/place.c	/^	int z;$/;"	m	struct:s_legal_pos	file:
z_offset	../../libarchfpga/include/physical_types.h	/^	int z_offset;$/;"	m	struct:s_direct_inf
z_offset	place/place_macro.h	/^	int z_offset;$/;"	m	struct:s_pl_macro_member
znew	place/place.c	/^	int znew;$/;"	m	struct:s_pl_moved_block	file:
zold	place/place.c	/^	int zold;$/;"	m	struct:s_pl_moved_block	file:
zoom_fit	base/graphics.c	/^zoom_fit (void (*drawscreen) (void)) $/;"	f	file:
zoom_in	base/graphics.c	/^zoom_in (void (*drawscreen) (void)) $/;"	f	file:
zoom_out	base/graphics.c	/^zoom_out (void (*drawscreen) (void)) $/;"	f	file:
