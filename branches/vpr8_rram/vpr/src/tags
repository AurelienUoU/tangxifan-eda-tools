!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AAPACK_MAX_FEASIBLE_BLOCK_ARRAY_SIZE	pack/cluster.cpp	/^#define AAPACK_MAX_FEASIBLE_BLOCK_ARRAY_SIZE /;"	d	file:
AAPACK_MAX_HIGH_FANOUT_EXPLORE	pack/cluster.cpp	/^#define AAPACK_MAX_HIGH_FANOUT_EXPLORE /;"	d	file:
AAPACK_MAX_NET_SINKS_IGNORE	pack/cluster.cpp	/^#define AAPACK_MAX_NET_SINKS_IGNORE /;"	d	file:
AAPACK_MAX_TRANSITIVE_EXPLORE	pack/cluster.cpp	/^#define AAPACK_MAX_TRANSITIVE_EXPLORE /;"	d	file:
AAPACK_MAX_TRANSITIVE_FANOUT_EXPLORE	pack/cluster.cpp	/^#define AAPACK_MAX_TRANSITIVE_FANOUT_EXPLORE /;"	d	file:
ABORTED	place/place.cpp	/^	REJECTED, ACCEPTED, ABORTED$/;"	e	enum:e_swap_result	file:
ABSOLUTE	../../libs/libarchfpga/src/physical_types.h	/^	ABSOLUTE, FRACTIONAL$/;"	e	enum:e_Fc_type
ACCEPTED	place/place.cpp	/^	REJECTED, ACCEPTED, ABORTED$/;"	e	enum:e_swap_result	file:
ACTIVE_HIGH	base/netlist_writer.cpp	/^            ACTIVE_HIGH,$/;"	m	class:LatchInst::Type	file:	access:private
ACTIVE_LOW	base/netlist_writer.cpp	/^            ACTIVE_LOW,$/;"	m	class:LatchInst::Type	file:	access:private
AGGREGATED	base/vpr_types.h	/^    AGGREGATED,         \/\/Show aggregated intra-block and inter-block delays$/;"	m	class:ScreenUpdatePriority::e_timing_report_detail	access:private
AGGRESSIVE	base/vpr_types.h	/^	OFF, SAFE, AGGRESSIVE$/;"	e	enum:ScreenUpdatePriority::e_routing_failure_predictor
ALICEBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    ALICEBLUE,$/;"	e	enum:color_types
ALL_NETS	draw/draw_types.h	/^	ALL_NETS, HIGHLIGHTED$/;"	e	enum:e_draw_net_type
ANALYSIS_DELAY_CALCULATOR_H	timing/AnalysisDelayCalculator.h	/^#define ANALYSIS_DELAY_CALCULATOR_H$/;"	d
ANTIQUEWHITE	../../libs/libeasygl/src/easygl_constants.h	/^    ANTIQUEWHITE,$/;"	e	enum:color_types
ANY	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
ANYBUT	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
ANYOF	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
AQUA	../../libs/libeasygl/src/easygl_constants.h	/^    AQUA,$/;"	e	enum:color_types
AQUAMARINE	../../libs/libeasygl/src/easygl_constants.h	/^    AQUAMARINE,$/;"	e	enum:color_types
ARCH_ERROR_H	../../libs/libarchfpga/src/arch_error.h	/^#define ARCH_ERROR_H$/;"	d
ARCH_TYPES_H	../../libs/libarchfpga/src/arch_types.h	/^#define ARCH_TYPES_H$/;"	d
ARCH_UTIL_H	../../libs/libarchfpga/src/arch_util.h	/^#define ARCH_UTIL_H$/;"	d
AREA_IMPROVED_MIXED	route/rr_graph_area.cpp	/^			AREA_IMPROVED_MIXED		\/* both NMOS and PMOS. extra spacing required for N-wells *\/$/;"	e	enum:e_trans_area_eq	file:
AREA_IMPROVED_NMOS_ONLY	route/rr_graph_area.cpp	/^			AREA_IMPROVED_NMOS_ONLY,	\/* only NMOS transistors taken into account *\/$/;"	e	enum:e_trans_area_eq	file:
AREA_ORIGINAL	route/rr_graph_area.cpp	/^enum e_trans_area_eq {	AREA_ORIGINAL,$/;"	e	enum:e_trans_area_eq	file:
ARITHMEAN	base/vpr_types.h	/^    ARITHMEAN,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
ASYNCHRONOUS	base/netlist_writer.cpp	/^            ASYNCHRONOUS,$/;"	m	class:LatchInst::Type	file:	access:private
ATOM_LOOKUP_H	base/atom_lookup.h	/^#define ATOM_LOOKUP_H$/;"	d
ATOM_NETLIST_FWD_H	base/atom_netlist_fwd.h	/^#define ATOM_NETLIST_FWD_H$/;"	d
ATOM_NETLIST_H	base/atom_netlist.h	/^#define ATOM_NETLIST_H$/;"	d
ATOM_NETLIST_UTILS_H	base/atom_netlist_utils.h	/^#define ATOM_NETLIST_UTILS_H$/;"	d
AUTO	../../libs/libarchfpga/src/physical_types.h	/^    AUTO,$/;"	e	enum:GridDefType
AUTO	../../libs/libarchfpga/src/physical_types.h	/^    AUTO,$/;"	m	class:BufferSize	access:private
AUTO	base/read_circuit.h	/^    AUTO, \/\/Infer from file extension$/;"	m	class:e_circuit_format	access:private
AUTO_SCHED	base/vpr_types.h	/^	AUTO_SCHED, USER_SCHED$/;"	e	enum:ScreenUpdatePriority::sched_type
AVERAGE	route/router_lookahead_map.cpp	/^	AVERAGE,$/;"	e	enum:e_representative_entry_method	file:
AZURE	../../libs/libeasygl/src/easygl_constants.h	/^    AZURE,$/;"	e	enum:color_types
ActFile	base/read_options.h	/^    argparse::ArgValue<std::string> ActFile;$/;"	m	struct:t_options	access:public
ActFile	base/vpr_types.h	/^	std::string ActFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
AnalysisOpts	base/vpr_types.h	/^    t_analysis_opts AnalysisOpts; \/* Analysis options *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
AnnealSched	base/vpr_types.h	/^	t_annealing_sched AnnealSched; \/* Placement option annealing schedule *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
Arc	base/netlist_writer.cpp	/^        Arc(std::string src_port, \/\/Source of the arc$/;"	f	class:Arc	access:public	signature:(std::string src_port, int src_ipin, std::string snk_port, int snk_ipin, float del, std::string cond=Ó)
Arc	base/netlist_writer.cpp	/^class Arc {$/;"	c	file:
Arc::Arc	base/netlist_writer.cpp	/^        Arc(std::string src_port, \/\/Source of the arc$/;"	f	class:Arc	access:public	signature:(std::string src_port, int src_ipin, std::string snk_port, int snk_ipin, float del, std::string cond=Ó)
Arc::condition	base/netlist_writer.cpp	/^        std::string condition() const { return condition_; }$/;"	f	class:Arc	access:public	signature:() const
Arc::condition_	base/netlist_writer.cpp	/^        std::string condition_;$/;"	m	class:Arc	file:	access:private
Arc::delay	base/netlist_writer.cpp	/^        double delay() const { return delay_; }$/;"	f	class:Arc	access:public	signature:() const
Arc::delay_	base/netlist_writer.cpp	/^        double delay_;$/;"	m	class:Arc	file:	access:private
Arc::sink_ipin	base/netlist_writer.cpp	/^        int sink_ipin() const { return sink_ipin_; }$/;"	f	class:Arc	access:public	signature:() const
Arc::sink_ipin_	base/netlist_writer.cpp	/^        int sink_ipin_;$/;"	m	class:Arc	file:	access:private
Arc::sink_name	base/netlist_writer.cpp	/^        std::string sink_name() const { return sink_name_; }$/;"	f	class:Arc	access:public	signature:() const
Arc::sink_name_	base/netlist_writer.cpp	/^        std::string sink_name_;$/;"	m	class:Arc	file:	access:private
Arc::source_ipin	base/netlist_writer.cpp	/^        int source_ipin() const { return source_ipin_; }$/;"	f	class:Arc	access:public	signature:() const
Arc::source_ipin_	base/netlist_writer.cpp	/^        int source_ipin_;$/;"	m	class:Arc	file:	access:private
Arc::source_name	base/netlist_writer.cpp	/^        std::string source_name() const { return source_name_; }$/;"	f	class:Arc	access:public	signature:() const
Arc::source_name_	base/netlist_writer.cpp	/^        std::string source_name_;$/;"	m	class:Arc	file:	access:private
ArchFile	base/read_options.h	/^    argparse::ArgValue<std::string> ArchFile;$/;"	m	struct:t_options	access:public
ArchFile	base/vpr_types.h	/^    std::string ArchFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ArchFpgaError	../../libs/libarchfpga/src/arch_error.h	/^        ArchFpgaError(std::string msg="", std::string new_filename="", size_t new_linenumber=-1)$/;"	f	class:ArchFpgaError	access:public	signature:(std::string msg=Ó, std::string new_filename=Ó, size_t new_linenumber=-1)
ArchFpgaError	../../libs/libarchfpga/src/arch_error.h	/^class ArchFpgaError : public vtr::VtrError {$/;"	c	inherits:vtr::VtrError
ArchFpgaError::ArchFpgaError	../../libs/libarchfpga/src/arch_error.h	/^        ArchFpgaError(std::string msg="", std::string new_filename="", size_t new_linenumber=-1)$/;"	f	class:ArchFpgaError	access:public	signature:(std::string msg=Ó, std::string new_filename=Ó, size_t new_linenumber=-1)
Assignment	base/netlist_writer.cpp	/^        Assignment(std::string lval, \/\/The left value (assigned to)$/;"	f	class:Assignment	access:public	signature:(std::string lval, std::string rval)
Assignment	base/netlist_writer.cpp	/^class Assignment {$/;"	c	file:
Assignment::Assignment	base/netlist_writer.cpp	/^        Assignment(std::string lval, \/\/The left value (assigned to)$/;"	f	class:Assignment	access:public	signature:(std::string lval, std::string rval)
Assignment::lval_	base/netlist_writer.cpp	/^        std::string lval_;$/;"	m	class:Assignment	file:	access:private
Assignment::print_blif	base/netlist_writer.cpp	/^        void print_blif(std::ostream& os, std::string indent) {$/;"	f	class:Assignment	access:public	signature:(std::ostream& os, std::string indent)
Assignment::print_verilog	base/netlist_writer.cpp	/^        void print_verilog(std::ostream& os, std::string indent) {$/;"	f	class:Assignment	access:public	signature:(std::ostream& os, std::string indent)
Assignment::rval_	base/netlist_writer.cpp	/^        std::string rval_;$/;"	m	class:Assignment	file:	access:private
AtomBlockId	base/atom_netlist_fwd.h	/^typedef vtr::StrongId<atom_block_id_tag> AtomBlockId;$/;"	t
AtomBlockType	base/atom_netlist_fwd.h	/^enum class AtomBlockType : char {$/;"	c
AtomBlockType::INPAD	base/atom_netlist_fwd.h	/^    INPAD,          \/\/A primary input$/;"	m	class:AtomBlockType	access:private
AtomBlockType::OUTPAD	base/atom_netlist_fwd.h	/^    OUTPAD,         \/\/A primary output$/;"	m	class:AtomBlockType	access:private
AtomContext	base/vpr_context.h	/^struct AtomContext : public Context {$/;"	s	inherits:Context
AtomContext::lookup	base/vpr_context.h	/^    AtomLookup lookup;$/;"	m	struct:AtomContext	access:public
AtomContext::nlist	base/vpr_context.h	/^    AtomNetlist nlist;$/;"	m	struct:AtomContext	access:public
AtomDelayCalc	timing/atom_delay_calc.h	/^        AtomDelayCalc(const AtomNetlist& netlist, const AtomLookup& netlist_lookup);$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
AtomDelayCalc	timing/atom_delay_calc.h	/^class AtomDelayCalc {$/;"	c
AtomDelayCalc	timing/atom_delay_calc.inl	/^inline AtomDelayCalc::AtomDelayCalc(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)$/;"	f	class:AtomDelayCalc	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
AtomDelayCalc::AtomDelayCalc	timing/atom_delay_calc.h	/^        AtomDelayCalc(const AtomNetlist& netlist, const AtomLookup& netlist_lookup);$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
AtomDelayCalc::AtomDelayCalc	timing/atom_delay_calc.inl	/^inline AtomDelayCalc::AtomDelayCalc(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)$/;"	f	class:AtomDelayCalc	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
AtomDelayCalc::atom_clock_to_q_delay	timing/atom_delay_calc.h	/^        float atom_clock_to_q_delay(const AtomPinId clk_pin, const AtomPinId output_pin, const DelayType delay_type) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId clk_pin, const AtomPinId output_pin, const DelayType delay_type) const
AtomDelayCalc::atom_clock_to_q_delay	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_clock_to_q_delay(const AtomPinId \/*clock_pin*\/, const AtomPinId pin, const DelayType delay_type) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId , const AtomPinId pin, const DelayType delay_type) const
AtomDelayCalc::atom_combinational_delay	timing/atom_delay_calc.h	/^        float atom_combinational_delay(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const
AtomDelayCalc::atom_combinational_delay	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_combinational_delay(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const
AtomDelayCalc::atom_hold_time	timing/atom_delay_calc.h	/^        float atom_hold_time(const AtomPinId clk_pin, const AtomPinId input_pin) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId clk_pin, const AtomPinId input_pin) const
AtomDelayCalc::atom_hold_time	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_hold_time(const AtomPinId \/*clock_pin*\/, const AtomPinId pin) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId , const AtomPinId pin) const
AtomDelayCalc::atom_setup_time	timing/atom_delay_calc.h	/^        float atom_setup_time(const AtomPinId clk_pin, const AtomPinId input_pin) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId clk_pin, const AtomPinId input_pin) const
AtomDelayCalc::atom_setup_time	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_setup_time(const AtomPinId \/*clock_pin*\/, const AtomPinId pin) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId , const AtomPinId pin) const
AtomDelayCalc::find_pb_graph_pin	timing/atom_delay_calc.h	/^        const t_pb_graph_pin* find_pb_graph_pin(const AtomPinId atom_pin) const;$/;"	p	class:AtomDelayCalc	access:private	signature:(const AtomPinId atom_pin) const
AtomDelayCalc::find_pb_graph_pin	timing/atom_delay_calc.inl	/^inline const t_pb_graph_pin* AtomDelayCalc::find_pb_graph_pin(const AtomPinId atom_pin) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId atom_pin) const
AtomDelayCalc::netlist_	timing/atom_delay_calc.h	/^        const AtomNetlist& netlist_;$/;"	m	class:AtomDelayCalc	access:private
AtomDelayCalc::netlist_lookup_	timing/atom_delay_calc.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:AtomDelayCalc	access:private
AtomLookup	base/atom_lookup.h	/^class AtomLookup {$/;"	c
AtomLookup::atom_clb	base/atom_lookup.cpp	/^ClusterBlockId AtomLookup::atom_clb(const AtomBlockId blk_id) const {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id) const
AtomLookup::atom_clb	base/atom_lookup.h	/^        ClusterBlockId atom_clb(const AtomBlockId blk_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id) const
AtomLookup::atom_net	base/atom_lookup.cpp	/^AtomNetId AtomLookup::atom_net(const ClusterNetId clb_net_index) const {$/;"	f	class:AtomLookup	signature:(const ClusterNetId clb_net_index) const
AtomLookup::atom_net	base/atom_lookup.h	/^        AtomNetId atom_net(const ClusterNetId clb_net_index) const;$/;"	p	class:AtomLookup	access:public	signature:(const ClusterNetId clb_net_index) const
AtomLookup::atom_net_to_clb_net_	base/atom_lookup.h	/^        vtr::bimap<AtomNetId,ClusterNetId, vtr::linear_map, vtr::linear_map> atom_net_to_clb_net_;$/;"	m	class:AtomLookup	access:private
AtomLookup::atom_pb	base/atom_lookup.cpp	/^const t_pb* AtomLookup::atom_pb(const AtomBlockId blk_id) const {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id) const
AtomLookup::atom_pb	base/atom_lookup.h	/^        const t_pb* atom_pb(const AtomBlockId blk_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id) const
AtomLookup::atom_pb_graph_node	base/atom_lookup.cpp	/^const t_pb_graph_node* AtomLookup::atom_pb_graph_node(const AtomBlockId blk_id) const {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id) const
AtomLookup::atom_pb_graph_node	base/atom_lookup.h	/^        const t_pb_graph_node* atom_pb_graph_node(const AtomBlockId blk_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id) const
AtomLookup::atom_pin_classic_tnode	base/atom_lookup.cpp	/^int AtomLookup::atom_pin_classic_tnode(const AtomPinId pin_id) const {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin_id) const
AtomLookup::atom_pin_classic_tnode	base/atom_lookup.h	/^        int atom_pin_classic_tnode(const AtomPinId pin_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin_id) const
AtomLookup::atom_pin_pb_graph_pin	base/atom_lookup.cpp	/^const t_pb_graph_pin* AtomLookup::atom_pin_pb_graph_pin(AtomPinId atom_pin) const {$/;"	f	class:AtomLookup	signature:(AtomPinId atom_pin) const
AtomLookup::atom_pin_pb_graph_pin	base/atom_lookup.h	/^        const t_pb_graph_pin* atom_pin_pb_graph_pin(AtomPinId atom_pin) const;$/;"	p	class:AtomLookup	access:public	signature:(AtomPinId atom_pin) const
AtomLookup::atom_pin_tnode	base/atom_lookup.cpp	/^tatum::NodeId AtomLookup::atom_pin_tnode(const AtomPinId pin, BlockTnode block_tnode_type) const {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin, BlockTnode block_tnode_type) const
AtomLookup::atom_pin_tnode	base/atom_lookup.h	/^        tatum::NodeId atom_pin_tnode(const AtomPinId pin, BlockTnode block_tnode_type=BlockTnode::EXTERNAL) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin, BlockTnode block_tnode_type=BlockTnode::EXTERNAL) const
AtomLookup::atom_pin_tnode_external_	base/atom_lookup.h	/^        vtr::linear_map<AtomPinId,tatum::NodeId> atom_pin_tnode_external_;$/;"	m	class:AtomLookup	access:private
AtomLookup::atom_pin_tnode_internal_	base/atom_lookup.h	/^        vtr::linear_map<AtomPinId,tatum::NodeId> atom_pin_tnode_internal_;$/;"	m	class:AtomLookup	access:private
AtomLookup::atom_pin_to_classic_tnode_	base/atom_lookup.h	/^        vtr::bimap<AtomPinId,int,vtr::linear_map,linear_map_classic_tnode> atom_pin_to_classic_tnode_;$/;"	m	class:AtomLookup	access:private
AtomLookup::atom_pin_to_pb_graph_pin_	base/atom_lookup.h	/^        vtr::vector_map<AtomPinId,const t_pb_graph_pin*> atom_pin_to_pb_graph_pin_;$/;"	m	class:AtomLookup	access:private
AtomLookup::atom_to_clb_	base/atom_lookup.h	/^        vtr::vector_map<AtomBlockId,ClusterBlockId> atom_to_clb_;$/;"	m	class:AtomLookup	access:private
AtomLookup::atom_to_pb_	base/atom_lookup.h	/^        vtr::bimap<AtomBlockId,const t_pb*, vtr::linear_map, std::unordered_map> atom_to_pb_;$/;"	m	class:AtomLookup	access:private
AtomLookup::classic_tnode_atom_pin	base/atom_lookup.cpp	/^AtomPinId AtomLookup::classic_tnode_atom_pin(const int tnode_index) const {$/;"	f	class:AtomLookup	signature:(const int tnode_index) const
AtomLookup::classic_tnode_atom_pin	base/atom_lookup.h	/^        AtomPinId classic_tnode_atom_pin(const int tnode_index) const;$/;"	p	class:AtomLookup	access:public	signature:(const int tnode_index) const
AtomLookup::clb_net	base/atom_lookup.cpp	/^ClusterNetId AtomLookup::clb_net(const AtomNetId net_id) const {$/;"	f	class:AtomLookup	signature:(const AtomNetId net_id) const
AtomLookup::clb_net	base/atom_lookup.h	/^		ClusterNetId clb_net(const AtomNetId net_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomNetId net_id) const
AtomLookup::pb_atom	base/atom_lookup.cpp	/^AtomBlockId AtomLookup::pb_atom(const t_pb* pb) const {$/;"	f	class:AtomLookup	signature:(const t_pb* pb) const
AtomLookup::pb_atom	base/atom_lookup.h	/^        AtomBlockId pb_atom(const t_pb* pb) const;$/;"	p	class:AtomLookup	access:public	signature:(const t_pb* pb) const
AtomLookup::set_atom_clb	base/atom_lookup.cpp	/^void AtomLookup::set_atom_clb(const AtomBlockId blk_id, const ClusterBlockId clb) {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id, const ClusterBlockId clb)
AtomLookup::set_atom_clb	base/atom_lookup.h	/^        void set_atom_clb(const AtomBlockId blk_id, const ClusterBlockId clb);$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id, const ClusterBlockId clb)
AtomLookup::set_atom_clb_net	base/atom_lookup.cpp	/^void AtomLookup::set_atom_clb_net(const AtomNetId net_id, const ClusterNetId clb_net_index) {$/;"	f	class:AtomLookup	signature:(const AtomNetId net_id, const ClusterNetId clb_net_index)
AtomLookup::set_atom_clb_net	base/atom_lookup.h	/^        void set_atom_clb_net(const AtomNetId net_id, const ClusterNetId clb_net_index);$/;"	p	class:AtomLookup	access:public	signature:(const AtomNetId net_id, const ClusterNetId clb_net_index)
AtomLookup::set_atom_pb	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pb(const AtomBlockId blk_id, const t_pb* pb) {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id, const t_pb* pb)
AtomLookup::set_atom_pb	base/atom_lookup.h	/^        void set_atom_pb(const AtomBlockId blk_id, const t_pb* pb);$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id, const t_pb* pb)
AtomLookup::set_atom_pin_classic_tnode	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pin_classic_tnode(const AtomPinId pin_id, const int tnode_index) {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin_id, const int tnode_index)
AtomLookup::set_atom_pin_classic_tnode	base/atom_lookup.h	/^        void set_atom_pin_classic_tnode(const AtomPinId pin_id, const int tnode_index);$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin_id, const int tnode_index)
AtomLookup::set_atom_pin_pb_graph_pin	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pin_pb_graph_pin(AtomPinId atom_pin, const t_pb_graph_pin* gpin) {$/;"	f	class:AtomLookup	signature:(AtomPinId atom_pin, const t_pb_graph_pin* gpin)
AtomLookup::set_atom_pin_pb_graph_pin	base/atom_lookup.h	/^        void set_atom_pin_pb_graph_pin(AtomPinId atom_pin, const t_pb_graph_pin* gpin);$/;"	p	class:AtomLookup	access:public	signature:(AtomPinId atom_pin, const t_pb_graph_pin* gpin)
AtomLookup::set_atom_pin_tnode	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pin_tnode(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type) {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type)
AtomLookup::set_atom_pin_tnode	base/atom_lookup.h	/^        void set_atom_pin_tnode(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type=BlockTnode::EXTERNAL);$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type=BlockTnode::EXTERNAL)
AtomLookup::tnode_atom_pin	base/atom_lookup.cpp	/^AtomPinId AtomLookup::tnode_atom_pin(const tatum::NodeId tnode) const {$/;"	f	class:AtomLookup	signature:(const tatum::NodeId tnode) const
AtomLookup::tnode_atom_pin	base/atom_lookup.h	/^        AtomPinId tnode_atom_pin(const tatum::NodeId tnode) const;$/;"	p	class:AtomLookup	access:public	signature:(const tatum::NodeId tnode) const
AtomLookup::tnode_atom_pin_	base/atom_lookup.h	/^        vtr::linear_map<tatum::NodeId,AtomPinId> tnode_atom_pin_;$/;"	m	class:AtomLookup	access:private
AtomLookup::tnode_atom_pins	base/atom_lookup.cpp	/^AtomLookup::tnode_pin_range AtomLookup::tnode_atom_pins() const {$/;"	f	class:AtomLookup	signature:() const
AtomLookup::tnode_atom_pins	base/atom_lookup.h	/^        tnode_pin_range tnode_atom_pins() const;$/;"	p	class:AtomLookup	access:public	signature:() const
AtomLookup::tnode_pin_iterator	base/atom_lookup.h	/^        typedef vtr::linear_map<tatum::NodeId,AtomPinId>::const_iterator tnode_pin_iterator;$/;"	t	class:AtomLookup	access:public
AtomLookup::tnode_pin_range	base/atom_lookup.h	/^        typedef vtr::Range<tnode_pin_iterator> tnode_pin_range;$/;"	t	class:AtomLookup	access:public
AtomNetId	base/atom_netlist_fwd.h	/^typedef vtr::StrongId<atom_net_id_tag> AtomNetId;$/;"	t
AtomNetlist	base/atom_netlist.cpp	/^AtomNetlist::AtomNetlist(std::string name, std::string id)$/;"	f	class:AtomNetlist	signature:(std::string name, std::string id)
AtomNetlist	base/atom_netlist.h	/^        AtomNetlist(std::string name = "", std::string id = "");$/;"	p	class:AtomNetlist	access:public	signature:(std::string name = Ó, std::string id = Ó)
AtomNetlist	base/atom_netlist.h	/^class AtomNetlist : public Netlist<AtomBlockId,AtomPortId,AtomPinId,AtomNetId> {$/;"	c	inherits:Netlist
AtomNetlist::AtomNetlist	base/atom_netlist.cpp	/^AtomNetlist::AtomNetlist(std::string name, std::string id)$/;"	f	class:AtomNetlist	signature:(std::string name, std::string id)
AtomNetlist::AtomNetlist	base/atom_netlist.h	/^        AtomNetlist(std::string name = "", std::string id = "");$/;"	p	class:AtomNetlist	access:public	signature:(std::string name = Ó, std::string id = Ó)
AtomNetlist::TruthTable	base/atom_netlist.h	/^        typedef std::vector<std::vector<vtr::LogicValue>> TruthTable;$/;"	t	class:AtomNetlist	access:public
AtomNetlist::add_net	base/atom_netlist.cpp	/^AtomNetId AtomNetlist::add_net(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks) {$/;"	f	class:AtomNetlist	signature:(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks)
AtomNetlist::add_net	base/atom_netlist.h	/^        AtomNetId   add_net(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks);$/;"	p	class:AtomNetlist	access:public	signature:(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks)
AtomNetlist::block_model	base/atom_netlist.cpp	/^const t_model* AtomNetlist::block_model(const AtomBlockId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId id) const
AtomNetlist::block_model	base/atom_netlist.h	/^        const t_model* block_model(const AtomBlockId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId id) const
AtomNetlist::block_models_	base/atom_netlist.h	/^        vtr::vector_map<AtomBlockId, const t_model*>        block_models_;             \/\/Architecture model of each block$/;"	m	class:AtomNetlist	access:private
AtomNetlist::block_truth_table	base/atom_netlist.cpp	/^const AtomNetlist::TruthTable& AtomNetlist::block_truth_table (const AtomBlockId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId id) const
AtomNetlist::block_truth_table	base/atom_netlist.h	/^        const TruthTable& block_truth_table(const AtomBlockId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId id) const
AtomNetlist::block_truth_tables_	base/atom_netlist.h	/^        vtr::vector_map<AtomBlockId,TruthTable>             block_truth_tables_;       \/\/Truth tables of each block$/;"	m	class:AtomNetlist	access:private
AtomNetlist::block_type	base/atom_netlist.cpp	/^AtomBlockType AtomNetlist::block_type (const AtomBlockId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId id) const
AtomNetlist::block_type	base/atom_netlist.h	/^        AtomBlockType block_type(const AtomBlockId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId id) const
AtomNetlist::clean_blocks_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_blocks_impl(const vtr::vector_map<AtomBlockId,AtomBlockId>& block_id_map) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomBlockId,AtomBlockId>& block_id_map)
AtomNetlist::clean_nets_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_nets_impl(const vtr::vector_map<AtomNetId, AtomNetId>& \/*net_id_map*\/) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomNetId, AtomNetId>& )
AtomNetlist::clean_pins_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_pins_impl(const vtr::vector_map<AtomPinId, AtomPinId>& \/*pin_id_map*\/) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPinId, AtomPinId>& )
AtomNetlist::clean_ports_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_ports_impl(const vtr::vector_map<AtomPortId,AtomPortId>& port_id_map) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPortId,AtomPortId>& port_id_map)
AtomNetlist::create_block	base/atom_netlist.cpp	/^AtomBlockId AtomNetlist::create_block(const std::string name, const t_model* model, const TruthTable truth_table) {$/;"	f	class:AtomNetlist	signature:(const std::string name, const t_model* model, const TruthTable truth_table)
AtomNetlist::create_block	base/atom_netlist.h	/^        AtomBlockId create_block(const std::string name, const t_model* model, const TruthTable truth_table=TruthTable());$/;"	p	class:AtomNetlist	access:public	signature:(const std::string name, const t_model* model, const TruthTable truth_table=TruthTable())
AtomNetlist::create_net	base/atom_netlist.cpp	/^AtomNetId AtomNetlist::create_net(const std::string name) {$/;"	f	class:AtomNetlist	signature:(const std::string name)
AtomNetlist::create_net	base/atom_netlist.h	/^        AtomNetId   create_net(const std::string name); \/\/An empty or existing net$/;"	p	class:AtomNetlist	access:public	signature:(const std::string name)
AtomNetlist::create_pin	base/atom_netlist.cpp	/^AtomPinId AtomNetlist::create_pin(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type_, bool is_const) {$/;"	f	class:AtomNetlist	signature:(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type_, bool is_const)
AtomNetlist::create_pin	base/atom_netlist.h	/^        AtomPinId   create_pin(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type, bool is_const=false);$/;"	p	class:AtomNetlist	access:public	signature:(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type, bool is_const=false)
AtomNetlist::create_port	base/atom_netlist.cpp	/^AtomPortId AtomNetlist::create_port(const AtomBlockId blk_id, const t_model_ports* model_port) {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId blk_id, const t_model_ports* model_port)
AtomNetlist::create_port	base/atom_netlist.h	/^        AtomPortId  create_port(const AtomBlockId blk_id, const t_model_ports* model_port);$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId blk_id, const t_model_ports* model_port)
AtomNetlist::find_atom_port	base/atom_netlist.cpp	/^AtomPortId AtomNetlist::find_atom_port(const AtomBlockId blk_id, const t_model_ports* model_port) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId blk_id, const t_model_ports* model_port) const
AtomNetlist::find_atom_port	base/atom_netlist.h	/^        AtomPortId  find_atom_port(const AtomBlockId blk_id, const t_model_ports* model_port) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId blk_id, const t_model_ports* model_port) const
AtomNetlist::override	base/atom_netlist.h	/^        bool validate_block_sizes_impl(size_t num_blocks) const override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        bool validate_net_sizes_impl(size_t num_nets) const override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        bool validate_pin_sizes_impl(size_t num_pins) const override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        bool validate_port_sizes_impl(size_t num_ports) const override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void clean_blocks_impl(const vtr::vector_map<AtomBlockId,AtomBlockId>& block_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void clean_nets_impl(const vtr::vector_map<AtomNetId, AtomNetId>& net_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void clean_pins_impl(const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void clean_ports_impl(const vtr::vector_map<AtomPortId,AtomPortId>& port_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void rebuild_block_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map, const vtr::vector_map<AtomPortId, AtomPortId>& port_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void rebuild_net_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void rebuild_pin_refs_impl(const vtr::vector_map<AtomPortId, AtomPortId>& port_id_map, const vtr::vector_map<AtomNetId, AtomNetId>& net_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void rebuild_port_refs_impl(const vtr::vector_map<AtomBlockId, AtomBlockId>& block_id_map, const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void remove_block_impl(const AtomBlockId blk_id) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void remove_net_impl(const AtomNetId net_id) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void remove_pin_impl(const AtomPinId pin_id) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void remove_port_impl(const AtomPortId port_id) override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::override	base/atom_netlist.h	/^        void shrink_to_fit_impl() override;$/;"	m	class:AtomNetlist	access:private
AtomNetlist::port_model	base/atom_netlist.cpp	/^const t_model_ports* AtomNetlist::port_model(const AtomPortId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomPortId id) const
AtomNetlist::port_model	base/atom_netlist.h	/^        const t_model_ports* port_model(const AtomPortId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomPortId id) const
AtomNetlist::port_models_	base/atom_netlist.h	/^        vtr::vector_map<AtomPortId, const t_model_ports*>   port_models_;   \/\/Architecture port models of each port$/;"	m	class:AtomNetlist	access:private
AtomNetlist::rebuild_block_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_block_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& \/*pin_id_map*\/,$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPinId, AtomPinId>& , const vtr::vector_map<AtomPortId, AtomPortId>& )
AtomNetlist::rebuild_net_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_net_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& \/*pin_id_map*\/) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPinId, AtomPinId>& )
AtomNetlist::rebuild_pin_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_pin_refs_impl(const vtr::vector_map<AtomPortId, AtomPortId>& \/*port_id_map*\/,$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPortId, AtomPortId>& , const vtr::vector_map<AtomNetId, AtomNetId>& )
AtomNetlist::rebuild_port_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_port_refs_impl(const vtr::vector_map<AtomBlockId, AtomBlockId>& \/*block_id_map*\/,$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomBlockId, AtomBlockId>& , const vtr::vector_map<AtomPinId, AtomPinId>& )
AtomNetlist::remove_block_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_block_impl(const AtomBlockId \/*blk_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId )
AtomNetlist::remove_net_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_net_impl(const AtomNetId \/*net_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomNetId )
AtomNetlist::remove_pin_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_pin_impl(const AtomPinId \/*pin_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomPinId )
AtomNetlist::remove_port_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_port_impl(const AtomPortId \/*port_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomPortId )
AtomNetlist::shrink_to_fit_impl	base/atom_netlist.cpp	/^void AtomNetlist::shrink_to_fit_impl() {$/;"	f	class:AtomNetlist	signature:()
AtomNetlist::validate_block_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_block_sizes_impl(size_t num_blocks) const {$/;"	f	class:AtomNetlist	signature:(size_t num_blocks) const
AtomNetlist::validate_net_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_net_sizes_impl(size_t \/*num_nets*\/) const {$/;"	f	class:AtomNetlist	signature:(size_t ) const
AtomNetlist::validate_pin_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_pin_sizes_impl(size_t \/*num_pins*\/) const {$/;"	f	class:AtomNetlist	signature:(size_t ) const
AtomNetlist::validate_port_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_port_sizes_impl(size_t num_ports) const {$/;"	f	class:AtomNetlist	signature:(size_t num_ports) const
AtomPinId	base/atom_netlist_fwd.h	/^typedef vtr::StrongId<atom_pin_id_tag> AtomPinId;$/;"	t
AtomPortId	base/atom_netlist_fwd.h	/^typedef vtr::StrongId<atom_port_id_tag> AtomPortId;$/;"	t
BEIGE	../../libs/libeasygl/src/easygl_constants.h	/^    BEIGE,$/;"	e	enum:color_types
BISQUE	../../libs/libeasygl/src/easygl_constants.h	/^    BISQUE, \/\/ A weird colour, not unlike the "peach" colour of pencil crayons, but closer to "Blanched Almond" and "Moccasin"$/;"	e	enum:color_types
BI_DIRECTIONAL	../../libs/libarchfpga/src/physical_types.h	/^	UNI_DIRECTIONAL, BI_DIRECTIONAL$/;"	e	enum:e_directionality
BLACK	../../libs/libeasygl/src/easygl_constants.h	/^    BLACK,$/;"	e	enum:color_types
BLANCHEDALMOND	../../libs/libeasygl/src/easygl_constants.h	/^    BLANCHEDALMOND,$/;"	e	enum:color_types
BLEND	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
BLIF	base/read_circuit.h	/^    BLIF, \/\/Strict structural BLIF$/;"	m	class:e_circuit_format	access:private
BLK_FAILED_FEASIBLE	base/vpr_types.h	/^    BLK_FAILED_FEASIBLE,$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
BLK_FAILED_ROUTE	base/vpr_types.h	/^    BLK_FAILED_ROUTE,$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
BLK_PASSED	base/vpr_types.h	/^	BLK_PASSED,$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
BLK_STATUS_UNDEFINED	base/vpr_types.h	/^    BLK_STATUS_UNDEFINED$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
BLUE	../../libs/libeasygl/src/easygl_constants.h	/^    BLUE,$/;"	e	enum:color_types
BLUEVIOLET	../../libs/libeasygl/src/easygl_constants.h	/^    BLUEVIOLET,$/;"	e	enum:color_types
BOL	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
BOTH	route/route_budgets.h	/^    POSITIVE, NEGATIVE, BOTH$/;"	e	enum:slack_allocated_type
BOUNDING_BOX_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:ScreenUpdatePriority::e_place_algorithm
BRANCH	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
BREADTH_FIRST	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:ScreenUpdatePriority::e_router_algorithm
BROWN	../../libs/libeasygl/src/easygl_constants.h	/^    BROWN,$/;"	e	enum:color_types
BUFFER	../../libs/libarchfpga/src/physical_types.h	/^    BUFFER,         \/\/A non-configurable non-tristate-able buffer (uni-driver)$/;"	m	class:SwitchType	access:private
BUFSIZE	../../libs/libeasygl/src/graphics_state.h	/^#define BUFSIZE /;"	d
BUILD_SWITCHBLOCKS_H	route/build_switchblocks.h	/^#define BUILD_SWITCHBLOCKS_H$/;"	d
BUILD_TIMESTAMP	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* BUILD_TIMESTAMP = "@VTR_BUILD_TIMESTAMP@";$/;"	m	namespace:vtr	file:
BURLYWOOD	../../libs/libeasygl/src/easygl_constants.h	/^    BURLYWOOD,$/;"	e	enum:color_types
BUTT	../../libs/libeasygl/src/easygl_constants.h	/^    BUTT = 0, ROUND$/;"	e	enum:line_caps
BUTTON_POLY	../../libs/libeasygl/src/graphics.cpp	/^    BUTTON_POLY,$/;"	e	enum:__anon17	file:
BUTTON_SEPARATOR	../../libs/libeasygl/src/graphics.cpp	/^    BUTTON_SEPARATOR$/;"	e	enum:__anon17	file:
BUTTON_TEXT	../../libs/libeasygl/src/graphics.cpp	/^    BUTTON_TEXT = 0,$/;"	e	enum:__anon17	file:
BUTTON_TEXT_LEN	../../libs/libeasygl/src/graphics.cpp	/^#define BUTTON_TEXT_LEN	/;"	d	file:
BYTE_TO_MIB	../../libs/libvtrutil/src/vtr_time.h	/^            constexpr static float BYTE_TO_MIB = 1024*1024;$/;"	m	class:vtr::Timer	access:private
BitFields	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        BitFields(bit_value_t init_v)$/;"	f	class:BitSpace::BitFields	access:public	signature:(bit_value_t init_v)
BitFields	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    class BitFields$/;"	c	namespace:BitSpace
BitIndex	base/atom_netlist_fwd.h	/^typedef unsigned BitIndex;$/;"	t
BitIndex	base/netlist_fwd.h	/^typedef unsigned BitIndex;$/;"	t
BitSpace	../../libs/librtlnumber/src/include/internal_bits.hpp	/^namespace BitSpace {$/;"	n
BitSpace::BitFields	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    class BitFields$/;"	c	namespace:BitSpace
BitSpace::BitFields::BitFields	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        BitFields(bit_value_t init_v)$/;"	f	class:BitSpace::BitFields	access:public	signature:(bit_value_t init_v)
BitSpace::BitFields::bits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        T bits = _All_x;$/;"	m	class:BitSpace::BitFields	access:private
BitSpace::BitFields::get_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bit_value_t get_bit(size_t address)$/;"	f	class:BitSpace::BitFields	access:public	signature:(size_t address)
BitSpace::BitFields::get_bit_location	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t get_bit_location(size_t address)$/;"	f	class:BitSpace::BitFields	access:private	signature:(size_t address)
BitSpace::BitFields::has_unknowns	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bool has_unknowns()$/;"	f	class:BitSpace::BitFields	access:public	signature:()
BitSpace::BitFields::make_insert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        T make_insert(size_t loc, bit_value_t value)$/;"	f	class:BitSpace::BitFields	access:private	signature:(size_t loc, bit_value_t value)
BitSpace::BitFields::make_mask	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        T make_mask(size_t loc)$/;"	f	class:BitSpace::BitFields	access:private	signature:(size_t loc)
BitSpace::BitFields::set_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        void set_bit(size_t address, bit_value_t value)$/;"	f	class:BitSpace::BitFields	access:public	signature:(size_t address, bit_value_t value)
BitSpace::BitFields::size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        static size_t size()$/;"	f	class:BitSpace::BitFields	access:public	signature:()
BitSpace::VerilogBits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    class VerilogBits$/;"	c	namespace:BitSpace
BitSpace::VerilogBits::VerilogBits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits()$/;"	f	class:BitSpace::VerilogBits	access:private	signature:()
BitSpace::VerilogBits::VerilogBits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits(size_t data_size, bit_value_t value_in)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t data_size, bit_value_t value_in)
BitSpace::VerilogBits::bit_size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t bit_size;$/;"	m	class:BitSpace::VerilogBits	access:private
BitSpace::VerilogBits::bits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        std::vector<BitFields<veri_internal_bits_t>> bits;$/;"	m	class:BitSpace::VerilogBits	access:private
BitSpace::VerilogBits::bitwise_reduce	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits *bitwise_reduce(const bit_value_t lut[4][4])$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(const bit_value_t lut[4][4])
BitSpace::VerilogBits::get_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bit_value_t get_bit(size_t address)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t address)
BitSpace::VerilogBits::get_bitfield	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        BitFields<veri_internal_bits_t> *get_bitfield(size_t index)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t index)
BitSpace::VerilogBits::has_unknowns	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bool has_unknowns()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
BitSpace::VerilogBits::invert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits *invert()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
BitSpace::VerilogBits::list_size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t list_size()$/;"	f	class:BitSpace::VerilogBits	access:private	signature:()
BitSpace::VerilogBits::set_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        void set_bit(size_t address, bit_value_t value)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t address, bit_value_t value)
BitSpace::VerilogBits::size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t size()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
BitSpace::VerilogBits::to_index	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t to_index(size_t address)$/;"	f	class:BitSpace::VerilogBits	access:private	signature:(size_t address)
BitSpace::VerilogBits::to_string	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        std::string to_string(bool big_endian)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(bool big_endian)
BitSpace::VerilogBits::twos_complement	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits *twos_complement()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
BitSpace::_0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _0 = 0x0;$/;"	m	namespace:BitSpace
BitSpace::_1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _1 = 0x1;$/;"	m	namespace:BitSpace
BitSpace::_All_0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_0 = static_cast<veri_internal_bits_t>(0x0000000000000000UL);$/;"	m	namespace:BitSpace
BitSpace::_All_1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_1 = static_cast<veri_internal_bits_t>(0x5555555555555555UL);$/;"	m	namespace:BitSpace
BitSpace::_All_x	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_x = static_cast<veri_internal_bits_t>(0xAAAAAAAAAAAAAAAAUL);$/;"	m	namespace:BitSpace
BitSpace::_All_z	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_z = static_cast<veri_internal_bits_t>(0xFFFFFFFFFFFFFFFFUL);$/;"	m	namespace:BitSpace
BitSpace::_x	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _x = 0x2;$/;"	m	namespace:BitSpace
BitSpace::_z	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _z = 0x3;$/;"	m	namespace:BitSpace
BitSpace::bit_to_c	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static char bit_to_c(bit_value_t bit)$/;"	f	namespace:BitSpace	signature:(bit_value_t bit)
BitSpace::bit_value_t	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    typedef uint8_t bit_value_t;$/;"	t	namespace:BitSpace
BitSpace::c_to_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static bit_value_t c_to_bit(char c)$/;"	f	namespace:BitSpace	signature:(char c)
BitSpace::l_and	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_and[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_buf	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_buf[4] = {$/;"	m	namespace:BitSpace
BitSpace::l_bufif0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_bufif0[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_bufif1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_bufif1[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_carry	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_carry[4][4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_case_eq	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_case_eq[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_case_neq	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_case_neq[4][4] =$/;"	m	namespace:BitSpace
BitSpace::l_eq	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_eq[4][4] = $/;"	m	namespace:BitSpace
BitSpace::l_ge	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_ge[4][4] = unroll_2d(l_lt);$/;"	m	namespace:BitSpace
BitSpace::l_gt	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_gt[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_half_carry	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_half_carry[4][4] = unroll_2d(l_carry[_0]);$/;"	m	namespace:BitSpace
BitSpace::l_half_sum	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_half_sum[4][4] = unroll_2d(l_sum[_0]);$/;"	m	namespace:BitSpace
BitSpace::l_le	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_le[4][4] = unroll_2d(l_gt);$/;"	m	namespace:BitSpace
BitSpace::l_lt	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_lt[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_nand	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_nand[4][4] = $/;"	m	namespace:BitSpace
BitSpace::l_nmos	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_nmos[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_nor	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_nor[4][4] = $/;"	m	namespace:BitSpace
BitSpace::l_not	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_not[4] = {$/;"	m	namespace:BitSpace
BitSpace::l_notif0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_notif0[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_notif1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_notif1[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_or	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_or[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_rnmos	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_rnmos[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_rpmos	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_rpmos[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_sum	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_sum[4][4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_ternary	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_ternary[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_unk	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_unk[4][4] = {$/;"	m	namespace:BitSpace
BitSpace::l_xnor	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_xnor[4][4] = $/;"	m	namespace:BitSpace
BitSpace::l_xor	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_xor[4][4] = {$/;"	m	namespace:BitSpace
BlackBoxInst	base/netlist_writer.cpp	/^        BlackBoxInst(std::string type_name, \/\/Instance type$/;"	f	class:BlackBoxInst	access:public	signature:(std::string type_name, std::string inst_name, std::map<std::string,std::string> params, std::map<std::string,std::vector<std::string>> input_port_conns, std::map<std::string,std::vector<std::string>> output_port_conns, std::vector<Arc> timing_arcs, std::map<std::string,double> ports_tsu, std::map<std::string,double> ports_tcq)
BlackBoxInst	base/netlist_writer.cpp	/^class BlackBoxInst : public Instance {$/;"	c	file:	inherits:Instance
BlackBoxInst::BlackBoxInst	base/netlist_writer.cpp	/^        BlackBoxInst(std::string type_name, \/\/Instance type$/;"	f	class:BlackBoxInst	access:public	signature:(std::string type_name, std::string inst_name, std::map<std::string,std::string> params, std::map<std::string,std::vector<std::string>> input_port_conns, std::map<std::string,std::vector<std::string>> output_port_conns, std::vector<Arc> timing_arcs, std::map<std::string,double> ports_tsu, std::map<std::string,double> ports_tcq)
BlackBoxInst::find_port_size	base/netlist_writer.cpp	/^        size_t find_port_size(std::string port_name) {$/;"	f	class:BlackBoxInst	access:public	signature:(std::string port_name)
BlackBoxInst::input_port_conns_	base/netlist_writer.cpp	/^        std::map<std::string,std::vector<std::string>> input_port_conns_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::inst_name_	base/netlist_writer.cpp	/^        std::string inst_name_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::output_port_conns_	base/netlist_writer.cpp	/^        std::map<std::string,std::vector<std::string>> output_port_conns_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::params_	base/netlist_writer.cpp	/^        std::map<std::string,std::string> params_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::ports_tcq_	base/netlist_writer.cpp	/^        std::map<std::string,double> ports_tcq_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::ports_thld_	base/netlist_writer.cpp	/^        std::map<std::string,double> ports_thld_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::ports_tsu_	base/netlist_writer.cpp	/^        std::map<std::string,double> ports_tsu_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::timing_arcs_	base/netlist_writer.cpp	/^        std::vector<Arc> timing_arcs_;$/;"	m	class:BlackBoxInst	file:	access:private
BlackBoxInst::type_name_	base/netlist_writer.cpp	/^        std::string type_name_;$/;"	m	class:BlackBoxInst	file:	access:private
BlifAllocCallback	base/read_blif.cpp	/^        BlifAllocCallback(e_circuit_format blif_format, AtomNetlist& main_netlist, $/;"	f	struct:BlifAllocCallback	access:public	signature:(e_circuit_format blif_format, AtomNetlist& main_netlist, const std::string netlist_id, const t_model* user_models, const t_model* library_models, int verbosity)
BlifAllocCallback	base/read_blif.cpp	/^struct BlifAllocCallback : public blifparse::Callback {$/;"	s	file:	inherits:blifparse::Callback
BlifAllocCallback::BlifAllocCallback	base/read_blif.cpp	/^        BlifAllocCallback(e_circuit_format blif_format, AtomNetlist& main_netlist, $/;"	f	struct:BlifAllocCallback	access:public	signature:(e_circuit_format blif_format, AtomNetlist& main_netlist, const std::string netlist_id, const t_model* user_models, const t_model* library_models, int verbosity)
BlifAllocCallback::OUTPAD_NAME_PREFIX	base/read_blif.cpp	/^        static constexpr const char* OUTPAD_NAME_PREFIX = "out:";$/;"	m	struct:BlifAllocCallback	file:	access:public
BlifAllocCallback::blif_format_	base/read_blif.cpp	/^        e_circuit_format blif_format_ = e_circuit_format::BLIF;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::blif_models_	base/read_blif.cpp	/^        std::vector<AtomNetlist> blif_models_;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::blif_models_black_box_	base/read_blif.cpp	/^        std::vector<bool> blif_models_black_box_;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::const_gen_inference_	base/read_blif.cpp	/^        e_const_gen_inference const_gen_inference_ = e_const_gen_inference::COMB;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::curr_block	base/read_blif.cpp	/^        AtomBlockId curr_block() const {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:() const
BlifAllocCallback::curr_block_	base/read_blif.cpp	/^        AtomBlockId curr_block_;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::curr_model	base/read_blif.cpp	/^        AtomNetlist& curr_model() {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:()
BlifAllocCallback::determine_main_netlist_index	base/read_blif.cpp	/^        size_t determine_main_netlist_index() {$/;"	f	struct:BlifAllocCallback	access:public	signature:()
BlifAllocCallback::ended_	base/read_blif.cpp	/^        bool ended_ = true; \/\/Initially no active .model$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::filename_	base/read_blif.cpp	/^        std::string filename_ = "";$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::find_model	base/read_blif.cpp	/^        const t_model* find_model(std::string name) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(std::string name)
BlifAllocCallback::find_model_port	base/read_blif.cpp	/^        const t_model_ports* find_model_port(const t_model* blk_model, std::string port_name) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(const t_model* blk_model, std::string port_name)
BlifAllocCallback::library_arch_models_	base/read_blif.cpp	/^        const t_model* library_arch_models_ = nullptr;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::lineno_	base/read_blif.cpp	/^        int lineno_ = -1;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::main_netlist_	base/read_blif.cpp	/^        AtomNetlist& main_netlist_; \/\/User object we fill$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::netlist_id_	base/read_blif.cpp	/^        const std::string netlist_id_; \/\/Unique identifier based on the contents of the blif file$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::set_curr_block	base/read_blif.cpp	/^        void set_curr_block(AtomBlockId blk) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(AtomBlockId blk)
BlifAllocCallback::set_curr_model_blackbox	base/read_blif.cpp	/^        void set_curr_model_blackbox(bool val) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(bool val)
BlifAllocCallback::split_index	base/read_blif.cpp	/^        std::pair<std::string, int> split_index(const std::string& signal_name) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(const std::string& signal_name)
BlifAllocCallback::unique_subckt_name	base/read_blif.cpp	/^        std::string unique_subckt_name() {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:()
BlifAllocCallback::unique_subckt_name_counter_	base/read_blif.cpp	/^        size_t unique_subckt_name_counter_ = 0;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::user_arch_models_	base/read_blif.cpp	/^        const t_model* user_arch_models_ = nullptr;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::verbosity_	base/read_blif.cpp	/^        int verbosity_ = 1;$/;"	m	struct:BlifAllocCallback	file:	access:private
BlifAllocCallback::verify_blackbox_model	base/read_blif.cpp	/^        bool verify_blackbox_model(AtomNetlist& blif_model) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(AtomNetlist& blif_model)
BlifFile	base/read_options.h	/^    argparse::ArgValue<std::string> BlifFile;$/;"	m	struct:t_options	access:public
BlifFile	base/vpr_types.h	/^	std::string BlifFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
BlockTnode	base/atom_lookup_fwd.h	/^enum class BlockTnode {$/;"	c
BlockTnode::INTERNAL	base/atom_lookup_fwd.h	/^    INTERNAL, \/\/tnodes corresponding to internal paths withing atom blocks$/;"	m	class:BlockTnode	access:private
BoolToReqOpt	../../libs/libarchfpga/src/read_xml_util.cpp	/^extern ReqOpt BoolToReqOpt(bool b) {$/;"	f	signature:(bool b)
BoolToReqOpt	../../libs/libarchfpga/src/read_xml_util.h	/^pugiutil::ReqOpt BoolToReqOpt(bool b);$/;"	p	signature:(bool b)
BufferSize	../../libs/libarchfpga/src/physical_types.h	/^enum class BufferSize {$/;"	c
BufferSize::AUTO	../../libs/libarchfpga/src/physical_types.h	/^    AUTO,$/;"	m	class:BufferSize	access:private
C	../../libs/libarchfpga/src/physical_types.h	/^		float C;$/;"	m	union:t_port_power::__anon13	access:public
C	route/rr_node.cpp	/^float t_rr_node::C() const {$/;"	f	class:t_rr_node	signature:() const
C	route/rr_node.h	/^        float C() const;$/;"	p	class:t_rr_node	access:public	signature:() const
C	route/rr_node.h	/^    float C;$/;"	m	struct:t_rr_rc_data	access:public
CADETBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    CADETBLUE,$/;"	e	enum:color_types
CAD_TYPES_H	../../libs/libarchfpga/src/cad_types.h	/^#define CAD_TYPES_H$/;"	d
CB_METRICS_H	route/cb_metrics.h	/^#define CB_METRICS_H$/;"	d
CHANX_COST_INDEX_START	base/vpr_types.h	/^	CHANX_COST_INDEX_START$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
CHARTREUSE	../../libs/libeasygl/src/easygl_constants.h	/^    CHARTREUSE,$/;"	e	enum:color_types
CHECK	place/place.cpp	/^	NORMAL, CHECK$/;"	e	enum:e_cost_methods	file:
CHECKARCH_H	base/CheckArch.h	/^#define CHECKARCH_H$/;"	d
CHECKSETUP_H	base/CheckSetup.h	/^#define CHECKSETUP_H$/;"	d
CHECK_NETLIST_H	base/check_netlist.h	/^#define CHECK_NETLIST_H$/;"	d
CHECK_RAND	../../libs/libvtrutil/src/vtr_random.cpp	/^#define CHECK_RAND$/;"	d	file:
CHECK_RR_GRAPH_H	route/check_rr_graph.h	/^#define CHECK_RR_GRAPH_H$/;"	d
CHOCOLATE	../../libs/libeasygl/src/easygl_constants.h	/^    CHOCOLATE,$/;"	e	enum:color_types
CLASSIC	base/vpr_types.h	/^    CLASSIC, \/\/VPR's classic lookahead (assumes uniform wire types)$/;"	m	class:ScreenUpdatePriority::e_router_lookahead	access:private
CLOCK_DENS	power/power.h	/^#define CLOCK_DENS /;"	d
CLOCK_MODELING_H	base/clock_modeling.h	/^#define CLOCK_MODELING_H$/;"	d
CLOCK_PROB	power/power.h	/^#define CLOCK_PROB /;"	d
CLOSE	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
CLUSTERED_NETLIST_FWD_H	base/clustered_netlist_fwd.h	/^#define CLUSTERED_NETLIST_FWD_H$/;"	d
CLUSTERED_NETLIST_H	base/clustered_netlist.h	/^#define CLUSTERED_NETLIST_H$/;"	d
CLUSTERED_NETLIST_UTILS_H	base/clustered_netlist_utils.h	/^#define CLUSTERED_NETLIST_UTILS_H$/;"	d
CLUSTER_FEASIBILITY_CHECK_H	pack/cluster_feasibility_filter.h	/^#define CLUSTER_FEASIBILITY_CHECK_H$/;"	d
CLUSTER_H	pack/cluster.h	/^#define CLUSTER_H$/;"	d
CLUSTER_PLACEMENT_H	pack/cluster_placement.h	/^#define CLUSTER_PLACEMENT_H$/;"	d
CLUSTER_ROUTER_H	pack/cluster_router.h	/^#define CLUSTER_ROUTER_H$/;"	d
COMB	base/vpr_types.h	/^    COMB, \/\/Only combinational constant generator inference$/;"	m	class:ScreenUpdatePriority::e_const_gen_inference	access:private
COMPILER	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* COMPILER = "@VTR_COMPILER_INFO@";$/;"	m	namespace:vtr	file:
COMPLETE_INTERC	../../libs/libarchfpga/src/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
CONGESTED_SLOPE_VAL	route/route_timing.cpp	/^#define CONGESTED_SLOPE_VAL /;"	d	file:
CONSTANT_NETS_H	base/constant_nets.h	/^#define CONSTANT_NETS_H$/;"	d
CONSTANT_NET_GLOBAL	base/constant_nets.h	/^    CONSTANT_NET_GLOBAL, \/\/Treat constant nets as globals (i.e. not routed)$/;"	e	enum:e_constant_net_method
CONSTANT_NET_ROUTE	base/constant_nets.h	/^    CONSTANT_NET_ROUTE   \/\/Treat constant nets a non-globals (i.e. routed)$/;"	e	enum:e_constant_net_method
CONVERT_NM_PER_M	power/power.cpp	/^#define CONVERT_NM_PER_M /;"	d	file:
CONVERT_UM_PER_M	power/power.cpp	/^#define CONVERT_UM_PER_M /;"	d	file:
CORAL	../../libs/libeasygl/src/easygl_constants.h	/^    CORAL, \/\/ A burnt pinkish-orange perhaps?$/;"	e	enum:color_types
CORNFLOWERBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    CORNFLOWERBLUE,$/;"	e	enum:color_types
CORNSILK	../../libs/libeasygl/src/easygl_constants.h	/^    CORNSILK,$/;"	e	enum:color_types
CRIMSON	../../libs/libeasygl/src/easygl_constants.h	/^    CRIMSON,$/;"	e	enum:color_types
CUSTOM	../../libs/libarchfpga/src/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL, CUSTOM$/;"	e	enum:e_switch_block_type
CYAN	../../libs/libeasygl/src/easygl_constants.h	/^    CYAN,$/;"	e	enum:color_types
C_d	power/power.h	/^	float C_d;$/;"	m	struct:t_transistor_size_inf	access:public
C_downstream	route/route_tree_type.h	/^	float C_downstream;$/;"	m	struct:t_rt_node	access:public
C_downstream	timing/net_delay.cpp	/^	float C_downstream;$/;"	m	struct:t_rc_node	file:	access:public
C_g	power/power.h	/^	float C_g;$/;"	m	struct:t_transistor_size_inf	access:public
C_internal	../../libs/libarchfpga/src/physical_types.h	/^	float C_internal; \/*Internal capacitance of the pb *\/$/;"	m	struct:t_pb_type_power	access:public
C_ipin_cblock	base/vpr_types.h	/^	float C_ipin_cblock;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
C_load	route/rr_node.h	/^	float C_load;$/;"	m	struct:t_rr_indexed_data	access:public
C_s	power/power.h	/^	float C_s;$/;"	m	struct:t_transistor_size_inf	access:public
C_wire	../../libs/libarchfpga/src/physical_types.h	/^	float C_wire; \/* Wire capacitance (per meter) *\/$/;"	m	struct:t_clock_network	access:public
C_wire	../../libs/libarchfpga/src/physical_types.h	/^	float C_wire;$/;"	m	struct:t_pb_graph_pin_power	access:public
C_wire_local	../../libs/libarchfpga/src/physical_types.h	/^	float C_wire_local; \/* Capacitance of local interconnect (per meter) *\/$/;"	m	struct:t_power_arch	access:public
Chans	../../libs/libarchfpga/src/physical_types.h	/^	t_chan_width_dist Chans;$/;"	m	struct:t_arch	access:public
CheckArch	base/CheckArch.cpp	/^void CheckArch(const t_arch& Arch) {$/;"	f	signature:(const t_arch& Arch)
CheckArch	base/CheckArch.h	/^void CheckArch(const t_arch& Arch);$/;"	p	signature:(const t_arch& Arch)
CheckGrid	base/SetupGrid.cpp	/^static void CheckGrid(const DeviceGrid& grid) {$/;"	f	file:	signature:(const DeviceGrid& grid)
CheckGrid	base/SetupGrid.cpp	/^static void CheckGrid(const DeviceGrid& grid);$/;"	p	file:	signature:(const DeviceGrid& grid)
CheckSegments	base/CheckArch.cpp	/^static void CheckSegments(const t_arch& Arch) {$/;"	f	file:	signature:(const t_arch& Arch)
CheckSegments	base/CheckArch.cpp	/^static void CheckSegments(const t_arch& Arch);$/;"	p	file:	signature:(const t_arch& Arch)
CheckSetup	base/CheckSetup.cpp	/^void CheckSetup($/;"	f	signature:( const t_packer_opts& PackerOpts, const t_placer_opts& PlacerOpts, const t_router_opts& RouterOpts, const t_det_routing_arch& RoutingArch, const t_segment_inf * Segments, const t_timing_inf Timing, const t_chan_width_dist Chans)
CheckSetup	base/CheckSetup.h	/^void CheckSetup($/;"	p	signature:( const t_packer_opts& PackerOpts, const t_placer_opts& PlacerOpts, const t_router_opts& RouterOpts, const t_det_routing_arch& RoutingArch, const t_segment_inf * Segments, const t_timing_inf Timing, const t_chan_width_dist Chans)
CheckSwitches	base/CheckArch.cpp	/^static void CheckSwitches(const t_arch& Arch) {$/;"	f	file:	signature:(const t_arch& Arch)
CheckSwitches	base/CheckArch.cpp	/^static void CheckSwitches(const t_arch& Arch);$/;"	p	file:	signature:(const t_arch& Arch)
Cin	../../libs/libarchfpga/src/physical_types.h	/^	float Cin = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
Cin	../../libs/libarchfpga/src/physical_types.h	/^        float Cin = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
CircuitName	base/read_options.h	/^    argparse::ArgValue<std::string> CircuitName;$/;"	m	struct:t_options	access:public
CircuitName	base/vpr_types.h	/^	std::string CircuitName;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ClassicLookahead	route/router_lookahead.h	/^class ClassicLookahead : public RouterLookahead {$/;"	c	inherits:RouterLookahead
ClassicLookahead::classic_wire_lookahead_cost	route/router_lookahead.cpp	/^float ClassicLookahead::classic_wire_lookahead_cost(int inode, int target_node, float criticality, float R_upstream) const {$/;"	f	class:ClassicLookahead	signature:(int inode, int target_node, float criticality, float R_upstream) const
ClassicLookahead::classic_wire_lookahead_cost	route/router_lookahead.h	/^        float classic_wire_lookahead_cost(int node, int target_node, float criticality, float R_upstream) const;$/;"	p	class:ClassicLookahead	access:private	signature:(int node, int target_node, float criticality, float R_upstream) const
ClassicLookahead::get_expected_cost	route/router_lookahead.cpp	/^float ClassicLookahead::get_expected_cost(int current_node, int target_node, const t_conn_cost_params& params, float R_upstream) const {$/;"	f	class:ClassicLookahead	signature:(int current_node, int target_node, const t_conn_cost_params& params, float R_upstream) const
ClassicLookahead::override	route/router_lookahead.h	/^        float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const override;$/;"	m	class:ClassicLookahead	access:public
ClbDelayCalc	timing/clb_delay_calc.h	/^        ClbDelayCalc();$/;"	p	class:ClbDelayCalc	access:public	signature:()
ClbDelayCalc	timing/clb_delay_calc.h	/^class ClbDelayCalc {$/;"	c
ClbDelayCalc	timing/clb_delay_calc.inl	/^inline ClbDelayCalc::ClbDelayCalc()$/;"	f	class:ClbDelayCalc	signature:()
ClbDelayCalc::ClbDelayCalc	timing/clb_delay_calc.h	/^        ClbDelayCalc();$/;"	p	class:ClbDelayCalc	access:public	signature:()
ClbDelayCalc::ClbDelayCalc	timing/clb_delay_calc.inl	/^inline ClbDelayCalc::ClbDelayCalc()$/;"	f	class:ClbDelayCalc	signature:()
ClbDelayCalc::clb_input_to_internal_sink_delay	timing/clb_delay_calc.h	/^        float clb_input_to_internal_sink_delay(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:public	signature:(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const
ClbDelayCalc::clb_input_to_internal_sink_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::clb_input_to_internal_sink_delay(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const
ClbDelayCalc::find_pb_graph_edge	timing/clb_delay_calc.h	/^        const t_pb_graph_edge* find_pb_graph_edge(ClusterBlockId clb, int pb_route_idx) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(ClusterBlockId clb, int pb_route_idx) const
ClbDelayCalc::find_pb_graph_edge	timing/clb_delay_calc.h	/^        const t_pb_graph_edge* find_pb_graph_edge(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const
ClbDelayCalc::find_pb_graph_edge	timing/clb_delay_calc.inl	/^inline const t_pb_graph_edge* ClbDelayCalc::find_pb_graph_edge(ClusterBlockId clb, int pb_route_idx) const {$/;"	f	class:ClbDelayCalc	signature:(ClusterBlockId clb, int pb_route_idx) const
ClbDelayCalc::find_pb_graph_edge	timing/clb_delay_calc.inl	/^inline const t_pb_graph_edge* ClbDelayCalc::find_pb_graph_edge(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const {$/;"	f	class:ClbDelayCalc	signature:(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const
ClbDelayCalc::internal_src_to_clb_output_delay	timing/clb_delay_calc.h	/^        float internal_src_to_clb_output_delay(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:public	signature:(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const
ClbDelayCalc::internal_src_to_clb_output_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::internal_src_to_clb_output_delay(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const
ClbDelayCalc::internal_src_to_internal_sink_delay	timing/clb_delay_calc.h	/^        float internal_src_to_internal_sink_delay(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:public	signature:(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const
ClbDelayCalc::internal_src_to_internal_sink_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::internal_src_to_internal_sink_delay(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const
ClbDelayCalc::intra_lb_pb_pin_lookup_	timing/clb_delay_calc.h	/^        IntraLbPbPinLookup intra_lb_pb_pin_lookup_;$/;"	m	class:ClbDelayCalc	access:private
ClbDelayCalc::pb_route_delay	timing/clb_delay_calc.h	/^        float pb_route_delay(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const
ClbDelayCalc::pb_route_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::pb_route_delay(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const
ClbDelayCalc::trace_delay	timing/clb_delay_calc.h	/^        float trace_delay(ClusterBlockId clb, int src_pb_route_pin, int sink_pb_route_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(ClusterBlockId clb, int src_pb_route_pin, int sink_pb_route_pin, DelayType delay_type) const
ClbDelayCalc::trace_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::trace_delay(ClusterBlockId clb, int src_pb_route_id, int sink_pb_route_id, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(ClusterBlockId clb, int src_pb_route_id, int sink_pb_route_id, DelayType delay_type) const
Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConcreteHoldTimingInfo	access:private
Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConcreteSetupHoldTimingInfo	access:private
Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConcreteSetupTimingInfo	access:private
Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConstantTimingInfo	access:private
ClockModeling	base/clock_modeling.h	/^namespace ClockModeling$/;"	n
ClockModeling::treat_clock_pins_as_non_globals	base/clock_modeling.cpp	/^void ClockModeling::treat_clock_pins_as_non_globals() {$/;"	f	class:ClockModeling	signature:()
ClockModeling::treat_clock_pins_as_non_globals	base/clock_modeling.h	/^    void treat_clock_pins_as_non_globals();$/;"	p	namespace:ClockModeling	signature:()
ClusterBlockId	base/clustered_netlist_fwd.h	/^typedef vtr::StrongId<cluster_block_id_tag> ClusterBlockId;$/;"	t
ClusterNetId	base/clustered_netlist_fwd.h	/^typedef vtr::StrongId<cluster_net_id_tag> ClusterNetId;$/;"	t
ClusterPinId	base/clustered_netlist_fwd.h	/^typedef vtr::StrongId<cluster_pin_id_tag> ClusterPinId;$/;"	t
ClusterPortId	base/clustered_netlist_fwd.h	/^typedef vtr::StrongId<cluster_port_id_tag> ClusterPortId;$/;"	t
ClusteredNetlist	base/clustered_netlist.cpp	/^ClusteredNetlist::ClusteredNetlist(std::string name, std::string id)$/;"	f	class:ClusteredNetlist	signature:(std::string name, std::string id)
ClusteredNetlist	base/clustered_netlist.h	/^        ClusteredNetlist(std::string name="", std::string id="");$/;"	p	class:ClusteredNetlist	access:public	signature:(std::string name=Ó, std::string id=Ó)
ClusteredNetlist	base/clustered_netlist.h	/^class ClusteredNetlist : public Netlist<ClusterBlockId, ClusterPortId, ClusterPinId, ClusterNetId> {$/;"	c	inherits:Netlist
ClusteredNetlist::ClusteredNetlist	base/clustered_netlist.cpp	/^ClusteredNetlist::ClusteredNetlist(std::string name, std::string id)$/;"	f	class:ClusteredNetlist	signature:(std::string name, std::string id)
ClusteredNetlist::ClusteredNetlist	base/clustered_netlist.h	/^        ClusteredNetlist(std::string name="", std::string id="");$/;"	p	class:ClusteredNetlist	access:public	signature:(std::string name=Ó, std::string id=Ó)
ClusteredNetlist::block_contains_primary_input	base/clustered_netlist.cpp	/^bool ClusteredNetlist::block_contains_primary_input(const ClusterBlockId blk) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk) const
ClusteredNetlist::block_contains_primary_input	base/clustered_netlist.h	/^        bool block_contains_primary_input(const ClusterBlockId blk) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk) const
ClusteredNetlist::block_contains_primary_output	base/clustered_netlist.cpp	/^bool ClusteredNetlist::block_contains_primary_output(const ClusterBlockId blk) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk) const
ClusteredNetlist::block_contains_primary_output	base/clustered_netlist.h	/^        bool block_contains_primary_output(const ClusterBlockId blk) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk) const
ClusteredNetlist::block_logical_pins_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterBlockId, std::vector<ClusterPinId>> block_logical_pins_; \/\/The logical pin associated with each physical block pin$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::block_net	base/clustered_netlist.cpp	/^ClusterNetId ClusteredNetlist::block_net(const ClusterBlockId blk_id, const int phys_pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id, const int phys_pin_index) const
ClusteredNetlist::block_net	base/clustered_netlist.h	/^        ClusterNetId block_net(const ClusterBlockId blk_id, const int pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk_id, const int pin_index) const
ClusteredNetlist::block_pb	base/clustered_netlist.cpp	/^t_pb* ClusteredNetlist::block_pb(const ClusterBlockId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId id) const
ClusteredNetlist::block_pb	base/clustered_netlist.h	/^        t_pb* block_pb(const ClusterBlockId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId id) const
ClusteredNetlist::block_pbs_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterBlockId, t_pb*>                     block_pbs_;         \/\/Physical block representing the clustering & internal hierarchy of each CLB$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::block_pin	base/clustered_netlist.cpp	/^ClusterPinId ClusteredNetlist::block_pin(const ClusterBlockId blk, const int phys_pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk, const int phys_pin_index) const
ClusteredNetlist::block_pin	base/clustered_netlist.h	/^        ClusterPinId block_pin(const ClusterBlockId blk, const int phys_pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk, const int phys_pin_index) const
ClusteredNetlist::block_pin_net_index	base/clustered_netlist.cpp	/^int ClusteredNetlist::block_pin_net_index(const ClusterBlockId blk_id, const int pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id, const int pin_index) const
ClusteredNetlist::block_pin_net_index	base/clustered_netlist.h	/^        int block_pin_net_index(const ClusterBlockId blk_id, const int pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk_id, const int pin_index) const
ClusteredNetlist::block_type	base/clustered_netlist.cpp	/^t_type_ptr ClusteredNetlist::block_type(const ClusterBlockId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId id) const
ClusteredNetlist::block_type	base/clustered_netlist.h	/^        t_type_ptr block_type(const ClusterBlockId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId id) const
ClusteredNetlist::block_types_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterBlockId, t_type_ptr>                block_types_;       \/\/The type of physical block this user circuit block is mapped to$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::clean_blocks_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_blocks_impl(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& block_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& block_id_map)
ClusteredNetlist::clean_nets_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_nets_impl(const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map)
ClusteredNetlist::clean_pins_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_pins_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map)
ClusteredNetlist::clean_ports_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_ports_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map)
ClusteredNetlist::create_block	base/clustered_netlist.cpp	/^ClusterBlockId ClusteredNetlist::create_block(const char *name, t_pb* pb, t_type_ptr type) {$/;"	f	class:ClusteredNetlist	signature:(const char *name, t_pb* pb, t_type_ptr type)
ClusteredNetlist::create_block	base/clustered_netlist.h	/^        ClusterBlockId create_block(const char *name, t_pb* pb, t_type_ptr type);$/;"	p	class:ClusteredNetlist	access:public	signature:(const char *name, t_pb* pb, t_type_ptr type)
ClusteredNetlist::create_net	base/clustered_netlist.cpp	/^ClusterNetId ClusteredNetlist::create_net(const std::string name) {$/;"	f	class:ClusteredNetlist	signature:(const std::string name)
ClusteredNetlist::create_net	base/clustered_netlist.h	/^        ClusterNetId    create_net(const std::string name);$/;"	p	class:ClusteredNetlist	access:public	signature:(const std::string name)
ClusteredNetlist::create_pin	base/clustered_netlist.cpp	/^ClusterPinId ClusteredNetlist::create_pin(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type_, int pin_index, bool is_const) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type_, int pin_index, bool is_const)
ClusteredNetlist::create_pin	base/clustered_netlist.h	/^        ClusterPinId   create_pin(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type, int pin_index, bool is_const=false);$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type, int pin_index, bool is_const=false)
ClusteredNetlist::create_port	base/clustered_netlist.cpp	/^ClusterPortId ClusteredNetlist::create_port(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type)
ClusteredNetlist::create_port	base/clustered_netlist.h	/^        ClusterPortId create_port(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type);$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type)
ClusteredNetlist::net_is_global	base/clustered_netlist.cpp	/^bool ClusteredNetlist::net_is_global(const ClusterNetId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterNetId id) const
ClusteredNetlist::net_is_global	base/clustered_netlist.h	/^        bool net_is_global(const ClusterNetId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterNetId id) const
ClusteredNetlist::net_is_global_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterNetId, bool> net_is_global_;     \/\/Boolean mapping indicating if the net is global$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::net_pin_physical_index	base/clustered_netlist.cpp	/^int ClusteredNetlist::net_pin_physical_index(const ClusterNetId net_id, int net_pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterNetId net_id, int net_pin_index) const
ClusteredNetlist::net_pin_physical_index	base/clustered_netlist.h	/^        int net_pin_physical_index(const ClusterNetId net_id, int net_pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterNetId net_id, int net_pin_index) const
ClusteredNetlist::override	base/clustered_netlist.h	/^        bool validate_block_sizes_impl(size_t num_blocks) const override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        bool validate_net_sizes_impl(size_t num_nets) const override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        bool validate_pin_sizes_impl(size_t num_pins) const override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        bool validate_port_sizes_impl(size_t num_ports) const override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void clean_blocks_impl(const vtr::vector_map<ClusterBlockId,ClusterBlockId>& block_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void clean_nets_impl(const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void clean_pins_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void clean_ports_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void rebuild_block_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map, const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void rebuild_net_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void rebuild_pin_refs_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map, const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void rebuild_port_refs_impl(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& block_id_map, const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void remove_block_impl(const ClusterBlockId blk_id) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void remove_net_impl(const ClusterNetId net_id) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void remove_pin_impl(const ClusterPinId pin_id) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void remove_port_impl(const ClusterPortId port_id) override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::override	base/clustered_netlist.h	/^        void shrink_to_fit_impl() override;$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::pin_physical_index	base/clustered_netlist.cpp	/^int ClusteredNetlist::pin_physical_index(const ClusterPinId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPinId id) const
ClusteredNetlist::pin_physical_index	base/clustered_netlist.h	/^        int pin_physical_index(const ClusterPinId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterPinId id) const
ClusteredNetlist::pin_physical_index_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterPinId, int> pin_physical_index_; \/\/The physical pin index (i.e. pin index$/;"	m	class:ClusteredNetlist	access:private
ClusteredNetlist::rebuild_block_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_block_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& \/*pin_id_map*\/,$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPinId, ClusterPinId>& , const vtr::vector_map<ClusterPortId, ClusterPortId>& )
ClusteredNetlist::rebuild_net_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_net_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& \/*pin_id_map*\/) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPinId, ClusterPinId>& )
ClusteredNetlist::rebuild_pin_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_pin_refs_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& \/*port_id_map*\/,$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPortId, ClusterPortId>& , const vtr::vector_map<ClusterNetId, ClusterNetId>& )
ClusteredNetlist::rebuild_port_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_port_refs_impl(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& \/*block_id_map*\/,$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& , const vtr::vector_map<ClusterPinId, ClusterPinId>& )
ClusteredNetlist::remove_block_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_block_impl(const ClusterBlockId blk_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id)
ClusteredNetlist::remove_net_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_net_impl(const ClusterNetId net_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterNetId net_id)
ClusteredNetlist::remove_pin_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_pin_impl(const ClusterPinId pin_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPinId pin_id)
ClusteredNetlist::remove_port_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_port_impl(const ClusterPortId port_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPortId port_id)
ClusteredNetlist::set_net_is_global	base/clustered_netlist.cpp	/^void ClusteredNetlist::set_net_is_global(ClusterNetId net_id, bool state) {$/;"	f	class:ClusteredNetlist	signature:(ClusterNetId net_id, bool state)
ClusteredNetlist::set_net_is_global	base/clustered_netlist.h	/^        void set_net_is_global(ClusterNetId net_id, bool state);$/;"	p	class:ClusteredNetlist	access:public	signature:(ClusterNetId net_id, bool state)
ClusteredNetlist::set_pin_physical_index	base/clustered_netlist.cpp	/^void ClusteredNetlist::set_pin_physical_index(const ClusterPinId pin, const int phys_pin_index) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPinId pin, const int phys_pin_index)
ClusteredNetlist::set_pin_physical_index	base/clustered_netlist.h	/^        void    set_pin_physical_index(const ClusterPinId pin_id, const int index);$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterPinId pin_id, const int index)
ClusteredNetlist::shrink_to_fit_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::shrink_to_fit_impl() {$/;"	f	class:ClusteredNetlist	signature:()
ClusteredNetlist::validate_block_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_block_sizes_impl(size_t num_blocks) const {$/;"	f	class:ClusteredNetlist	signature:(size_t num_blocks) const
ClusteredNetlist::validate_net_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_net_sizes_impl(size_t num_nets) const {$/;"	f	class:ClusteredNetlist	signature:(size_t num_nets) const
ClusteredNetlist::validate_pin_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_pin_sizes_impl(size_t num_pins) const {$/;"	f	class:ClusteredNetlist	signature:(size_t num_pins) const
ClusteredNetlist::validate_port_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_port_sizes_impl(size_t \/*num_ports*\/) const {$/;"	f	class:ClusteredNetlist	signature:(size_t ) const
ClusteredPinAtomPinsLookup	base/clustered_netlist_utils.cpp	/^ClusteredPinAtomPinsLookup::ClusteredPinAtomPinsLookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	class:ClusteredPinAtomPinsLookup	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
ClusteredPinAtomPinsLookup	base/clustered_netlist_utils.h	/^        ClusteredPinAtomPinsLookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	class:ClusteredPinAtomPinsLookup	access:public	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
ClusteredPinAtomPinsLookup	base/clustered_netlist_utils.h	/^class ClusteredPinAtomPinsLookup {$/;"	c
ClusteredPinAtomPinsLookup::ClusteredPinAtomPinsLookup	base/clustered_netlist_utils.cpp	/^ClusteredPinAtomPinsLookup::ClusteredPinAtomPinsLookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	class:ClusteredPinAtomPinsLookup	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
ClusteredPinAtomPinsLookup::ClusteredPinAtomPinsLookup	base/clustered_netlist_utils.h	/^        ClusteredPinAtomPinsLookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	class:ClusteredPinAtomPinsLookup	access:public	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
ClusteredPinAtomPinsLookup::atom_pin_iterator	base/clustered_netlist_utils.h	/^        typedef std::vector<AtomPinId>::const_iterator      atom_pin_iterator;$/;"	t	class:ClusteredPinAtomPinsLookup	access:public
ClusteredPinAtomPinsLookup::atom_pin_range	base/clustered_netlist_utils.h	/^        typedef typename vtr::Range<atom_pin_iterator>   atom_pin_range;$/;"	t	class:ClusteredPinAtomPinsLookup	access:public
ClusteredPinAtomPinsLookup::clustered_pin_connected_atom_pins_	base/clustered_netlist_utils.h	/^        vtr::vector<ClusterPinId,std::vector<AtomPinId>> clustered_pin_connected_atom_pins_;$/;"	m	class:ClusteredPinAtomPinsLookup	access:private
ClusteredPinAtomPinsLookup::connected_atom_pins	base/clustered_netlist_utils.cpp	/^ClusteredPinAtomPinsLookup::atom_pin_range ClusteredPinAtomPinsLookup::connected_atom_pins(ClusterPinId clustered_pin) const {$/;"	f	class:ClusteredPinAtomPinsLookup	signature:(ClusterPinId clustered_pin) const
ClusteredPinAtomPinsLookup::connected_atom_pins	base/clustered_netlist_utils.h	/^        atom_pin_range connected_atom_pins(ClusterPinId clustered_pin) const;$/;"	p	class:ClusteredPinAtomPinsLookup	access:public	signature:(ClusterPinId clustered_pin) const
ClusteredPinAtomPinsLookup::init_lookup	base/clustered_netlist_utils.cpp	/^void ClusteredPinAtomPinsLookup::init_lookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	class:ClusteredPinAtomPinsLookup	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
ClusteredPinAtomPinsLookup::init_lookup	base/clustered_netlist_utils.h	/^        void init_lookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	class:ClusteredPinAtomPinsLookup	access:private	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
ClusteringContext	base/vpr_context.h	/^struct ClusteringContext : public Context {$/;"	s	inherits:Context
ClusteringContext::clb_nlist	base/vpr_context.h	/^	ClusteredNetlist clb_nlist;$/;"	m	struct:ClusteringContext	access:public
Cmetal	../../libs/libarchfpga/src/physical_types.h	/^	float Cmetal;$/;"	m	struct:t_segment_inf	access:public
Cmetal	base/vpr_types.h	/^	float Cmetal = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
Cmetal	base/vpr_types.h	/^        float Cmetal() const { return seg_detail_->Cmetal; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
Cmetal_per_m	base/vpr_types.h	/^	float Cmetal_per_m = 0; \/* Used for power *\/$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
Cmetal_per_m	base/vpr_types.h	/^        float Cmetal_per_m() const { return seg_detail_->Cmetal_per_m; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
CmosTechFile	base/read_options.h	/^    argparse::ArgValue<std::string> CmosTechFile;$/;"	m	struct:t_options	access:public
CmosTechFile	base/vpr_types.h	/^	std::string CmosTechFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
Color	../../libs/libvtrutil/src/vtr_color_map.h	/^struct Color {$/;"	s	namespace:vtr
ColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^ColorMap::ColorMap(float min_val, float max_val, const std::vector<Color<float>>& color_data)$/;"	f	class:vtr::ColorMap	signature:(float min_val, float max_val, const std::vector<Color<float>>& color_data)
ColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        ColorMap(float min, float max, const std::vector<Color<float>>& color_data);$/;"	p	class:vtr::ColorMap	access:public	signature:(float min, float max, const std::vector<Color<float>>& color_data)
ColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class ColorMap {$/;"	c	namespace:vtr
ConcreteHoldTimingInfo	timing/concrete_timing_info.h	/^        ConcreteHoldTimingInfo(std::shared_ptr<const tatum::TimingGraph> timing_graph_v,$/;"	f	class:ConcreteHoldTimingInfo	access:public	signature:(std::shared_ptr<const tatum::TimingGraph> timing_graph_v, std::shared_ptr<const tatum::TimingConstraints> timing_constraints_v, std::shared_ptr<DelayCalc> delay_calc, std::shared_ptr<tatum::HoldTimingAnalyzer> analyzer_v)
ConcreteHoldTimingInfo	timing/concrete_timing_info.h	/^class ConcreteHoldTimingInfo : public HoldTimingInfo {$/;"	c	inherits:HoldTimingInfo
ConcreteHoldTimingInfo::Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::ConcreteHoldTimingInfo	timing/concrete_timing_info.h	/^        ConcreteHoldTimingInfo(std::shared_ptr<const tatum::TimingGraph> timing_graph_v,$/;"	f	class:ConcreteHoldTimingInfo	access:public	signature:(std::shared_ptr<const tatum::TimingGraph> timing_graph_v, std::shared_ptr<const tatum::TimingConstraints> timing_constraints_v, std::shared_ptr<DelayCalc> delay_calc, std::shared_ptr<tatum::HoldTimingAnalyzer> analyzer_v)
ConcreteHoldTimingInfo::delay_calc_	timing/concrete_timing_info.h	/^        std::shared_ptr<DelayCalc> delay_calc_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::hold_analyzer_	timing/concrete_timing_info.h	/^        std::shared_ptr<tatum::HoldTimingAnalyzer> hold_analyzer_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::slack_crit_	timing/concrete_timing_info.h	/^        HoldSlackCrit slack_crit_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::timing_constraints_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingConstraints> timing_constraints_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::timing_graph_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingGraph> timing_graph_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
ConcreteHoldTimingInfo::update_hold_slacks	timing/concrete_timing_info.h	/^        void update_hold_slacks() {$/;"	f	class:ConcreteHoldTimingInfo	access:public	signature:()
ConcreteHoldTimingInfo::warn_unconstrained_	timing/concrete_timing_info.h	/^        bool warn_unconstrained_ = true;$/;"	m	class:ConcreteHoldTimingInfo	access:private
ConcreteSetupHoldTimingInfo	timing/concrete_timing_info.h	/^        ConcreteSetupHoldTimingInfo(std::shared_ptr<const tatum::TimingGraph> timing_graph_v,$/;"	f	class:ConcreteSetupHoldTimingInfo	access:public	signature:(std::shared_ptr<const tatum::TimingGraph> timing_graph_v, std::shared_ptr<const tatum::TimingConstraints> timing_constraints_v, std::shared_ptr<DelayCalc> delay_calc, std::shared_ptr<tatum::SetupHoldTimingAnalyzer> analyzer_v)
ConcreteSetupHoldTimingInfo	timing/concrete_timing_info.h	/^class ConcreteSetupHoldTimingInfo : public SetupHoldTimingInfo {$/;"	c	inherits:SetupHoldTimingInfo
ConcreteSetupHoldTimingInfo::Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConcreteSetupHoldTimingInfo	access:private
ConcreteSetupHoldTimingInfo::ConcreteSetupHoldTimingInfo	timing/concrete_timing_info.h	/^        ConcreteSetupHoldTimingInfo(std::shared_ptr<const tatum::TimingGraph> timing_graph_v,$/;"	f	class:ConcreteSetupHoldTimingInfo	access:public	signature:(std::shared_ptr<const tatum::TimingGraph> timing_graph_v, std::shared_ptr<const tatum::TimingConstraints> timing_constraints_v, std::shared_ptr<DelayCalc> delay_calc, std::shared_ptr<tatum::SetupHoldTimingAnalyzer> analyzer_v)
ConcreteSetupHoldTimingInfo::dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConcreteSetupHoldTimingInfo	access:private
ConcreteSetupHoldTimingInfo::hold_timing_	timing/concrete_timing_info.h	/^        ConcreteHoldTimingInfo<DelayCalc> hold_timing_;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
ConcreteSetupHoldTimingInfo::setup_hold_analyzer_	timing/concrete_timing_info.h	/^        std::shared_ptr<tatum::SetupHoldTimingAnalyzer> setup_hold_analyzer_;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
ConcreteSetupHoldTimingInfo::setup_timing_	timing/concrete_timing_info.h	/^        ConcreteSetupTimingInfo<DelayCalc> setup_timing_;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
ConcreteSetupHoldTimingInfo::warn_unconstrained_	timing/concrete_timing_info.h	/^        bool warn_unconstrained_ = true;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
ConcreteSetupTimingInfo	timing/concrete_timing_info.h	/^        ConcreteSetupTimingInfo(std::shared_ptr<const tatum::TimingGraph> timing_graph_v,$/;"	f	class:ConcreteSetupTimingInfo	access:public	signature:(std::shared_ptr<const tatum::TimingGraph> timing_graph_v, std::shared_ptr<const tatum::TimingConstraints> timing_constraints_v, std::shared_ptr<DelayCalc> delay_calc, std::shared_ptr<tatum::SetupTimingAnalyzer> analyzer_v)
ConcreteSetupTimingInfo	timing/concrete_timing_info.h	/^class ConcreteSetupTimingInfo : public SetupTimingInfo {$/;"	c	inherits:SetupTimingInfo
ConcreteSetupTimingInfo::Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::ConcreteSetupTimingInfo	timing/concrete_timing_info.h	/^        ConcreteSetupTimingInfo(std::shared_ptr<const tatum::TimingGraph> timing_graph_v,$/;"	f	class:ConcreteSetupTimingInfo	access:public	signature:(std::shared_ptr<const tatum::TimingGraph> timing_graph_v, std::shared_ptr<const tatum::TimingConstraints> timing_constraints_v, std::shared_ptr<DelayCalc> delay_calc, std::shared_ptr<tatum::SetupTimingAnalyzer> analyzer_v)
ConcreteSetupTimingInfo::delay_calc_	timing/concrete_timing_info.h	/^        std::shared_ptr<DelayCalc> delay_calc_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::setup_analyzer_	timing/concrete_timing_info.h	/^        std::shared_ptr<tatum::SetupTimingAnalyzer> setup_analyzer_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::slack_crit_	timing/concrete_timing_info.h	/^        SetupSlackCrit slack_crit_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::timing_constraints_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingConstraints> timing_constraints_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::timing_graph_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingGraph> timing_graph_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
ConcreteSetupTimingInfo::update_setup_slacks	timing/concrete_timing_info.h	/^        void update_setup_slacks() {$/;"	f	class:ConcreteSetupTimingInfo	access:public	signature:()
ConcreteSetupTimingInfo::warn_unconstrained_	timing/concrete_timing_info.h	/^        bool warn_unconstrained_ = true;$/;"	m	class:ConcreteSetupTimingInfo	access:private
Conn_Block_Metrics	route/cb_metrics.h	/^class Conn_Block_Metrics{$/;"	c
Conn_Block_Metrics::clear	route/cb_metrics.h	/^	void clear(){$/;"	f	class:Conn_Block_Metrics	access:public	signature:()
Conn_Block_Metrics::hamming_proximity	route/cb_metrics.h	/^	float hamming_proximity;$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::lemieux_cost_func	route/cb_metrics.h	/^	float lemieux_cost_func;$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::num_wire_types	route/cb_metrics.h	/^	int num_wire_types;			\/* the number of different wire types, used for computing pin diversity *\/$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::pin_diversity	route/cb_metrics.h	/^	float pin_diversity;$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::pin_locations	route/cb_metrics.h	/^	t_2d_int_vec pin_locations;		\/* [0..3][0..num_on_this_side-1]. Keeps track of which pins come out on which side of the block *\/$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::pin_to_tracks	route/cb_metrics.h	/^	t_vec_vec_set pin_to_tracks;		\/* [0..3][0..num_pins_on_side-1][0..tracks_connected-1]. A lookup for which tracks connect to a given pin *\/$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::track_to_pins	route/cb_metrics.h	/^	t_vec_vec_set track_to_pins;		\/* [0..3][0..W-1][0..pins_connected-1]. A convenient lookup for which pins connect to a given track *\/$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::wire_homogeneity	route/cb_metrics.h	/^	float wire_homogeneity;$/;"	m	class:Conn_Block_Metrics	access:public
Conn_Block_Metrics::wire_types_used_count	route/cb_metrics.h	/^	t_3d_int_vec wire_types_used_count;	\/* [0..3][0..num_pins_on_side-1][0..num_wire_types-1]. Keeps track of how many times each pin connects to each of the wire types *\/$/;"	m	class:Conn_Block_Metrics	access:public
Connection_based_routing_resources	route/connection_based_routing.h	/^	Connection_based_routing_resources();$/;"	p	class:Connection_based_routing_resources	access:public	signature:()
Connection_based_routing_resources	route/connection_based_routing.h	/^class Connection_based_routing_resources {$/;"	c
Connection_based_routing_resources	route/route_timing.cpp	/^Connection_based_routing_resources::Connection_based_routing_resources() :$/;"	f	class:Connection_based_routing_resources	signature:()
Connection_based_routing_resources::Connection_based_routing_resources	route/connection_based_routing.h	/^	Connection_based_routing_resources();$/;"	p	class:Connection_based_routing_resources	access:public	signature:()
Connection_based_routing_resources::Connection_based_routing_resources	route/route_timing.cpp	/^Connection_based_routing_resources::Connection_based_routing_resources() :$/;"	f	class:Connection_based_routing_resources	signature:()
Connection_based_routing_resources::clear_force_reroute_for_connection	route/connection_based_routing.h	/^	void clear_force_reroute_for_connection(int rr_sink_node);$/;"	p	class:Connection_based_routing_resources	access:public	signature:(int rr_sink_node)
Connection_based_routing_resources::clear_force_reroute_for_connection	route/route_timing.cpp	/^void Connection_based_routing_resources::clear_force_reroute_for_connection(int rr_sink_node) {$/;"	f	class:Connection_based_routing_resources	signature:(int rr_sink_node)
Connection_based_routing_resources::clear_force_reroute_for_net	route/connection_based_routing.h	/^	void clear_force_reroute_for_net();$/;"	p	class:Connection_based_routing_resources	access:public	signature:()
Connection_based_routing_resources::clear_force_reroute_for_net	route/route_timing.cpp	/^void Connection_based_routing_resources::clear_force_reroute_for_net() {$/;"	f	class:Connection_based_routing_resources	signature:()
Connection_based_routing_resources::connection_criticality_tolerance	route/connection_based_routing.h	/^	float connection_criticality_tolerance;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::connection_delay_optimality_tolerance	route/connection_based_routing.h	/^	float connection_delay_optimality_tolerance;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::convert_sink_nodes_to_net_pins	route/connection_based_routing.h	/^	void convert_sink_nodes_to_net_pins(std::vector<int>& rr_sink_nodes) const;$/;"	p	class:Connection_based_routing_resources	access:public	signature:(std::vector<int>& rr_sink_nodes) const
Connection_based_routing_resources::convert_sink_nodes_to_net_pins	route/route_timing.cpp	/^void Connection_based_routing_resources::convert_sink_nodes_to_net_pins(vector<int>& rr_sink_nodes) const {$/;"	f	class:Connection_based_routing_resources	signature:(vector<int>& rr_sink_nodes) const
Connection_based_routing_resources::critical_path_delay_grew_significantly	route/connection_based_routing.h	/^	bool critical_path_delay_grew_significantly(float new_critical_path_delay) const {$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float new_critical_path_delay) const
Connection_based_routing_resources::critical_path_growth_tolerance	route/connection_based_routing.h	/^	float critical_path_growth_tolerance;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::current_inet	route/connection_based_routing.h	/^	ClusterNetId current_inet;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::forcible_reroute_connection_flag	route/connection_based_routing.h	/^	vtr::vector<ClusterNetId, std::unordered_map<int,bool>> forcible_reroute_connection_flag;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::forcibly_reroute_connections	route/connection_based_routing.h	/^	bool forcibly_reroute_connections(float max_criticality,$/;"	p	class:Connection_based_routing_resources	access:public	signature:(float max_criticality, std::shared_ptr<const SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
Connection_based_routing_resources::forcibly_reroute_connections	route/route_timing.cpp	/^bool Connection_based_routing_resources::forcibly_reroute_connections(float max_criticality,$/;"	f	class:Connection_based_routing_resources	signature:(float max_criticality, std::shared_ptr<const SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
Connection_based_routing_resources::get_current_inet	route/connection_based_routing.h	/^	ClusterNetId get_current_inet() const {return current_inet;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:() const
Connection_based_routing_resources::get_reached_rt_sinks	route/connection_based_routing.h	/^	std::vector<t_rt_node*>& get_reached_rt_sinks() {return reached_rt_sinks;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:()
Connection_based_routing_resources::get_remaining_targets	route/connection_based_routing.h	/^	std::vector<int>& get_remaining_targets() {return remaining_targets;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:()
Connection_based_routing_resources::get_stable_critical_path_delay	route/connection_based_routing.h	/^	float get_stable_critical_path_delay() const {return last_stable_critical_path_delay;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:() const
Connection_based_routing_resources::last_stable_critical_path_delay	route/connection_based_routing.h	/^	float last_stable_critical_path_delay;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::lower_bound_connection_delay	route/connection_based_routing.h	/^	vtr::vector<ClusterNetId, std::vector<float>> lower_bound_connection_delay;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::prepare_routing_for_net	route/connection_based_routing.h	/^	void prepare_routing_for_net(ClusterNetId inet) {$/;"	f	class:Connection_based_routing_resources	access:public	signature:(ClusterNetId inet)
Connection_based_routing_resources::put_sink_rt_nodes_in_net_pins_lookup	route/connection_based_routing.h	/^	void put_sink_rt_nodes_in_net_pins_lookup(const std::vector<t_rt_node*>& sink_rt_nodes,$/;"	p	class:Connection_based_routing_resources	access:public	signature:(const std::vector<t_rt_node*>& sink_rt_nodes, t_rt_node** rt_node_of_sink) const
Connection_based_routing_resources::put_sink_rt_nodes_in_net_pins_lookup	route/route_timing.cpp	/^void Connection_based_routing_resources::put_sink_rt_nodes_in_net_pins_lookup(const vector<t_rt_node*>& sink_rt_nodes,$/;"	f	class:Connection_based_routing_resources	signature:(const vector<t_rt_node*>& sink_rt_nodes, t_rt_node** rt_node_of_sink) const
Connection_based_routing_resources::reached_rt_sink	route/connection_based_routing.h	/^	void reached_rt_sink(t_rt_node* rt_sink) {reached_rt_sinks.push_back(rt_sink);}$/;"	f	class:Connection_based_routing_resources	access:public	signature:(t_rt_node* rt_sink)
Connection_based_routing_resources::reached_rt_sinks	route/connection_based_routing.h	/^	std::vector<t_rt_node*> reached_rt_sinks;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::remaining_targets	route/connection_based_routing.h	/^	std::vector<int> remaining_targets;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::rr_sink_node_to_pin	route/connection_based_routing.h	/^	vtr::vector<ClusterNetId, std::unordered_map<int,int>> rr_sink_node_to_pin;$/;"	m	class:Connection_based_routing_resources	access:private
Connection_based_routing_resources::sanity_check_lookup	route/connection_based_routing.h	/^	bool sanity_check_lookup() const;$/;"	p	class:Connection_based_routing_resources	access:public	signature:() const
Connection_based_routing_resources::sanity_check_lookup	route/route_timing.cpp	/^bool Connection_based_routing_resources::sanity_check_lookup() const {$/;"	f	class:Connection_based_routing_resources	signature:() const
Connection_based_routing_resources::set_connection_criticality_tolerance	route/connection_based_routing.h	/^    void set_connection_criticality_tolerance(float val) { connection_criticality_tolerance = val; }$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float val)
Connection_based_routing_resources::set_connection_delay_tolerance	route/connection_based_routing.h	/^    void set_connection_delay_tolerance(float val) { connection_delay_optimality_tolerance = val; }$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float val)
Connection_based_routing_resources::set_lower_bound_connection_delays	route/connection_based_routing.h	/^	void set_lower_bound_connection_delays(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	class:Connection_based_routing_resources	access:public	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
Connection_based_routing_resources::set_lower_bound_connection_delays	route/route_timing.cpp	/^void Connection_based_routing_resources::set_lower_bound_connection_delays(vtr::vector<ClusterNetId, float *> &net_delay) {$/;"	f	class:Connection_based_routing_resources	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
Connection_based_routing_resources::set_stable_critical_path_delay	route/connection_based_routing.h	/^	void set_stable_critical_path_delay(float stable_critical_path_delay) {last_stable_critical_path_delay = stable_critical_path_delay;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float stable_critical_path_delay)
Connection_based_routing_resources::should_force_reroute_connection	route/connection_based_routing.h	/^	bool should_force_reroute_connection(int rr_sink_node) const {$/;"	f	class:Connection_based_routing_resources	access:public	signature:(int rr_sink_node) const
Connection_based_routing_resources::toreach_rr_sink	route/connection_based_routing.h	/^	void toreach_rr_sink(int rr_sink_node) {remaining_targets.push_back(rr_sink_node);}$/;"	f	class:Connection_based_routing_resources	access:public	signature:(int rr_sink_node)
ConstantTimingInfo	timing/concrete_timing_info.h	/^        ConstantTimingInfo(const float criticality)$/;"	f	class:ConstantTimingInfo	access:public	signature:(const float criticality)
ConstantTimingInfo	timing/concrete_timing_info.h	/^class ConstantTimingInfo : public SetupHoldTimingInfo {$/;"	c	inherits:SetupHoldTimingInfo
ConstantTimingInfo::Clock	timing/concrete_timing_info.h	/^        typedef std::chrono::high_resolution_clock Clock;$/;"	t	class:ConstantTimingInfo	access:private
ConstantTimingInfo::ConstantTimingInfo	timing/concrete_timing_info.h	/^        ConstantTimingInfo(const float criticality)$/;"	f	class:ConstantTimingInfo	access:public	signature:(const float criticality)
ConstantTimingInfo::criticality_	timing/concrete_timing_info.h	/^        float criticality_;$/;"	m	class:ConstantTimingInfo	access:private
ConstantTimingInfo::dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConstantTimingInfo	access:private
Context	base/vpr_context.h	/^    Context() = default;$/;"	p	struct:Context	access:public	signature:()
Context	base/vpr_context.h	/^    Context(Context&) = delete;$/;"	p	struct:Context	access:public	signature:(Context&)
Context	base/vpr_context.h	/^struct Context {$/;"	s
Context::Context	base/vpr_context.h	/^    Context() = default;$/;"	p	struct:Context	access:public	signature:()
Context::Context	base/vpr_context.h	/^    Context(Context&) = delete;$/;"	p	struct:Context	access:public	signature:(Context&)
Context::operator =	base/vpr_context.h	/^    Context& operator=(Context&) = delete;$/;"	p	struct:Context	access:public	signature:(Context&)
Context::~Context	base/vpr_context.h	/^    virtual ~Context() = default;$/;"	p	struct:Context	access:public	signature:()
Cost_Entry	route/router_lookahead_map.cpp	/^	Cost_Entry(){$/;"	f	class:Cost_Entry	access:public	signature:()
Cost_Entry	route/router_lookahead_map.cpp	/^	Cost_Entry(float set_delay, float set_congestion){$/;"	f	class:Cost_Entry	access:public	signature:(float set_delay, float set_congestion)
Cost_Entry	route/router_lookahead_map.cpp	/^class Cost_Entry{$/;"	c	file:
Cost_Entry::Cost_Entry	route/router_lookahead_map.cpp	/^	Cost_Entry(){$/;"	f	class:Cost_Entry	access:public	signature:()
Cost_Entry::Cost_Entry	route/router_lookahead_map.cpp	/^	Cost_Entry(float set_delay, float set_congestion){$/;"	f	class:Cost_Entry	access:public	signature:(float set_delay, float set_congestion)
Cost_Entry::congestion	route/router_lookahead_map.cpp	/^	float congestion;$/;"	m	class:Cost_Entry	file:	access:public
Cost_Entry::delay	route/router_lookahead_map.cpp	/^	float delay;$/;"	m	class:Cost_Entry	file:	access:public
Cout	../../libs/libarchfpga/src/physical_types.h	/^	float Cout = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
Cout	../../libs/libarchfpga/src/physical_types.h	/^        float Cout = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
CreateEchoFile	base/read_options.h	/^    argparse::ArgValue<bool> CreateEchoFile;$/;"	m	struct:t_options	access:public
CreateModelLibrary	../../libs/libarchfpga/src/arch_util.cpp	/^void CreateModelLibrary(t_arch *arch) {$/;"	f	signature:(t_arch *arch)
CreateModelLibrary	../../libs/libarchfpga/src/arch_util.h	/^void CreateModelLibrary(t_arch *arch);$/;"	p	signature:(t_arch *arch)
Criticality_comp	route/route_timing.cpp	/^    Criticality_comp(const float* calculated_criticalities) : criticality{calculated_criticalities}$/;"	f	struct:Criticality_comp	access:public	signature:(const float* calculated_criticalities)
Criticality_comp	route/route_timing.cpp	/^struct Criticality_comp {$/;"	s	file:
Criticality_comp::Criticality_comp	route/route_timing.cpp	/^    Criticality_comp(const float* calculated_criticalities) : criticality{calculated_criticalities}$/;"	f	struct:Criticality_comp	access:public	signature:(const float* calculated_criticalities)
Criticality_comp::criticality	route/route_timing.cpp	/^    const float* criticality;$/;"	m	struct:Criticality_comp	file:	access:public
Criticality_comp::operator ()	route/route_timing.cpp	/^    bool operator()(int a, int b) const {$/;"	f	struct:Criticality_comp	access:public	signature:(int a, int b) const
CustomSentinel	../../libs/libvtrutil/src/vtr_sentinels.h	/^class CustomSentinel {$/;"	c	namespace:vtr
DARKBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    DARKBLUE,$/;"	e	enum:color_types
DARKCYAN	../../libs/libeasygl/src/easygl_constants.h	/^    DARKCYAN,$/;"	e	enum:color_types
DARKGOLDENROD	../../libs/libeasygl/src/easygl_constants.h	/^    DARKGOLDENROD,$/;"	e	enum:color_types
DARKGRAY	../../libs/libeasygl/src/easygl_constants.h	/^    DARKGRAY,$/;"	e	enum:color_types
DARKGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    DARKGREEN,$/;"	e	enum:color_types
DARKGREY	../../libs/libeasygl/src/easygl_constants.h	/^    DARKGREY,$/;"	e	enum:color_types
DARKKHAKI	../../libs/libeasygl/src/easygl_constants.h	/^    DARKKHAKI,$/;"	e	enum:color_types
DARKMAGENTA	../../libs/libeasygl/src/easygl_constants.h	/^    DARKMAGENTA,$/;"	e	enum:color_types
DARKOLIVEGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    DARKOLIVEGREEN,$/;"	e	enum:color_types
DARKORANGE	../../libs/libeasygl/src/easygl_constants.h	/^    DARKORANGE,$/;"	e	enum:color_types
DARKORCHID	../../libs/libeasygl/src/easygl_constants.h	/^    DARKORCHID,$/;"	e	enum:color_types
DARKRED	../../libs/libeasygl/src/easygl_constants.h	/^    DARKRED,$/;"	e	enum:color_types
DARKSALMON	../../libs/libeasygl/src/easygl_constants.h	/^    DARKSALMON,$/;"	e	enum:color_types
DARKSEAGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    DARKSEAGREEN,$/;"	e	enum:color_types
DARKSLATEBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    DARKSLATEBLUE,$/;"	e	enum:color_types
DARKSLATEGRAY	../../libs/libeasygl/src/easygl_constants.h	/^    DARKSLATEGRAY,$/;"	e	enum:color_types
DARKSLATEGREY	../../libs/libeasygl/src/easygl_constants.h	/^    DARKSLATEGREY,$/;"	e	enum:color_types
DARKTURQUOISE	../../libs/libeasygl/src/easygl_constants.h	/^    DARKTURQUOISE,$/;"	e	enum:color_types
DARKVIOLET	../../libs/libeasygl/src/easygl_constants.h	/^    DARKVIOLET,$/;"	e	enum:color_types
DASHED	../../libs/libeasygl/src/easygl_constants.h	/^    SOLID, DASHED$/;"	e	enum:line_types
DEBUG_V_BITS	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    #define DEBUG_V_BITS$/;"	d
DEEPPINK	../../libs/libeasygl/src/easygl_constants.h	/^    DEEPPINK,$/;"	e	enum:color_types
DEEPSKYBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    DEEPSKYBLUE,$/;"	e	enum:color_types
DEFAULT_ABS_TOL	../../libs/libvtrutil/src/vtr_math.h	/^    constexpr double DEFAULT_ABS_TOL = 0;$/;"	m	namespace:vtr
DEFAULT_ARROW_SIZE	draw/draw_global.h	/^constexpr float DEFAULT_ARROW_SIZE = 0.3;$/;"	v
DEFAULT_REL_TOL	../../libs/libvtrutil/src/vtr_math.h	/^    constexpr double DEFAULT_REL_TOL = 1e-9;$/;"	m	namespace:vtr
DEFAULT_RR_NODE_COLOR	draw/draw.cpp	/^#define DEFAULT_RR_NODE_COLOR /;"	d	file:
DEFAULT_SWITCH	../../libs/libarchfpga/src/physical_types.h	/^constexpr int DEFAULT_SWITCH = -2;$/;"	v
DEGTORAD	../../libs/libeasygl/src/graphics.cpp	/^#define DEGTORAD(/;"	d	file:
DELAY_NORMALIZED	base/vpr_types.h	/^	DELAY_NORMALIZED, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
DELAY_NORMALIZED_FREQUENCY	base/vpr_types.h	/^	DELAY_NORMALIZED_FREQUENCY, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
DELAY_NORMALIZED_LENGTH	base/vpr_types.h	/^	DELAY_NORMALIZED_LENGTH, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
DELAY_NORMALIZED_LENGTH_FREQUENCY	base/vpr_types.h	/^	DELAY_NORMALIZED_LENGTH_FREQUENCY, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
DELTA	../../libs/libarchfpga/src/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
DELTA	base/vpr_types.h	/^    DELTA,          \/\/Delta x\/y based delay model$/;"	m	class:ScreenUpdatePriority::PlaceDelayModelType	access:private
DELTA_OVERRIDE	base/vpr_types.h	/^    DELTA_OVERRIDE, \/\/Delta x\/y based delay model with special case delay overrides$/;"	m	class:ScreenUpdatePriority::PlaceDelayModelType	access:private
DEMAND_ONLY	base/vpr_types.h	/^    DEMAND_ONLY$/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
DETAILED	base/vpr_types.h	/^	GLOBAL, DETAILED$/;"	e	enum:ScreenUpdatePriority::e_route_type
DEVICE_GRID	base/device_grid.h	/^#define DEVICE_GRID$/;"	d
DIGIT	timing/slre.cpp	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon10	file:
DIMGRAY	../../libs/libeasygl/src/easygl_constants.h	/^    DIMGRAY,$/;"	e	enum:color_types
DIMGREY	../../libs/libeasygl/src/easygl_constants.h	/^    DIMGREY,$/;"	e	enum:color_types
DIRECTION_STRING	base/vpr_types.h	/^constexpr std::array<const char*, NUM_DIRECTIONS> DIRECTION_STRING = { {"INC_DIRECTION", "DEC_DIRECTION", "BI_DIRECTION", "NO_DIRECTION"} };$/;"	m	class:ScreenUpdatePriority	access:private
DIRECT_INTERC	../../libs/libarchfpga/src/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
DISABLE	base/vpr_types.h	/^    MINIMAX, SCALE_DELAY, DISABLE$/;"	e	enum:ScreenUpdatePriority::e_routing_budgets_algorithm
DISCOUNT_FUNCTION_BASE	timing/path_delay.h	/^	#define DISCOUNT_FUNCTION_BASE /;"	d
DODGERBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    DODGERBLUE,$/;"	e	enum:color_types
DONT_CARE	../../libs/libvtrutil/src/vtr_logic.h	/^        DONT_CARE = 2,$/;"	m	class:vtr::LogicValue	access:private
DO_NOT_ANALYSE	timing/path_delay.h	/^#define DO_NOT_ANALYSE /;"	d
DRAW_ACC_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_ACC_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_ALL_BUT_BUFFERS_RR	draw/draw_types.h	/^	DRAW_ALL_BUT_BUFFERS_RR,$/;"	e	enum:e_draw_rr_toggle
DRAW_ALL_RR	draw/draw_types.h	/^	DRAW_ALL_RR,$/;"	e	enum:e_draw_rr_toggle
DRAW_BASE_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_BASE_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_BLOCK_PIN_UTIL_INPUTS	draw/draw_types.h	/^    DRAW_BLOCK_PIN_UTIL_INPUTS,$/;"	e	enum:e_draw_block_pin_util
DRAW_BLOCK_PIN_UTIL_OUTPUTS	draw/draw_types.h	/^    DRAW_BLOCK_PIN_UTIL_OUTPUTS,$/;"	e	enum:e_draw_block_pin_util
DRAW_BLOCK_PIN_UTIL_TOTAL	draw/draw_types.h	/^    DRAW_BLOCK_PIN_UTIL_TOTAL,$/;"	e	enum:e_draw_block_pin_util
DRAW_CONGESTED	draw/draw_types.h	/^	DRAW_CONGESTED,$/;"	e	enum:e_draw_congestion
DRAW_CONGESTED_WITH_NETS	draw/draw_types.h	/^	DRAW_CONGESTED_WITH_NETS,$/;"	e	enum:e_draw_congestion
DRAW_CONGEST_MAX	draw/draw_types.h	/^	DRAW_CONGEST_MAX$/;"	e	enum:e_draw_congestion
DRAW_CRIT_PATH_FLYLINES	draw/draw_types.h	/^    , DRAW_CRIT_PATH_FLYLINES$/;"	e	enum:e_draw_crit_path
DRAW_CRIT_PATH_FLYLINES_DELAYS	draw/draw_types.h	/^    , DRAW_CRIT_PATH_FLYLINES_DELAYS$/;"	e	enum:e_draw_crit_path
DRAW_CRIT_PATH_ROUTING	draw/draw_types.h	/^    , DRAW_CRIT_PATH_ROUTING$/;"	e	enum:e_draw_crit_path
DRAW_CRIT_PATH_ROUTING_DELAYS	draw/draw_types.h	/^    , DRAW_CRIT_PATH_ROUTING_DELAYS$/;"	e	enum:e_draw_crit_path
DRAW_GLOBAL_H	draw/draw_global.h	/^#define DRAW_GLOBAL_H$/;"	d
DRAW_H	draw/draw.h	/^#define DRAW_H$/;"	d
DRAW_LOGICAL_CONNECTIONS	draw/draw_types.h	/^	DRAW_LOGICAL_CONNECTIONS$/;"	e	enum:e_draw_nets
DRAW_LOG_ACC_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_LOG_ACC_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_LOG_PRES_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_LOG_PRES_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_LOG_TOTAL_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_LOG_TOTAL_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_MOUSE_OVER_RR	draw/draw_types.h	/^	DRAW_MOUSE_OVER_RR,$/;"	e	enum:e_draw_rr_toggle
DRAW_NETS	draw/draw_types.h	/^	DRAW_NETS,$/;"	e	enum:e_draw_nets
DRAW_NODES_AND_SBOX_RR	draw/draw_types.h	/^	DRAW_NODES_AND_SBOX_RR,$/;"	e	enum:e_draw_rr_toggle
DRAW_NODES_RR	draw/draw_types.h	/^	DRAW_NODES_RR,$/;"	e	enum:e_draw_rr_toggle
DRAW_NORMAL	../../libs/libeasygl/src/easygl_constants.h	/^    DRAW_NORMAL = 0,$/;"	e	enum:e_draw_mode
DRAW_NO_BLOCK_PIN_UTIL	draw/draw_types.h	/^    DRAW_NO_BLOCK_PIN_UTIL = 0,$/;"	e	enum:e_draw_block_pin_util
DRAW_NO_CONGEST	draw/draw_types.h	/^	DRAW_NO_CONGEST = 0,$/;"	e	enum:e_draw_congestion
DRAW_NO_CRIT_PATH	draw/draw_types.h	/^      DRAW_NO_CRIT_PATH$/;"	e	enum:e_draw_crit_path
DRAW_NO_NETS	draw/draw_types.h	/^	DRAW_NO_NETS = 0,$/;"	e	enum:e_draw_nets
DRAW_NO_ROUTER_RR_COST	draw/draw_types.h	/^    DRAW_NO_ROUTER_RR_COST,$/;"	e	enum:e_draw_router_rr_cost
DRAW_NO_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_NO_ROUTING_COSTS = 0,$/;"	e	enum:e_draw_routing_costs
DRAW_NO_ROUTING_UTIL	draw/draw_types.h	/^    DRAW_NO_ROUTING_UTIL,$/;"	e	enum:e_draw_routing_util
DRAW_NO_RR	draw/draw_types.h	/^	DRAW_NO_RR = 0,$/;"	e	enum:e_draw_rr_toggle
DRAW_PIN_UTIL_MAX	draw/draw_types.h	/^    DRAW_PIN_UTIL_MAX$/;"	e	enum:e_draw_block_pin_util
DRAW_PRES_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_PRES_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_ROUTER_RR_COST_EXPECTED	draw/draw_types.h	/^    DRAW_ROUTER_RR_COST_EXPECTED,$/;"	e	enum:e_draw_router_rr_cost
DRAW_ROUTER_RR_COST_KNOWN	draw/draw_types.h	/^    DRAW_ROUTER_RR_COST_KNOWN,$/;"	e	enum:e_draw_router_rr_cost
DRAW_ROUTER_RR_COST_MAX	draw/draw_types.h	/^    DRAW_ROUTER_RR_COST_MAX, \/\/End of options$/;"	e	enum:e_draw_router_rr_cost
DRAW_ROUTER_RR_COST_TOTAL	draw/draw_types.h	/^    DRAW_ROUTER_RR_COST_TOTAL,$/;"	e	enum:e_draw_router_rr_cost
DRAW_ROUTING_COST_MAX	draw/draw_types.h	/^    DRAW_ROUTING_COST_MAX$/;"	e	enum:e_draw_routing_costs
DRAW_ROUTING_UTIL	draw/draw_types.h	/^    DRAW_ROUTING_UTIL,$/;"	e	enum:e_draw_routing_util
DRAW_ROUTING_UTIL_MAX	draw/draw_types.h	/^    DRAW_ROUTING_UTIL_MAX,$/;"	e	enum:e_draw_routing_util
DRAW_ROUTING_UTIL_OVER_BLOCKS	draw/draw_types.h	/^    DRAW_ROUTING_UTIL_OVER_BLOCKS, \/\/Draw over blocks at full opacity (useful for figure generation)$/;"	e	enum:e_draw_routing_util
DRAW_ROUTING_UTIL_WITH_FORMULA	draw/draw_types.h	/^    DRAW_ROUTING_UTIL_WITH_FORMULA,$/;"	e	enum:e_draw_routing_util
DRAW_ROUTING_UTIL_WITH_VALUE	draw/draw_types.h	/^    DRAW_ROUTING_UTIL_WITH_VALUE,$/;"	e	enum:e_draw_routing_util
DRAW_RR_TOGGLE_MAX	draw/draw_types.h	/^	DRAW_RR_TOGGLE_MAX$/;"	e	enum:e_draw_rr_toggle
DRAW_TOTAL_ROUTING_COSTS	draw/draw_types.h	/^    DRAW_TOTAL_ROUTING_COSTS,$/;"	e	enum:e_draw_routing_costs
DRAW_TYPES_H	draw/draw_types.h	/^#define DRAW_TYPES_H$/;"	d
DRAW_XOR	../../libs/libeasygl/src/easygl_constants.h	/^    DRAW_XOR$/;"	e	enum:e_draw_mode
DRIVEN_BY_IT_COLOR	draw/draw.h	/^const color_types DRIVEN_BY_IT_COLOR = LIGHTMEDIUMBLUE;$/;"	v
DRIVER	../../libs/libarchfpga/src/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
DRIVER	base/netlist_fwd.h	/^	DRIVER,	\/\/The pin drives a net$/;"	m	class:PinType	access:private
DRIVES_IT_COLOR	draw/draw.h	/^const color_types DRIVES_IT_COLOR = RED;$/;"	v
DefaultSentinel	../../libs/libvtrutil/src/vtr_sentinels.h	/^class DefaultSentinel {$/;"	c	namespace:vtr
DefaultSentinel	../../libs/libvtrutil/src/vtr_sentinels.h	/^class DefaultSentinel<T*> {$/;"	c	namespace:vtr
DelayType	timing/DelayType.h	/^enum class DelayType {$/;"	c
DelayType::MAX	timing/DelayType.h	/^    MAX = 0,$/;"	m	class:DelayType	access:private
DelayType::MIN	timing/DelayType.h	/^    MIN,$/;"	m	class:DelayType	access:private
DeltaDelayModel	place/place_delay_model.h	/^        DeltaDelayModel(vtr::Matrix<float> delta_delays, t_router_opts router_opts)$/;"	f	class:DeltaDelayModel	access:public	signature:(vtr::Matrix<float> delta_delays, t_router_opts router_opts)
DeltaDelayModel	place/place_delay_model.h	/^class DeltaDelayModel : public PlaceDelayModel {$/;"	c	inherits:PlaceDelayModel
DeltaDelayModel::DeltaDelayModel	place/place_delay_model.h	/^        DeltaDelayModel(vtr::Matrix<float> delta_delays, t_router_opts router_opts)$/;"	f	class:DeltaDelayModel	access:public	signature:(vtr::Matrix<float> delta_delays, t_router_opts router_opts)
DeltaDelayModel::delay	place/place_delay_model.cpp	/^float DeltaDelayModel::delay(int from_x, int from_y, int \/*from_pin*\/, int to_x, int to_y, int \/*to_pin*\/) const {$/;"	f	class:DeltaDelayModel	signature:(int from_x, int from_y, int , int to_x, int to_y, int ) const
DeltaDelayModel::delays_	place/place_delay_model.h	/^        vtr::Matrix<float> delays_;$/;"	m	class:DeltaDelayModel	access:private
DeltaDelayModel::dump_echo	place/place_delay_model.cpp	/^void DeltaDelayModel::dump_echo(std::string filepath) const {$/;"	f	class:DeltaDelayModel	signature:(std::string filepath) const
DeltaDelayModel::override	place/place_delay_model.h	/^        float delay(int from_x, int from_y, int \/*from_pin*\/, int to_x, int to_y, int \/*to_pin*\/) const override;$/;"	m	class:DeltaDelayModel	access:public
DeltaDelayModel::override	place/place_delay_model.h	/^        void dump_echo(std::string filepath) const override;$/;"	m	class:DeltaDelayModel	access:public
DeltaDelayModel::router_opts_	place/place_delay_model.h	/^        t_router_opts router_opts_;$/;"	m	class:DeltaDelayModel	access:private
DeviceContext	base/vpr_context.h	/^struct DeviceContext : public Context {$/;"	s	inherits:Context
DeviceContext::EMPTY_TYPE	base/vpr_context.h	/^    t_type_ptr EMPTY_TYPE;$/;"	m	struct:DeviceContext	access:public
DeviceContext::arch	base/vpr_context.h	/^    t_arch arch;$/;"	m	struct:DeviceContext	access:public
DeviceContext::arch_switch_inf	base/vpr_context.h	/^    t_arch_switch_inf *arch_switch_inf; \/* [0..(num_arch_switches-1)] *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::block_types	base/vpr_context.h	/^    t_type_descriptor *block_types;$/;"	m	struct:DeviceContext	access:public
DeviceContext::chan_width	base/vpr_context.h	/^    t_chan_width chan_width;$/;"	m	struct:DeviceContext	access:public
DeviceContext::clock_arch	base/vpr_context.h	/^    t_clock_arch * clock_arch;$/;"	m	struct:DeviceContext	access:public
DeviceContext::grid	base/vpr_context.h	/^    DeviceGrid grid; \/* FPGA complex block grid [0 .. grid.width()-1][0 .. grid.height()-1] *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::input_types	base/vpr_context.h	/^    std::set<t_type_ptr> input_types;$/;"	m	struct:DeviceContext	access:public
DeviceContext::num_arch_switches	base/vpr_context.h	/^    int num_arch_switches;$/;"	m	struct:DeviceContext	access:public
DeviceContext::num_block_types	base/vpr_context.h	/^    int num_block_types;$/;"	m	struct:DeviceContext	access:public
DeviceContext::num_rr_indexed_data	base/vpr_context.h	/^    int num_rr_indexed_data;$/;"	m	struct:DeviceContext	access:public
DeviceContext::num_rr_switches	base/vpr_context.h	/^    int num_rr_switches;$/;"	m	struct:DeviceContext	access:public
DeviceContext::output_types	base/vpr_context.h	/^    std::set<t_type_ptr> output_types;$/;"	m	struct:DeviceContext	access:public
DeviceContext::pb_max_internal_delay	base/vpr_context.h	/^    float pb_max_internal_delay = UNDEFINED; \/* biggest internal delay of block *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::pbtype_max_internal_delay	base/vpr_context.h	/^    const t_pb_type *pbtype_max_internal_delay; \/* block type with highest internal delay *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::rr_indexed_data	base/vpr_context.h	/^    t_rr_indexed_data *rr_indexed_data; \/* [0 .. num_rr_indexed_data-1] *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::rr_node_indices	base/vpr_context.h	/^    t_rr_node_indices rr_node_indices; \/\/[0..NUM_RR_TYPES-1][0..grid.width()-1][0..grid.width()-1][0..size-1]$/;"	m	struct:DeviceContext	access:public
DeviceContext::rr_nodes	base/vpr_context.h	/^    std::vector<t_rr_node> rr_nodes; \/* autogenerated in build_rr_graph *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::rr_rc_data	base/vpr_context.h	/^    std::vector<t_rr_rc_data> rr_rc_data;$/;"	m	struct:DeviceContext	access:public
DeviceContext::rr_switch_inf	base/vpr_context.h	/^    t_rr_switch_inf *rr_switch_inf; \/* autogenerated in build_rr_graph based on switch fan-in. [0..(num_rr_switches-1)] *\/$/;"	m	struct:DeviceContext	access:public
DeviceContext::switch_fanin_remap	base/vpr_context.h	/^    std::vector<std::map<int, int>> switch_fanin_remap;$/;"	m	struct:DeviceContext	access:public
DeviceGrid	base/device_grid.cpp	/^DeviceGrid::DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid)$/;"	f	class:DeviceGrid	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid)
DeviceGrid	base/device_grid.cpp	/^DeviceGrid::DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res)$/;"	f	class:DeviceGrid	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res)
DeviceGrid	base/device_grid.h	/^        DeviceGrid() = default;$/;"	p	class:DeviceGrid	access:public	signature:()
DeviceGrid	base/device_grid.h	/^        DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid);$/;"	p	class:DeviceGrid	access:public	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid)
DeviceGrid	base/device_grid.h	/^        DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res);$/;"	p	class:DeviceGrid	access:public	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res)
DeviceGrid	base/device_grid.h	/^class DeviceGrid {$/;"	c
DeviceGrid::DeviceGrid	base/device_grid.cpp	/^DeviceGrid::DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid)$/;"	f	class:DeviceGrid	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid)
DeviceGrid::DeviceGrid	base/device_grid.cpp	/^DeviceGrid::DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res)$/;"	f	class:DeviceGrid	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res)
DeviceGrid::DeviceGrid	base/device_grid.h	/^        DeviceGrid() = default;$/;"	p	class:DeviceGrid	access:public	signature:()
DeviceGrid::DeviceGrid	base/device_grid.h	/^        DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid);$/;"	p	class:DeviceGrid	access:public	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid)
DeviceGrid::DeviceGrid	base/device_grid.h	/^        DeviceGrid(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res);$/;"	p	class:DeviceGrid	access:public	signature:(std::string grid_name, vtr::Matrix<t_grid_tile> grid, std::vector<t_type_ptr> limiting_res)
DeviceGrid::clear	base/device_grid.cpp	/^void DeviceGrid::clear() {$/;"	f	class:DeviceGrid	signature:()
DeviceGrid::clear	base/device_grid.h	/^        void clear();$/;"	p	class:DeviceGrid	access:public	signature:()
DeviceGrid::count_instances	base/device_grid.cpp	/^void DeviceGrid::count_instances() {$/;"	f	class:DeviceGrid	signature:()
DeviceGrid::count_instances	base/device_grid.h	/^        void count_instances();$/;"	p	class:DeviceGrid	access:private	signature:()
DeviceGrid::grid_	base/device_grid.h	/^        vtr::Matrix<t_grid_tile> grid_;$/;"	m	class:DeviceGrid	access:private
DeviceGrid::height	base/device_grid.h	/^        size_t height() const { return grid_.dim_size(1); }$/;"	f	class:DeviceGrid	access:public	signature:() const
DeviceGrid::instance_counts_	base/device_grid.h	/^        std::map<t_type_ptr,size_t> instance_counts_;$/;"	m	class:DeviceGrid	access:private
DeviceGrid::limiting_resources	base/device_grid.h	/^        std::vector<t_type_ptr> limiting_resources() const { return limiting_resources_; }$/;"	f	class:DeviceGrid	access:public	signature:() const
DeviceGrid::limiting_resources_	base/device_grid.h	/^        std::vector<t_type_ptr> limiting_resources_;$/;"	m	class:DeviceGrid	access:private
DeviceGrid::name	base/device_grid.h	/^        const std::string& name() const { return name_; }$/;"	f	class:DeviceGrid	access:public	signature:() const
DeviceGrid::name_	base/device_grid.h	/^        std::string name_;$/;"	m	class:DeviceGrid	access:private
DeviceGrid::num_instances	base/device_grid.cpp	/^size_t DeviceGrid::num_instances(t_type_ptr type) const {$/;"	f	class:DeviceGrid	signature:(t_type_ptr type) const
DeviceGrid::num_instances	base/device_grid.h	/^        size_t num_instances(t_type_ptr type) const;$/;"	p	class:DeviceGrid	access:public	signature:(t_type_ptr type) const
DeviceGrid::operator []	base/device_grid.h	/^        auto operator[](size_t index) const { return grid_[index]; }$/;"	f	class:DeviceGrid	access:public	signature:(size_t index) const
DeviceGrid::operator []	base/device_grid.h	/^        auto operator[](size_t index) { return grid_[index]; }$/;"	f	class:DeviceGrid	access:public	signature:(size_t index)
DeviceGrid::width	base/device_grid.h	/^        size_t width() const { return grid_.dim_size(0); }$/;"	f	class:DeviceGrid	access:public	signature:() const
DimRange	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        DimRange() = default;$/;"	p	class:vtr::DimRange	access:public	signature:()
DimRange	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        DimRange(size_t begin, size_t end)$/;"	f	class:vtr::DimRange	access:public	signature:(size_t begin, size_t end)
DimRange	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class DimRange {$/;"	c	namespace:vtr
Directs	../../libs/libarchfpga/src/physical_types.h	/^	t_direct_inf *Directs;$/;"	m	struct:t_arch	access:public
DomainPair	timing/DomainPair.h	/^    DomainPair(tatum::DomainId l, tatum::DomainId c)$/;"	f	struct:DomainPair	access:public	signature:(tatum::DomainId l, tatum::DomainId c)
DomainPair	timing/DomainPair.h	/^struct DomainPair {$/;"	s
DomainPair::DomainPair	timing/DomainPair.h	/^    DomainPair(tatum::DomainId l, tatum::DomainId c)$/;"	f	struct:DomainPair	access:public	signature:(tatum::DomainId l, tatum::DomainId c)
DomainPair::capture	timing/DomainPair.h	/^    tatum::DomainId capture;$/;"	m	struct:DomainPair	access:public
DomainPair::launch	timing/DomainPair.h	/^    tatum::DomainId launch;$/;"	m	struct:DomainPair	access:public
DomainPair::operator <	timing/DomainPair.h	/^    friend bool operator<(const DomainPair& lhs, const DomainPair& rhs) {$/;"	f	struct:DomainPair	access:friend	signature:(const DomainPair& lhs, const DomainPair& rhs)
EASYGL_CONSTANTS_H	../../libs/libeasygl/src/easygl_constants.h	/^#define EASYGL_CONSTANTS_H$/;"	d
EASYGL_SURFACE_IMPL_H	../../libs/libeasygl/src/SurfaceImpl.h	/^#define EASYGL_SURFACE_IMPL_H$/;"	d
ECHO_ARCH_H	../../libs/libarchfpga/src/echo_arch.h	/^#define ECHO_ARCH_H$/;"	d
ECHO_FILES_H	base/echo_files.h	/^#define ECHO_FILES_H$/;"	d
EMPTY_BLOCK_ID	base/vpr_types.h	/^constexpr auto EMPTY_BLOCK_ID = ClusterBlockId(-1);$/;"	m	class:ScreenUpdatePriority	access:private
EMPTY_BLOCK_LIGHTEN_FACTOR	draw/draw.cpp	/^constexpr float EMPTY_BLOCK_LIGHTEN_FACTOR = 0.10;$/;"	v
EMPTY_BLOCK_NAME	base/vpr_types.h	/^constexpr const char* EMPTY_BLOCK_NAME = "EMPTY";$/;"	m	class:ScreenUpdatePriority	access:private
EMPTY_DELTA	place/timing_place_lookup.cpp	/^constexpr float EMPTY_DELTA = -2; \/\/Indicates delta delay from\/to an EMPTY block$/;"	v
EMPTY_TYPE	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static t_type_ptr EMPTY_TYPE = nullptr;$/;"	v	file:
EMPTY_TYPE	base/vpr_context.h	/^    t_type_ptr EMPTY_TYPE;$/;"	m	struct:DeviceContext	access:public
EMPTY_TYPE_INDEX	../../libs/libarchfpga/src/read_xml_arch_file.h	/^#define EMPTY_TYPE_INDEX /;"	d
END	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
EOL	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
EPSILON	base/vpr_types.h	/^#define EPSILON /;"	d
EQ_EVAL	../../libs/librtlnumber/src/rtl_int.cpp	/^#define EQ_EVAL /;"	d	file:
ERROR_EXIT_CODE	base/vpr_exit_codes.h	/^constexpr int ERROR_EXIT_CODE = 1; \/\/Something went wrong internally$/;"	v
ERROR_THRESHOLD	base/check_netlist.cpp	/^#define ERROR_THRESHOLD /;"	d	file:
ERROR_TOL	place/place.cpp	/^#define ERROR_TOL /;"	d	file:
ERR_MSG	../../libs/librtlnumber/src/include/rtl_utils.hpp	/^#define ERR_MSG(/;"	d
ERR_PORT	../../libs/libarchfpga/src/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
EXACT	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
EXPR_EVAL_H	../../libs/libarchfpga/src/expr_eval.h	/^#define EXPR_EVAL_H$/;"	d
E_ANNOT_PIN_TO_PIN_CAPACITANCE	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_CAPACITANCE,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_CAPACITANCE_C	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_CAPACITANCE_C = 0$/;"	e	enum:e_pin_to_pin_capacitance_annotations
E_ANNOT_PIN_TO_PIN_CONSTANT	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MATRIX = 0, E_ANNOT_PIN_TO_PIN_CONSTANT$/;"	e	enum:e_pin_to_pin_annotation_format
E_ANNOT_PIN_TO_PIN_DELAY	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY = 0,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MAX	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MAX,    \/\/primitive max clock-to-q delay$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MIN	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MIN,    \/\/primitive min clock-to-q delay$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_MAX	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_MAX,               \/\/pb interconnect or primitive combinational max delay$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_MIN	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_MIN = 0,           \/\/pb interconnect or primitive combinational max delay$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_THOLD	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_THOLD,             \/\/primitive hold time$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_TSETUP	../../libs/libarchfpga/src/physical_types.h	/^    E_ANNOT_PIN_TO_PIN_DELAY_TSETUP,            \/\/primitive setup time$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_MATRIX	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MATRIX = 0, E_ANNOT_PIN_TO_PIN_CONSTANT$/;"	e	enum:e_pin_to_pin_annotation_format
E_ANNOT_PIN_TO_PIN_PACK_PATTERN	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_PACK_PATTERN$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_PACK_PATTERN_NAME	../../libs/libarchfpga/src/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_PACK_PATTERN_NAME = 0$/;"	e	enum:e_pin_to_pin_pack_pattern_annotations
E_CORE	../../libs/libarchfpga/src/physical_types.h	/^	E_CORE,$/;"	e	enum:e_sb_location
E_CORNER	../../libs/libarchfpga/src/physical_types.h	/^	E_CORNER,$/;"	e	enum:e_sb_location
E_CRITICALITY_FILE	base/echo_files.h	/^	E_CRITICALITY_FILE,$/;"	e	enum:e_output_files
E_CRIT_PATH_FILE	base/echo_files.h	/^	E_CRIT_PATH_FILE,$/;"	e	enum:e_output_files
E_CUSTOM_PIN_DISTR	../../libs/libarchfpga/src/physical_types.h	/^    E_CUSTOM_PIN_DISTR$/;"	e	enum:e_pin_location_distr
E_DETAILED_ROUTE_AT_END_ONLY	pack/cluster.cpp	/^	E_DETAILED_ROUTE_AT_END_ONLY = 0, E_DETAILED_ROUTE_FOR_EACH_ATOM, E_DETAILED_ROUTE_END$/;"	e	enum:e_detailed_routing_stages	file:
E_DETAILED_ROUTE_END	pack/cluster.cpp	/^	E_DETAILED_ROUTE_AT_END_ONLY = 0, E_DETAILED_ROUTE_FOR_EACH_ATOM, E_DETAILED_ROUTE_END$/;"	e	enum:e_detailed_routing_stages	file:
E_DETAILED_ROUTE_FOR_EACH_ATOM	pack/cluster.cpp	/^	E_DETAILED_ROUTE_AT_END_ONLY = 0, E_DETAILED_ROUTE_FOR_EACH_ATOM, E_DETAILED_ROUTE_END$/;"	e	enum:e_detailed_routing_stages	file:
E_ECHO_ANALYSIS_TIMING_GRAPH	base/echo_files.h	/^	E_ECHO_ANALYSIS_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_ARCH	base/echo_files.h	/^	E_ECHO_ARCH,$/;"	e	enum:e_echo_files
E_ECHO_ATOM_NETLIST_CLEANED	base/echo_files.h	/^	E_ECHO_ATOM_NETLIST_CLEANED,$/;"	e	enum:e_echo_files
E_ECHO_ATOM_NETLIST_ORIG	base/echo_files.h	/^	E_ECHO_ATOM_NETLIST_ORIG,$/;"	e	enum:e_echo_files
E_ECHO_CHAN_DETAILS	base/echo_files.h	/^	E_ECHO_CHAN_DETAILS,$/;"	e	enum:e_echo_files
E_ECHO_CLUSTERING_BLOCK_CRITICALITIES	base/echo_files.h	/^	E_ECHO_CLUSTERING_BLOCK_CRITICALITIES,$/;"	e	enum:e_echo_files
E_ECHO_CLUSTERING_TIMING_INFO	base/echo_files.h	/^	E_ECHO_CLUSTERING_TIMING_INFO,$/;"	e	enum:e_echo_files
E_ECHO_COMPLETE_NET_TRACE	base/echo_files.h	/^	E_ECHO_COMPLETE_NET_TRACE,$/;"	e	enum:e_echo_files
E_ECHO_CRITICAL_PATH	base/echo_files.h	/^	E_ECHO_CRITICAL_PATH,$/;"	e	enum:e_echo_files
E_ECHO_ENDPOINT_TIMING	base/echo_files.h	/^    E_ECHO_ENDPOINT_TIMING,$/;"	e	enum:e_echo_files
E_ECHO_END_CLB_PLACEMENT	base/echo_files.h	/^	E_ECHO_END_CLB_PLACEMENT,$/;"	e	enum:e_echo_files
E_ECHO_END_TOKEN	base/echo_files.h	/^	E_ECHO_END_TOKEN$/;"	e	enum:e_echo_files
E_ECHO_FINAL_PLACEMENT_CRITICALITY	base/echo_files.h	/^	E_ECHO_FINAL_PLACEMENT_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_FINAL_PLACEMENT_SLACK	base/echo_files.h	/^	E_ECHO_FINAL_PLACEMENT_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_FINAL_PLACEMENT_TIMING_GRAPH	base/echo_files.h	/^	E_ECHO_FINAL_PLACEMENT_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_FINAL_ROUTING_TIMING_GRAPH	base/echo_files.h	/^    E_ECHO_FINAL_ROUTING_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_CLB_PLACEMENT	base/echo_files.h	/^	E_ECHO_INITIAL_CLB_PLACEMENT,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_PLACEMENT_CRITICALITY	base/echo_files.h	/^	E_ECHO_INITIAL_PLACEMENT_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_PLACEMENT_SLACK	base/echo_files.h	/^	E_ECHO_INITIAL_PLACEMENT_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_INITIAL_PLACEMENT_TIMING_GRAPH	base/echo_files.h	/^	E_ECHO_INITIAL_PLACEMENT_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_LB_TYPE_RR_GRAPH	base/echo_files.h	/^	E_ECHO_LB_TYPE_RR_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_MEM	base/echo_files.h	/^	E_ECHO_MEM,$/;"	e	enum:e_echo_files
E_ECHO_NET_DELAY	base/echo_files.h	/^	E_ECHO_NET_DELAY,$/;"	e	enum:e_echo_files
E_ECHO_PB_GRAPH	base/echo_files.h	/^	E_ECHO_PB_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_CRITICAL_PATH	base/echo_files.h	/^	E_ECHO_PLACEMENT_CRITICAL_PATH,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_CRIT_PATH	base/echo_files.h	/^    E_ECHO_PLACEMENT_CRIT_PATH,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_DELTA_DELAY_MODEL	base/echo_files.h	/^	E_ECHO_PLACEMENT_DELTA_DELAY_MODEL,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_LOGIC_SINK_DELAYS	base/echo_files.h	/^	E_ECHO_PLACEMENT_LOGIC_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_LOWER_BOUND_SINK_DELAYS	base/echo_files.h	/^	E_ECHO_PLACEMENT_LOWER_BOUND_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_PLACEMENT_SINK_DELAYS	base/echo_files.h	/^	E_ECHO_PLACEMENT_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_PLACE_MACROS	base/echo_files.h	/^    E_ECHO_PLACE_MACROS,$/;"	e	enum:e_echo_files
E_ECHO_POST_PACK_NETLIST	base/echo_files.h	/^	E_ECHO_POST_PACK_NETLIST,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_CRITICALITY	base/echo_files.h	/^	E_ECHO_PRE_PACKING_CRITICALITY,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_MOLECULES_AND_PATTERNS	base/echo_files.h	/^	E_ECHO_PRE_PACKING_MOLECULES_AND_PATTERNS,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_SLACK	base/echo_files.h	/^	E_ECHO_PRE_PACKING_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_PRE_PACKING_TIMING_GRAPH	base/echo_files.h	/^	E_ECHO_PRE_PACKING_TIMING_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_ROUTING_SINK_DELAYS	base/echo_files.h	/^	E_ECHO_ROUTING_SINK_DELAYS,$/;"	e	enum:e_echo_files
E_ECHO_RR_GRAPH	base/echo_files.h	/^	E_ECHO_RR_GRAPH,$/;"	e	enum:e_echo_files
E_ECHO_SBLOCK_PATTERN	base/echo_files.h	/^	E_ECHO_SBLOCK_PATTERN,$/;"	e	enum:e_echo_files
E_ECHO_SEG_DETAILS	base/echo_files.h	/^	E_ECHO_SEG_DETAILS,$/;"	e	enum:e_echo_files
E_ECHO_SLACK	base/echo_files.h	/^	E_ECHO_SLACK,$/;"	e	enum:e_echo_files
E_ECHO_TIMING_CONSTRAINTS	base/echo_files.h	/^	E_ECHO_TIMING_CONSTRAINTS,$/;"	e	enum:e_echo_files
E_EVERYWHERE	../../libs/libarchfpga/src/physical_types.h	/^	E_EVERYWHERE$/;"	e	enum:e_sb_location
E_FILE_END_TOKEN	base/echo_files.h	/^	E_FILE_END_TOKEN$/;"	e	enum:e_output_files
E_FML_BRACKET	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_FML_BRACKET,$/;"	e	enum:e_formula_obj	file:
E_FML_COMMA	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_FML_COMMA,$/;"	e	enum:e_formula_obj	file:
E_FML_NUMBER	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_FML_NUMBER,$/;"	e	enum:e_formula_obj	file:
E_FML_NUM_FORMULA_OBJS	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_FML_NUM_FORMULA_OBJS$/;"	e	enum:e_formula_obj	file:
E_FML_OPERATOR	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_FML_OPERATOR,$/;"	e	enum:e_formula_obj	file:
E_FML_UNDEFINED	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_FML_UNDEFINED = 0,$/;"	e	enum:e_formula_obj	file:
E_FRINGE	../../libs/libarchfpga/src/physical_types.h	/^	E_FRINGE,		\/* perimeter minus corners *\/$/;"	e	enum:e_sb_location
E_OP_ADD	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_ADD,$/;"	e	enum:e_operator	file:
E_OP_DIV	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_DIV,$/;"	e	enum:e_operator	file:
E_OP_GCD	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_GCD,$/;"	e	enum:e_operator	file:
E_OP_LCM	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_LCM,$/;"	e	enum:e_operator	file:
E_OP_MAX	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_MAX,$/;"	e	enum:e_operator	file:
E_OP_MIN	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_MIN,$/;"	e	enum:e_operator	file:
E_OP_MULT	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_MULT,$/;"	e	enum:e_operator	file:
E_OP_NUM_OPS	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_NUM_OPS$/;"	e	enum:e_operator	file:
E_OP_SUB	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_SUB,$/;"	e	enum:e_operator	file:
E_OP_UNDEFINED	../../libs/libarchfpga/src/expr_eval.cpp	/^	E_OP_UNDEFINED = 0,$/;"	e	enum:e_operator	file:
E_PERIMETER	../../libs/libarchfpga/src/physical_types.h	/^	E_PERIMETER = 0,$/;"	e	enum:e_sb_location
E_PERIMETER_PIN_DISTR	../../libs/libarchfpga/src/physical_types.h	/^	E_PERIMETER_PIN_DISTR,$/;"	e	enum:e_pin_location_distr
E_SLACK_FILE	base/echo_files.h	/^	E_SLACK_FILE,$/;"	e	enum:e_output_files
E_SPREAD_INPUTS_PERIMETER_OUTPUTS_PIN_DISTR	../../libs/libarchfpga/src/physical_types.h	/^	E_SPREAD_INPUTS_PERIMETER_OUTPUTS_PIN_DISTR,$/;"	e	enum:e_pin_location_distr
E_SPREAD_PIN_DISTR	../../libs/libarchfpga/src/physical_types.h	/^	E_SPREAD_PIN_DISTR,$/;"	e	enum:e_pin_location_distr
EchoArch	../../libs/libarchfpga/src/echo_arch.cpp	/^void EchoArch(const char *EchoFile, const t_type_descriptor* Types,$/;"	f	signature:(const char *EchoFile, const t_type_descriptor* Types, const int NumTypes, const t_arch *arch)
EchoArch	../../libs/libarchfpga/src/echo_arch.h	/^void EchoArch(const char* EchoFile, const t_type_descriptor* Types,$/;"	p	signature:(const char* EchoFile, const t_type_descriptor* Types, const int NumTypes, const t_arch *arch)
EchoEnabled	base/echo_files.cpp	/^static bool EchoEnabled;$/;"	v	file:
Enum	base/vpr_types.h	/^	int Enum;$/;"	m	struct:ScreenUpdatePriority::t_TokenPair	access:public
Expansion_Cost_Entry	route/router_lookahead_map.cpp	/^class Expansion_Cost_Entry{$/;"	c	file:
Expansion_Cost_Entry::add_cost_entry	route/router_lookahead_map.cpp	/^	void add_cost_entry(float add_delay, float add_congestion){$/;"	f	class:Expansion_Cost_Entry	access:public	signature:(float add_delay, float add_congestion)
Expansion_Cost_Entry::clear_cost_entries	route/router_lookahead_map.cpp	/^	void clear_cost_entries(){$/;"	f	class:Expansion_Cost_Entry	access:public	signature:()
Expansion_Cost_Entry::cost_vector	route/router_lookahead_map.cpp	/^	vector<Cost_Entry> cost_vector;$/;"	m	class:Expansion_Cost_Entry	file:	access:private
Expansion_Cost_Entry::get_average_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_average_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
Expansion_Cost_Entry::get_average_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_average_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
Expansion_Cost_Entry::get_geomean_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_geomean_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
Expansion_Cost_Entry::get_geomean_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_geomean_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
Expansion_Cost_Entry::get_median_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_median_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
Expansion_Cost_Entry::get_median_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_median_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
Expansion_Cost_Entry::get_representative_cost_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_representative_cost_entry(e_representative_entry_method method){$/;"	f	class:Expansion_Cost_Entry	access:public	signature:(e_representative_entry_method method)
Expansion_Cost_Entry::get_smallest_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_smallest_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
Expansion_Cost_Entry::get_smallest_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_smallest_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
FALLING_EDGE	base/netlist_writer.cpp	/^            FALLING_EDGE,$/;"	m	class:LatchInst::Type	file:	access:private
FALSE	../../libs/libvtrutil/src/vtr_logic.h	/^        FALSE = 0,$/;"	m	class:vtr::LogicValue	access:private
FEASIBLE	pack/cluster.cpp	/^	FEASIBLE, INFEASIBLE$/;"	e	enum:e_feasibility	file:
FF_size	../../libs/libarchfpga/src/physical_types.h	/^	float FF_size;$/;"	m	struct:t_power_arch	access:public
FILE_NAME	../../libs/librtlnumber/src/include/rtl_utils.hpp	/^#define FILE_NAME /;"	d
FINAL_DISCOUNT_FUNCTION_BASE	timing/path_delay.h	/^	#define FINAL_DISCOUNT_FUNCTION_BASE /;"	d
FIREBRICK	../../libs/libeasygl/src/easygl_constants.h	/^    FIREBRICK,$/;"	e	enum:color_types
FIRST	route/router_lookahead_map.cpp	/^	FIRST = 0,	\/\/the first cost that was recorded$/;"	e	enum:e_representative_entry_method	file:
FIRST_ITER_WIRELENTH_LIMIT	base/vpr_types.h	/^#define FIRST_ITER_WIRELENTH_LIMIT /;"	d
FIXED	../../libs/libarchfpga/src/physical_types.h	/^    FIXED$/;"	e	enum:GridDefType
FIXED	../../libs/libarchfpga/src/physical_types.h	/^    FIXED,      \/\/Switchpoints are ordered as specified in architecture$/;"	m	class:SwitchPointOrder	access:private
FLOAT_PRECISION	route/rr_graph_writer.cpp	/^constexpr int FLOAT_PRECISION = std::numeric_limits<float>::max_digits10;$/;"	v
FLORALWHITE	../../libs/libeasygl/src/easygl_constants.h	/^    FLORALWHITE,$/;"	e	enum:color_types
FONTCACHE_H	../../libs/libeasygl/src/fontcache.h	/^#define FONTCACHE_H$/;"	d
FONT_CACHE_SIZE_FOR_ROTATED	../../libs/libeasygl/src/fontcache.h	/^#define FONT_CACHE_SIZE_FOR_ROTATED /;"	d
FONT_CACHE_SIZE_FOR_ZEROS	../../libs/libeasygl/src/fontcache.h	/^#define FONT_CACHE_SIZE_FOR_ZEROS /;"	d
FORESTGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    FORESTGREEN,$/;"	e	enum:color_types
FRACTIONAL	../../libs/libarchfpga/src/physical_types.h	/^	ABSOLUTE, FRACTIONAL$/;"	e	enum:e_Fc_type
FRACTIONAL	../../libs/libarchfpga/src/physical_types.h	/^    FRACTIONAL,   \/\/Fractional Fc specification (i.e. fraction of routing channel tracks)$/;"	m	class:e_fc_value_type	access:private
FREE	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:ScreenUpdatePriority::e_pad_loc_type
FROM_X_TO_Y	draw/draw_types.h	/^	FROM_X_TO_Y, FROM_Y_TO_X$/;"	e	enum:e_edge_dir
FROM_Y_TO_X	draw/draw_types.h	/^	FROM_X_TO_Y, FROM_Y_TO_X$/;"	e	enum:e_edge_dir
FUCHSIA	../../libs/libeasygl/src/easygl_constants.h	/^    FUCHSIA,$/;"	e	enum:color_types
FULL	../../libs/libarchfpga/src/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL, CUSTOM$/;"	e	enum:e_switch_block_type
FULL	../../libs/libarchfpga/src/physical_types.h	/^    FULL,    \/\/The pins within the port are fully equivalent and can be freely swapped (e.g. logically equivalent or modelling a full-crossbar)$/;"	m	class:PortEquivalence	access:private
FileNameOpts	base/vpr_types.h	/^	t_file_name_opts FileNameOpts; \/* File names *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
FontCache	../../libs/libeasygl/src/fontcache.h	/^    FontCache()$/;"	f	class:FontCache	access:public	signature:()
FontCache	../../libs/libeasygl/src/fontcache.h	/^    FontCache(const FontCache&) = delete;$/;"	p	class:FontCache	access:private	signature:(const FontCache&)
FontCache	../../libs/libeasygl/src/fontcache.h	/^class FontCache {$/;"	c
FontCache::FontCache	../../libs/libeasygl/src/fontcache.h	/^    FontCache()$/;"	f	class:FontCache	access:public	signature:()
FontCache::FontCache	../../libs/libeasygl/src/fontcache.h	/^    FontCache(const FontCache&) = delete;$/;"	p	class:FontCache	access:private	signature:(const FontCache&)
FontCache::clear	../../libs/libeasygl/src/fontcache.cpp	/^void FontCache::clear() {$/;"	f	class:FontCache	signature:()
FontCache::clear	../../libs/libeasygl/src/fontcache.h	/^    void clear();$/;"	p	class:FontCache	access:public	signature:()
FontCache::close_font	../../libs/libeasygl/src/fontcache.cpp	/^void FontCache::close_font(font_ptr \/*font*\/) {$/;"	f	class:FontCache	signature:(font_ptr )
FontCache::close_font	../../libs/libeasygl/src/fontcache.cpp	/^void FontCache::close_font(font_ptr font) {$/;"	f	class:FontCache	signature:(font_ptr font)
FontCache::close_font	../../libs/libeasygl/src/fontcache.h	/^    static void close_font(font_ptr font);$/;"	p	class:FontCache	access:private	signature:(font_ptr font)
FontCache::descriptor2font_rotated	../../libs/libeasygl/src/fontcache.h	/^    font_lookup descriptor2font_rotated;$/;"	m	class:FontCache	access:private
FontCache::descriptor2font_zeros	../../libs/libeasygl/src/fontcache.h	/^    font_lookup descriptor2font_zeros;$/;"	m	class:FontCache	access:private
FontCache::do_font_loading	../../libs/libeasygl/src/fontcache.cpp	/^font_ptr FontCache::do_font_loading($/;"	f	class:FontCache	signature:( int pointsize, int degrees )
FontCache::do_font_loading	../../libs/libeasygl/src/fontcache.h	/^    static font_ptr do_font_loading(int pointsize, int degrees);$/;"	p	class:FontCache	access:private	signature:(int pointsize, int degrees)
FontCache::font_descriptor	../../libs/libeasygl/src/fontcache.h	/^    typedef std::pair<size_t, int> font_descriptor;$/;"	t	class:FontCache	access:private
FontCache::font_lookup	../../libs/libeasygl/src/fontcache.h	/^    typedef std::unordered_map<font_descriptor, font_ptr, fontdesc_hasher> font_lookup;$/;"	t	class:FontCache	access:private
FontCache::font_queue	../../libs/libeasygl/src/fontcache.h	/^    typedef std::deque<font_descriptor> font_queue;$/;"	t	class:FontCache	access:private
FontCache::fontdesc_hasher	../../libs/libeasygl/src/fontcache.h	/^    struct fontdesc_hasher {$/;"	s	class:FontCache	access:private
FontCache::fontdesc_hasher::operator ()	../../libs/libeasygl/src/fontcache.h	/^        inline std::size_t operator()(const font_descriptor& v) const {$/;"	f	struct:FontCache::fontdesc_hasher	access:public	signature:(const font_descriptor& v) const
FontCache::get_font_info	../../libs/libeasygl/src/fontcache.cpp	/^font_ptr FontCache::get_font_info($/;"	f	class:FontCache	signature:( size_t pointsize, int degrees, queue_type& orderqueue, map_type& descr2font_map, size_t max_size)
FontCache::get_font_info	../../libs/libeasygl/src/fontcache.cpp	/^font_ptr FontCache::get_font_info(size_t pointsize, int degrees) {$/;"	f	class:FontCache	signature:(size_t pointsize, int degrees)
FontCache::get_font_info	../../libs/libeasygl/src/fontcache.h	/^    font_ptr get_font_info(size_t pointsize, int degrees);$/;"	p	class:FontCache	access:public	signature:(size_t pointsize, int degrees)
FontCache::get_font_info	../../libs/libeasygl/src/fontcache.h	/^    static font_ptr get_font_info($/;"	p	class:FontCache	access:private	signature:( size_t pointsize, int degrees, queue_type& orderqueue, map_type& descr2font_map, size_t max_size)
FontCache::operator =	../../libs/libeasygl/src/fontcache.h	/^    FontCache& operator=(const FontCache&) = delete;$/;"	p	class:FontCache	access:private	signature:(const FontCache&)
FontCache::order_rotated	../../libs/libeasygl/src/fontcache.h	/^    font_queue order_rotated;$/;"	m	class:FontCache	access:private
FontCache::order_zeros	../../libs/libeasygl/src/fontcache.h	/^    font_queue order_zeros;$/;"	m	class:FontCache	access:private
Formula_Object	../../libs/libarchfpga/src/expr_eval.cpp	/^	Formula_Object(){$/;"	f	class:Formula_Object	access:public	signature:()
Formula_Object	../../libs/libarchfpga/src/expr_eval.cpp	/^class Formula_Object{$/;"	c	file:
Formula_Object::Formula_Object	../../libs/libarchfpga/src/expr_eval.cpp	/^	Formula_Object(){$/;"	f	class:Formula_Object	access:public	signature:()
Formula_Object::data	../../libs/libarchfpga/src/expr_eval.cpp	/^	} data;$/;"	m	class:Formula_Object	typeref:union:Formula_Object::u_Data	file:	access:public
Formula_Object::to_string	../../libs/libarchfpga/src/expr_eval.cpp	/^    std::string to_string() const {$/;"	f	class:Formula_Object	access:public	signature:() const
Formula_Object::type	../../libs/libarchfpga/src/expr_eval.cpp	/^	t_formula_obj type;$/;"	m	class:Formula_Object	file:	access:public
Formula_Object::u_Data	../../libs/libarchfpga/src/expr_eval.cpp	/^	union u_Data {$/;"	u	class:Formula_Object	file:	access:public
Formula_Object::u_Data::left_bracket	../../libs/libarchfpga/src/expr_eval.cpp	/^		bool left_bracket;	\/*for bracket objects -- specifies if this is a left bracket*\/$/;"	m	union:Formula_Object::u_Data	file:	access:public
Formula_Object::u_Data::num	../../libs/libarchfpga/src/expr_eval.cpp	/^		int num;		\/*for number objects*\/$/;"	m	union:Formula_Object::u_Data	file:	access:public
Formula_Object::u_Data::op	../../libs/libarchfpga/src/expr_eval.cpp	/^		t_operator op;		\/*for operator objects*\/$/;"	m	union:Formula_Object::u_Data	file:	access:public
Formula_Object::u_Data::u_Data	../../libs/libarchfpga/src/expr_eval.cpp	/^		u_Data(){ memset(this, 0, sizeof(u_Data)); }$/;"	f	union:Formula_Object::u_Data	access:public	signature:()
Fs	../../libs/libarchfpga/src/physical_types.h	/^	int Fs;$/;"	m	struct:t_arch	access:public
Fs	base/vpr_types.h	/^	int Fs;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
GAIN	pack/cluster.cpp	/^	GAIN, NO_GAIN$/;"	e	enum:e_gain_update	file:
GAINSBORO	../../libs/libeasygl/src/easygl_constants.h	/^    GAINSBORO,$/;"	e	enum:color_types
GAUSSIAN	../../libs/libarchfpga/src/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
GEOMEAN	route/router_lookahead_map.cpp	/^	GEOMEAN,$/;"	e	enum:e_representative_entry_method	file:
GHOSTWHITE	../../libs/libeasygl/src/easygl_constants.h	/^    GHOSTWHITE,$/;"	e	enum:color_types
GLOBAL	base/vpr_types.h	/^	GLOBAL, DETAILED$/;"	e	enum:ScreenUpdatePriority::e_route_type
GLOBALS_H	base/globals.h	/^#define GLOBALS_H$/;"	d
GL_SCREEN	../../libs/libeasygl/src/easygl_constants.h	/^    GL_SCREEN = 1$/;"	e	enum:__anon14
GL_WORLD	../../libs/libeasygl/src/easygl_constants.h	/^    GL_WORLD = 0,$/;"	e	enum:__anon14
GOLD	../../libs/libeasygl/src/easygl_constants.h	/^    GOLD,$/;"	e	enum:color_types
GOLDENROD	../../libs/libeasygl/src/easygl_constants.h	/^    GOLDENROD,$/;"	e	enum:color_types
GOT_FROM_SCRATCH	place/place.cpp	/^#define GOT_FROM_SCRATCH /;"	d	file:
GRAPHICS_AUTOMARK_H	../../libs/libeasygl/src/graphics_automark.h	/^#define GRAPHICS_AUTOMARK_H$/;"	d
GRAPHICS_H	../../libs/libeasygl/src/graphics.h	/^#define GRAPHICS_H$/;"	d
GRAPHICS_STATE_H	../../libs/libeasygl/src/graphics_state.h	/^#define GRAPHICS_STATE_H$/;"	d
GRAPHICS_TYPES_H	../../libs/libeasygl/src/graphics_types.h	/^#define GRAPHICS_TYPES_H$/;"	d
GRAPH_BIDIR	route/rr_graph.h	/^    GRAPH_BIDIR, \/* Detailed bidirectional graph *\/$/;"	e	enum:e_graph_type
GRAPH_GLOBAL	route/rr_graph.h	/^    GRAPH_GLOBAL, \/* One node per channel with wire capacity > 1 and full connectivity *\/$/;"	e	enum:e_graph_type
GRAPH_UNIDIR	route/rr_graph.h	/^    GRAPH_UNIDIR, \/* Detailed unidir graph, untilable *\/$/;"	e	enum:e_graph_type
GRAPH_UNIDIR_TILEABLE	route/rr_graph.h	/^    GRAPH_UNIDIR_TILEABLE \/* Detail unidir graph with wire groups multiples of 2*L *\/$/;"	e	enum:e_graph_type
GRAY	../../libs/libeasygl/src/easygl_constants.h	/^    GRAY,$/;"	e	enum:color_types
GREEN	../../libs/libeasygl/src/easygl_constants.h	/^    GREEN,$/;"	e	enum:color_types
GREENYELLOW	../../libs/libeasygl/src/easygl_constants.h	/^    GREENYELLOW,$/;"	e	enum:color_types
GREY	../../libs/libeasygl/src/easygl_constants.h	/^    GREY,$/;"	e	enum:color_types
GREY55	../../libs/libeasygl/src/easygl_constants.h	/^    GREY55,$/;"	e	enum:color_types
GREY75	../../libs/libeasygl/src/easygl_constants.h	/^    GREY75,$/;"	e	enum:color_types
GT_EVAL	../../libs/librtlnumber/src/rtl_int.cpp	/^#define GT_EVAL /;"	d	file:
Generate_Post_Synthesis_Netlist	base/read_options.h	/^    argparse::ArgValue<bool> Generate_Post_Synthesis_Netlist;$/;"	m	struct:t_options	access:public
GetTokenTypeFromChar	util/token.cpp	/^enum e_token_type GetTokenTypeFromChar(const enum e_token_type cur_token_type,$/;"	f	signature:(const enum e_token_type cur_token_type, const char cur)
GetTokenTypeFromChar	util/token.cpp	/^enum e_token_type GetTokenTypeFromChar(const enum e_token_type cur_token_type,$/;"	p	file:	signature:(const enum e_token_type cur_token_type, const char cur)
GetTokensFromString	util/token.cpp	/^t_token *GetTokensFromString(const char* inString, int * num_tokens) {$/;"	f	signature:(const char* inString, int * num_tokens)
GetTokensFromString	util/token.h	/^t_token *GetTokensFromString(const char* inString, int * num_tokens);$/;"	p	signature:(const char* inString, int * num_tokens)
GraphPause	base/read_options.h	/^    argparse::ArgValue<int> GraphPause;$/;"	m	struct:t_options	access:public
GraphPause	base/vpr_types.h	/^	int GraphPause; \/* user interactiveness graphics option *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
GridDefType	../../libs/libarchfpga/src/physical_types.h	/^enum GridDefType {$/;"	g
HAMMING_PROXIMITY	route/cb_metrics.h	/^	HAMMING_PROXIMITY,$/;"	e	enum:e_metric
HASHSIZE	util/hash.h	/^#define HASHSIZE /;"	d
HEADER_PUGICONFIG_HPP	../../libs/EXTERNAL/libpugixml/src/pugiconfig.hpp	/^#define HEADER_PUGICONFIG_HPP$/;"	d
HEADER_PUGIXML_HPP	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#define HEADER_PUGIXML_HPP$/;"	d
HIGHLIGHTED	draw/draw_types.h	/^	ALL_NETS, HIGHLIGHTED$/;"	e	enum:e_draw_net_type
HILL_CLIMBING	pack/cluster.cpp	/^	HILL_CLIMBING, NOT_HILL_CLIMBING$/;"	e	enum:e_gain_type	file:
HMETIS_GRAPH_WRITER	pack/hmetis_graph_writer.h	/^#define HMETIS_GRAPH_WRITER$/;"	d
HOLD	route/route_budgets.h	/^    SETUP, HOLD$/;"	e	enum:analysis_type
HONEYDEW	../../libs/libeasygl/src/easygl_constants.h	/^    HONEYDEW,$/;"	e	enum:color_types
HORIZONTAL	../../libs/libarchfpga/src/physical_types.h	/^    HORIZONTAL,    \/\/Horizontal straight-through connections$/;"	m	class:e_sb_type	access:private
HOTPINK	../../libs/libeasygl/src/easygl_constants.h	/^    HOTPINK,$/;"	e	enum:color_types
HSL_H	draw/hsl.h	/^#define HSL_H$/;"	d
HUGE_NEGATIVE_FLOAT	base/vpr_types.h	/^#define HUGE_NEGATIVE_FLOAT /;"	d
HUGE_POSITIVE_FLOAT	base/vpr_types.h	/^#define HUGE_POSITIVE_FLOAT /;"	d
HistogramBucket	util/histogram.h	/^    HistogramBucket(float min_val, float max_val, float init_count = 0)$/;"	f	struct:HistogramBucket	access:public	signature:(float min_val, float max_val, float init_count = 0)
HistogramBucket	util/histogram.h	/^struct HistogramBucket {$/;"	s
HistogramBucket::HistogramBucket	util/histogram.h	/^    HistogramBucket(float min_val, float max_val, float init_count = 0)$/;"	f	struct:HistogramBucket	access:public	signature:(float min_val, float max_val, float init_count = 0)
HistogramBucket::count	util/histogram.h	/^    size_t count = 0;$/;"	m	struct:HistogramBucket	access:public
HistogramBucket::max_value	util/histogram.h	/^    float max_value = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:HistogramBucket	access:public
HistogramBucket::min_value	util/histogram.h	/^    float min_value = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:HistogramBucket	access:public
HoldSlackCrit	timing/slack_evaluation.cpp	/^HoldSlackCrit::HoldSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)$/;"	f	class:HoldSlackCrit	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
HoldSlackCrit	timing/slack_evaluation.h	/^        HoldSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup);$/;"	p	class:HoldSlackCrit	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
HoldSlackCrit	timing/slack_evaluation.h	/^class HoldSlackCrit {$/;"	c
HoldSlackCrit::HoldSlackCrit	timing/slack_evaluation.cpp	/^HoldSlackCrit::HoldSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)$/;"	f	class:HoldSlackCrit	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
HoldSlackCrit::HoldSlackCrit	timing/slack_evaluation.h	/^        HoldSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup);$/;"	p	class:HoldSlackCrit	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
HoldSlackCrit::calc_pin_criticality	timing/slack_evaluation.cpp	/^float HoldSlackCrit::calc_pin_criticality(AtomPinId pin,$/;"	f	class:HoldSlackCrit	signature:(AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer, const float scale, const float shift)
HoldSlackCrit::calc_pin_criticality	timing/slack_evaluation.h	/^        float calc_pin_criticality(AtomPinId pin,$/;"	p	class:HoldSlackCrit	access:private	signature:(AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer, const float scale, const float shift)
HoldSlackCrit::hold_pin_criticality	timing/slack_evaluation.cpp	/^float HoldSlackCrit::hold_pin_criticality(AtomPinId pin) const { return pin_criticalities_[pin]; }$/;"	f	class:HoldSlackCrit	signature:(AtomPinId pin) const
HoldSlackCrit::hold_pin_criticality	timing/slack_evaluation.h	/^        float hold_pin_criticality(AtomPinId pin) const;$/;"	p	class:HoldSlackCrit	access:public	signature:(AtomPinId pin) const
HoldSlackCrit::hold_pin_slack	timing/slack_evaluation.cpp	/^float HoldSlackCrit::hold_pin_slack(AtomPinId pin) const { return pin_slacks_[pin]; }$/;"	f	class:HoldSlackCrit	signature:(AtomPinId pin) const
HoldSlackCrit::hold_pin_slack	timing/slack_evaluation.h	/^        float hold_pin_slack(AtomPinId pin) const;$/;"	p	class:HoldSlackCrit	access:public	signature:(AtomPinId pin) const
HoldSlackCrit::netlist_	timing/slack_evaluation.h	/^        const AtomNetlist& netlist_;$/;"	m	class:HoldSlackCrit	access:private
HoldSlackCrit::netlist_lookup_	timing/slack_evaluation.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:HoldSlackCrit	access:private
HoldSlackCrit::pin_criticalities_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_criticalities_;$/;"	m	class:HoldSlackCrit	access:private
HoldSlackCrit::pin_slacks_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_slacks_;$/;"	m	class:HoldSlackCrit	access:private
HoldSlackCrit::update_criticalities	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_criticalities	timing/slack_evaluation.h	/^        void update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:private	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_pin_slack	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_pin_slack(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_pin_slack	timing/slack_evaluation.h	/^        void update_pin_slack(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:private	signature:(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_slacks	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_slacks(const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_slacks	timing/slack_evaluation.h	/^        void update_slacks(const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:private	signature:(const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_slacks_and_criticalities	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
HoldSlackCrit::update_slacks_and_criticalities	timing/slack_evaluation.h	/^        void update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:public	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
HoldTimingInfo	timing/timing_info.h	/^class HoldTimingInfo : public virtual TimingInfo {$/;"	c	inherits:TimingInfo
HoldTimingInfo::hold_analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::HoldTimingAnalyzer> hold_analyzer() const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:() const
HoldTimingInfo::hold_pin_criticality	timing/timing_info.h	/^        virtual float hold_pin_criticality(AtomPinId pin) const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:(AtomPinId pin) const
HoldTimingInfo::hold_pin_slack	timing/timing_info.h	/^        virtual float hold_pin_slack(AtomPinId pin) const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:(AtomPinId pin) const
HoldTimingInfo::hold_total_negative_slack	timing/timing_info.h	/^        virtual float hold_total_negative_slack() const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:() const
HoldTimingInfo::hold_worst_negative_slack	timing/timing_info.h	/^        virtual float hold_worst_negative_slack() const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:() const
HoldTimingInfo::update_hold	timing/timing_info.h	/^        virtual void update_hold() = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:()
IA	../../libs/libvtrutil/src/vtr_random.cpp	/^constexpr size_t IA = 1103515245u;$/;"	m	namespace:vtr	file:
IC	../../libs/libvtrutil/src/vtr_random.cpp	/^constexpr size_t IC = 12345u;$/;"	m	namespace:vtr	file:
IDEAL_CLOCK	base/clock_modeling.h	/^    IDEAL_CLOCK, \/\/Treat the clock pins as ideal (i.e. not routed)$/;"	e	enum:e_clock_modeling
IM	../../libs/libvtrutil/src/vtr_random.cpp	/^constexpr size_t IM = 2147483648u;$/;"	m	namespace:vtr	file:
IMPOSSIBLE_DELTA	place/timing_place_lookup.cpp	/^constexpr float IMPOSSIBLE_DELTA = std::numeric_limits<float>::infinity(); \/\/Indicates there is no valid delta delay$/;"	v
IN	../../libs/libarchfpga/src/physical_types.h	/^    IN, \/\/The fc specification for an input pin$/;"	m	class:e_fc_type	access:private
INCLUDE_TRACK_BUFFERS	route/rr_graph.h	/^#define INCLUDE_TRACK_BUFFERS /;"	d
INDIANRED	../../libs/libeasygl/src/easygl_constants.h	/^    INDIANRED,$/;"	e	enum:color_types
INDIGO	../../libs/libeasygl/src/easygl_constants.h	/^    INDIGO,$/;"	e	enum:color_types
INFEASIBLE	pack/cluster.cpp	/^	FEASIBLE, INFEASIBLE$/;"	e	enum:e_feasibility	file:
INFINITE	base/place_and_route.h	/^#define INFINITE /;"	d
INITIAL_TEMP	route/cb_metrics.h	/^#define INITIAL_TEMP /;"	d
INOUT_PORT	../../libs/libarchfpga/src/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
INPAD	base/atom_netlist_fwd.h	/^    INPAD,          \/\/A primary input$/;"	m	class:AtomBlockType	access:private
INPUT	base/netlist_fwd.h	/^	INPUT,  \/\/The port is a data-input$/;"	m	class:PortType	access:private
INPUT	pack/cluster.cpp	/^	INPUT, OUTPUT$/;"	e	enum:e_net_relation_to_clustered_block	file:
INTERNAL	base/atom_lookup_fwd.h	/^    INTERNAL, \/\/tnodes corresponding to internal paths withing atom blocks$/;"	m	class:BlockTnode	access:private
INTERNAL_BITS_HPP	../../libs/librtlnumber/src/include/internal_bits.hpp	/^#define INTERNAL_BITS_HPP$/;"	d
INTERRUPTED_EXIT_CODE	base/vpr_exit_codes.h	/^constexpr int INTERRUPTED_EXIT_CODE = 3; \/\/VPR was interrupted by the user (e.g. SIGINT\/ctr-C)$/;"	v
INTRA_LOGIC_BLOCK_H	draw/intra_logic_block.h	/^#define INTRA_LOGIC_BLOCK_H$/;"	d
INVALID	../../libs/libarchfpga/src/physical_types.h	/^    INVALID,        \/\/Unspecified, usually an error$/;"	m	class:SwitchType	access:private
INVALID	../../libs/libvtrutil/src/vtr_sentinels.h	/^        constexpr static T INVALID() { return T(); }$/;"	f	class:vtr::DefaultSentinel	access:public	signature:()
INVALID	../../libs/libvtrutil/src/vtr_sentinels.h	/^        constexpr static T INVALID() { return T(val); }$/;"	f	class:vtr::CustomSentinel	access:public	signature:()
INVALID	../../libs/libvtrutil/src/vtr_sentinels.h	/^        constexpr static T* INVALID() { return nullptr; }$/;"	f	class:vtr::DefaultSentinel	access:public	signature:()
INVALID	../../libs/libvtrutil/src/vtr_strong_id.h	/^        static constexpr StrongId INVALID() { return StrongId(); }$/;"	f	class:vtr::StrongId	access:public	signature:()
INVALID_BLOCK_ID	base/vpr_types.h	/^constexpr auto INVALID_BLOCK_ID = ClusterBlockId(-2);$/;"	m	class:ScreenUpdatePriority	access:private
INVALID_DELTA	place/timing_place_lookup.cpp	/^constexpr float INVALID_DELTA = std::numeric_limits<float>::quiet_NaN(); \/\/Indicates there is no valid delta delay$/;"	v
INVALID_INDEX	base/netlist.h	/^        constexpr static int INVALID_INDEX = -1;$/;"	m	class:Netlist	access:protected
INV_1X_C	power/power.h	/^	float INV_1X_C;$/;"	m	struct:t_power_commonly_used	access:public
INV_1X_C_in	power/power.h	/^	float INV_1X_C_in;$/;"	m	struct:t_power_commonly_used	access:public
INV_2X_C	power/power.h	/^	float INV_2X_C;$/;"	m	struct:t_power_commonly_used	access:public
IN_PORT	../../libs/libarchfpga/src/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
IPIN_COST_INDEX	base/vpr_types.h	/^	IPIN_COST_INDEX,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
IVORY	../../libs/libeasygl/src/easygl_constants.h	/^    IVORY,$/;"	e	enum:color_types
IdRemapper	base/netlist.h	/^        typedef NetlistIdRemapper<BlockId,PortId,PinId,NetId> IdRemapper;$/;"	t	class:Netlist	access:public
InEventLoop	../../libs/libeasygl/src/graphics_state.h	/^    bool InEventLoop;$/;"	m	class:t_win32_state	access:public
InfernoColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^InfernoColorMap::InfernoColorMap(float min_val, float max_val)$/;"	f	class:vtr::InfernoColorMap	signature:(float min_val, float max_val)
InfernoColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        InfernoColorMap(float min, float max);$/;"	p	class:vtr::InfernoColorMap	access:public	signature:(float min, float max)
InfernoColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class InfernoColorMap : public ColorMap {$/;"	c	namespace:vtr	inherits:ColorMap
InstPort	../../libs/libarchfpga/src/arch_util.cpp	/^InstPort::InstPort(std::string str) {$/;"	f	class:InstPort	signature:(std::string str)
InstPort	../../libs/libarchfpga/src/arch_util.h	/^        InstPort() = default;$/;"	p	class:InstPort	access:public	signature:()
InstPort	../../libs/libarchfpga/src/arch_util.h	/^        InstPort(std::string str);$/;"	p	class:InstPort	access:public	signature:(std::string str)
InstPort	../../libs/libarchfpga/src/arch_util.h	/^class InstPort {$/;"	c
InstPort::InstPort	../../libs/libarchfpga/src/arch_util.cpp	/^InstPort::InstPort(std::string str) {$/;"	f	class:InstPort	signature:(std::string str)
InstPort::InstPort	../../libs/libarchfpga/src/arch_util.h	/^        InstPort() = default;$/;"	p	class:InstPort	access:public	signature:()
InstPort::InstPort	../../libs/libarchfpga/src/arch_util.h	/^        InstPort(std::string str);$/;"	p	class:InstPort	access:public	signature:(std::string str)
InstPort::UNSPECIFIED	../../libs/libarchfpga/src/arch_util.h	/^        static constexpr int UNSPECIFIED = -1;$/;"	m	class:InstPort	access:public
InstPort::instance_	../../libs/libarchfpga/src/arch_util.h	/^        name_index instance_;$/;"	m	class:InstPort	access:private
InstPort::instance_high_index	../../libs/libarchfpga/src/arch_util.h	/^        int instance_high_index() const { return instance_.high_idx; }$/;"	f	class:InstPort	access:public	signature:() const
InstPort::instance_low_index	../../libs/libarchfpga/src/arch_util.h	/^        int instance_low_index() const { return instance_.low_idx; }$/;"	f	class:InstPort	access:public	signature:() const
InstPort::instance_name	../../libs/libarchfpga/src/arch_util.h	/^        std::string instance_name() const { return instance_.name; }$/;"	f	class:InstPort	access:public	signature:() const
InstPort::name_index	../../libs/libarchfpga/src/arch_util.h	/^        struct name_index {$/;"	s	class:InstPort	access:private
InstPort::name_index::high_idx	../../libs/libarchfpga/src/arch_util.h	/^            int high_idx = UNSPECIFIED;$/;"	m	struct:InstPort::name_index	access:public
InstPort::name_index::low_idx	../../libs/libarchfpga/src/arch_util.h	/^            int low_idx = UNSPECIFIED;$/;"	m	struct:InstPort::name_index	access:public
InstPort::name_index::name	../../libs/libarchfpga/src/arch_util.h	/^            std::string name = "";$/;"	m	struct:InstPort::name_index	access:public
InstPort::num_instances	../../libs/libarchfpga/src/arch_util.cpp	/^int InstPort::num_instances() const {$/;"	f	class:InstPort	signature:() const
InstPort::num_instances	../../libs/libarchfpga/src/arch_util.h	/^        int num_instances() const;$/;"	p	class:InstPort	access:public	signature:() const
InstPort::num_pins	../../libs/libarchfpga/src/arch_util.cpp	/^int InstPort::num_pins() const {$/;"	f	class:InstPort	signature:() const
InstPort::num_pins	../../libs/libarchfpga/src/arch_util.h	/^        int num_pins() const;$/;"	p	class:InstPort	access:public	signature:() const
InstPort::parse_name_index	../../libs/libarchfpga/src/arch_util.cpp	/^InstPort::name_index InstPort::parse_name_index(std::string str) {$/;"	f	class:InstPort	signature:(std::string str)
InstPort::parse_name_index	../../libs/libarchfpga/src/arch_util.h	/^        name_index parse_name_index(std::string str);$/;"	p	class:InstPort	access:private	signature:(std::string str)
InstPort::port_	../../libs/libarchfpga/src/arch_util.h	/^        name_index port_;$/;"	m	class:InstPort	access:private
InstPort::port_high_index	../../libs/libarchfpga/src/arch_util.h	/^        int port_high_index() const { return port_.high_idx; }$/;"	f	class:InstPort	access:public	signature:() const
InstPort::port_low_index	../../libs/libarchfpga/src/arch_util.h	/^        int port_low_index() const { return port_.low_idx; }$/;"	f	class:InstPort	access:public	signature:() const
InstPort::port_name	../../libs/libarchfpga/src/arch_util.h	/^        std::string port_name() const { return port_.name; }$/;"	f	class:InstPort	access:public	signature:() const
Instance	base/netlist_writer.cpp	/^class Instance {$/;"	c	file:
Instance::print_blif	base/netlist_writer.cpp	/^        virtual void print_blif(std::ostream& os, size_t& unconn_count, int depth=0) = 0;$/;"	p	class:Instance	file:	access:public	signature:(std::ostream& os, size_t& unconn_count, int depth=0)
Instance::print_sdf	base/netlist_writer.cpp	/^        virtual void print_sdf(std::ostream& os, int depth=0) = 0;$/;"	p	class:Instance	file:	access:public	signature:(std::ostream& os, int depth=0)
Instance::print_verilog	base/netlist_writer.cpp	/^        virtual void print_verilog(std::ostream& os, int depth=0) = 0;$/;"	p	class:Instance	file:	access:public	signature:(std::ostream& os, int depth=0)
Instance::~Instance	base/netlist_writer.cpp	/^        virtual ~Instance() = default;$/;"	p	class:Instance	file:	access:public	signature:()
IntraLbPbPinLookup	util/vpr_utils.cpp	/^IntraLbPbPinLookup::IntraLbPbPinLookup(const IntraLbPbPinLookup& rhs)$/;"	f	class:IntraLbPbPinLookup	signature:(const IntraLbPbPinLookup& rhs)
IntraLbPbPinLookup	util/vpr_utils.cpp	/^IntraLbPbPinLookup::IntraLbPbPinLookup(t_type_descriptor* block_types, int ntypes)$/;"	f	class:IntraLbPbPinLookup	signature:(t_type_descriptor* block_types, int ntypes)
IntraLbPbPinLookup	util/vpr_utils.h	/^        IntraLbPbPinLookup(const IntraLbPbPinLookup& rhs);$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(const IntraLbPbPinLookup& rhs)
IntraLbPbPinLookup	util/vpr_utils.h	/^        IntraLbPbPinLookup(t_type_descriptor* block_types, int num_block_types);$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(t_type_descriptor* block_types, int num_block_types)
IntraLbPbPinLookup	util/vpr_utils.h	/^class IntraLbPbPinLookup {$/;"	c
IntraLbPbPinLookup::IntraLbPbPinLookup	util/vpr_utils.cpp	/^IntraLbPbPinLookup::IntraLbPbPinLookup(const IntraLbPbPinLookup& rhs)$/;"	f	class:IntraLbPbPinLookup	signature:(const IntraLbPbPinLookup& rhs)
IntraLbPbPinLookup::IntraLbPbPinLookup	util/vpr_utils.cpp	/^IntraLbPbPinLookup::IntraLbPbPinLookup(t_type_descriptor* block_types, int ntypes)$/;"	f	class:IntraLbPbPinLookup	signature:(t_type_descriptor* block_types, int ntypes)
IntraLbPbPinLookup::IntraLbPbPinLookup	util/vpr_utils.h	/^        IntraLbPbPinLookup(const IntraLbPbPinLookup& rhs);$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(const IntraLbPbPinLookup& rhs)
IntraLbPbPinLookup::IntraLbPbPinLookup	util/vpr_utils.h	/^        IntraLbPbPinLookup(t_type_descriptor* block_types, int num_block_types);$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(t_type_descriptor* block_types, int num_block_types)
IntraLbPbPinLookup::block_types_	util/vpr_utils.h	/^        t_type_descriptor* block_types_;$/;"	m	class:IntraLbPbPinLookup	access:private
IntraLbPbPinLookup::intra_lb_pb_pin_lookup_	util/vpr_utils.h	/^        t_pb_graph_pin*** intra_lb_pb_pin_lookup_;$/;"	m	class:IntraLbPbPinLookup	access:private
IntraLbPbPinLookup::num_types_	util/vpr_utils.h	/^        int num_types_;$/;"	m	class:IntraLbPbPinLookup	access:private
IntraLbPbPinLookup::operator =	util/vpr_utils.cpp	/^IntraLbPbPinLookup& IntraLbPbPinLookup::operator=(IntraLbPbPinLookup rhs) {$/;"	f	class:IntraLbPbPinLookup	signature:(IntraLbPbPinLookup rhs)
IntraLbPbPinLookup::operator =	util/vpr_utils.h	/^        IntraLbPbPinLookup& operator=(IntraLbPbPinLookup rhs);$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(IntraLbPbPinLookup rhs)
IntraLbPbPinLookup::pb_gpin	util/vpr_utils.cpp	/^const t_pb_graph_pin* IntraLbPbPinLookup::pb_gpin(int itype, int ipin) const {$/;"	f	class:IntraLbPbPinLookup	signature:(int itype, int ipin) const
IntraLbPbPinLookup::pb_gpin	util/vpr_utils.h	/^        const t_pb_graph_pin* pb_gpin(int itype, int ipin) const;$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(int itype, int ipin) const
IntraLbPbPinLookup::swap	util/vpr_utils.h	/^        friend void swap(IntraLbPbPinLookup& lhs, IntraLbPbPinLookup& rhs);$/;"	p	class:IntraLbPbPinLookup	access:friend	signature:(IntraLbPbPinLookup& lhs, IntraLbPbPinLookup& rhs)
IntraLbPbPinLookup::~IntraLbPbPinLookup	util/vpr_utils.cpp	/^IntraLbPbPinLookup::~IntraLbPbPinLookup() {$/;"	f	class:IntraLbPbPinLookup	signature:()
IntraLbPbPinLookup::~IntraLbPbPinLookup	util/vpr_utils.h	/^        ~IntraLbPbPinLookup();$/;"	p	class:IntraLbPbPinLookup	access:public	signature:()
IsWhitespace	util/token.cpp	/^bool IsWhitespace(char c) {$/;"	f	signature:(char c)
IsWhitespace	util/token.cpp	/^bool IsWhitespace(char c);$/;"	p	file:	signature:(char c)
KHAKI	../../libs/libeasygl/src/easygl_constants.h	/^    KHAKI, \/\/ Wikipedia says "a light shade of yellow-green" , but this one is more yellow, and very light$/;"	e	enum:color_types
LATCH_CLASS	../../libs/libarchfpga/src/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
LAVENDER	../../libs/libeasygl/src/easygl_constants.h	/^    LAVENDER,$/;"	e	enum:color_types
LAVENDERBLUSH	../../libs/libeasygl/src/easygl_constants.h	/^    LAVENDERBLUSH,$/;"	e	enum:color_types
LAWNGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    LAWNGREEN,$/;"	e	enum:color_types
LB_INTERMEDIATE	pack/pack_types.h	/^	LB_SOURCE = 0, LB_SINK, LB_INTERMEDIATE, NUM_LB_RR_TYPES$/;"	e	enum:e_lb_rr_type
LB_SINK	pack/pack_types.h	/^	LB_SOURCE = 0, LB_SINK, LB_INTERMEDIATE, NUM_LB_RR_TYPES$/;"	e	enum:e_lb_rr_type
LB_SOURCE	pack/pack_types.h	/^	LB_SOURCE = 0, LB_SINK, LB_INTERMEDIATE, NUM_LB_RR_TYPES$/;"	e	enum:e_lb_rr_type
LB_TYPE_RR_GRAPH_H	pack/lb_type_rr_graph.h	/^#define LB_TYPE_RR_GRAPH_H$/;"	d
LEAVE_CLUSTERED	pack/cluster.cpp	/^	REMOVE_CLUSTERED, LEAVE_CLUSTERED$/;"	e	enum:e_removal_policy	file:
LEMIEUX_COST_FUNC	route/cb_metrics.h	/^	LEMIEUX_COST_FUNC,	\/* described by lemieux in his 2001 book; used there for creating routable sparse crossbars *\/$/;"	e	enum:e_metric
LEMONCHIFFON	../../libs/libeasygl/src/easygl_constants.h	/^    LEMONCHIFFON,$/;"	e	enum:color_types
LIGHTBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTBLUE,$/;"	e	enum:color_types
LIGHTCORAL	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTCORAL,$/;"	e	enum:color_types
LIGHTCYAN	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTCYAN,$/;"	e	enum:color_types
LIGHTGOLDENRODYELLOW	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTGOLDENRODYELLOW,$/;"	e	enum:color_types
LIGHTGRAY	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTGRAY,$/;"	e	enum:color_types
LIGHTGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTGREEN,$/;"	e	enum:color_types
LIGHTGREY	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTGREY,$/;"	e	enum:color_types
LIGHTMEDIUMBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTMEDIUMBLUE,$/;"	e	enum:color_types
LIGHTPINK	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTPINK,$/;"	e	enum:color_types
LIGHTSALMON	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTSALMON,$/;"	e	enum:color_types
LIGHTSEAGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTSEAGREEN,$/;"	e	enum:color_types
LIGHTSKYBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTSKYBLUE, \/\/ A nice light blue$/;"	e	enum:color_types
LIGHTSLATEGRAY	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTSLATEGRAY,$/;"	e	enum:color_types
LIGHTSLATEGREY	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTSLATEGREY,$/;"	e	enum:color_types
LIGHTSTEELBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTSTEELBLUE,$/;"	e	enum:color_types
LIGHTYELLOW	../../libs/libeasygl/src/easygl_constants.h	/^    LIGHTYELLOW,$/;"	e	enum:color_types
LIME	../../libs/libeasygl/src/easygl_constants.h	/^    LIME,$/;"	e	enum:color_types
LIMEGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    LIMEGREEN,$/;"	e	enum:color_types
LINELENGTH	pack/output_blif.cpp	/^#define LINELENGTH /;"	d	file:
LINELENGTH	pack/output_clustering.cpp	/^#define LINELENGTH /;"	d	file:
LINEN	../../libs/libeasygl/src/easygl_constants.h	/^    LINEN,$/;"	e	enum:color_types
LOD_area_test	../../libs/libeasygl/src/graphics.h	/^inline bool LOD_area_test(float area_threshold) {$/;"	f	signature:(float area_threshold)
LOD_min_dim_test	../../libs/libeasygl/src/graphics.cpp	/^bool LOD_min_dim_test(float dim_threshold) {$/;"	f	signature:(float dim_threshold)
LOD_min_dim_test	../../libs/libeasygl/src/graphics.h	/^bool LOD_min_dim_test(float dim_threshold);$/;"	p	signature:(float dim_threshold)
LOD_screen_area_test	../../libs/libeasygl/src/graphics.cpp	/^bool LOD_screen_area_test(t_bound_box \/*test*\/, float \/*screen_area_threshold*\/) {$/;"	f	signature:(t_bound_box , float )
LOD_screen_area_test	../../libs/libeasygl/src/graphics.cpp	/^bool LOD_screen_area_test(t_bound_box test, float screen_area_threshold) {$/;"	f	signature:(t_bound_box test, float screen_area_threshold)
LOD_screen_area_test	../../libs/libeasygl/src/graphics.h	/^bool LOD_screen_area_test(t_bound_box test, float screen_area_threshold);$/;"	p	signature:(t_bound_box test, float screen_area_threshold)
LOD_screen_area_test_square	draw/draw.cpp	/^static inline bool LOD_screen_area_test_square(float width, float screen_area_threshold) {$/;"	f	file:	signature:(float width, float screen_area_threshold)
LOD_screen_area_test_square	draw/draw.cpp	/^static inline bool LOD_screen_area_test_square(float width, float screen_area_threshold);$/;"	p	file:	signature:(float width, float screen_area_threshold)
LOGIC_TYPES_H	../../libs/libarchfpga/src/logic_types.h	/^#define LOGIC_TYPES_H$/;"	d
LOG_DEFAULT_FILE_NAME	../../libs/liblog/src/log.cpp	/^#define LOG_DEFAULT_FILE_NAME /;"	d	file:
LOG_H	../../libs/liblog/src/log.h	/^#define LOG_H$/;"	d
LONGLINE	route/segment_stats.cpp	/^#define LONGLINE /;"	d	file:
LOWEST_TEMP	route/cb_metrics.h	/^#define LOWEST_TEMP /;"	d
LT_EVAL	../../libs/librtlnumber/src/rtl_int.cpp	/^#define LT_EVAL /;"	d	file:
LUT_CLASS	../../libs/libarchfpga/src/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
LUT_transistor_size	../../libs/libarchfpga/src/physical_types.h	/^	float LUT_transistor_size;$/;"	m	struct:t_power_arch	access:public
LatchInst	base/netlist_writer.cpp	/^        LatchInst(std::string inst_name, \/\/Name of this instance$/;"	f	class:LatchInst	access:public	signature:(std::string inst_name, std::map<std::string,std::string> port_conns, Type type, vtr::LogicValue init_value, double tcq=std::numeric_limits<double>::quiet_NaN(), double tsu=std::numeric_limits<double>::quiet_NaN(), double thld=std::numeric_limits<double>::quiet_NaN())
LatchInst	base/netlist_writer.cpp	/^class LatchInst : public Instance {$/;"	c	file:	inherits:Instance
LatchInst::LatchInst	base/netlist_writer.cpp	/^        LatchInst(std::string inst_name, \/\/Name of this instance$/;"	f	class:LatchInst	access:public	signature:(std::string inst_name, std::map<std::string,std::string> port_conns, Type type, vtr::LogicValue init_value, double tcq=std::numeric_limits<double>::quiet_NaN(), double tsu=std::numeric_limits<double>::quiet_NaN(), double thld=std::numeric_limits<double>::quiet_NaN())
LatchInst::Type	base/netlist_writer.cpp	/^        enum class Type {$/;"	c	class:LatchInst	file:	access:public
LatchInst::Type::ACTIVE_HIGH	base/netlist_writer.cpp	/^            ACTIVE_HIGH,$/;"	m	class:LatchInst::Type	file:	access:private
LatchInst::Type::ACTIVE_LOW	base/netlist_writer.cpp	/^            ACTIVE_LOW,$/;"	m	class:LatchInst::Type	file:	access:private
LatchInst::Type::ASYNCHRONOUS	base/netlist_writer.cpp	/^            ASYNCHRONOUS,$/;"	m	class:LatchInst::Type	file:	access:private
LatchInst::Type::FALLING_EDGE	base/netlist_writer.cpp	/^            FALLING_EDGE,$/;"	m	class:LatchInst::Type	file:	access:private
LatchInst::Type::RISING_EDGE	base/netlist_writer.cpp	/^            RISING_EDGE,$/;"	m	class:LatchInst::Type	file:	access:private
LatchInst::initial_value_	base/netlist_writer.cpp	/^        vtr::LogicValue initial_value_;$/;"	m	class:LatchInst	file:	access:private
LatchInst::instance_name_	base/netlist_writer.cpp	/^        std::string instance_name_;$/;"	m	class:LatchInst	file:	access:private
LatchInst::operator <<	base/netlist_writer.cpp	/^        friend std::ostream& operator<<(std::ostream& os, const Type& type) {$/;"	f	class:LatchInst	access:friend	signature:(std::ostream& os, const Type& type)
LatchInst::operator >>	base/netlist_writer.cpp	/^        friend std::istream& operator>>(std::istream& is, Type& type) {$/;"	f	class:LatchInst	access:friend	signature:(std::istream& is, Type& type)
LatchInst::port_connections_	base/netlist_writer.cpp	/^        std::map<std::string,std::string> port_connections_;$/;"	m	class:LatchInst	file:	access:private
LatchInst::tcq_	base/netlist_writer.cpp	/^        double tcq_; \/\/Clock delay + tcq$/;"	m	class:LatchInst	file:	access:private
LatchInst::thld_	base/netlist_writer.cpp	/^        double thld_; \/\/Hold time$/;"	m	class:LatchInst	file:	access:private
LatchInst::tsu_	base/netlist_writer.cpp	/^        double tsu_; \/\/Setup time$/;"	m	class:LatchInst	file:	access:private
LatchInst::type_	base/netlist_writer.cpp	/^        Type type_;$/;"	m	class:LatchInst	file:	access:private
Line	../../libs/libvtrutil/src/vtr_geometry.h	/^        Line(std::vector<Point<T>> line_points);$/;"	p	class:vtr::Line	access:public	signature:(std::vector<Point<T>> line_points)
Line	../../libs/libvtrutil/src/vtr_geometry.h	/^class Line {$/;"	c	namespace:vtr
Line	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Line<T>::Line(std::vector<Point<T>> line_points)$/;"	f	class:vtr::Line	signature:(std::vector<Point<T>> line_points)
LinearModel	route/routing_predictor.cpp	/^    LinearModel(float slope = std::numeric_limits<float>::quiet_NaN(), float y_intercept = std::numeric_limits<float>::quiet_NaN())$/;"	f	class:LinearModel	access:public	signature:(float slope = std::numeric_limits<float>::quiet_NaN(), float y_intercept = std::numeric_limits<float>::quiet_NaN())
LinearModel	route/routing_predictor.cpp	/^class LinearModel {$/;"	c	file:
LinearModel::LinearModel	route/routing_predictor.cpp	/^    LinearModel(float slope = std::numeric_limits<float>::quiet_NaN(), float y_intercept = std::numeric_limits<float>::quiet_NaN())$/;"	f	class:LinearModel	access:public	signature:(float slope = std::numeric_limits<float>::quiet_NaN(), float y_intercept = std::numeric_limits<float>::quiet_NaN())
LinearModel::find_x_for_y_value	route/routing_predictor.cpp	/^    float find_x_for_y_value(float y_value) const {$/;"	f	class:LinearModel	access:public	signature:(float y_value) const
LinearModel::find_y_for_x_value	route/routing_predictor.cpp	/^    float find_y_for_x_value(float x_value) const {$/;"	f	class:LinearModel	access:public	signature:(float x_value) const
LinearModel::get_slope	route/routing_predictor.cpp	/^    float get_slope() {$/;"	f	class:LinearModel	access:public	signature:()
LinearModel::slope_	route/routing_predictor.cpp	/^    float slope_;$/;"	m	class:LinearModel	file:	access:private
LinearModel::y_intercept_	route/routing_predictor.cpp	/^    float y_intercept_;$/;"	m	class:LinearModel	file:	access:private
LogicValue	../../libs/libvtrutil/src/vtr_logic.h	/^    enum class LogicValue {$/;"	c	namespace:vtr
LogicVec	base/netlist_writer.cpp	/^        LogicVec() = default;$/;"	p	class:LogicVec	file:	access:public	signature:()
LogicVec	base/netlist_writer.cpp	/^        LogicVec(size_t size_val, \/\/Number of logic values$/;"	f	class:LogicVec	access:public	signature:(size_t size_val, vtr::LogicValue init_value)
LogicVec	base/netlist_writer.cpp	/^        LogicVec(std::vector<vtr::LogicValue> values)$/;"	f	class:LogicVec	access:public	signature:(std::vector<vtr::LogicValue> values)
LogicVec	base/netlist_writer.cpp	/^class LogicVec {$/;"	c	file:
LogicVec::LogicVec	base/netlist_writer.cpp	/^        LogicVec() = default;$/;"	p	class:LogicVec	file:	access:public	signature:()
LogicVec::LogicVec	base/netlist_writer.cpp	/^        LogicVec(size_t size_val, \/\/Number of logic values$/;"	f	class:LogicVec	access:public	signature:(size_t size_val, vtr::LogicValue init_value)
LogicVec::LogicVec	base/netlist_writer.cpp	/^        LogicVec(std::vector<vtr::LogicValue> values)$/;"	f	class:LogicVec	access:public	signature:(std::vector<vtr::LogicValue> values)
LogicVec::begin	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::const_reverse_iterator begin() const { return values_.crbegin(); }$/;"	f	class:LogicVec	access:public	signature:() const
LogicVec::begin	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::reverse_iterator begin() { return values_.rbegin(); }$/;"	f	class:LogicVec	access:public	signature:()
LogicVec::end	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::const_reverse_iterator end() const { return values_.crend(); }$/;"	f	class:LogicVec	access:public	signature:() const
LogicVec::end	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::reverse_iterator end() { return values_.rend(); }$/;"	f	class:LogicVec	access:public	signature:()
LogicVec::operator <<	base/netlist_writer.cpp	/^        friend std::ostream& operator<<(std::ostream& os, LogicVec logic_vec) {$/;"	f	class:LogicVec	access:friend	signature:(std::ostream& os, LogicVec logic_vec)
LogicVec::operator []	base/netlist_writer.cpp	/^        vtr::LogicValue& operator[](size_t i) { return values_[i]; }$/;"	f	class:LogicVec	access:public	signature:(size_t i)
LogicVec::size	base/netlist_writer.cpp	/^        size_t size() { return values_.size(); }$/;"	f	class:LogicVec	access:public	signature:()
LogicVec::values_	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue> values_; \/\/The logic values$/;"	m	class:LogicVec	file:	access:private
LutInst	base/netlist_writer.cpp	/^        LutInst(size_t lut_size, \/\/The LUT size$/;"	f	class:LutInst	access:public	signature:(size_t lut_size, LogicVec lut_mask, std::string inst_name, std::map<std::string,std::vector<std::string>> port_conns, std::vector<Arc> timing_arc_values)
LutInst	base/netlist_writer.cpp	/^class LutInst : public Instance {$/;"	c	file:	inherits:Instance
LutInst::LutInst	base/netlist_writer.cpp	/^        LutInst(size_t lut_size, \/\/The LUT size$/;"	f	class:LutInst	access:public	signature:(size_t lut_size, LogicVec lut_mask, std::string inst_name, std::map<std::string,std::vector<std::string>> port_conns, std::vector<Arc> timing_arc_values)
LutInst::inst_name_	base/netlist_writer.cpp	/^        std::string inst_name_;$/;"	m	class:LutInst	file:	access:private
LutInst::instance_name	base/netlist_writer.cpp	/^        std::string instance_name() { return inst_name_; }$/;"	f	class:LutInst	access:public	signature:()
LutInst::lut_mask_	base/netlist_writer.cpp	/^        LogicVec lut_mask_;$/;"	m	class:LutInst	file:	access:private
LutInst::lut_size_	base/netlist_writer.cpp	/^        size_t lut_size_;$/;"	m	class:LutInst	file:	access:private
LutInst::port_conns_	base/netlist_writer.cpp	/^        std::map<std::string,std::vector<std::string>> port_conns_;$/;"	m	class:LutInst	file:	access:private
LutInst::timing_arcs	base/netlist_writer.cpp	/^        const std::vector<Arc>& timing_arcs() { return timing_arcs_; }$/;"	f	class:LutInst	access:public	signature:()
LutInst::timing_arcs_	base/netlist_writer.cpp	/^        std::vector<Arc> timing_arcs_;$/;"	m	class:LutInst	file:	access:private
LutInst::type	base/netlist_writer.cpp	/^        std::string type() { return type_; }$/;"	f	class:LutInst	access:public	signature:()
LutInst::type_	base/netlist_writer.cpp	/^        std::string type_;$/;"	m	class:LutInst	file:	access:private
MAGENTA	../../libs/libeasygl/src/easygl_constants.h	/^    MAGENTA,$/;"	e	enum:color_types
MAJOR	base/vpr_types.h	/^    MAJOR = 1$/;"	m	class:ScreenUpdatePriority	access:private
MAP	base/vpr_types.h	/^    MAP,     \/\/Lookahead considering different wire types (see Oleg Petelin's MASc Thesis)$/;"	m	class:ScreenUpdatePriority::e_router_lookahead	access:private
MAROON	../../libs/libeasygl/src/easygl_constants.h	/^    MAROON,$/;"	e	enum:color_types
MAX	base/vpr_types.h	/^    MAX,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
MAX	timing/DelayType.h	/^    MAX = 0,$/;"	m	class:DelayType	access:private
MAXPIXEL	../../libs/libeasygl/src/graphics.cpp	/^#define MAXPIXEL /;"	d	file:
MAXPTS	../../libs/libeasygl/src/graphics.cpp	/^#define MAXPTS /;"	d	file:
MAX_BLOCK_COLOURS	draw/draw_global.h	/^#define MAX_BLOCK_COLOURS /;"	d
MAX_CHANNEL_WIDTH	../../libs/libarchfpga/src/arch_types.h	/^constexpr int MAX_CHANNEL_WIDTH = 8000;$/;"	v
MAX_FIXED_POLY_PTS	../../libs/libeasygl/src/graphics.cpp	/^#define MAX_FIXED_POLY_PTS /;"	d	file:
MAX_INNER_ITERATIONS	route/cb_metrics.h	/^#define MAX_INNER_ITERATIONS /;"	d
MAX_INPUTS	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
MAX_INPUT_PINS	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
MAX_INV_TIMING_COST	place/place.cpp	/^#define MAX_INV_TIMING_COST /;"	d	file:
MAX_LOGS	power/power.h	/^#define MAX_LOGS /;"	d
MAX_MOVES_BEFORE_RECOMPUTE	place/place.cpp	/^#define MAX_MOVES_BEFORE_RECOMPUTE /;"	d	file:
MAX_NUM_TRIES_TO_PLACE_MACROS_RANDOMLY	place/place.cpp	/^#define MAX_NUM_TRIES_TO_PLACE_MACROS_RANDOMLY /;"	d	file:
MAX_OUTER_ITERATIONS	route/cb_metrics.h	/^#define MAX_OUTER_ITERATIONS /;"	d
MAX_PINS	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
MAX_SHORT	base/vpr_types.h	/^#define MAX_SHORT /;"	d
MAX_STRING_LEN	util/vpr_utils.cpp	/^#define MAX_STRING_LEN /;"	d	file:
MAX_TRACK_OFFSET	route/router_lookahead_map.cpp	/^#define MAX_TRACK_OFFSET /;"	d	file:
MEDIAN	base/vpr_types.h	/^    MEDIAN,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
MEDIAN	route/router_lookahead_map.cpp	/^	MEDIAN$/;"	e	enum:e_representative_entry_method	file:
MEDIUMAQUAMARINE	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMAQUAMARINE,$/;"	e	enum:color_types
MEDIUMBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMBLUE,$/;"	e	enum:color_types
MEDIUMORCHID	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMORCHID,$/;"	e	enum:color_types
MEDIUMPURPLE	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMPURPLE,$/;"	e	enum:color_types
MEDIUMSEAGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMSEAGREEN,$/;"	e	enum:color_types
MEDIUMSLATEBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMSLATEBLUE,$/;"	e	enum:color_types
MEDIUMSPRINGGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMSPRINGGREEN,$/;"	e	enum:color_types
MEDIUMTURQUOISE	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMTURQUOISE,$/;"	e	enum:color_types
MEDIUMVIOLETRED	../../libs/libeasygl/src/easygl_constants.h	/^    MEDIUMVIOLETRED,$/;"	e	enum:color_types
MEMORY_CLASS	../../libs/libarchfpga/src/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
MENU_FONT_SIZE	../../libs/libeasygl/src/graphics.cpp	/^#define MENU_FONT_SIZE /;"	d	file:
MIDNIGHTBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    MIDNIGHTBLUE,$/;"	e	enum:color_types
MIN	base/vpr_types.h	/^    MIN,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
MIN	timing/DelayType.h	/^    MIN,$/;"	m	class:DelayType	access:private
MINIMAX	base/vpr_types.h	/^    MINIMAX, SCALE_DELAY, DISABLE$/;"	e	enum:ScreenUpdatePriority::e_routing_budgets_algorithm
MINOR	base/vpr_types.h	/^    MINOR = 0,$/;"	m	class:ScreenUpdatePriority	access:private
MINPIXEL	../../libs/libeasygl/src/graphics.cpp	/^#define MINPIXEL /;"	d	file:
MINTCREAM	../../libs/libeasygl/src/easygl_constants.h	/^    MINTCREAM,$/;"	e	enum:color_types
MIN_VISIBLE_AREA	draw/draw_global.h	/^#define MIN_VISIBLE_AREA /;"	d
MISTYROSE	../../libs/libeasygl/src/easygl_constants.h	/^    MISTYROSE,$/;"	e	enum:color_types
MOCCASIN	../../libs/libeasygl/src/easygl_constants.h	/^    MOCCASIN,$/;"	e	enum:color_types
MODEL_INPUT	../../libs/libarchfpga/src/arch_types.h	/^constexpr const char* MODEL_INPUT = ".input";$/;"	v
MODEL_LATCH	../../libs/libarchfpga/src/arch_types.h	/^constexpr const char* MODEL_LATCH = ".latch";$/;"	v
MODEL_NAMES	../../libs/libarchfpga/src/arch_types.h	/^constexpr const char* MODEL_NAMES = ".names";$/;"	v
MODEL_OUTPUT	../../libs/libarchfpga/src/arch_types.h	/^constexpr const char* MODEL_OUTPUT = ".output";$/;"	v
MOLECULE_FORCED_PACK	base/vpr_types.h	/^	MOLECULE_SINGLE_ATOM, MOLECULE_FORCED_PACK$/;"	e	enum:ScreenUpdatePriority::e_pack_pattern_molecule_type
MOLECULE_SINGLE_ATOM	base/vpr_types.h	/^	MOLECULE_SINGLE_ATOM, MOLECULE_FORCED_PACK$/;"	e	enum:ScreenUpdatePriority::e_pack_pattern_molecule_type
MUX	../../libs/libarchfpga/src/physical_types.h	/^    MUX = 0,        \/\/A configurable (buffered) mux (single-driver)$/;"	m	class:SwitchType	access:private
MUX_INTERC	../../libs/libarchfpga/src/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
MWIDTH	../../libs/libeasygl/src/graphics.cpp	/^#define MWIDTH	/;"	d	file:
MY_POINT	../../libs/libeasygl/src/graphics.cpp	/^#define MY_POINT /;"	d	file:
MapLookahead	route/router_lookahead.h	/^class MapLookahead : public RouterLookahead {$/;"	c	inherits:RouterLookahead
MapLookahead::get_expected_cost	route/router_lookahead.cpp	/^float MapLookahead::get_expected_cost(int current_node, int target_node, const t_conn_cost_params& params, float \/*R_upstream*\/) const {$/;"	f	class:MapLookahead	signature:(int current_node, int target_node, const t_conn_cost_params& params, float ) const
MapLookahead::override	route/router_lookahead.h	/^        float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const override;$/;"	m	class:MapLookahead	access:protected
NAVAJOWHITE	../../libs/libeasygl/src/easygl_constants.h	/^    NAVAJOWHITE,$/;"	e	enum:color_types
NAVY	../../libs/libeasygl/src/easygl_constants.h	/^    NAVY,$/;"	e	enum:color_types
NEGATIVE	route/route_budgets.h	/^    POSITIVE, NEGATIVE, BOTH$/;"	e	enum:slack_allocated_type
NEGATIVE_EPSILON	base/vpr_types.h	/^#define NEGATIVE_EPSILON /;"	d
NETLIST	base/vpr_types.h	/^    NETLIST,            \/\/Only show netlist elements$/;"	m	class:ScreenUpdatePriority::e_timing_report_detail	access:private
NETLIST_FWD_H	base/netlist_fwd.h	/^#define NETLIST_FWD_H$/;"	d
NETLIST_H	base/netlist.h	/^#define NETLIST_H$/;"	d
NETLIST_UTILS_H	base/netlist_utils.h	/^#define NETLIST_UTILS_H$/;"	d
NETLIST_WALKER_H	base/netlist_walker.h	/^#define NETLIST_WALKER_H$/;"	d
NETLIST_WRITER_H	base/netlist_writer.h	/^#define NETLIST_WRITER_H$/;"	d
NET_DELAY_H	timing/net_delay.h	/^#define NET_DELAY_H$/;"	d
NET_DRIVER_INDEX	base/netlist.h	/^        constexpr static int NET_DRIVER_INDEX = 0;$/;"	m	class:Netlist	access:protected
NEVER_CLUSTER	base/vpr_types.h	/^#define NEVER_CLUSTER /;"	d
NMOS	power/power.h	/^	NMOS, PMOS$/;"	e	enum:e_tx_type
NMOS_1X_C_d	power/power.h	/^	float NMOS_1X_C_d;$/;"	m	struct:t_power_commonly_used	access:public
NMOS_1X_C_g	power/power.h	/^	float NMOS_1X_C_g;$/;"	m	struct:t_power_commonly_used	access:public
NMOS_1X_C_s	power/power.h	/^	float NMOS_1X_C_s;$/;"	m	struct:t_power_commonly_used	access:public
NMOS_1X_st_leakage	power/power.h	/^	float NMOS_1X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
NMOS_2X_st_leakage	power/power.h	/^	float NMOS_2X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
NMOS_inf	power/power.h	/^	t_transistor_inf NMOS_inf;$/;"	m	struct:t_power_tech	access:public
NONE	../../libs/libarchfpga/src/physical_types.h	/^    NONE,          \/\/No SB at this location$/;"	m	class:e_sb_type	access:private
NONE	../../libs/libarchfpga/src/physical_types.h	/^    NONE,    \/\/The pins within the port are not equivalent and can not be swapped$/;"	m	class:PortEquivalence	access:private
NONE	base/vpr_types.h	/^    NONE, \/\/No constant generator inference$/;"	m	class:ScreenUpdatePriority::e_const_gen_inference	access:private
NONSPACE	timing/slre.cpp	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon10	file:
NORMAL	place/place.cpp	/^	NORMAL, CHECK$/;"	e	enum:e_cost_methods	file:
NORMAL	route/route_timing.cpp	/^    NORMAL,$/;"	m	class:RouterCongestionMode	file:	access:private
NOT_FOUND	base/place_and_route.h	/^#define NOT_FOUND /;"	d
NOT_HILL_CLIMBING	pack/cluster.cpp	/^	HILL_CLIMBING, NOT_HILL_CLIMBING$/;"	e	enum:e_gain_type	file:
NOT_UPDATED_YET	place/place.cpp	/^#define NOT_UPDATED_YET /;"	d	file:
NOT_VALID	base/vpr_types.h	/^#define NOT_VALID /;"	d
NO_CLUSTER	base/vpr_types.h	/^#define NO_CLUSTER /;"	d
NO_FIXED_CHANNEL_WIDTH	base/vpr_types.h	/^constexpr int NO_FIXED_CHANNEL_WIDTH = -1;$/;"	m	class:ScreenUpdatePriority	access:private
NO_GAIN	pack/cluster.cpp	/^	GAIN, NO_GAIN$/;"	e	enum:e_gain_update	file:
NO_PICTURE	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:ScreenUpdatePriority::pic_type
NO_PREVIOUS	base/vpr_types.h	/^#define NO_PREVIOUS /;"	d
NO_SWITCH	../../libs/libarchfpga/src/physical_types.h	/^constexpr int NO_SWITCH = -1;$/;"	v
NO_TIMING	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:ScreenUpdatePriority::e_router_algorithm
NUM_BUCKETS	timing/path_delay.cpp	/^#define NUM_BUCKETS /;"	d	file:
NUM_COLOR	../../libs/libeasygl/src/easygl_constants.h	/^    NUM_COLOR$/;"	e	enum:color_types
NUM_FONT_TYPES	../../libs/libeasygl/src/fontcache.h	/^#define NUM_FONT_TYPES /;"	d
NUM_LB_RR_TYPES	pack/pack_types.h	/^	LB_SOURCE = 0, LB_SINK, LB_INTERMEDIATE, NUM_LB_RR_TYPES$/;"	e	enum:e_lb_rr_type
NUM_METRICS	route/cb_metrics.h	/^	NUM_METRICS$/;"	e	enum:e_metric
NUM_MODELS_IN_LIBRARY	../../libs/libarchfpga/src/read_xml_arch_file.h	/^#define NUM_MODELS_IN_LIBRARY /;"	d
NUM_WIRE_METRICS	route/cb_metrics.h	/^	NUM_WIRE_METRICS,$/;"	e	enum:e_metric
NdMatrix	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrix : public NdMatrixBase<T,N> {$/;"	c	namespace:vtr	inherits:NdMatrixBase
NdMatrix	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrix<T,1> : public NdMatrixBase<T,1> {$/;"	c	namespace:vtr	inherits:NdMatrixBase
NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase() {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:()
NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase(NdMatrixBase&& other)$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(NdMatrixBase&& other)
NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase(const NdMatrixBase& other)$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(const NdMatrixBase& other)
NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrixBase {$/;"	c	namespace:vtr
NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,1>(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)
NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,N>(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)
NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrixProxy {$/;"	c	namespace:vtr
NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrixProxy<T,1> {$/;"	c	namespace:vtr
NdOffsetMatrix	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrix : public NdOffsetMatrixBase<T,N> {$/;"	c	namespace:vtr	inherits:NdOffsetMatrixBase
NdOffsetMatrix	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrix<T,1> : public NdOffsetMatrixBase<T,1> {$/;"	c	namespace:vtr	inherits:NdOffsetMatrixBase
NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase() {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:()
NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(NdOffsetMatrixBase&& other)$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(NdOffsetMatrixBase&& other)
NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(const NdOffsetMatrixBase& other)$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(const NdOffsetMatrixBase& other)
NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(std::array<DimRange,N> dim_ranges, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<DimRange,N> dim_ranges, T value=T())
NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrixBase {$/;"	c	namespace:vtr
NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,1>(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)
NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,N>(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)
NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrixProxy {$/;"	c	namespace:vtr
NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrixProxy<T,1> {$/;"	c	namespace:vtr
NetFile	base/read_options.h	/^    argparse::ArgValue<std::string> NetFile;$/;"	m	struct:t_options	access:public
NetFile	base/vpr_types.h	/^	std::string NetFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
Netlist	base/netlist.h	/^        Netlist(std::string name="", std::string id="");$/;"	p	class:Netlist	access:public	signature:(std::string name=Ó, std::string id=Ó)
Netlist	base/netlist.h	/^class Netlist {$/;"	c
Netlist	base/netlist.tpp	/^Netlist<BlockId, PortId, PinId, NetId>::Netlist(std::string name, std::string id)$/;"	f	class:Netlist	signature:(std::string name, std::string id)
Netlist::INVALID_INDEX	base/netlist.h	/^        constexpr static int INVALID_INDEX = -1;$/;"	m	class:Netlist	access:protected
Netlist::IdRemapper	base/netlist.h	/^        typedef NetlistIdRemapper<BlockId,PortId,PinId,NetId> IdRemapper;$/;"	t	class:Netlist	access:public
Netlist::NET_DRIVER_INDEX	base/netlist.h	/^        constexpr static int NET_DRIVER_INDEX = 0;$/;"	m	class:Netlist	access:protected
Netlist::Netlist	base/netlist.h	/^        Netlist(std::string name="", std::string id="");$/;"	p	class:Netlist	access:public	signature:(std::string name=Ó, std::string id=Ó)
Netlist::Netlist	base/netlist.tpp	/^Netlist<BlockId, PortId, PinId, NetId>::Netlist(std::string name, std::string id)$/;"	f	class:Netlist	signature:(std::string name, std::string id)
Netlist::StringId	base/netlist.h	/^        typedef vtr::StrongId<string_id_tag> StringId;$/;"	t	class:Netlist	access:protected
Netlist::add_net	base/netlist.h	/^        NetId   add_net(const std::string name, PinId driver, std::vector<PinId> sinks);$/;"	p	class:Netlist	access:protected	signature:(const std::string name, PinId driver, std::vector<PinId> sinks)
Netlist::add_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::add_net(const std::string name, PinId driver, std::vector<PinId> sinks) {$/;"	f	class:Netlist	signature:(const std::string name, PinId driver, std::vector<PinId> sinks)
Netlist::associate_pin_with_block	base/netlist.h	/^        void associate_pin_with_block(const PinId pin_id, const PortType type, const BlockId blk_id);$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id, const PortType type, const BlockId blk_id)
Netlist::associate_pin_with_block	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::associate_pin_with_block(const PinId pin_id, const PortType type, const BlockId blk_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const PortType type, const BlockId blk_id)
Netlist::associate_pin_with_net	base/netlist.h	/^        int associate_pin_with_net(const PinId pin_id, const PinType type, const NetId net_id);$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id, const PinType type, const NetId net_id)
Netlist::associate_pin_with_net	base/netlist.tpp	/^int Netlist<BlockId, PortId, PinId, NetId>::associate_pin_with_net(const PinId pin_id, const PinType type, const NetId net_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const PinType type, const NetId net_id)
Netlist::associate_pin_with_port	base/netlist.h	/^        void associate_pin_with_port(const PinId pin_id, const PortId port_id);$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id, const PortId port_id)
Netlist::associate_pin_with_port	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::associate_pin_with_port(const PinId pin_id, const PortId port_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const PortId port_id)
Netlist::associate_port_with_block	base/netlist.h	/^        void associate_port_with_block(const PortId port_id, const PortType type, const BlockId blk_id);$/;"	p	class:Netlist	access:protected	signature:(const PortId port_id, const PortType type, const BlockId blk_id)
Netlist::associate_port_with_block	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::associate_port_with_block(const PortId port_id, const PortType type, const BlockId blk_id) {$/;"	f	class:Netlist	signature:(const PortId port_id, const PortType type, const BlockId blk_id)
Netlist::attr_iterator	base/netlist.h	/^        typedef typename std::unordered_map<std::string, std::string>::const_iterator   attr_iterator;$/;"	t	class:Netlist	access:public
Netlist::attr_range	base/netlist.h	/^        typedef typename vtr::Range<attr_iterator>  attr_range;$/;"	t	class:Netlist	access:public
Netlist::block_attrs	base/netlist.h	/^        attr_range          block_attrs(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_attrs	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::attr_range Netlist<BlockId, PortId, PinId, NetId>::block_attrs(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_attrs_	base/netlist.h	/^        vtr::vector_map<BlockId, std::unordered_map<std::string,std::string>>       block_attrs_;         \/\/Attributes of each block$/;"	m	class:Netlist	access:private
Netlist::block_clock_pins	base/netlist.h	/^        pin_range           block_clock_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_clock_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_clock_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_clock_ports	base/netlist.h	/^        port_range          block_clock_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_clock_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_clock_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_ids_	base/netlist.h	/^        vtr::vector_map<BlockId, BlockId>                   block_ids_;                \/\/Valid block ids$/;"	m	class:Netlist	access:private
Netlist::block_input_pins	base/netlist.h	/^        pin_range           block_input_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_input_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_input_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_input_ports	base/netlist.h	/^        port_range          block_input_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_input_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_input_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_is_combinational	base/netlist.h	/^        bool                block_is_combinational(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_is_combinational	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::block_is_combinational(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<BlockId, BlockId>::const_iterator              block_iterator;$/;"	t	class:Netlist	access:public
Netlist::block_name	base/netlist.h	/^        const std::string&  block_name(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::block_name(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_name_to_block_id_	base/netlist.h	/^        vtr::vector_map<StringId,BlockId>               block_name_to_block_id_;$/;"	m	class:Netlist	access:private
Netlist::block_names_	base/netlist.h	/^        vtr::vector_map<BlockId, StringId>                  block_names_;              \/\/Name of each block$/;"	m	class:Netlist	access:private
Netlist::block_num_clock_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_clock_pins_;     \/\/Number of clock pins on each block$/;"	m	class:Netlist	access:private
Netlist::block_num_clock_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_clock_ports_;    \/\/Clock ports of each block$/;"	m	class:Netlist	access:private
Netlist::block_num_input_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_input_pins_;     \/\/Number of input pins on each block$/;"	m	class:Netlist	access:private
Netlist::block_num_input_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_input_ports_;    \/\/Input ports of each block$/;"	m	class:Netlist	access:private
Netlist::block_num_output_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_output_pins_;    \/\/Number of output pins on each block$/;"	m	class:Netlist	access:private
Netlist::block_num_output_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_output_ports_;   \/\/Output ports of each block$/;"	m	class:Netlist	access:private
Netlist::block_output_pins	base/netlist.h	/^        pin_range           block_output_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_output_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_output_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_output_ports	base/netlist.h	/^        port_range          block_output_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_output_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_output_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_params	base/netlist.h	/^        param_range         block_params(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_params	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::param_range Netlist<BlockId, PortId, PinId, NetId>::block_params(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_params_	base/netlist.h	/^        vtr::vector_map<BlockId, std::unordered_map<std::string,std::string>>       block_params_;        \/\/Parameters of each block$/;"	m	class:Netlist	access:private
Netlist::block_pins	base/netlist.h	/^        pin_range           block_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, std::vector<PinId>>        block_pins_;               \/\/Pins of each block$/;"	m	class:Netlist	access:private
Netlist::block_ports	base/netlist.h	/^        port_range          block_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
Netlist::block_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
Netlist::block_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, std::vector<PortId>>       block_ports_;              \/\/Ports of each block$/;"	m	class:Netlist	access:private
Netlist::block_range	base/netlist.h	/^        typedef typename vtr::Range<block_iterator> block_range;$/;"	t	class:Netlist	access:public
Netlist::blocks	base/netlist.h	/^        block_range blocks() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::blocks	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::block_range Netlist<BlockId, PortId, PinId, NetId>::blocks() const {$/;"	f	class:Netlist	signature:() const
Netlist::build_id_maps	base/netlist.h	/^        IdRemapper build_id_maps();$/;"	p	class:Netlist	access:protected	signature:()
Netlist::build_id_maps	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::IdRemapper Netlist<BlockId, PortId, PinId, NetId>::build_id_maps() {$/;"	f	class:Netlist	signature:()
Netlist::clean_blocks	base/netlist.h	/^        void clean_blocks(const vtr::vector_map<BlockId, BlockId>& block_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map)
Netlist::clean_blocks	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_blocks(const vtr::vector_map<BlockId, BlockId>& block_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map)
Netlist::clean_blocks_impl	base/netlist.h	/^        virtual void clean_blocks_impl(const vtr::vector_map<BlockId, BlockId>& block_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map)
Netlist::clean_nets	base/netlist.h	/^        void clean_nets(const vtr::vector_map<NetId, NetId>& net_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<NetId, NetId>& net_id_map)
Netlist::clean_nets	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_nets(const vtr::vector_map<NetId, NetId>& net_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<NetId, NetId>& net_id_map)
Netlist::clean_nets_impl	base/netlist.h	/^        virtual void clean_nets_impl(const vtr::vector_map<NetId, NetId>& net_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<NetId, NetId>& net_id_map)
Netlist::clean_pins	base/netlist.h	/^        void clean_pins(const vtr::vector_map<PinId, PinId>& pin_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::clean_pins	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_pins(const vtr::vector_map<PinId, PinId>& pin_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::clean_pins_impl	base/netlist.h	/^        virtual void clean_pins_impl(const vtr::vector_map<PinId, PinId>& pin_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::clean_ports	base/netlist.h	/^        void clean_ports(const vtr::vector_map<PortId, PortId>& port_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map)
Netlist::clean_ports	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_ports(const vtr::vector_map<PortId, PortId>& port_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<PortId, PortId>& port_id_map)
Netlist::clean_ports_impl	base/netlist.h	/^        virtual void clean_ports_impl(const vtr::vector_map<PortId, PortId>& port_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map)
Netlist::compress	base/netlist.h	/^        IdRemapper compress();$/;"	p	class:Netlist	access:public	signature:()
Netlist::compress	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::IdRemapper Netlist<BlockId, PortId, PinId, NetId>::compress() {$/;"	f	class:Netlist	signature:()
Netlist::create_block	base/netlist.h	/^        BlockId create_block(const std::string name);$/;"	p	class:Netlist	access:protected	signature:(const std::string name)
Netlist::create_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::create_block(const std::string name) {$/;"	f	class:Netlist	signature:(const std::string name)
Netlist::create_net	base/netlist.h	/^        NetId   create_net(const std::string name); \/\/An empty or existing net$/;"	p	class:Netlist	access:protected	signature:(const std::string name)
Netlist::create_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::create_net(const std::string name) {$/;"	f	class:Netlist	signature:(const std::string name)
Netlist::create_pin	base/netlist.h	/^        PinId   create_pin(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType pin_type, bool is_const=false);$/;"	p	class:Netlist	access:protected	signature:(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType pin_type, bool is_const=false)
Netlist::create_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::create_pin(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType type, bool is_const) {$/;"	f	class:Netlist	signature:(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType type, bool is_const)
Netlist::create_port	base/netlist.h	/^        PortId  create_port(const BlockId blk_id, const std::string name, BitIndex width, PortType type);$/;"	p	class:Netlist	access:protected	signature:(const BlockId blk_id, const std::string name, BitIndex width, PortType type)
Netlist::create_port	base/netlist.tpp	/^PortId Netlist<BlockId, PortId, PinId, NetId>::create_port(const BlockId blk_id, const std::string name, BitIndex width, PortType type) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string name, BitIndex width, PortType type)
Netlist::create_string	base/netlist.h	/^        StringId create_string(const std::string& str);$/;"	p	class:Netlist	access:protected	signature:(const std::string& str)
Netlist::create_string	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::StringId Netlist<BlockId, PortId, PinId, NetId>::create_string(const std::string& str) {$/;"	f	class:Netlist	signature:(const std::string& str)
Netlist::dirty_	base/netlist.h	/^        bool dirty_ = false;        \/\/Indicates the netlist has invalid entries from remove_*() functions$/;"	m	class:Netlist	access:private
Netlist::find_block	base/netlist.h	/^        BlockId     find_block(const StringId name_id) const;$/;"	p	class:Netlist	access:protected	signature:(const StringId name_id) const
Netlist::find_block	base/netlist.h	/^        BlockId find_block(const std::string& name) const;$/;"	p	class:Netlist	access:public	signature:(const std::string& name) const
Netlist::find_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::find_block(const std::string& name) const {$/;"	f	class:Netlist	signature:(const std::string& name) const
Netlist::find_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::find_block(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const {$/;"	f	class:Netlist	signature:(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const
Netlist::find_net	base/netlist.h	/^        NetId       find_net(const StringId name_id) const;$/;"	p	class:Netlist	access:protected	signature:(const StringId name_id) const
Netlist::find_net	base/netlist.h	/^        NetId   find_net(const std::string& name) const;$/;"	p	class:Netlist	access:public	signature:(const std::string& name) const
Netlist::find_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::find_net(const std::string& name) const {$/;"	f	class:Netlist	signature:(const std::string& name) const
Netlist::find_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::find_net(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const {$/;"	f	class:Netlist	signature:(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const
Netlist::find_pin	base/netlist.h	/^        PinId   find_pin(const PortId port_id, BitIndex port_bit) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id, BitIndex port_bit) const
Netlist::find_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::find_pin(const PortId port_id, BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(const PortId port_id, BitIndex port_bit) const
Netlist::find_port	base/netlist.h	/^        PortId  find_port(const BlockId blk_id, const std::string& name) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string& name) const
Netlist::find_port	base/netlist.tpp	/^PortId Netlist<BlockId, PortId, PinId, NetId>::find_port(const BlockId blk_id, const std::string& name) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string& name) const
Netlist::find_string	base/netlist.h	/^        StringId    find_string(const std::string& str) const;$/;"	p	class:Netlist	access:protected	signature:(const std::string& str) const
Netlist::find_string	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::StringId Netlist<BlockId, PortId, PinId, NetId>::find_string(const std::string& str) const {$/;"	f	class:Netlist	signature:(const std::string& str) const
Netlist::is_compressed	base/netlist.h	/^        bool is_compressed() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::is_compressed	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::is_compressed() const {$/;"	f	class:Netlist	signature:() const
Netlist::is_dirty	base/netlist.h	/^        bool is_dirty() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::is_dirty	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::is_dirty() const {$/;"	f	class:Netlist	signature:() const
Netlist::merge_nets	base/netlist.h	/^        void merge_nets(const NetId driver_net, const NetId sink_net);$/;"	p	class:Netlist	access:public	signature:(const NetId driver_net, const NetId sink_net)
Netlist::merge_nets	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::merge_nets(const NetId driver_net, const NetId sink_net) {$/;"	f	class:Netlist	signature:(const NetId driver_net, const NetId sink_net)
Netlist::net_driver	base/netlist.h	/^        PinId               net_driver(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
Netlist::net_driver	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::net_driver(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
Netlist::net_driver_block	base/netlist.h	/^        BlockId             net_driver_block(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
Netlist::net_driver_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::net_driver_block(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
Netlist::net_ids_	base/netlist.h	/^        vtr::vector_map<NetId,NetId>              net_ids_;     \/\/Valid net ids$/;"	m	class:Netlist	access:private
Netlist::net_is_constant	base/netlist.h	/^        bool                net_is_constant(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
Netlist::net_is_constant	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::net_is_constant(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
Netlist::net_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<NetId, NetId>::const_iterator                  net_iterator;$/;"	t	class:Netlist	access:public
Netlist::net_name	base/netlist.h	/^        const std::string&  net_name(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
Netlist::net_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::net_name(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
Netlist::net_name_to_net_id_	base/netlist.h	/^        vtr::vector_map<StringId,NetId>                 net_name_to_net_id_;$/;"	m	class:Netlist	access:private
Netlist::net_names_	base/netlist.h	/^        vtr::vector_map<NetId,StringId>           net_names_;   \/\/Name of each net$/;"	m	class:Netlist	access:private
Netlist::net_pin	base/netlist.h	/^        PinId               net_pin(const NetId net_id, int net_pin_index) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id, int net_pin_index) const
Netlist::net_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::net_pin(const NetId net_id, int net_pin_index) const {$/;"	f	class:Netlist	signature:(const NetId net_id, int net_pin_index) const
Netlist::net_pin_block	base/netlist.h	/^        BlockId             net_pin_block(const NetId net_id, int net_pin_index) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id, int net_pin_index) const
Netlist::net_pin_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::net_pin_block(const NetId net_id, int net_pin_index) const {$/;"	f	class:Netlist	signature:(const NetId net_id, int net_pin_index) const
Netlist::net_pins	base/netlist.h	/^        pin_range           net_pins(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
Netlist::net_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::net_pins(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
Netlist::net_pins_	base/netlist.h	/^        vtr::vector_map<NetId,std::vector<PinId>> net_pins_;    \/\/Pins associated with each net$/;"	m	class:Netlist	access:private
Netlist::net_range	base/netlist.h	/^        typedef typename vtr::Range<net_iterator>   net_range;$/;"	t	class:Netlist	access:public
Netlist::net_sinks	base/netlist.h	/^        pin_range           net_sinks(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
Netlist::net_sinks	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::net_sinks(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
Netlist::netlist_id	base/netlist.h	/^        const std::string& netlist_id() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::netlist_id	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::netlist_id() const {$/;"	f	class:Netlist	signature:() const
Netlist::netlist_id_	base/netlist.h	/^        std::string netlist_id_;    \/\/Unique identifier for the netlist$/;"	m	class:Netlist	access:private
Netlist::netlist_name	base/netlist.h	/^        const std::string& netlist_name() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::netlist_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::netlist_name() const {$/;"	f	class:Netlist	signature:() const
Netlist::netlist_name_	base/netlist.h	/^        std::string netlist_name_;  \/\/Name of the top-level netlist$/;"	m	class:Netlist	access:private
Netlist::nets	base/netlist.h	/^        net_range   nets() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::nets	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::net_range Netlist<BlockId, PortId, PinId, NetId>::nets() const {$/;"	f	class:Netlist	signature:() const
Netlist::param_iterator	base/netlist.h	/^        typedef typename std::unordered_map<std::string, std::string>::const_iterator   param_iterator;$/;"	t	class:Netlist	access:public
Netlist::param_range	base/netlist.h	/^        typedef typename vtr::Range<param_iterator> param_range;$/;"	t	class:Netlist	access:public
Netlist::pin_block	base/netlist.h	/^        BlockId     pin_block(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::pin_block(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_ids_	base/netlist.h	/^        vtr::vector_map<PinId, PinId>       pin_ids_;           \/\/Valid pin ids$/;"	m	class:Netlist	access:private
Netlist::pin_is_constant	base/netlist.h	/^        bool        pin_is_constant(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_is_constant	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::pin_is_constant(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_is_constant_	base/netlist.h	/^        vtr::vector_map<PinId, bool>        pin_is_constant_;   \/\/Indicates if the pin always keeps a constant value$/;"	m	class:Netlist	access:private
Netlist::pin_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<PinId, PinId>::const_iterator                  pin_iterator;$/;"	t	class:Netlist	access:public
Netlist::pin_name	base/netlist.h	/^        std::string pin_name(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_name	base/netlist.tpp	/^std::string Netlist<BlockId, PortId, PinId, NetId>::pin_name(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_net	base/netlist.h	/^        NetId       pin_net(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::pin_net(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_net_index	base/netlist.h	/^        int         pin_net_index(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_net_index	base/netlist.tpp	/^int Netlist<BlockId, PortId, PinId, NetId>::pin_net_index(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_net_indices_	base/netlist.h	/^        vtr::vector_map<PinId, int>         pin_net_indices_;   \/\/Index of the specified pin within it's associated net$/;"	m	class:Netlist	access:private
Netlist::pin_nets_	base/netlist.h	/^        vtr::vector_map<PinId, NetId>       pin_nets_;          \/\/Net associated with each pin$/;"	m	class:Netlist	access:private
Netlist::pin_port	base/netlist.h	/^        PortId      pin_port(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_port	base/netlist.tpp	/^PortId Netlist<BlockId, PortId, PinId, NetId>::pin_port(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_port_bit	base/netlist.h	/^        BitIndex    pin_port_bit(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_port_bit	base/netlist.tpp	/^BitIndex Netlist<BlockId, PortId, PinId, NetId>::pin_port_bit(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_port_bits_	base/netlist.h	/^        vtr::vector_map<PinId, BitIndex>    pin_port_bits_;     \/\/The pins bit position in the port$/;"	m	class:Netlist	access:private
Netlist::pin_port_type	base/netlist.h	/^        PortType    pin_port_type(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_port_type	base/netlist.tpp	/^PortType Netlist<BlockId, PortId, PinId, NetId>::pin_port_type(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pin_ports_	base/netlist.h	/^        vtr::vector_map<PinId, PortId>      pin_ports_;         \/\/Type of each pin$/;"	m	class:Netlist	access:private
Netlist::pin_range	base/netlist.h	/^        typedef typename vtr::Range<pin_iterator>   pin_range;$/;"	t	class:Netlist	access:public
Netlist::pin_type	base/netlist.h	/^        PinType     pin_type(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
Netlist::pin_type	base/netlist.tpp	/^PinType Netlist<BlockId, PortId, PinId, NetId>::pin_type(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
Netlist::pins	base/netlist.h	/^        pin_range   pins() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::pins() const {$/;"	f	class:Netlist	signature:() const
Netlist::port_block	base/netlist.h	/^        BlockId             port_block(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
Netlist::port_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::port_block(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
Netlist::port_blocks_	base/netlist.h	/^        vtr::vector_map<PortId, BlockId>                port_blocks_;   \/\/Block associated with each port$/;"	m	class:Netlist	access:private
Netlist::port_ids_	base/netlist.h	/^        vtr::vector_map<PortId, PortId>                 port_ids_;      \/\/Valid port ids$/;"	m	class:Netlist	access:private
Netlist::port_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<PortId, PortId>::const_iterator                port_iterator;$/;"	t	class:Netlist	access:public
Netlist::port_name	base/netlist.h	/^        const std::string&  port_name(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
Netlist::port_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::port_name(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
Netlist::port_names_	base/netlist.h	/^        vtr::vector_map<PortId, StringId>               port_names_;    \/\/Name of each port$/;"	m	class:Netlist	access:private
Netlist::port_net	base/netlist.h	/^        NetId               port_net(const PortId port_id, const BitIndex port_bit) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id, const BitIndex port_bit) const
Netlist::port_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::port_net(const PortId port_id, const BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(const PortId port_id, const BitIndex port_bit) const
Netlist::port_pin	base/netlist.h	/^        PinId               port_pin(const PortId port_id, const BitIndex port_bit) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id, const BitIndex port_bit) const
Netlist::port_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::port_pin(const PortId port_id, const BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(const PortId port_id, const BitIndex port_bit) const
Netlist::port_pins	base/netlist.h	/^        pin_range           port_pins(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
Netlist::port_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::port_pins(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
Netlist::port_pins_	base/netlist.h	/^        vtr::vector_map<PortId, std::vector<PinId>>     port_pins_;     \/\/Pins associated with each port$/;"	m	class:Netlist	access:private
Netlist::port_range	base/netlist.h	/^        typedef typename vtr::Range<port_iterator>  port_range;$/;"	t	class:Netlist	access:public
Netlist::port_type	base/netlist.h	/^        PortType            port_type(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
Netlist::port_type	base/netlist.tpp	/^PortType Netlist<BlockId, PortId, PinId, NetId>::port_type(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
Netlist::port_types_	base/netlist.h	/^        vtr::vector_map<PortId, PortType>               port_types_;    \/\/Type of the port (INPUT, OUTPUT, CLOCK)$/;"	m	class:Netlist	access:private
Netlist::port_width	base/netlist.h	/^        BitIndex            port_width(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
Netlist::port_width	base/netlist.tpp	/^BitIndex Netlist<BlockId, PortId, PinId, NetId>::port_width(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
Netlist::port_widths_	base/netlist.h	/^        vtr::vector_map<PortId, BitIndex>               port_widths_;   \/\/Width (in bits) of each port$/;"	m	class:Netlist	access:private
Netlist::ports	base/netlist.h	/^        port_range  ports() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::ports() const {$/;"	f	class:Netlist	signature:() const
Netlist::print_stats	base/netlist.h	/^        void print_stats() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::print_stats	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::print_stats() const {$/;"	f	class:Netlist	signature:() const
Netlist::rebuild_block_refs	base/netlist.h	/^        void rebuild_block_refs(const vtr::vector_map<PinId, PinId>& pin_id_map,$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map)
Netlist::rebuild_block_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_block_refs(const vtr::vector_map<PinId, PinId>& pin_id_map,$/;"	f	class:Netlist	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map)
Netlist::rebuild_block_refs_impl	base/netlist.h	/^        virtual void rebuild_block_refs_impl(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map)
Netlist::rebuild_lookups	base/netlist.h	/^        void rebuild_lookups();$/;"	p	class:Netlist	access:protected	signature:()
Netlist::rebuild_lookups	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_lookups() {$/;"	f	class:Netlist	signature:()
Netlist::rebuild_net_refs	base/netlist.h	/^        void rebuild_net_refs(const vtr::vector_map<PinId, PinId>& pin_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::rebuild_net_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_net_refs(const vtr::vector_map<PinId, PinId>& pin_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::rebuild_net_refs_impl	base/netlist.h	/^        virtual void rebuild_net_refs_impl(const vtr::vector_map<PinId, PinId>& pin_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::rebuild_pin_refs	base/netlist.h	/^        void rebuild_pin_refs(const vtr::vector_map<PortId, PortId>& port_id_map,$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map)
Netlist::rebuild_pin_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_pin_refs(const vtr::vector_map<PortId, PortId>& port_id_map,$/;"	f	class:Netlist	signature:(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map)
Netlist::rebuild_pin_refs_impl	base/netlist.h	/^        virtual void rebuild_pin_refs_impl(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map)
Netlist::rebuild_port_refs	base/netlist.h	/^        void rebuild_port_refs(const vtr::vector_map<BlockId, BlockId>& block_id_map,$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::rebuild_port_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_port_refs(const vtr::vector_map<BlockId, BlockId>& block_id_map,$/;"	f	class:Netlist	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::rebuild_port_refs_impl	base/netlist.h	/^        virtual void rebuild_port_refs_impl(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map)
Netlist::remove_and_compress	base/netlist.h	/^        IdRemapper remove_and_compress();$/;"	p	class:Netlist	access:public	signature:()
Netlist::remove_and_compress	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::IdRemapper Netlist<BlockId, PortId, PinId, NetId>::remove_and_compress() {$/;"	f	class:Netlist	signature:()
Netlist::remove_block	base/netlist.h	/^        void remove_block(const BlockId blk_id);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id)
Netlist::remove_block	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_block(const BlockId blk_id) {$/;"	f	class:Netlist	signature:(const BlockId blk_id)
Netlist::remove_block_impl	base/netlist.h	/^        virtual void remove_block_impl(const BlockId blk_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const BlockId blk_id)
Netlist::remove_net	base/netlist.h	/^        void remove_net(const NetId net_id);$/;"	p	class:Netlist	access:public	signature:(const NetId net_id)
Netlist::remove_net	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_net(const NetId net_id) {$/;"	f	class:Netlist	signature:(const NetId net_id)
Netlist::remove_net_impl	base/netlist.h	/^        virtual void remove_net_impl(const NetId net_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const NetId net_id)
Netlist::remove_net_pin	base/netlist.h	/^        void remove_net_pin(const NetId net_id, const PinId pin_id);$/;"	p	class:Netlist	access:public	signature:(const NetId net_id, const PinId pin_id)
Netlist::remove_net_pin	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_net_pin(const NetId net_id, const PinId pin_id) {$/;"	f	class:Netlist	signature:(const NetId net_id, const PinId pin_id)
Netlist::remove_pin	base/netlist.h	/^        void remove_pin(const PinId pin_id);$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id)
Netlist::remove_pin	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_pin(const PinId pin_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id)
Netlist::remove_pin_impl	base/netlist.h	/^        virtual void remove_pin_impl(const PinId pin_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id)
Netlist::remove_port	base/netlist.h	/^        void remove_port(const PortId port_id);$/;"	p	class:Netlist	access:public	signature:(const PortId port_id)
Netlist::remove_port	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_port(const PortId port_id) {$/;"	f	class:Netlist	signature:(const PortId port_id)
Netlist::remove_port_impl	base/netlist.h	/^        virtual void remove_port_impl(const PortId port_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const PortId port_id)
Netlist::remove_unused	base/netlist.h	/^        void remove_unused();$/;"	p	class:Netlist	access:public	signature:()
Netlist::remove_unused	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_unused() {$/;"	f	class:Netlist	signature:()
Netlist::set_block_attr	base/netlist.h	/^        void set_block_attr(const BlockId blk_id, const std::string &name, const std::string &value);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
Netlist::set_block_attr	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_block_attr(const BlockId blk_id, const std::string &name, const std::string &value) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
Netlist::set_block_name	base/netlist.h	/^        void set_block_name(const BlockId blk_id, const std::string new_name);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string new_name)
Netlist::set_block_name	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_block_name(const BlockId blk_id, const std::string new_name) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string new_name)
Netlist::set_block_param	base/netlist.h	/^        void set_block_param(const BlockId blk_id, const std::string &name, const std::string &value);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
Netlist::set_block_param	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_block_param(const BlockId blk_id, const std::string &name, const std::string &value) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
Netlist::set_pin_is_constant	base/netlist.h	/^        void set_pin_is_constant(const PinId pin_id, const bool value);$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id, const bool value)
Netlist::set_pin_is_constant	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_pin_is_constant(const PinId pin_id, const bool value) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const bool value)
Netlist::set_pin_net	base/netlist.h	/^        void set_pin_net(const PinId pin, PinType pin_type, const NetId net);$/;"	p	class:Netlist	access:public	signature:(const PinId pin, PinType pin_type, const NetId net)
Netlist::set_pin_net	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_pin_net(const PinId pin, PinType type, const NetId net) {$/;"	f	class:Netlist	signature:(const PinId pin, PinType type, const NetId net)
Netlist::shrink_to_fit	base/netlist.h	/^        void shrink_to_fit();$/;"	p	class:Netlist	access:protected	signature:()
Netlist::shrink_to_fit	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::shrink_to_fit() {$/;"	f	class:Netlist	signature:()
Netlist::shrink_to_fit_impl	base/netlist.h	/^        virtual void shrink_to_fit_impl() = 0;$/;"	p	class:Netlist	access:protected	signature:()
Netlist::string_ids_	base/netlist.h	/^        vtr::vector_map<StringId,StringId>      string_ids_;    \/\/Valid string ids$/;"	m	class:Netlist	access:private
Netlist::string_to_string_id_	base/netlist.h	/^        std::unordered_map<std::string, StringId>       string_to_string_id_;$/;"	m	class:Netlist	access:private
Netlist::strings_	base/netlist.h	/^        vtr::vector_map<StringId,std::string>   strings_;       \/\/Strings$/;"	m	class:Netlist	access:private
Netlist::valid_block_id	base/netlist.h	/^        bool valid_block_id(BlockId block_id) const;$/;"	p	class:Netlist	access:protected	signature:(BlockId block_id) const
Netlist::valid_block_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_block_id(BlockId block_id) const {$/;"	f	class:Netlist	signature:(BlockId block_id) const
Netlist::valid_net_id	base/netlist.h	/^        bool valid_net_id(NetId net_id) const;$/;"	p	class:Netlist	access:protected	signature:(NetId net_id) const
Netlist::valid_net_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_net_id(NetId net_id) const {$/;"	f	class:Netlist	signature:(NetId net_id) const
Netlist::valid_pin_id	base/netlist.h	/^        bool valid_pin_id(PinId pin_id) const;$/;"	p	class:Netlist	access:protected	signature:(PinId pin_id) const
Netlist::valid_pin_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_pin_id(PinId pin_id) const {$/;"	f	class:Netlist	signature:(PinId pin_id) const
Netlist::valid_port_bit	base/netlist.h	/^        bool valid_port_bit(PortId port_id, BitIndex port_bit) const;$/;"	p	class:Netlist	access:protected	signature:(PortId port_id, BitIndex port_bit) const
Netlist::valid_port_bit	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_port_bit(PortId port_id, BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(PortId port_id, BitIndex port_bit) const
Netlist::valid_port_id	base/netlist.h	/^        bool valid_port_id(PortId port_id) const;$/;"	p	class:Netlist	access:protected	signature:(PortId port_id) const
Netlist::valid_port_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_port_id(PortId port_id) const {$/;"	f	class:Netlist	signature:(PortId port_id) const
Netlist::valid_string_id	base/netlist.h	/^        bool valid_string_id(StringId string_id) const;$/;"	p	class:Netlist	access:protected	signature:(StringId string_id) const
Netlist::valid_string_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_string_id(typename Netlist<BlockId, PortId, PinId, NetId>::StringId string_id) const {$/;"	f	class:Netlist	signature:(typename Netlist<BlockId, PortId, PinId, NetId>::StringId string_id) const
Netlist::validate_block_pin_refs	base/netlist.h	/^        bool validate_block_pin_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_block_pin_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_block_pin_refs() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_block_port_refs	base/netlist.h	/^        bool validate_block_port_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_block_port_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_block_port_refs() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_block_sizes	base/netlist.h	/^        bool validate_block_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_block_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_block_sizes() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_block_sizes_impl	base/netlist.h	/^        virtual bool validate_block_sizes_impl(size_t num_blocks) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_blocks) const
Netlist::validate_net_pin_refs	base/netlist.h	/^        bool validate_net_pin_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_net_pin_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_net_pin_refs() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_net_sizes	base/netlist.h	/^        bool validate_net_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_net_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_net_sizes() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_net_sizes_impl	base/netlist.h	/^        virtual bool validate_net_sizes_impl(size_t num_nets) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_nets) const
Netlist::validate_pin_sizes	base/netlist.h	/^        bool validate_pin_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_pin_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_pin_sizes() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_pin_sizes_impl	base/netlist.h	/^        virtual bool validate_pin_sizes_impl(size_t num_pins) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_pins) const
Netlist::validate_port_pin_refs	base/netlist.h	/^        bool validate_port_pin_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_port_pin_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_port_pin_refs() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_port_sizes	base/netlist.h	/^        bool validate_port_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_port_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_port_sizes() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_port_sizes_impl	base/netlist.h	/^        virtual bool validate_port_sizes_impl(size_t num_ports) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_ports) const
Netlist::validate_string_refs	base/netlist.h	/^        bool validate_string_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_string_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_string_refs() const {$/;"	f	class:Netlist	signature:() const
Netlist::validate_string_sizes	base/netlist.h	/^        bool validate_string_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::validate_string_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_string_sizes() const {$/;"	f	class:Netlist	signature:() const
Netlist::verify	base/netlist.h	/^        bool verify() const;$/;"	p	class:Netlist	access:public	signature:() const
Netlist::verify	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify() const {$/;"	f	class:Netlist	signature:() const
Netlist::verify_block_invariants	base/netlist.h	/^        bool verify_block_invariants() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::verify_block_invariants	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_block_invariants() const {$/;"	f	class:Netlist	signature:() const
Netlist::verify_lookups	base/netlist.h	/^        bool verify_lookups() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::verify_lookups	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_lookups() const {$/;"	f	class:Netlist	signature:() const
Netlist::verify_refs	base/netlist.h	/^        bool verify_refs() const; \/\/All cross-references$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::verify_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_refs() const {$/;"	f	class:Netlist	signature:() const
Netlist::verify_sizes	base/netlist.h	/^        bool verify_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
Netlist::verify_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_sizes() const {$/;"	f	class:Netlist	signature:() const
Netlist::~Netlist	base/netlist.h	/^        virtual ~Netlist();$/;"	p	class:Netlist	access:public	signature:()
Netlist::~Netlist	base/netlist.tpp	/^Netlist<BlockId, PortId, PinId, NetId>::~Netlist() = default;$/;"	p	class:Netlist	file:	signature:()
NetlistIdRemapper	base/netlist.h	/^class NetlistIdRemapper {$/;"	c
NetlistIdRemapper::block_id_map_	base/netlist.h	/^        vtr::vector_map<BlockId, BlockId> block_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
NetlistIdRemapper::net_id_map_	base/netlist.h	/^        vtr::vector_map<NetId, NetId> net_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
NetlistIdRemapper::new_block_id	base/netlist.h	/^        BlockId new_block_id(BlockId old_blk) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(BlockId old_blk) const
NetlistIdRemapper::new_block_id	base/netlist.tpp	/^BlockId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_block_id(BlockId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(BlockId old_id) const
NetlistIdRemapper::new_net_id	base/netlist.h	/^        NetId new_net_id(NetId old_net) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(NetId old_net) const
NetlistIdRemapper::new_net_id	base/netlist.tpp	/^NetId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_net_id(NetId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(NetId old_id) const
NetlistIdRemapper::new_pin_id	base/netlist.h	/^        PinId new_pin_id(PinId old_pin) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(PinId old_pin) const
NetlistIdRemapper::new_pin_id	base/netlist.tpp	/^PinId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_pin_id(PinId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(PinId old_id) const
NetlistIdRemapper::new_port_id	base/netlist.h	/^        PortId new_port_id(PortId old_port) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(PortId old_port) const
NetlistIdRemapper::new_port_id	base/netlist.tpp	/^PortId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_port_id(PortId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(PortId old_id) const
NetlistIdRemapper::pin_id_map_	base/netlist.h	/^        vtr::vector_map<PinId, PinId> pin_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
NetlistIdRemapper::port_id_map_	base/netlist.h	/^        vtr::vector_map<PortId, PortId> port_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
NetlistOpts	base/vpr_types.h	/^	t_netlist_opts NetlistOpts; \/* Options for packer *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
NetlistVisitor	base/netlist_walker.h	/^class NetlistVisitor {$/;"	c
NetlistVisitor::finish	base/netlist_walker.h	/^        void finish() { finish_impl(); }$/;"	f	class:NetlistVisitor	access:public	signature:()
NetlistVisitor::finish_impl	base/netlist_walker.cpp	/^void NetlistVisitor::finish_impl() {$/;"	f	class:NetlistVisitor	signature:()
NetlistVisitor::finish_impl	base/netlist_walker.h	/^        virtual void finish_impl();$/;"	p	class:NetlistVisitor	access:protected	signature:()
NetlistVisitor::start	base/netlist_walker.h	/^        void start() { start_impl(); }$/;"	f	class:NetlistVisitor	access:public	signature:()
NetlistVisitor::start_impl	base/netlist_walker.cpp	/^void NetlistVisitor::start_impl() {$/;"	f	class:NetlistVisitor	signature:()
NetlistVisitor::start_impl	base/netlist_walker.h	/^        virtual void start_impl();$/;"	p	class:NetlistVisitor	access:protected	signature:()
NetlistVisitor::visit_atom	base/netlist_walker.h	/^        void visit_atom(const t_pb* atom) { visit_atom_impl(atom); }$/;"	f	class:NetlistVisitor	access:public	signature:(const t_pb* atom)
NetlistVisitor::visit_atom_impl	base/netlist_walker.cpp	/^void NetlistVisitor::visit_atom_impl(const t_pb* \/*atom*\/) {$/;"	f	class:NetlistVisitor	signature:(const t_pb* )
NetlistVisitor::visit_atom_impl	base/netlist_walker.h	/^        virtual void visit_atom_impl(const t_pb* atom);$/;"	p	class:NetlistVisitor	access:protected	signature:(const t_pb* atom)
NetlistVisitor::visit_clb	base/netlist_walker.h	/^        void visit_clb(const t_pb* clb) { visit_clb_impl(clb); }$/;"	f	class:NetlistVisitor	access:public	signature:(const t_pb* clb)
NetlistVisitor::visit_clb_impl	base/netlist_walker.cpp	/^void NetlistVisitor::visit_clb_impl(const t_pb* \/*clb*\/) {$/;"	f	class:NetlistVisitor	signature:(const t_pb* )
NetlistVisitor::visit_clb_impl	base/netlist_walker.h	/^        virtual void visit_clb_impl(const t_pb* clb);$/;"	p	class:NetlistVisitor	access:protected	signature:(const t_pb* clb)
NetlistVisitor::visit_top	base/netlist_walker.h	/^        void visit_top(const char* top_level_name) { visit_top_impl(top_level_name); }$/;"	f	class:NetlistVisitor	access:public	signature:(const char* top_level_name)
NetlistVisitor::visit_top_impl	base/netlist_walker.cpp	/^void NetlistVisitor::visit_top_impl(const char* \/*top_level_name*\/) {$/;"	f	class:NetlistVisitor	signature:(const char* )
NetlistVisitor::visit_top_impl	base/netlist_walker.h	/^        virtual void visit_top_impl(const char* top_level_name);$/;"	p	class:NetlistVisitor	access:protected	signature:(const char* top_level_name)
NetlistVisitor::~NetlistVisitor	base/netlist_walker.h	/^        virtual ~NetlistVisitor() = default;$/;"	p	class:NetlistVisitor	access:public	signature:()
NetlistWalker	base/netlist_walker.h	/^        NetlistWalker(NetlistVisitor& netlist_visitor)$/;"	f	class:NetlistWalker	access:public	signature:(NetlistVisitor& netlist_visitor)
NetlistWalker	base/netlist_walker.h	/^class NetlistWalker {$/;"	c
NetlistWalker::NetlistWalker	base/netlist_walker.h	/^        NetlistWalker(NetlistVisitor& netlist_visitor)$/;"	f	class:NetlistWalker	access:public	signature:(NetlistVisitor& netlist_visitor)
NetlistWalker::visitor_	base/netlist_walker.h	/^        NetlistVisitor& visitor_;$/;"	m	class:NetlistWalker	access:private
NetlistWalker::walk	base/netlist_walker.cpp	/^void NetlistWalker::walk() {$/;"	f	class:NetlistWalker	signature:()
NetlistWalker::walk	base/netlist_walker.h	/^        void walk();$/;"	p	class:NetlistWalker	access:public	signature:()
NetlistWalker::walk_atoms	base/netlist_walker.cpp	/^void NetlistWalker::walk_atoms(const t_pb* pb) {$/;"	f	class:NetlistWalker	signature:(const t_pb* pb)
NetlistWalker::walk_atoms	base/netlist_walker.h	/^        void walk_atoms(const t_pb* pb);$/;"	p	class:NetlistWalker	access:private	signature:(const t_pb* pb)
NetlistWriterVisitor	base/netlist_writer.cpp	/^        NetlistWriterVisitor(std::ostream& verilog_os, \/\/Output stream for verilog netlist$/;"	f	class:NetlistWriterVisitor	access:public	signature:(std::ostream& verilog_os, std::ostream& blif_os, std::ostream& sdf_os, std::shared_ptr<const AnalysisDelayCalculator> delay_calc)
NetlistWriterVisitor	base/netlist_writer.cpp	/^class NetlistWriterVisitor : public NetlistVisitor {$/;"	c	file:	inherits:NetlistVisitor
NetlistWriterVisitor::NetlistWriterVisitor	base/netlist_writer.cpp	/^        NetlistWriterVisitor(std::ostream& verilog_os, \/\/Output stream for verilog netlist$/;"	f	class:NetlistWriterVisitor	access:public	signature:(std::ostream& verilog_os, std::ostream& blif_os, std::ostream& sdf_os, std::shared_ptr<const AnalysisDelayCalculator> delay_calc)
NetlistWriterVisitor::assignments_	base/netlist_writer.cpp	/^        std::vector<Assignment> assignments_; \/\/Set of assignments (i.e. net-to-net connections)$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::blif_os_	base/netlist_writer.cpp	/^        std::ostream& blif_os_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::cell_instances_	base/netlist_writer.cpp	/^        std::vector<std::shared_ptr<Instance>> cell_instances_; \/\/Set of cell instances$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::delay_calc_	base/netlist_writer.cpp	/^        std::shared_ptr<const AnalysisDelayCalculator> delay_calc_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::determine_lut_permutation	base/netlist_writer.cpp	/^        std::vector<int> determine_lut_permutation(size_t num_inputs, const t_pb* atom_pb) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(size_t num_inputs, const t_pb* atom_pb)
NetlistWriterVisitor::find_atom_input_logical_net	base/netlist_writer.cpp	/^        AtomNetId find_atom_input_logical_net(const t_pb* atom, int atom_input_idx) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom, int atom_input_idx)
NetlistWriterVisitor::find_num_inputs	base/netlist_writer.cpp	/^        int find_num_inputs(const t_pb* pb) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* pb)
NetlistWriterVisitor::find_tnode	base/netlist_writer.cpp	/^        tatum::NodeId find_tnode(const t_pb* atom, int cluster_pin_idx) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom, int cluster_pin_idx)
NetlistWriterVisitor::find_top_cb	base/netlist_writer.cpp	/^        const t_pb* find_top_cb(const t_pb* curr) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* curr)
NetlistWriterVisitor::find_top_pb_route	base/netlist_writer.cpp	/^        const t_pb_routes& find_top_pb_route(const t_pb* curr) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* curr)
NetlistWriterVisitor::get_delay_ps	base/netlist_writer.cpp	/^        double get_delay_ps(tatum::NodeId source_tnode, tatum::NodeId sink_tnode) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(tatum::NodeId source_tnode, tatum::NodeId sink_tnode)
NetlistWriterVisitor::inputs_	base/netlist_writer.cpp	/^        std::vector<std::string> inputs_; \/\/Name of circuit inputs$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::interconnect_name	base/netlist_writer.cpp	/^        std::string interconnect_name(std::string driver_wire, std::string sink_wire) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(std::string driver_wire, std::string sink_wire)
NetlistWriterVisitor::load_lut_mask	base/netlist_writer.cpp	/^        LogicVec load_lut_mask(size_t num_inputs, \/\/LUT size$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(size_t num_inputs, const t_pb* atom)
NetlistWriterVisitor::logical_net_drivers_	base/netlist_writer.cpp	/^        std::map<AtomNetId, std::pair<std::string,tatum::NodeId>> logical_net_drivers_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::logical_net_sink_delays_	base/netlist_writer.cpp	/^        std::map<std::string, float> logical_net_sink_delays_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::logical_net_sinks_	base/netlist_writer.cpp	/^        std::map<AtomNetId, std::vector<std::pair<std::string,tatum::NodeId>>> logical_net_sinks_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::make_adder_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_adder_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
NetlistWriterVisitor::make_inst_wire	base/netlist_writer.cpp	/^        std::string make_inst_wire(AtomNetId atom_net_id, \/\/The id of the net in the atom netlist$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(AtomNetId atom_net_id, tatum::NodeId tnode_id, std::string inst_name, PortType port_type, int port_idx, int pin_idx)
NetlistWriterVisitor::make_io	base/netlist_writer.cpp	/^        std::string make_io(const t_pb* atom, \/\/The implementation primitive representing the I\/O$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom, PortType dir)
NetlistWriterVisitor::make_latch_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_latch_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
NetlistWriterVisitor::make_lut_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_lut_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
NetlistWriterVisitor::make_multiply_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_multiply_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
NetlistWriterVisitor::make_ram_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_ram_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
NetlistWriterVisitor::names_encodes_on_set	base/netlist_writer.cpp	/^        bool names_encodes_on_set(vtr::t_linked_vptr* names_row_ptr) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(vtr::t_linked_vptr* names_row_ptr)
NetlistWriterVisitor::names_row_to_logic_vec	base/netlist_writer.cpp	/^        LogicVec names_row_to_logic_vec(const std::string names_row, size_t num_inputs, bool encoding_on_set) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const std::string names_row, size_t num_inputs, bool encoding_on_set)
NetlistWriterVisitor::other	base/netlist_writer.cpp	/^        NetlistWriterVisitor(NetlistWriterVisitor& other) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
NetlistWriterVisitor::other	base/netlist_writer.cpp	/^        NetlistWriterVisitor(NetlistWriterVisitor&& other) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
NetlistWriterVisitor::outputs_	base/netlist_writer.cpp	/^        std::vector<std::string> outputs_; \/\/Name of circuit outputs$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::pin_id_to_tnode_lookup_	base/netlist_writer.cpp	/^        std::map<std::pair<ClusterBlockId,int>,tatum::NodeId> pin_id_to_tnode_lookup_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::print_blif	base/netlist_writer.cpp	/^        void print_blif(int depth=0) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(int depth=0)
NetlistWriterVisitor::print_sdf	base/netlist_writer.cpp	/^        void print_sdf(int depth=0) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(int depth=0)
NetlistWriterVisitor::print_verilog	base/netlist_writer.cpp	/^        void print_verilog(int depth=0) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(int depth=0)
NetlistWriterVisitor::rhs	base/netlist_writer.cpp	/^        NetlistWriterVisitor& operator=(NetlistWriterVisitor& rhs) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
NetlistWriterVisitor::rhs	base/netlist_writer.cpp	/^        NetlistWriterVisitor& operator=(NetlistWriterVisitor&& rhs) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
NetlistWriterVisitor::sdf_os_	base/netlist_writer.cpp	/^        std::ostream& sdf_os_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::top_module_name_	base/netlist_writer.cpp	/^        std::string top_module_name_; \/\/Name of the top level module (i.e. the circuit)$/;"	m	class:NetlistWriterVisitor	file:	access:private
NetlistWriterVisitor::verilog_os_	base/netlist_writer.cpp	/^        std::ostream& verilog_os_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
NoOpLookahead	route/router_lookahead.h	/^class NoOpLookahead : public RouterLookahead {$/;"	c	inherits:RouterLookahead
NoOpLookahead::get_expected_cost	route/router_lookahead.cpp	/^float NoOpLookahead::get_expected_cost(int \/*current_node*\/, int \/*target_node*\/, const t_conn_cost_params& \/*params*\/, float \/*R_upstream*\/) const {$/;"	f	class:NoOpLookahead	signature:(int , int , const t_conn_cost_params& , float ) const
NoOpLookahead::override	route/router_lookahead.h	/^        float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const override;$/;"	m	class:NoOpLookahead	access:protected
OFF	../../libs/libeasygl/src/graphics.cpp	/^#define OFF /;"	d	file:
OFF	base/vpr_types.h	/^	OFF, SAFE, AGGRESSIVE$/;"	e	enum:ScreenUpdatePriority::e_routing_failure_predictor
OFF	base/vpr_types.h	/^    OFF, ON, AUTO	$/;"	m	class:ScreenUpdatePriority::e_unrelated_clustering	access:private
OFF	base/vpr_types.h	/^    OFF,$/;"	m	class:ScreenUpdatePriority::e_incr_reroute_delay_ripup	access:private
OFF_SCREEN	../../libs/libeasygl/src/easygl_constants.h	/^    OFF_SCREEN$/;"	e	enum:__anon15
OLDLACE	../../libs/libeasygl/src/easygl_constants.h	/^    OLDLACE,$/;"	e	enum:color_types
OLIVE	../../libs/libeasygl/src/easygl_constants.h	/^    OLIVE,$/;"	e	enum:color_types
OLIVEDRAB	../../libs/libeasygl/src/easygl_constants.h	/^    OLIVEDRAB,$/;"	e	enum:color_types
ON	../../libs/libeasygl/src/graphics.cpp	/^#define ON /;"	d	file:
ON	base/vpr_types.h	/^    OFF, ON, AUTO	$/;"	m	class:ScreenUpdatePriority::e_unrelated_clustering	access:private
ON	base/vpr_types.h	/^    ON,$/;"	m	class:ScreenUpdatePriority::e_incr_reroute_delay_ripup	access:private
ON_SCREEN	../../libs/libeasygl/src/easygl_constants.h	/^    ON_SCREEN = 0,$/;"	e	enum:__anon15
OPEN	../../libs/libarchfpga/src/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
OPEN	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
OPIN_COST_INDEX	base/vpr_types.h	/^	OPIN_COST_INDEX,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
OPTIONAL	../../libs/libpugiutil/src/pugixml_util.hpp	/^        OPTIONAL$/;"	e	enum:pugiutil::ReqOpt
ORANGE	../../libs/libeasygl/src/easygl_constants.h	/^    ORANGE,$/;"	e	enum:color_types
ORANGERED	../../libs/libeasygl/src/easygl_constants.h	/^    ORANGERED,$/;"	e	enum:color_types
ORCHID	../../libs/libeasygl/src/easygl_constants.h	/^    ORCHID,$/;"	e	enum:color_types
OUTPAD	base/atom_netlist_fwd.h	/^    OUTPAD,         \/\/A primary output$/;"	m	class:AtomBlockType	access:private
OUTPAD_NAME_PREFIX	base/read_blif.cpp	/^        static constexpr const char* OUTPAD_NAME_PREFIX = "out:";$/;"	m	struct:BlifAllocCallback	file:	access:public
OUTPUT	base/netlist_fwd.h	/^	OUTPUT, \/\/The port is an output (usually data, but potentially a clock)$/;"	m	class:PortType	access:private
OUTPUT	pack/cluster.cpp	/^	INPUT, OUTPUT$/;"	e	enum:e_net_relation_to_clustered_block	file:
OUTPUT_CLUSTERING_H	pack/output_clustering.h	/^#define OUTPUT_CLUSTERING_H$/;"	d
OUT_PORT	../../libs/libarchfpga/src/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard(const OsFormatGuard&&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&&)
OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard(const OsFormatGuard&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&)
OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        explicit OsFormatGuard(std::ostream& os)$/;"	f	class:vtr::OsFormatGuard	access:public	signature:(std::ostream& os)
OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^class OsFormatGuard {$/;"	c	namespace:vtr
OverrideDelayModel	place/place_delay_model.h	/^        OverrideDelayModel(std::unique_ptr<PlaceDelayModel> base_delay_model, t_router_opts router_opts)$/;"	f	class:OverrideDelayModel	access:public	signature:(std::unique_ptr<PlaceDelayModel> base_delay_model, t_router_opts router_opts)
OverrideDelayModel	place/place_delay_model.h	/^class OverrideDelayModel : public PlaceDelayModel {$/;"	c	inherits:PlaceDelayModel
OverrideDelayModel::OverrideDelayModel	place/place_delay_model.h	/^        OverrideDelayModel(std::unique_ptr<PlaceDelayModel> base_delay_model, t_router_opts router_opts)$/;"	f	class:OverrideDelayModel	access:public	signature:(std::unique_ptr<PlaceDelayModel> base_delay_model, t_router_opts router_opts)
OverrideDelayModel::base_delay_model_	place/place_delay_model.h	/^        std::unique_ptr<PlaceDelayModel> base_delay_model_;$/;"	m	class:OverrideDelayModel	access:private
OverrideDelayModel::delay	place/place_delay_model.cpp	/^float OverrideDelayModel::delay(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const {$/;"	f	class:OverrideDelayModel	signature:(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const
OverrideDelayModel::delay_overrides_	place/place_delay_model.h	/^        vtr::flat_map2<t_override,float> delay_overrides_;$/;"	m	class:OverrideDelayModel	access:private
OverrideDelayModel::dump_echo	place/place_delay_model.cpp	/^void OverrideDelayModel::dump_echo(std::string filepath) const {$/;"	f	class:OverrideDelayModel	signature:(std::string filepath) const
OverrideDelayModel::override	place/place_delay_model.h	/^        float delay(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const override;$/;"	m	class:OverrideDelayModel	access:public
OverrideDelayModel::override	place/place_delay_model.h	/^        void dump_echo(std::string filepath) const override;$/;"	m	class:OverrideDelayModel	access:public
OverrideDelayModel::router_opts_	place/place_delay_model.h	/^        t_router_opts router_opts_;$/;"	m	class:OverrideDelayModel	access:private
OverrideDelayModel::set_delay_override	place/place_delay_model.cpp	/^void OverrideDelayModel::set_delay_override(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay_val) {$/;"	f	class:OverrideDelayModel	signature:(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay_val)
OverrideDelayModel::set_delay_override	place/place_delay_model.h	/^        void set_delay_override(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay);$/;"	p	class:OverrideDelayModel	access:public	signature:(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay)
OverrideDelayModel::t_override	place/place_delay_model.h	/^        struct t_override {$/;"	s	class:OverrideDelayModel	access:private
OverrideDelayModel::t_override::delta_x	place/place_delay_model.h	/^            int delta_x;$/;"	m	struct:OverrideDelayModel::t_override	access:public
OverrideDelayModel::t_override::delta_y	place/place_delay_model.h	/^            int delta_y;$/;"	m	struct:OverrideDelayModel::t_override	access:public
OverrideDelayModel::t_override::from_class	place/place_delay_model.h	/^            int from_class;$/;"	m	struct:OverrideDelayModel::t_override	access:public
OverrideDelayModel::t_override::from_type	place/place_delay_model.h	/^            int from_type;$/;"	m	struct:OverrideDelayModel::t_override	access:public
OverrideDelayModel::t_override::operator <	place/place_delay_model.h	/^            friend bool operator<(const t_override& lhs, const t_override& rhs) {$/;"	f	struct:OverrideDelayModel::t_override	access:friend	signature:(const t_override& lhs, const t_override& rhs)
OverrideDelayModel::t_override::to_class	place/place_delay_model.h	/^            int to_class;$/;"	m	struct:OverrideDelayModel::t_override	access:public
OverrideDelayModel::t_override::to_type	place/place_delay_model.h	/^            int to_type;$/;"	m	struct:OverrideDelayModel::t_override	access:public
OveruseInfo	route/route_timing.cpp	/^    OveruseInfo(size_t total = 0u, size_t overused = 0u, size_t total_overuse_val = 0u, size_t worst_overuse_val = 0u)$/;"	f	class:OveruseInfo	access:public	signature:(size_t total = 0u, size_t overused = 0u, size_t total_overuse_val = 0u, size_t worst_overuse_val = 0u)
OveruseInfo	route/route_timing.cpp	/^class OveruseInfo {$/;"	c	file:
OveruseInfo::OveruseInfo	route/route_timing.cpp	/^    OveruseInfo(size_t total = 0u, size_t overused = 0u, size_t total_overuse_val = 0u, size_t worst_overuse_val = 0u)$/;"	f	class:OveruseInfo	access:public	signature:(size_t total = 0u, size_t overused = 0u, size_t total_overuse_val = 0u, size_t worst_overuse_val = 0u)
OveruseInfo::overused_node_ratio	route/route_timing.cpp	/^    float overused_node_ratio() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
OveruseInfo::overused_nodes	route/route_timing.cpp	/^    size_t overused_nodes() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
OveruseInfo::overused_nodes_	route/route_timing.cpp	/^    size_t overused_nodes_;$/;"	m	class:OveruseInfo	file:	access:private
OveruseInfo::total_nodes	route/route_timing.cpp	/^    size_t total_nodes() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
OveruseInfo::total_nodes_	route/route_timing.cpp	/^    size_t total_nodes_;$/;"	m	class:OveruseInfo	file:	access:private
OveruseInfo::total_overuse	route/route_timing.cpp	/^    size_t total_overuse() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
OveruseInfo::total_overuse_	route/route_timing.cpp	/^    size_t total_overuse_;$/;"	m	class:OveruseInfo	file:	access:private
OveruseInfo::worst_overuse	route/route_timing.cpp	/^    size_t worst_overuse() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
OveruseInfo::worst_overuse_	route/route_timing.cpp	/^    size_t worst_overuse_;$/;"	m	class:OveruseInfo	file:	access:private
PACK_BRUTE_FORCE	base/vpr_types.h	/^	PACK_GREEDY, PACK_BRUTE_FORCE$/;"	e	enum:ScreenUpdatePriority::e_packer_algorithm
PACK_GREEDY	base/vpr_types.h	/^	PACK_GREEDY, PACK_BRUTE_FORCE$/;"	e	enum:ScreenUpdatePriority::e_packer_algorithm
PACK_H	pack/pack.h	/^#define PACK_H$/;"	d
PACK_PATH_WEIGHT	timing/path_delay.h	/^	#define PACK_PATH_WEIGHT /;"	d
PACK_TYPES_H	pack/pack_types.h	/^#define PACK_TYPES_H$/;"	d
PALEGOLDENROD	../../libs/libeasygl/src/easygl_constants.h	/^    PALEGOLDENROD,$/;"	e	enum:color_types
PALEGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    PALEGREEN,$/;"	e	enum:color_types
PALETURQUOISE	../../libs/libeasygl/src/easygl_constants.h	/^    PALETURQUOISE,$/;"	e	enum:color_types
PALEVIOLETRED	../../libs/libeasygl/src/easygl_constants.h	/^    PALEVIOLETRED,$/;"	e	enum:color_types
PAPAYAWHIP	../../libs/libeasygl/src/easygl_constants.h	/^    PAPAYAWHIP,$/;"	e	enum:color_types
PARSE_SWITCHBLOCKS_H	../../libs/libarchfpga/src/parse_switchblocks.h	/^#define PARSE_SWITCHBLOCKS_H$/;"	d
PASS_GATE	../../libs/libarchfpga/src/physical_types.h	/^    PASS_GATE,      \/\/A configurable pass transitor switch (multi-driver)$/;"	m	class:SwitchType	access:private
PATH_DELAY	timing/path_delay.h	/^#define PATH_DELAY$/;"	d
PATH_DELAY2_H	timing/path_delay2.h	/^#define PATH_DELAY2_H$/;"	d
PATH_DELIM	../../libs/libvtrutil/src/vtr_path.cpp	/^const std::string PATH_DELIM = "\/";$/;"	m	namespace:vtr	file:
PATH_TIMING_DRIVEN_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:ScreenUpdatePriority::e_place_algorithm
PB_PIN_CLOCK	../../libs/libarchfpga/src/physical_types.h	/^	PB_PIN_CLOCK$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_INPAD	../../libs/libarchfpga/src/physical_types.h	/^	PB_PIN_INPAD,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_NORMAL	../../libs/libarchfpga/src/physical_types.h	/^	PB_PIN_NORMAL = 0,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_OUTPAD	../../libs/libarchfpga/src/physical_types.h	/^	PB_PIN_OUTPAD,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_SEQUENTIAL	../../libs/libarchfpga/src/physical_types.h	/^	PB_PIN_SEQUENTIAL,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_TERMINAL	../../libs/libarchfpga/src/physical_types.h	/^	PB_PIN_TERMINAL,$/;"	e	enum:e_pb_graph_pin_type
PB_TYPE_GRAPH_ANNOTATIONS_H	pack/pb_type_graph_annotations.h	/^#define PB_TYPE_GRAPH_ANNOTATIONS_H$/;"	d
PB_TYPE_GRAPH_H	pack/pb_type_graph.h	/^#define PB_TYPE_GRAPH_H$/;"	d
PEACHPUFF	../../libs/libeasygl/src/easygl_constants.h	/^    PEACHPUFF,$/;"	e	enum:color_types
PERU	../../libs/libeasygl/src/easygl_constants.h	/^    PERU,$/;"	e	enum:color_types
PHYSICAL_TYPES_H	../../libs/libarchfpga/src/physical_types.h	/^#define PHYSICAL_TYPES_H$/;"	d
PI	../../libs/libeasygl/src/fontcache.h	/^#define PI /;"	d
PI	../../libs/libeasygl/src/graphics.h	/^#define PI /;"	d
PICOSHA2_H	../../libs/libvtrutil/src/picosha2.h	/^#define PICOSHA2_H$/;"	d
PINK	../../libs/libeasygl/src/easygl_constants.h	/^    PINK,$/;"	e	enum:color_types
PIN_DIVERSITY	route/cb_metrics.h	/^	PIN_DIVERSITY,$/;"	e	enum:e_metric
PLACEMENT	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:ScreenUpdatePriority::pic_type
PLACEMENT_DELAY_CALCULATOR_H	timing/PlacementDelayCalculator.h	/^#define PLACEMENT_DELAY_CALCULATOR_H$/;"	d
PLACE_ALWAYS	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:ScreenUpdatePriority::pfreq
PLACE_DELAY_MODEL_H	place/place_delay_model.h	/^#define PLACE_DELAY_MODEL_H$/;"	d
PLACE_MACRO_H	place/place_macro.h	/^#define PLACE_MACRO_H$/;"	d
PLACE_NEVER	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:ScreenUpdatePriority::pfreq
PLACE_ONCE	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:ScreenUpdatePriority::pfreq
PLACE_PATH_WEIGHT	timing/path_delay.h	/^	#define PLACE_PATH_WEIGHT /;"	d
PLACE_UTIL_H	place/place_util.h	/^#define PLACE_UTIL_H$/;"	d
PLUM	../../libs/libeasygl/src/easygl_constants.h	/^    PLUM, \/\/ Much closer to pink than the colour of actual plums, and closer to its flower's colour$/;"	e	enum:color_types
PLUS	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
PLUSQ	timing/slre.cpp	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon10	file:
PMOS	power/power.h	/^	NMOS, PMOS$/;"	e	enum:e_tx_type
PMOS_1X_C_d	power/power.h	/^	float PMOS_1X_C_d;$/;"	m	struct:t_power_commonly_used	access:public
PMOS_1X_C_g	power/power.h	/^	float PMOS_1X_C_g;$/;"	m	struct:t_power_commonly_used	access:public
PMOS_1X_C_s	power/power.h	/^	float PMOS_1X_C_s;$/;"	m	struct:t_power_commonly_used	access:public
PMOS_1X_st_leakage	power/power.h	/^	float PMOS_1X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
PMOS_2X_st_leakage	power/power.h	/^	float PMOS_2X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
PMOS_inf	power/power.h	/^	t_transistor_inf PMOS_inf;$/;"	m	struct:t_power_tech	access:public
PN_ratio	power/power.h	/^	float PN_ratio; \/* Ratio of PMOS to NMOS in inverter *\/$/;"	m	struct:t_power_tech	access:public
PORTS	../../libs/libarchfpga/src/logic_types.h	/^enum PORTS {$/;"	g
POSITIVE	route/route_budgets.h	/^    POSITIVE, NEGATIVE, BOTH$/;"	e	enum:slack_allocated_type
POSTSCRIPT	../../libs/libeasygl/src/graphics_state.h	/^    POSTSCRIPT = 1$/;"	e	enum:__anon24
POST_CLUSTER_DELAY_CALCULATOR_H	timing/PostClusterDelayCalculator.h	/^#define POST_CLUSTER_DELAY_CALCULATOR_H$/;"	d
POWDERBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    POWDERBLUE,$/;"	e	enum:color_types
POWER_BREAKDOWN_ENTRY_TYPE_BUFS_WIRES	power/power.cpp	/^	POWER_BREAKDOWN_ENTRY_TYPE_BUFS_WIRES$/;"	e	enum:__anon5	file:
POWER_BREAKDOWN_ENTRY_TYPE_COMPONENT	power/power.cpp	/^	POWER_BREAKDOWN_ENTRY_TYPE_COMPONENT,$/;"	e	enum:__anon5	file:
POWER_BREAKDOWN_ENTRY_TYPE_INTERC	power/power.cpp	/^	POWER_BREAKDOWN_ENTRY_TYPE_INTERC,$/;"	e	enum:__anon5	file:
POWER_BREAKDOWN_ENTRY_TYPE_MODE	power/power.cpp	/^	POWER_BREAKDOWN_ENTRY_TYPE_MODE,$/;"	e	enum:__anon5	file:
POWER_BREAKDOWN_ENTRY_TYPE_PB	power/power.cpp	/^	POWER_BREAKDOWN_ENTRY_TYPE_PB,$/;"	e	enum:__anon5	file:
POWER_BREAKDOWN_ENTRY_TYPE_TITLE	power/power.cpp	/^	POWER_BREAKDOWN_ENTRY_TYPE_TITLE = 0,$/;"	e	enum:__anon5	file:
POWER_BUFFER_TYPE_ABSOLUTE_SIZE	../../libs/libarchfpga/src/physical_types.h	/^	POWER_BUFFER_TYPE_ABSOLUTE_SIZE$/;"	e	enum:e_power_buffer_type
POWER_BUFFER_TYPE_AUTO	../../libs/libarchfpga/src/physical_types.h	/^	POWER_BUFFER_TYPE_AUTO,$/;"	e	enum:e_power_buffer_type
POWER_BUFFER_TYPE_NONE	../../libs/libarchfpga/src/physical_types.h	/^	POWER_BUFFER_TYPE_NONE,$/;"	e	enum:e_power_buffer_type
POWER_BUFFER_TYPE_UNDEFINED	../../libs/libarchfpga/src/physical_types.h	/^	POWER_BUFFER_TYPE_UNDEFINED = 0,$/;"	e	enum:e_power_buffer_type
POWER_CALLIB_COMPONENT_BUFFER	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_BUFFER = 0,$/;"	e	enum:__anon3
POWER_CALLIB_COMPONENT_BUFFER_WITH_LEVR	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_BUFFER_WITH_LEVR,$/;"	e	enum:__anon3
POWER_CALLIB_COMPONENT_FF	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_FF,$/;"	e	enum:__anon3
POWER_CALLIB_COMPONENT_LUT	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_LUT,$/;"	e	enum:__anon3
POWER_CALLIB_COMPONENT_MAX	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_MAX$/;"	e	enum:__anon3
POWER_CALLIB_COMPONENT_MUX	power/power_callibrate.h	/^	POWER_CALLIB_COMPONENT_MUX,$/;"	e	enum:__anon3
POWER_COMPONENT_CLOCK	power/power_components.h	/^	POWER_COMPONENT_CLOCK, \/* Clock network *\/$/;"	e	enum:__anon4
POWER_COMPONENT_CLOCK_BUFFER	power/power_components.h	/^	POWER_COMPONENT_CLOCK_BUFFER, \/* Buffers in clock network *\/$/;"	e	enum:__anon4
POWER_COMPONENT_CLOCK_WIRE	power/power_components.h	/^	POWER_COMPONENT_CLOCK_WIRE, \/* Wires in clock network *\/$/;"	e	enum:__anon4
POWER_COMPONENT_IGNORE	power/power_components.h	/^	POWER_COMPONENT_IGNORE = 0, \/* *\/$/;"	e	enum:__anon4
POWER_COMPONENT_MAX_NUM	power/power_components.h	/^	POWER_COMPONENT_MAX_NUM$/;"	e	enum:__anon4
POWER_COMPONENT_PB	power/power_components.h	/^	POWER_COMPONENT_PB, \/* Logic Blocks, and other hard blocks *\/$/;"	e	enum:__anon4
POWER_COMPONENT_PB_BUFS_WIRE	power/power_components.h	/^	POWER_COMPONENT_PB_BUFS_WIRE, \/* Local buffers and wire capacitance *\/$/;"	e	enum:__anon4
POWER_COMPONENT_PB_INTERC_MUXES	power/power_components.h	/^	POWER_COMPONENT_PB_INTERC_MUXES, \/* Local interconnect structures (muxes) *\/$/;"	e	enum:__anon4
POWER_COMPONENT_PB_OTHER	power/power_components.h	/^	POWER_COMPONENT_PB_OTHER, \/* Power from other estimation methods - not transistor-level *\/$/;"	e	enum:__anon4
POWER_COMPONENT_PB_PRIMITIVES	power/power_components.h	/^	POWER_COMPONENT_PB_PRIMITIVES, \/* Primitives (LUTs, FF, etc) *\/$/;"	e	enum:__anon4
POWER_COMPONENT_ROUTE_CB	power/power_components.h	/^	POWER_COMPONENT_ROUTE_CB, \/* Connection box*\/$/;"	e	enum:__anon4
POWER_COMPONENT_ROUTE_GLB_WIRE	power/power_components.h	/^	POWER_COMPONENT_ROUTE_GLB_WIRE, \/* Wires *\/$/;"	e	enum:__anon4
POWER_COMPONENT_ROUTE_SB	power/power_components.h	/^	POWER_COMPONENT_ROUTE_SB, \/* Switch-box *\/$/;"	e	enum:__anon4
POWER_COMPONENT_ROUTING	power/power_components.h	/^	POWER_COMPONENT_ROUTING, \/* Power for routing fabric (not local routing) *\/$/;"	e	enum:__anon4
POWER_COMPONENT_TOTAL	power/power_components.h	/^	POWER_COMPONENT_TOTAL, \/* Total power for entire FPGA *\/$/;"	e	enum:__anon4
POWER_DRC_MIN_DIFF_L	power/power_sizing.h	/^#define POWER_DRC_MIN_DIFF_L /;"	d
POWER_DRC_MIN_L	power/power_sizing.h	/^#define POWER_DRC_MIN_L /;"	d
POWER_DRC_MIN_W	power/power_sizing.h	/^#define POWER_DRC_MIN_W /;"	d
POWER_DRC_POLY_OVERHANG	power/power_sizing.h	/^#define POWER_DRC_POLY_OVERHANG /;"	d
POWER_DRC_SPACING	power/power_sizing.h	/^#define POWER_DRC_SPACING /;"	d
POWER_LOG_ERROR	power/power.h	/^	POWER_LOG_ERROR, POWER_LOG_WARNING, POWER_LOG_NUM_TYPES$/;"	e	enum:__anon2
POWER_LOG_NUM_TYPES	power/power.h	/^	POWER_LOG_ERROR, POWER_LOG_WARNING, POWER_LOG_NUM_TYPES$/;"	e	enum:__anon2
POWER_LOG_WARNING	power/power.h	/^	POWER_LOG_ERROR, POWER_LOG_WARNING, POWER_LOG_NUM_TYPES$/;"	e	enum:__anon2
POWER_LUT_SLOW	power/power_components.h	/^#define POWER_LUT_SLOW$/;"	d
POWER_METHOD_ABSOLUTE	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_ABSOLUTE \/* Dynamic: Aboslute, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_AUTO_SIZES	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_AUTO_SIZES, \/* Transistor-level, auto-sized buffers\/wires *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_C_INTERNAL	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_C_INTERNAL, \/* Dynamic: Equiv. Internal capacitance, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_IGNORE	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_UNDEFINED = 0, POWER_METHOD_IGNORE, \/* Ignore power of this PB, and all children PB *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_SPECIFY_SIZES	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_SPECIFY_SIZES, \/* Transistor-level, user-specified buffers\/wires *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_SUM_OF_CHILDREN	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_SUM_OF_CHILDREN, \/* Ignore power of this PB, but consider children *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_TOGGLE_PINS	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_TOGGLE_PINS, \/* Dynamic: Energy per pin toggle, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_UNDEFINED	../../libs/libarchfpga/src/physical_types.h	/^	POWER_METHOD_UNDEFINED = 0, POWER_METHOD_IGNORE, \/* Ignore power of this PB, and all children PB *\/$/;"	e	enum:e_power_estimation_method_
POWER_MTA_L	power/power_sizing.h	/^#define POWER_MTA_L /;"	d
POWER_MTA_W	power/power_sizing.h	/^#define POWER_MTA_W /;"	d
POWER_RET_CODE_ERRORS	power/power.h	/^	POWER_RET_CODE_SUCCESS = 0, POWER_RET_CODE_ERRORS, POWER_RET_CODE_WARNINGS$/;"	e	enum:__anon1
POWER_RET_CODE_SUCCESS	power/power.h	/^	POWER_RET_CODE_SUCCESS = 0, POWER_RET_CODE_ERRORS, POWER_RET_CODE_WARNINGS$/;"	e	enum:__anon1
POWER_RET_CODE_WARNINGS	power/power.h	/^	POWER_RET_CODE_SUCCESS = 0, POWER_RET_CODE_ERRORS, POWER_RET_CODE_WARNINGS$/;"	e	enum:__anon1
POWER_WIRE_TYPE_ABSOLUTE_LENGTH	../../libs/libarchfpga/src/physical_types.h	/^	POWER_WIRE_TYPE_ABSOLUTE_LENGTH,$/;"	e	enum:e_power_wire_type
POWER_WIRE_TYPE_AUTO	../../libs/libarchfpga/src/physical_types.h	/^	POWER_WIRE_TYPE_AUTO$/;"	e	enum:e_power_wire_type
POWER_WIRE_TYPE_C	../../libs/libarchfpga/src/physical_types.h	/^	POWER_WIRE_TYPE_C,$/;"	e	enum:e_power_wire_type
POWER_WIRE_TYPE_IGNORED	../../libs/libarchfpga/src/physical_types.h	/^	POWER_WIRE_TYPE_IGNORED,$/;"	e	enum:e_power_wire_type
POWER_WIRE_TYPE_RELATIVE_LENGTH	../../libs/libarchfpga/src/physical_types.h	/^	POWER_WIRE_TYPE_RELATIVE_LENGTH,$/;"	e	enum:e_power_wire_type
POWER_WIRE_TYPE_UNDEFINED	../../libs/libarchfpga/src/physical_types.h	/^	POWER_WIRE_TYPE_UNDEFINED = 0,$/;"	e	enum:e_power_wire_type
PQ_Entry	route/router_lookahead_map.cpp	/^	PQ_Entry(int set_rr_node_ind, int \/*switch_ind*\/, float parent_delay, float parent_R_upstream, float parent_congestion_upstream, bool starting_node){$/;"	f	class:PQ_Entry	access:public	signature:(int set_rr_node_ind, int , float parent_delay, float parent_R_upstream, float parent_congestion_upstream, bool starting_node)
PQ_Entry	route/router_lookahead_map.cpp	/^class PQ_Entry{$/;"	c	file:
PQ_Entry::PQ_Entry	route/router_lookahead_map.cpp	/^	PQ_Entry(int set_rr_node_ind, int \/*switch_ind*\/, float parent_delay, float parent_R_upstream, float parent_congestion_upstream, bool starting_node){$/;"	f	class:PQ_Entry	access:public	signature:(int set_rr_node_ind, int , float parent_delay, float parent_R_upstream, float parent_congestion_upstream, bool starting_node)
PQ_Entry::R_upstream	route/router_lookahead_map.cpp	/^	float R_upstream;$/;"	m	class:PQ_Entry	file:	access:public
PQ_Entry::congestion_upstream	route/router_lookahead_map.cpp	/^	float congestion_upstream;$/;"	m	class:PQ_Entry	file:	access:public
PQ_Entry::cost	route/router_lookahead_map.cpp	/^	float cost;          \/\/the cost of the path to get to this node$/;"	m	class:PQ_Entry	file:	access:public
PQ_Entry::delay	route/router_lookahead_map.cpp	/^	float delay;$/;"	m	class:PQ_Entry	file:	access:public
PQ_Entry::operator <	route/router_lookahead_map.cpp	/^	bool operator < (const PQ_Entry &obj) const{$/;"	f	class:PQ_Entry	access:public	signature:(const PQ_Entry &obj) const
PQ_Entry::rr_node_ind	route/router_lookahead_map.cpp	/^	int rr_node_ind;     \/\/index in device_ctx.rr_nodes that this entry represents$/;"	m	class:PQ_Entry	file:	access:public
PREPACK_H	pack/prepack.h	/^#define PREPACK_H$/;"	d
PRE_CLUSTER_DELAY_CALCULATOR_H	timing/PreClusterDelayCalculator.h	/^#define PRE_CLUSTER_DELAY_CALCULATOR_H$/;"	d
PROC_TIME	base/place_and_route.h	/^#define PROC_TIME /;"	d
PUGIXML_API	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_API$/;"	d
PUGIXML_CHAR	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_CHAR /;"	d
PUGIXML_CLASS	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_CLASS /;"	d
PUGIXML_DEPRECATED	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#		define PUGIXML_DEPRECATED /;"	d
PUGIXML_DEPRECATED	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#		define PUGIXML_DEPRECATED$/;"	d
PUGIXML_FUNCTION	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_FUNCTION /;"	d
PUGIXML_HAS_LONG_LONG	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#		define PUGIXML_HAS_LONG_LONG$/;"	d
PUGIXML_LOC_H	../../libs/libpugiutil/src/pugixml_loc.hpp	/^#define PUGIXML_LOC_H$/;"	d
PUGIXML_SOURCE	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_SOURCE /;"	d
PUGIXML_TEXT	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_TEXT(/;"	d
PUGIXML_UTIL_H	../../libs/libpugiutil/src/pugixml_util.hpp	/^#define PUGIXML_UTIL_H$/;"	d
PUGIXML_VERSION	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^#	define PUGIXML_VERSION /;"	d
PUGI__CHECK_ERROR	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__CHECK_ERROR(/;"	d	file:
PUGI__CHECK_ERROR	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__CHECK_ERROR$/;"	d	file:
PUGI__DMC_VOLATILE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__DMC_VOLATILE /;"	d	file:
PUGI__DMC_VOLATILE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__DMC_VOLATILE$/;"	d	file:
PUGI__DMC_VOLATILE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__DMC_VOLATILE$/;"	d	file:
PUGI__ENDSEG	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__ENDSEG(/;"	d	file:
PUGI__ENDSEG	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__ENDSEG$/;"	d	file:
PUGI__ENDSWITH	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__ENDSWITH(/;"	d	file:
PUGI__ENDSWITH	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__ENDSWITH$/;"	d	file:
PUGI__FN	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__FN /;"	d	file:
PUGI__FN	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__FN$/;"	d	file:
PUGI__FN_NO_INLINE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__FN_NO_INLINE /;"	d	file:
PUGI__FN_NO_INLINE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__FN_NO_INLINE$/;"	d	file:
PUGI__GETPAGE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__GETPAGE(/;"	d	file:
PUGI__GETPAGE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__GETPAGE$/;"	d	file:
PUGI__GETPAGE_IMPL	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__GETPAGE_IMPL(/;"	d	file:
PUGI__GETPAGE_IMPL	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__GETPAGE_IMPL$/;"	d	file:
PUGI__IS_CHARTYPE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__IS_CHARTYPE(/;"	d	file:
PUGI__IS_CHARTYPE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__IS_CHARTYPE$/;"	d	file:
PUGI__IS_CHARTYPEX	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__IS_CHARTYPEX(/;"	d	file:
PUGI__IS_CHARTYPEX	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__IS_CHARTYPEX$/;"	d	file:
PUGI__IS_CHARTYPE_IMPL	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__IS_CHARTYPE_IMPL(/;"	d	file:
PUGI__IS_CHARTYPE_IMPL	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__IS_CHARTYPE_IMPL$/;"	d	file:
PUGI__MSVC_CRT_VERSION	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__MSVC_CRT_VERSION /;"	d	file:
PUGI__MSVC_CRT_VERSION	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__MSVC_CRT_VERSION$/;"	d	file:
PUGI__NODETYPE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__NODETYPE(/;"	d	file:
PUGI__NODETYPE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__NODETYPE$/;"	d	file:
PUGI__NO_INLINE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__NO_INLINE /;"	d	file:
PUGI__NO_INLINE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__NO_INLINE$/;"	d	file:
PUGI__NS_BEGIN	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__NS_BEGIN /;"	d	file:
PUGI__NS_BEGIN	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__NS_BEGIN$/;"	d	file:
PUGI__NS_END	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__NS_END /;"	d	file:
PUGI__NS_END	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__NS_END$/;"	d	file:
PUGI__OPTSET	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__OPTSET(/;"	d	file:
PUGI__OPTSET	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__OPTSET$/;"	d	file:
PUGI__POPNODE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__POPNODE(/;"	d	file:
PUGI__POPNODE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__POPNODE$/;"	d	file:
PUGI__PUSHNODE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__PUSHNODE(/;"	d	file:
PUGI__PUSHNODE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__PUSHNODE$/;"	d	file:
PUGI__SCANFOR	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__SCANFOR(/;"	d	file:
PUGI__SCANFOR	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__SCANFOR$/;"	d	file:
PUGI__SCANWHILE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__SCANWHILE(/;"	d	file:
PUGI__SCANWHILE	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__SCANWHILE$/;"	d	file:
PUGI__SCANWHILE_UNROLL	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__SCANWHILE_UNROLL(/;"	d	file:
PUGI__SCANWHILE_UNROLL	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__SCANWHILE_UNROLL$/;"	d	file:
PUGI__SKIPWS	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__SKIPWS(/;"	d	file:
PUGI__SKIPWS	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__SKIPWS$/;"	d	file:
PUGI__STATIC_ASSERT	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#define PUGI__STATIC_ASSERT(/;"	d	file:
PUGI__STATIC_ASSERT	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__STATIC_ASSERT$/;"	d	file:
PUGI__THROW_ERROR	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	#define PUGI__THROW_ERROR(/;"	d	file:
PUGI__THROW_ERROR	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__THROW_ERROR$/;"	d	file:
PUGI__UNLIKELY	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#	define PUGI__UNLIKELY(/;"	d	file:
PUGI__UNLIKELY	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#undef PUGI__UNLIKELY$/;"	d	file:
PULSE	../../libs/libarchfpga/src/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
PURPLE	../../libs/libeasygl/src/easygl_constants.h	/^    PURPLE,$/;"	e	enum:color_types
PackerOpts	base/vpr_types.h	/^	t_packer_opts PackerOpts; \/* Options for packer *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
PackerRRGraph	base/vpr_types.h	/^	std::vector <t_lb_type_rr_node> *PackerRRGraph;$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ParseBaseCost	base/read_options.cpp	/^struct ParseBaseCost {$/;"	s	file:
ParseBaseCost::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseBaseCost	access:public	signature:()
ParseBaseCost::from_str	base/read_options.cpp	/^    ConvertedValue<e_base_cost_type> from_str(std::string str) {$/;"	f	struct:ParseBaseCost	access:public	signature:(std::string str)
ParseBaseCost::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_base_cost_type val) {$/;"	f	struct:ParseBaseCost	access:public	signature:(e_base_cost_type val)
ParseCircuitFormat	base/read_options.cpp	/^struct ParseCircuitFormat {$/;"	s	file:
ParseCircuitFormat::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseCircuitFormat	access:public	signature:()
ParseCircuitFormat::from_str	base/read_options.cpp	/^    ConvertedValue<e_circuit_format> from_str(std::string str) {$/;"	f	struct:ParseCircuitFormat	access:public	signature:(std::string str)
ParseCircuitFormat::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_circuit_format val) {$/;"	f	struct:ParseCircuitFormat	access:public	signature:(e_circuit_format val)
ParseClockModeling	base/read_options.cpp	/^struct ParseClockModeling {$/;"	s	file:
ParseClockModeling::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseClockModeling	access:public	signature:()
ParseClockModeling::from_str	base/read_options.cpp	/^    ConvertedValue<e_clock_modeling> from_str(std::string str) {$/;"	f	struct:ParseClockModeling	access:public	signature:(std::string str)
ParseClockModeling::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_clock_modeling val) {$/;"	f	struct:ParseClockModeling	access:public	signature:(e_clock_modeling val)
ParseClusterSeed	base/read_options.cpp	/^struct ParseClusterSeed {$/;"	s	file:
ParseClusterSeed::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseClusterSeed	access:public	signature:()
ParseClusterSeed::from_str	base/read_options.cpp	/^    ConvertedValue<e_cluster_seed> from_str(std::string str) {$/;"	f	struct:ParseClusterSeed	access:public	signature:(std::string str)
ParseClusterSeed::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_cluster_seed val) {$/;"	f	struct:ParseClusterSeed	access:public	signature:(e_cluster_seed val)
ParseConstGenInference	base/read_options.cpp	/^struct ParseConstGenInference{$/;"	s	file:
ParseConstGenInference::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseConstGenInference	access:public	signature:()
ParseConstGenInference::from_str	base/read_options.cpp	/^    ConvertedValue<e_const_gen_inference> from_str(std::string str) {$/;"	f	struct:ParseConstGenInference	access:public	signature:(std::string str)
ParseConstGenInference::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_const_gen_inference val) {$/;"	f	struct:ParseConstGenInference	access:public	signature:(e_const_gen_inference val)
ParseConstantNetMethod	base/read_options.cpp	/^struct ParseConstantNetMethod {$/;"	s	file:
ParseConstantNetMethod::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseConstantNetMethod	access:public	signature:()
ParseConstantNetMethod::from_str	base/read_options.cpp	/^    ConvertedValue<e_constant_net_method> from_str(std::string str) {$/;"	f	struct:ParseConstantNetMethod	access:public	signature:(std::string str)
ParseConstantNetMethod::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_constant_net_method val) {$/;"	f	struct:ParseConstantNetMethod	access:public	signature:(e_constant_net_method val)
ParseIncrRerouteDelayRipup	base/read_options.cpp	/^struct ParseIncrRerouteDelayRipup {$/;"	s	file:
ParseIncrRerouteDelayRipup::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseIncrRerouteDelayRipup	access:public	signature:()
ParseIncrRerouteDelayRipup::from_str	base/read_options.cpp	/^    ConvertedValue<e_incr_reroute_delay_ripup> from_str(std::string str) {$/;"	f	struct:ParseIncrRerouteDelayRipup	access:public	signature:(std::string str)
ParseIncrRerouteDelayRipup::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_incr_reroute_delay_ripup val) {$/;"	f	struct:ParseIncrRerouteDelayRipup	access:public	signature:(e_incr_reroute_delay_ripup val)
ParseOnOff	base/read_options.cpp	/^struct ParseOnOff {$/;"	s	file:
ParseOnOff::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseOnOff	access:public	signature:()
ParseOnOff::from_str	base/read_options.cpp	/^    ConvertedValue<bool> from_str(std::string str) {$/;"	f	struct:ParseOnOff	access:public	signature:(std::string str)
ParseOnOff::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(bool val) {$/;"	f	struct:ParseOnOff	access:public	signature:(bool val)
ParsePlaceAlgorithm	base/read_options.cpp	/^struct ParsePlaceAlgorithm {$/;"	s	file:
ParsePlaceAlgorithm::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParsePlaceAlgorithm	access:public	signature:()
ParsePlaceAlgorithm::from_str	base/read_options.cpp	/^    ConvertedValue<e_place_algorithm> from_str(std::string str) {$/;"	f	struct:ParsePlaceAlgorithm	access:public	signature:(std::string str)
ParsePlaceAlgorithm::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_place_algorithm val) {$/;"	f	struct:ParsePlaceAlgorithm	access:public	signature:(e_place_algorithm val)
ParsePlaceDelayModel	base/read_options.cpp	/^struct ParsePlaceDelayModel {$/;"	s	file:
ParsePlaceDelayModel::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParsePlaceDelayModel	access:public	signature:()
ParsePlaceDelayModel::from_str	base/read_options.cpp	/^    ConvertedValue<PlaceDelayModelType> from_str(std::string str) {$/;"	f	struct:ParsePlaceDelayModel	access:public	signature:(std::string str)
ParsePlaceDelayModel::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(PlaceDelayModelType val) {$/;"	f	struct:ParsePlaceDelayModel	access:public	signature:(PlaceDelayModelType val)
ParseReducer	base/read_options.cpp	/^struct ParseReducer {$/;"	s	file:
ParseReducer::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseReducer	access:public	signature:()
ParseReducer::from_str	base/read_options.cpp	/^    ConvertedValue<e_reducer> from_str(std::string str) {$/;"	f	struct:ParseReducer	access:public	signature:(std::string str)
ParseReducer::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_reducer val) {$/;"	f	struct:ParseReducer	access:public	signature:(e_reducer val)
ParseRouteBBUpdate	base/read_options.cpp	/^struct ParseRouteBBUpdate {$/;"	s	file:
ParseRouteBBUpdate::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouteBBUpdate	access:public	signature:()
ParseRouteBBUpdate::from_str	base/read_options.cpp	/^    ConvertedValue<e_route_bb_update> from_str(std::string str) {$/;"	f	struct:ParseRouteBBUpdate	access:public	signature:(std::string str)
ParseRouteBBUpdate::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_route_bb_update val) {$/;"	f	struct:ParseRouteBBUpdate	access:public	signature:(e_route_bb_update val)
ParseRoutePredictor	base/read_options.cpp	/^struct ParseRoutePredictor {$/;"	s	file:
ParseRoutePredictor::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRoutePredictor	access:public	signature:()
ParseRoutePredictor::from_str	base/read_options.cpp	/^    ConvertedValue<e_routing_failure_predictor> from_str(std::string str) {$/;"	f	struct:ParseRoutePredictor	access:public	signature:(std::string str)
ParseRoutePredictor::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_routing_failure_predictor val) {$/;"	f	struct:ParseRoutePredictor	access:public	signature:(e_routing_failure_predictor val)
ParseRouteType	base/read_options.cpp	/^struct ParseRouteType {$/;"	s	file:
ParseRouteType::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouteType	access:public	signature:()
ParseRouteType::from_str	base/read_options.cpp	/^    ConvertedValue<e_route_type> from_str(std::string str) {$/;"	f	struct:ParseRouteType	access:public	signature:(std::string str)
ParseRouteType::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_route_type val) {$/;"	f	struct:ParseRouteType	access:public	signature:(e_route_type val)
ParseRouterAlgorithm	base/read_options.cpp	/^struct ParseRouterAlgorithm {$/;"	s	file:
ParseRouterAlgorithm::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouterAlgorithm	access:public	signature:()
ParseRouterAlgorithm::from_str	base/read_options.cpp	/^    ConvertedValue<e_router_algorithm> from_str(std::string str) {$/;"	f	struct:ParseRouterAlgorithm	access:public	signature:(std::string str)
ParseRouterAlgorithm::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_router_algorithm val) {$/;"	f	struct:ParseRouterAlgorithm	access:public	signature:(e_router_algorithm val)
ParseRouterLookahead	base/read_options.cpp	/^struct ParseRouterLookahead {$/;"	s	file:
ParseRouterLookahead::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouterLookahead	access:public	signature:()
ParseRouterLookahead::from_str	base/read_options.cpp	/^    ConvertedValue<e_router_lookahead> from_str(std::string str) {$/;"	f	struct:ParseRouterLookahead	access:public	signature:(std::string str)
ParseRouterLookahead::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_router_lookahead val) {$/;"	f	struct:ParseRouterLookahead	access:public	signature:(e_router_lookahead val)
ParseTimingReportDetail	base/read_options.cpp	/^struct ParseTimingReportDetail {$/;"	s	file:
ParseTimingReportDetail::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseTimingReportDetail	access:public	signature:()
ParseTimingReportDetail::from_str	base/read_options.cpp	/^    ConvertedValue<e_timing_report_detail> from_str(std::string str) {$/;"	f	struct:ParseTimingReportDetail	access:public	signature:(std::string str)
ParseTimingReportDetail::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_timing_report_detail val) {$/;"	f	struct:ParseTimingReportDetail	access:public	signature:(e_timing_report_detail val)
ParseUnrelatedClustering	base/read_options.cpp	/^struct ParseUnrelatedClustering {$/;"	s	file:
ParseUnrelatedClustering::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseUnrelatedClustering	access:public	signature:()
ParseUnrelatedClustering::from_str	base/read_options.cpp	/^    ConvertedValue<e_unrelated_clustering> from_str(std::string str) {$/;"	f	struct:ParseUnrelatedClustering	access:public	signature:(std::string str)
ParseUnrelatedClustering::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_unrelated_clustering val) {$/;"	f	struct:ParseUnrelatedClustering	access:public	signature:(e_unrelated_clustering val)
PinType	base/netlist_fwd.h	/^enum class PinType : char {$/;"	c
PinType::DRIVER	base/netlist_fwd.h	/^	DRIVER,	\/\/The pin drives a net$/;"	m	class:PinType	access:private
PinType::SINK	base/netlist_fwd.h	/^	SINK,	\/\/The pin is a net sink$/;"	m	class:PinType	access:private
PlaceAlgorithm	base/read_options.h	/^    argparse::ArgValue<e_place_algorithm> PlaceAlgorithm;$/;"	m	struct:t_options	access:public
PlaceAlphaT	base/read_options.h	/^    argparse::ArgValue<float> PlaceAlphaT;$/;"	m	struct:t_options	access:public
PlaceChanWidth	base/read_options.h	/^    argparse::ArgValue<int> PlaceChanWidth;$/;"	m	struct:t_options	access:public
PlaceDelayModel	place/place_delay_model.h	/^class PlaceDelayModel {$/;"	c
PlaceDelayModel::delay	place/place_delay_model.h	/^        virtual float delay(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const = 0;$/;"	p	class:PlaceDelayModel	access:public	signature:(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const
PlaceDelayModel::dump_echo	place/place_delay_model.h	/^        virtual void dump_echo(std::string filename) const = 0;$/;"	p	class:PlaceDelayModel	access:public	signature:(std::string filename) const
PlaceDelayModel::~PlaceDelayModel	place/place_delay_model.h	/^        virtual ~PlaceDelayModel() = default;$/;"	p	class:PlaceDelayModel	access:public	signature:()
PlaceDelayModelType	base/vpr_types.h	/^enum class PlaceDelayModelType {$/;"	c	class:ScreenUpdatePriority	access:private
PlaceExitT	base/read_options.h	/^    argparse::ArgValue<float> PlaceExitT;$/;"	m	struct:t_options	access:public
PlaceFile	base/read_options.h	/^    argparse::ArgValue<std::string> PlaceFile;$/;"	m	struct:t_options	access:public
PlaceFile	base/vpr_types.h	/^	std::string PlaceFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
PlaceInitT	base/read_options.h	/^    argparse::ArgValue<float> PlaceInitT;$/;"	m	struct:t_options	access:public
PlaceInnerNum	base/read_options.h	/^    argparse::ArgValue<float> PlaceInnerNum;$/;"	m	struct:t_options	access:public
PlaceTimingTradeoff	base/read_options.h	/^    argparse::ArgValue<float> PlaceTimingTradeoff;$/;"	m	struct:t_options	access:public
PlacementContext	base/vpr_context.h	/^struct PlacementContext : public Context {$/;"	s	inherits:Context
PlacementContext::block_locs	base/vpr_context.h	/^    vtr::vector_map<ClusterBlockId, t_block_loc> block_locs;$/;"	m	struct:PlacementContext	access:public
PlacementContext::grid_blocks	base/vpr_context.h	/^    vtr::Matrix<t_grid_blocks> grid_blocks; \/\/[0..device_ctx.grid.width()-1][0..device_ctx.grid.width()-1]$/;"	m	struct:PlacementContext	access:public
PlacementContext::placement_id	base/vpr_context.h	/^    std::string placement_id;$/;"	m	struct:PlacementContext	access:public
PlacerOpts	base/vpr_types.h	/^	t_placer_opts PlacerOpts; \/* Options for placer *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
PlasmaColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^PlasmaColorMap::PlasmaColorMap(float min_val, float max_val)$/;"	f	class:vtr::PlasmaColorMap	signature:(float min_val, float max_val)
PlasmaColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        PlasmaColorMap(float min, float max);$/;"	p	class:vtr::PlasmaColorMap	access:public	signature:(float min, float max)
PlasmaColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class PlasmaColorMap : public ColorMap {$/;"	c	namespace:vtr	inherits:ColorMap
Point	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point(T x_val, T y_val);$/;"	p	class:vtr::Point	access:public	signature:(T x_val, T y_val)
Point	../../libs/libvtrutil/src/vtr_geometry.h	/^class Point {$/;"	c	namespace:vtr
Point	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Point<T>::Point(T x_val, T y_val) $/;"	f	class:vtr::Point	signature:(T x_val, T y_val)
PortEquivalence	../../libs/libarchfpga/src/physical_types.h	/^enum class PortEquivalence {$/;"	c
PortEquivalence::FULL	../../libs/libarchfpga/src/physical_types.h	/^    FULL,    \/\/The pins within the port are fully equivalent and can be freely swapped (e.g. logically equivalent or modelling a full-crossbar)$/;"	m	class:PortEquivalence	access:private
PortEquivalence::NONE	../../libs/libarchfpga/src/physical_types.h	/^    NONE,    \/\/The pins within the port are not equivalent and can not be swapped$/;"	m	class:PortEquivalence	access:private
PortType	base/netlist_fwd.h	/^enum class PortType : char {$/;"	c
PortType::INPUT	base/netlist_fwd.h	/^	INPUT,  \/\/The port is a data-input$/;"	m	class:PortType	access:private
PortType::OUTPUT	base/netlist_fwd.h	/^	OUTPUT, \/\/The port is an output (usually data, but potentially a clock)$/;"	m	class:PortType	access:private
PostClusterDelayCalculator	timing/PostClusterDelayCalculator.h	/^    PostClusterDelayCalculator(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	class:PostClusterDelayCalculator	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
PostClusterDelayCalculator	timing/PostClusterDelayCalculator.h	/^class PostClusterDelayCalculator : public tatum::DelayCalculator {$/;"	c	inherits:tatum::DelayCalculator
PostClusterDelayCalculator	timing/PostClusterDelayCalculator.tpp	/^inline PostClusterDelayCalculator::PostClusterDelayCalculator(const AtomNetlist& netlist, $/;"	f	class:PostClusterDelayCalculator	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
PostClusterDelayCalculator::PostClusterDelayCalculator	timing/PostClusterDelayCalculator.h	/^    PostClusterDelayCalculator(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	class:PostClusterDelayCalculator	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
PostClusterDelayCalculator::PostClusterDelayCalculator	timing/PostClusterDelayCalculator.tpp	/^inline PostClusterDelayCalculator::PostClusterDelayCalculator(const AtomNetlist& netlist, $/;"	f	class:PostClusterDelayCalculator	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
PostClusterDelayCalculator::atom_clock_to_q_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_clock_to_q_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::atom_clock_to_q_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_clock_to_q_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::atom_combinational_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_combinational_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::atom_combinational_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_combinational_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::atom_delay_calc_	timing/PostClusterDelayCalculator.h	/^    AtomDelayCalc atom_delay_calc_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::atom_hold_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::atom_hold_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::atom_net_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_net_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::atom_net_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_net_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::atom_setup_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::atom_setup_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::calc_edge_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time calc_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
PostClusterDelayCalculator::calc_edge_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::calc_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::clb_delay_calc_	timing/PostClusterDelayCalculator.h	/^    ClbDelayCalc clb_delay_calc_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::clear_cache	timing/PostClusterDelayCalculator.h	/^    void clear_cache();$/;"	p	class:PostClusterDelayCalculator	access:public	signature:()
PostClusterDelayCalculator::clear_cache	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::clear_cache() {$/;"	f	class:PostClusterDelayCalculator	signature:()
PostClusterDelayCalculator::driver_clb_max_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> driver_clb_max_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::driver_clb_min_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> driver_clb_min_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::edge_max_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> edge_max_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::edge_min_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> edge_min_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::get_cached_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_cached_delay(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_cached_delay(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_cached_hold_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_cached_hold_time(tatum::EdgeId edge) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge) const
PostClusterDelayCalculator::get_cached_hold_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_cached_hold_time(tatum::EdgeId edge) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge) const
PostClusterDelayCalculator::get_cached_pins	timing/PostClusterDelayCalculator.h	/^    std::pair<ClusterPinId,ClusterPinId> get_cached_pins(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_cached_pins	timing/PostClusterDelayCalculator.tpp	/^inline std::pair<ClusterPinId,ClusterPinId> PostClusterDelayCalculator::get_cached_pins(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_cached_setup_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_cached_setup_time(tatum::EdgeId edge) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge) const
PostClusterDelayCalculator::get_cached_setup_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_cached_setup_time(tatum::EdgeId edge) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge) const
PostClusterDelayCalculator::get_driver_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_driver_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_sink_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::get_sink_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
PostClusterDelayCalculator::hold_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::inter_cluster_delay	timing/PostClusterDelayCalculator.h	/^	float inter_cluster_delay(ClusterNetId net_id, const int driver_net_pin_index, const int sink_net_pin_index) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(ClusterNetId net_id, const int driver_net_pin_index, const int sink_net_pin_index) const
PostClusterDelayCalculator::inter_cluster_delay	timing/PostClusterDelayCalculator.tpp	/^inline float PostClusterDelayCalculator::inter_cluster_delay(const ClusterNetId net_id, const int src_net_pin_index, const int sink_net_pin_index) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const ClusterNetId net_id, const int src_net_pin_index, const int sink_net_pin_index) const
PostClusterDelayCalculator::max_edge_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::max_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::min_edge_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::min_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::net_delay_	timing/PostClusterDelayCalculator.h	/^	vtr::vector<ClusterNetId, float *> net_delay_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::netlist_	timing/PostClusterDelayCalculator.h	/^    const AtomNetlist& netlist_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::netlist_lookup_	timing/PostClusterDelayCalculator.h	/^    const AtomLookup& netlist_lookup_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::override	timing/PostClusterDelayCalculator.h	/^    tatum::Time hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
PostClusterDelayCalculator::override	timing/PostClusterDelayCalculator.h	/^    tatum::Time max_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
PostClusterDelayCalculator::override	timing/PostClusterDelayCalculator.h	/^    tatum::Time min_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
PostClusterDelayCalculator::override	timing/PostClusterDelayCalculator.h	/^    tatum::Time setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
PostClusterDelayCalculator::pin_cache_max_	timing/PostClusterDelayCalculator.h	/^	mutable vtr::vector<tatum::EdgeId,std::pair<ClusterPinId,ClusterPinId>> pin_cache_max_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::pin_cache_min_	timing/PostClusterDelayCalculator.h	/^	mutable vtr::vector<tatum::EdgeId,std::pair<ClusterPinId,ClusterPinId>> pin_cache_min_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::set_cached_delay	timing/PostClusterDelayCalculator.h	/^    void set_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
PostClusterDelayCalculator::set_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
PostClusterDelayCalculator::set_cached_hold_time	timing/PostClusterDelayCalculator.h	/^    void set_cached_hold_time(tatum::EdgeId edge, tatum::Time hold) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, tatum::Time hold) const
PostClusterDelayCalculator::set_cached_hold_time	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_hold_time(tatum::EdgeId edge, tatum::Time hold) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, tatum::Time hold) const
PostClusterDelayCalculator::set_cached_pins	timing/PostClusterDelayCalculator.h	/^    void set_cached_pins(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const
PostClusterDelayCalculator::set_cached_pins	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_pins(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const
PostClusterDelayCalculator::set_cached_setup_time	timing/PostClusterDelayCalculator.h	/^    void set_cached_setup_time(tatum::EdgeId edge, tatum::Time setup) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, tatum::Time setup) const
PostClusterDelayCalculator::set_cached_setup_time	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_setup_time(tatum::EdgeId edge, tatum::Time setup) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, tatum::Time setup) const
PostClusterDelayCalculator::set_driver_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    void set_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
PostClusterDelayCalculator::set_driver_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
PostClusterDelayCalculator::set_sink_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    void set_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
PostClusterDelayCalculator::set_sink_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
PostClusterDelayCalculator::set_tsu_margin_absolute	timing/PostClusterDelayCalculator.h	/^    void set_tsu_margin_absolute(float val);$/;"	p	class:PostClusterDelayCalculator	access:public	signature:(float val)
PostClusterDelayCalculator::set_tsu_margin_absolute	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_tsu_margin_absolute(float new_margin) {$/;"	f	class:PostClusterDelayCalculator	signature:(float new_margin)
PostClusterDelayCalculator::set_tsu_margin_relative	timing/PostClusterDelayCalculator.h	/^    void set_tsu_margin_relative(float val);$/;"	p	class:PostClusterDelayCalculator	access:public	signature:(float val)
PostClusterDelayCalculator::set_tsu_margin_relative	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_tsu_margin_relative(float new_margin) {$/;"	f	class:PostClusterDelayCalculator	signature:(float new_margin)
PostClusterDelayCalculator::setup_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
PostClusterDelayCalculator::sink_clb_max_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> sink_clb_max_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::sink_clb_min_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> sink_clb_min_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::tsu_margin_abs_	timing/PostClusterDelayCalculator.h	/^    float tsu_margin_abs_ = 0.0e-12;$/;"	m	class:PostClusterDelayCalculator	access:private
PostClusterDelayCalculator::tsu_margin_rel_	timing/PostClusterDelayCalculator.h	/^    float tsu_margin_rel_ = 1.0;$/;"	m	class:PostClusterDelayCalculator	access:private
PowerCallibInputs	power/PowerSpicedComponent.cpp	/^PowerCallibInputs::PowerCallibInputs(PowerSpicedComponent * parent_,$/;"	f	class:PowerCallibInputs	signature:(PowerSpicedComponent * parent_, float inputs)
PowerCallibInputs	power/PowerSpicedComponent.h	/^	PowerCallibInputs(PowerSpicedComponent * parent, float num_inputs);$/;"	p	class:PowerCallibInputs	access:public	signature:(PowerSpicedComponent * parent, float num_inputs)
PowerCallibInputs	power/PowerSpicedComponent.h	/^class PowerCallibInputs {$/;"	c
PowerCallibInputs::PowerCallibInputs	power/PowerSpicedComponent.cpp	/^PowerCallibInputs::PowerCallibInputs(PowerSpicedComponent * parent_,$/;"	f	class:PowerCallibInputs	signature:(PowerSpicedComponent * parent_, float inputs)
PowerCallibInputs::PowerCallibInputs	power/PowerSpicedComponent.h	/^	PowerCallibInputs(PowerSpicedComponent * parent, float num_inputs);$/;"	p	class:PowerCallibInputs	access:public	signature:(PowerSpicedComponent * parent, float num_inputs)
PowerCallibInputs::add_size	power/PowerSpicedComponent.cpp	/^void PowerCallibInputs::add_size(float transistor_size, float power) {$/;"	f	class:PowerCallibInputs	signature:(float transistor_size, float power)
PowerCallibInputs::add_size	power/PowerSpicedComponent.h	/^	void add_size(float transistor_size, float power = 0.);$/;"	p	class:PowerCallibInputs	access:public	signature:(float transistor_size, float power = 0.)
PowerCallibInputs::callibrate	power/PowerSpicedComponent.cpp	/^void PowerCallibInputs::callibrate() {$/;"	f	class:PowerCallibInputs	signature:()
PowerCallibInputs::callibrate	power/PowerSpicedComponent.h	/^	void callibrate();$/;"	p	class:PowerCallibInputs	access:public	signature:()
PowerCallibInputs::done_callibration	power/PowerSpicedComponent.h	/^	bool done_callibration;$/;"	m	class:PowerCallibInputs	access:public
PowerCallibInputs::entries	power/PowerSpicedComponent.h	/^	std::vector<PowerCallibSize*> entries;$/;"	m	class:PowerCallibInputs	access:public
PowerCallibInputs::get_entry_bound	power/PowerSpicedComponent.cpp	/^PowerCallibSize * PowerCallibInputs::get_entry_bound(bool lower,$/;"	f	class:PowerCallibInputs	signature:(bool lower, float transistor_size)
PowerCallibInputs::get_entry_bound	power/PowerSpicedComponent.h	/^	PowerCallibSize * get_entry_bound(bool lower, float transistor_size);$/;"	p	class:PowerCallibInputs	access:public	signature:(bool lower, float transistor_size)
PowerCallibInputs::num_inputs	power/PowerSpicedComponent.h	/^	int num_inputs;$/;"	m	class:PowerCallibInputs	access:public
PowerCallibInputs::parent	power/PowerSpicedComponent.h	/^	PowerSpicedComponent * parent;$/;"	m	class:PowerCallibInputs	access:public
PowerCallibInputs::sort_me	power/PowerSpicedComponent.cpp	/^void PowerCallibInputs::sort_me() {$/;"	f	class:PowerCallibInputs	signature:()
PowerCallibInputs::sort_me	power/PowerSpicedComponent.h	/^	void sort_me();$/;"	p	class:PowerCallibInputs	access:public	signature:()
PowerCallibInputs::sorted	power/PowerSpicedComponent.h	/^	bool sorted;$/;"	m	class:PowerCallibInputs	access:public
PowerCallibSize	power/PowerSpicedComponent.h	/^	PowerCallibSize(float size, float power_) :$/;"	f	class:PowerCallibSize	access:public	signature:(float size, float power_)
PowerCallibSize	power/PowerSpicedComponent.h	/^class PowerCallibSize {$/;"	c
PowerCallibSize::PowerCallibSize	power/PowerSpicedComponent.h	/^	PowerCallibSize(float size, float power_) :$/;"	f	class:PowerCallibSize	access:public	signature:(float size, float power_)
PowerCallibSize::factor	power/PowerSpicedComponent.h	/^	float factor;$/;"	m	class:PowerCallibSize	access:public
PowerCallibSize::operator <	power/PowerSpicedComponent.h	/^	bool operator<(const PowerCallibSize & rhs) {$/;"	f	class:PowerCallibSize	access:public	signature:(const PowerCallibSize & rhs)
PowerCallibSize::power	power/PowerSpicedComponent.h	/^	float power;$/;"	m	class:PowerCallibSize	access:public
PowerCallibSize::transistor_size	power/PowerSpicedComponent.h	/^	float transistor_size;$/;"	m	class:PowerCallibSize	access:public
PowerContext	base/vpr_context.h	/^struct PowerContext : public Context {$/;"	s	inherits:Context
PowerContext::arch	base/vpr_context.h	/^    t_power_arch* arch;$/;"	m	struct:PowerContext	access:public
PowerContext::atom_net_power	base/vpr_context.h	/^    std::unordered_map<AtomNetId,t_net_power> atom_net_power;$/;"	m	struct:PowerContext	access:public
PowerContext::by_component	base/vpr_context.h	/^    t_power_components by_component;$/;"	m	struct:PowerContext	access:public
PowerContext::clb_net_power	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_net_power> clb_net_power;$/;"	m	struct:PowerContext	access:public
PowerContext::commonly_used	base/vpr_context.h	/^    t_power_commonly_used* commonly_used;$/;"	m	struct:PowerContext	access:public
PowerContext::output	base/vpr_context.h	/^    t_power_output* output;$/;"	m	struct:PowerContext	access:public
PowerContext::solution_inf	base/vpr_context.h	/^    t_solution_inf solution_inf;$/;"	m	struct:PowerContext	access:public
PowerContext::tech	base/vpr_context.h	/^    t_power_tech* tech;$/;"	m	struct:PowerContext	access:public
PowerFile	base/read_options.h	/^    argparse::ArgValue<std::string> PowerFile;$/;"	m	struct:t_options	access:public
PowerFile	base/vpr_types.h	/^	std::string PowerFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
PowerOpts	base/vpr_types.h	/^	t_power_opts PowerOpts;$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
PowerSpicedComponent	power/PowerSpicedComponent.cpp	/^PowerSpicedComponent::PowerSpicedComponent(std::string component_name,$/;"	f	class:PowerSpicedComponent	signature:(std::string component_name, float (*usage_fn)(int num_inputs, float transistor_size))
PowerSpicedComponent	power/PowerSpicedComponent.h	/^	PowerSpicedComponent(std::string component_name,$/;"	p	class:PowerSpicedComponent	access:public	signature:(std::string component_name, float (*usage_fn)(int num_inputs, float transistor_size))
PowerSpicedComponent	power/PowerSpicedComponent.h	/^class PowerSpicedComponent {$/;"	c
PowerSpicedComponent::PowerSpicedComponent	power/PowerSpicedComponent.cpp	/^PowerSpicedComponent::PowerSpicedComponent(std::string component_name,$/;"	f	class:PowerSpicedComponent	signature:(std::string component_name, float (*usage_fn)(int num_inputs, float transistor_size))
PowerSpicedComponent::PowerSpicedComponent	power/PowerSpicedComponent.h	/^	PowerSpicedComponent(std::string component_name,$/;"	p	class:PowerSpicedComponent	access:public	signature:(std::string component_name, float (*usage_fn)(int num_inputs, float transistor_size))
PowerSpicedComponent::add_data_point	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::add_data_point(int num_inputs, float transistor_size,$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs, float transistor_size, float power)
PowerSpicedComponent::add_data_point	power/PowerSpicedComponent.h	/^	void add_data_point(int num_inputs, float transistor_size, float power);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs, float transistor_size, float power)
PowerSpicedComponent::add_entry	power/PowerSpicedComponent.cpp	/^PowerCallibInputs * PowerSpicedComponent::add_entry(int num_inputs) {$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs)
PowerSpicedComponent::add_entry	power/PowerSpicedComponent.h	/^	PowerCallibInputs * add_entry(int num_inputs);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs)
PowerSpicedComponent::callibrate	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::callibrate() {$/;"	f	class:PowerSpicedComponent	signature:()
PowerSpicedComponent::callibrate	power/PowerSpicedComponent.h	/^	void callibrate();$/;"	p	class:PowerSpicedComponent	access:public	signature:()
PowerSpicedComponent::component_usage	power/PowerSpicedComponent.h	/^	float (*component_usage)(int num_inputs, float transistor_size);$/;"	m	class:PowerSpicedComponent	access:public
PowerSpicedComponent::done_callibration	power/PowerSpicedComponent.h	/^	bool done_callibration;$/;"	m	class:PowerSpicedComponent	access:public
PowerSpicedComponent::entries	power/PowerSpicedComponent.h	/^	std::vector<PowerCallibInputs*> entries;$/;"	m	class:PowerSpicedComponent	access:public
PowerSpicedComponent::get_entry	power/PowerSpicedComponent.cpp	/^PowerCallibInputs * PowerSpicedComponent::get_entry(int num_inputs) {$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs)
PowerSpicedComponent::get_entry	power/PowerSpicedComponent.h	/^	PowerCallibInputs* get_entry(int num_inputs);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs)
PowerSpicedComponent::get_entry_bound	power/PowerSpicedComponent.cpp	/^PowerCallibInputs * PowerSpicedComponent::get_entry_bound(bool lower,$/;"	f	class:PowerSpicedComponent	signature:(bool lower, int num_inputs)
PowerSpicedComponent::get_entry_bound	power/PowerSpicedComponent.h	/^	PowerCallibInputs * get_entry_bound(bool lower, int num_inputs);$/;"	p	class:PowerSpicedComponent	access:public	signature:(bool lower, int num_inputs)
PowerSpicedComponent::is_done_callibration	power/PowerSpicedComponent.cpp	/^bool PowerSpicedComponent::is_done_callibration() {$/;"	f	class:PowerSpicedComponent	signature:()
PowerSpicedComponent::is_done_callibration	power/PowerSpicedComponent.h	/^	bool is_done_callibration();$/;"	p	class:PowerSpicedComponent	access:public	signature:()
PowerSpicedComponent::name	power/PowerSpicedComponent.h	/^	std::string name;$/;"	m	class:PowerSpicedComponent	access:public
PowerSpicedComponent::print	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::print(FILE * fp) {$/;"	f	class:PowerSpicedComponent	signature:(FILE * fp)
PowerSpicedComponent::print	power/PowerSpicedComponent.h	/^	void print(FILE * fp);$/;"	p	class:PowerSpicedComponent	access:public	signature:(FILE * fp)
PowerSpicedComponent::scale_factor	power/PowerSpicedComponent.cpp	/^float PowerSpicedComponent::scale_factor(int num_inputs,$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs, float transistor_size)
PowerSpicedComponent::scale_factor	power/PowerSpicedComponent.h	/^	float scale_factor(int num_inputs, float transistor_size);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs, float transistor_size)
PowerSpicedComponent::sort_me	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::sort_me() {$/;"	f	class:PowerSpicedComponent	signature:()
PowerSpicedComponent::sort_me	power/PowerSpicedComponent.h	/^	void sort_me();$/;"	p	class:PowerSpicedComponent	access:public	signature:()
PowerSpicedComponent::sorted	power/PowerSpicedComponent.h	/^	bool sorted;$/;"	m	class:PowerSpicedComponent	access:public
PreClusterDelayCalculator	timing/PreClusterDelayCalculator.h	/^    PreClusterDelayCalculator(const AtomNetlist& netlist,$/;"	f	class:PreClusterDelayCalculator	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, float intercluster_net_delay, std::unordered_map<AtomBlockId,t_pb_graph_node*> expected_lowest_cost_pb_gnode)
PreClusterDelayCalculator	timing/PreClusterDelayCalculator.h	/^class PreClusterDelayCalculator : public tatum::DelayCalculator {$/;"	c	inherits:tatum::DelayCalculator
PreClusterDelayCalculator::PreClusterDelayCalculator	timing/PreClusterDelayCalculator.h	/^    PreClusterDelayCalculator(const AtomNetlist& netlist,$/;"	f	class:PreClusterDelayCalculator	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, float intercluster_net_delay, std::unordered_map<AtomBlockId,t_pb_graph_node*> expected_lowest_cost_pb_gnode)
PreClusterDelayCalculator::block_to_pb_gnode_	timing/PreClusterDelayCalculator.h	/^    const std::unordered_map<AtomBlockId,t_pb_graph_node*> block_to_pb_gnode_;$/;"	m	class:PreClusterDelayCalculator	access:private
PreClusterDelayCalculator::find_associated_clock_pin	timing/PreClusterDelayCalculator.h	/^    const t_pb_graph_pin* find_associated_clock_pin(const AtomPinId io_pin) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const AtomPinId io_pin) const
PreClusterDelayCalculator::find_pb_graph_pin	timing/PreClusterDelayCalculator.h	/^    const t_pb_graph_pin* find_pb_graph_pin(const AtomPinId pin) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const AtomPinId pin) const
PreClusterDelayCalculator::inter_cluster_net_delay_	timing/PreClusterDelayCalculator.h	/^    const float inter_cluster_net_delay_;$/;"	m	class:PreClusterDelayCalculator	access:private
PreClusterDelayCalculator::netlist_	timing/PreClusterDelayCalculator.h	/^    const AtomNetlist& netlist_;$/;"	m	class:PreClusterDelayCalculator	access:private
PreClusterDelayCalculator::netlist_lookup_	timing/PreClusterDelayCalculator.h	/^    const AtomLookup& netlist_lookup_;$/;"	m	class:PreClusterDelayCalculator	access:private
PreClusterDelayCalculator::prim_comb_delay	timing/PreClusterDelayCalculator.h	/^    tatum::Time prim_comb_delay(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const
PreClusterDelayCalculator::prim_tcq_delay	timing/PreClusterDelayCalculator.h	/^    tatum::Time prim_tcq_delay(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const
PrintArchInfo	../../libs/libarchfpga/src/echo_arch.cpp	/^void PrintArchInfo(FILE * Echo, const t_arch *arch) {$/;"	f	signature:(FILE * Echo, const t_arch *arch)
PrintArchInfo	../../libs/libarchfpga/src/echo_arch.cpp	/^void PrintArchInfo(FILE* Echo, const t_arch *arch);$/;"	p	file:	signature:(FILE* Echo, const t_arch *arch)
PrintArchInfo	../../libs/libarchfpga/src/physical_types.h	/^        friend void PrintArchInfo(FILE*, const t_arch*);$/;"	p	struct:t_arch_switch_inf	access:friend	signature:(FILE*, const t_arch*)
PrintHandlerDirect	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerDirect)(const char* pszMessage,	... );$/;"	t	namespace:vtr
PrintHandlerError	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerError)(const char* pszFileName, unsigned int lineNum, const char* pszMessage,	... );$/;"	t	namespace:vtr
PrintHandlerInfo	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerInfo)(const char* pszMessage, ... );$/;"	t	namespace:vtr
PrintHandlerWarning	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerWarning)(const char* pszFileName, unsigned int lineNum, const char* pszMessage,	... );$/;"	t	namespace:vtr
PrintPb_types_rec	../../libs/libarchfpga/src/echo_arch.cpp	/^static void PrintPb_types_rec(FILE* Echo, const t_pb_type * pb_type,$/;"	f	file:	signature:(FILE* Echo, const t_pb_type * pb_type, int level)
PrintPb_types_rec	../../libs/libarchfpga/src/echo_arch.cpp	/^static void PrintPb_types_rec(FILE* Echo, const t_pb_type * pb_type,$/;"	p	file:	signature:(FILE* Echo, const t_pb_type * pb_type, int level)
PrintPb_types_recPower	../../libs/libarchfpga/src/echo_arch.cpp	/^static void PrintPb_types_recPower(FILE* Echo,$/;"	f	file:	signature:(FILE* Echo, const t_pb_type * pb_type, const char* tabs)
PrintPb_types_recPower	../../libs/libarchfpga/src/echo_arch.cpp	/^static void PrintPb_types_recPower(FILE* Echo,$/;"	p	file:	signature:(FILE* Echo, const t_pb_type * pb_type, const char* tabs)
ProceedPressed	../../libs/libeasygl/src/graphics_state.h	/^    bool ProceedPressed = false;$/;"	m	struct:t_gl_state	access:public
ProcessCB_SB	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessCB_SB(pugi::xml_node Node, bool * list,$/;"	f	file:	signature:(pugi::xml_node Node, bool * list, const int len, const pugiutil::loc_data& loc_data)
ProcessCB_SB	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessCB_SB(pugi::xml_node Node, bool * list,$/;"	p	file:	signature:(pugi::xml_node Node, bool * list, const int len, const pugiutil::loc_data& loc_data)
ProcessChanWidthDistr	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessChanWidthDistr(pugi::xml_node Node,$/;"	f	file:	signature:(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data)
ProcessChanWidthDistr	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessChanWidthDistr(pugi::xml_node Node,$/;"	p	file:	signature:(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data)
ProcessChanWidthDistrDir	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessChanWidthDistrDir(pugi::xml_node Node, t_chan * chan, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Node, t_chan * chan, const pugiutil::loc_data& loc_data)
ProcessChanWidthDistrDir	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessChanWidthDistrDir(pugi::xml_node Node, t_chan * chan, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_chan * chan, const pugiutil::loc_data& loc_data)
ProcessClocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessClocks(pugi::xml_node Parent, t_clock_arch * clocks, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Parent, t_clock_arch * clocks, const pugiutil::loc_data& loc_data)
ProcessClocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessClocks(pugi::xml_node Parent, t_clock_arch * clocks, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Parent, t_clock_arch * clocks, const pugiutil::loc_data& loc_data)
ProcessComplexBlockProps	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessComplexBlockProps(pugi::xml_node Node, t_type_descriptor * Type, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Node, t_type_descriptor * Type, const pugiutil::loc_data& loc_data)
ProcessComplexBlockProps	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessComplexBlockProps(pugi::xml_node Node, t_type_descriptor * Type, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_type_descriptor * Type, const pugiutil::loc_data& loc_data)
ProcessComplexBlocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessComplexBlocks(pugi::xml_node Node,$/;"	f	file:	signature:(pugi::xml_node Node, t_type_descriptor ** Types, int *NumTypes, t_arch& arch, const bool timing_enabled, const t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data)
ProcessComplexBlocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessComplexBlocks(pugi::xml_node Node,$/;"	p	file:	signature:(pugi::xml_node Node, t_type_descriptor ** Types, int *NumTypes, t_arch& arch, const bool timing_enabled, const t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data)
ProcessDevice	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessDevice(pugi::xml_node Node, t_arch *arch, t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Node, t_arch *arch, t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data)
ProcessDevice	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessDevice(pugi::xml_node Node, t_arch *arch, t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_arch *arch, t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data)
ProcessDirects	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessDirects(pugi::xml_node Parent, t_direct_inf **Directs,$/;"	f	file:	signature:(pugi::xml_node Parent, t_direct_inf **Directs, int *NumDirects, const t_arch_switch_inf *Switches, const int NumSwitches, const pugiutil::loc_data& loc_data)
ProcessDirects	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessDirects(pugi::xml_node Parent, t_direct_inf **Directs,$/;"	p	file:	signature:(pugi::xml_node Parent, t_direct_inf **Directs, int *NumDirects, const t_arch_switch_inf *Switches, const int NumSwitches, const pugiutil::loc_data& loc_data)
ProcessGridLayout	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static t_grid_def ProcessGridLayout(pugi::xml_node layout_type_tag, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node layout_type_tag, const pugiutil::loc_data& loc_data)
ProcessGridLayout	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static t_grid_def ProcessGridLayout(pugi::xml_node layout_type_tag, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node layout_type_tag, const pugiutil::loc_data& loc_data)
ProcessInterconnect	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessInterconnect(pugi::xml_node Parent, t_mode * mode, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Parent, t_mode * mode, const pugiutil::loc_data& loc_data)
ProcessInterconnect	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessInterconnect(pugi::xml_node Parent, t_mode * mode, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Parent, t_mode * mode, const pugiutil::loc_data& loc_data)
ProcessLayout	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessLayout(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data)
ProcessLayout	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessLayout(pugi::xml_node layout_tag, t_arch *arch, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node layout_tag, t_arch *arch, const pugiutil::loc_data& loc_data)
ProcessLutClass	../../libs/libarchfpga/src/arch_util.cpp	/^void ProcessLutClass(t_pb_type *lut_pb_type) {$/;"	f	signature:(t_pb_type *lut_pb_type)
ProcessLutClass	../../libs/libarchfpga/src/arch_util.h	/^void ProcessLutClass(t_pb_type *lut_pb_type);$/;"	p	signature:(t_pb_type *lut_pb_type)
ProcessMemoryClass	../../libs/libarchfpga/src/arch_util.cpp	/^void ProcessMemoryClass(t_pb_type *mem_pb_type) {$/;"	f	signature:(t_pb_type *mem_pb_type)
ProcessMemoryClass	../../libs/libarchfpga/src/arch_util.h	/^void ProcessMemoryClass(t_pb_type *mem_pb_type);$/;"	p	signature:(t_pb_type *mem_pb_type)
ProcessMode	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessMode(pugi::xml_node Parent, t_mode * mode,$/;"	f	file:	signature:(pugi::xml_node Parent, t_mode * mode, const bool timing_enabled, const t_arch& arch, const pugiutil::loc_data& loc_data)
ProcessMode	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessMode(pugi::xml_node Parent, t_mode * mode,$/;"	p	file:	signature:(pugi::xml_node Parent, t_mode * mode, const bool timing_enabled, const t_arch& arch, const pugiutil::loc_data& loc_data)
ProcessModelPorts	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessModelPorts(pugi::xml_node port_group, t_model* model, std::set<std::string>& port_names, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node port_group, t_model* model, std::set<std::string>& port_names, const pugiutil::loc_data& loc_data)
ProcessModelPorts	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessModelPorts(pugi::xml_node port_group, t_model* model, std::set<std::string>& port_names, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node port_group, t_model* model, std::set<std::string>& port_names, const pugiutil::loc_data& loc_data)
ProcessModels	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessModels(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data)
ProcessModels	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessModels(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_arch *arch, const pugiutil::loc_data& loc_data)
ProcessPb_Type	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_Type(pugi::xml_node Parent, t_pb_type * pb_type,$/;"	f	file:	signature:(pugi::xml_node Parent, t_pb_type * pb_type, t_mode * mode, const bool timing_enabled, const t_arch& arch, const pugiutil::loc_data& loc_data)
ProcessPb_Type	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_Type(pugi::xml_node Parent, t_pb_type * pb_type,$/;"	p	file:	signature:(pugi::xml_node Parent, t_pb_type * pb_type, t_mode * mode, const bool timing_enabled, const t_arch& arch, const pugiutil::loc_data& loc_data)
ProcessPb_TypePort	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePort(pugi::xml_node Parent, t_port * port,$/;"	f	file:	signature:(pugi::xml_node Parent, t_port * port, e_power_estimation_method power_method, const bool is_root_pb_type, const pugiutil::loc_data& loc_data)
ProcessPb_TypePort	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePort(pugi::xml_node Parent, t_port * port,$/;"	p	file:	signature:(pugi::xml_node Parent, t_port * port, e_power_estimation_method power_method, const bool is_root_pb_type, const pugiutil::loc_data& loc_data)
ProcessPb_TypePort_Power	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePort_Power(pugi::xml_node Parent, t_port * port,$/;"	f	file:	signature:(pugi::xml_node Parent, t_port * port, e_power_estimation_method power_method, const pugiutil::loc_data& loc_data)
ProcessPb_TypePort_Power	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePort_Power(pugi::xml_node Parent, t_port * port,$/;"	p	file:	signature:(pugi::xml_node Parent, t_port * port, e_power_estimation_method power_method, const pugiutil::loc_data& loc_data)
ProcessPb_TypePower	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePower(pugi::xml_node Parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data)
ProcessPb_TypePowerEstMethod	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePowerEstMethod(pugi::xml_node Parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data)
ProcessPb_TypePowerEstMethod	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePowerEstMethod(pugi::xml_node Parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data)
ProcessPb_TypePowerPinToggle	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPb_TypePowerPinToggle(pugi::xml_node parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node parent, t_pb_type * pb_type, const pugiutil::loc_data& loc_data)
ProcessPinToPinAnnotations	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPinToPinAnnotations(pugi::xml_node Parent,$/;"	f	file:	signature:(pugi::xml_node Parent, t_pin_to_pin_annotation *annotation, t_pb_type * parent_pb_type, const pugiutil::loc_data& loc_data)
ProcessPinToPinAnnotations	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPinToPinAnnotations(pugi::xml_node parent,$/;"	p	file:	signature:(pugi::xml_node parent, t_pin_to_pin_annotation *annotation, t_pb_type * parent_pb_type, const pugiutil::loc_data& loc_data)
ProcessPower	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPower( pugi::xml_node parent,$/;"	f	file:	signature:( pugi::xml_node parent, t_power_arch * power_arch, const pugiutil::loc_data& loc_data)
ProcessPower	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessPower( pugi::xml_node parent,$/;"	p	file:	signature:( pugi::xml_node parent, t_power_arch * power_arch, const pugiutil::loc_data& loc_data)
ProcessSegments	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSegments(pugi::xml_node Parent,$/;"	f	file:	signature:(pugi::xml_node Parent, t_segment_inf **Segs, int *NumSegs, const t_arch_switch_inf *Switches, const int NumSwitches, const bool timing_enabled, const bool switchblocklist_required, const pugiutil::loc_data& loc_data)
ProcessSegments	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSegments(pugi::xml_node Parent,$/;"	p	file:	signature:(pugi::xml_node Parent, t_segment_inf **Segs, int *NumSegs, const t_arch_switch_inf *Switches, const int NumSwitches, const bool timing_enabled, const bool switchblocklist_required, const pugiutil::loc_data& loc_data)
ProcessSwitchTdel	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitchTdel(pugi::xml_node Node, const bool timing_enabled,$/;"	f	file:	signature:(pugi::xml_node Node, const bool timing_enabled, const int switch_index, t_arch_switch_inf *Switches, const pugiutil::loc_data& loc_data)
ProcessSwitchTdel	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitchTdel(pugi::xml_node Node, const bool timing_enabled,$/;"	p	file:	signature:(pugi::xml_node Node, const bool timing_enabled, const int switch_index, t_arch_switch_inf *Switches, const pugiutil::loc_data& loc_data)
ProcessSwitchblockLocations	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitchblockLocations(pugi::xml_node switchblock_locations, t_type_descriptor* type, const t_arch& arch, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node switchblock_locations, t_type_descriptor* type, const t_arch& arch, const pugiutil::loc_data& loc_data)
ProcessSwitchblockLocations	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitchblockLocations(pugi::xml_node swtichblock_locations, t_type_descriptor* type, const t_arch& arch, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node swtichblock_locations, t_type_descriptor* type, const t_arch& arch, const pugiutil::loc_data& loc_data)
ProcessSwitchblocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitchblocks(pugi::xml_node Parent, t_arch* arch, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Parent, t_arch* arch, const pugiutil::loc_data& loc_data)
ProcessSwitchblocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitchblocks(pugi::xml_node Parent, t_arch* arch, const pugiutil::loc_data& loc_data){$/;"	f	file:	signature:(pugi::xml_node Parent, t_arch* arch, const pugiutil::loc_data& loc_data)
ProcessSwitches	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitches(pugi::xml_node Node,$/;"	p	file:	signature:(pugi::xml_node Node, t_arch_switch_inf **Switches, int *NumSwitches, const bool timing_enabled, const pugiutil::loc_data& loc_data)
ProcessSwitches	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void ProcessSwitches(pugi::xml_node Parent,$/;"	f	file:	signature:(pugi::xml_node Parent, t_arch_switch_inf **Switches, int *NumSwitches, const bool timing_enabled, const pugiutil::loc_data& loc_data)
Process_Fc	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void Process_Fc(pugi::xml_node Node, t_type_descriptor * Type, t_segment_inf *segments, int num_segments, const t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Node, t_type_descriptor * Type, t_segment_inf *segments, int num_segments, const t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data)
Process_Fc	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void Process_Fc(pugi::xml_node Node, t_type_descriptor * Type, t_segment_inf *segments, int num_segments, const t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_type_descriptor * Type, t_segment_inf *segments, int num_segments, const t_default_fc_spec &arch_def_fc, const pugiutil::loc_data& loc_data)
Process_Fc_Values	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void Process_Fc_Values(pugi::xml_node Node, t_default_fc_spec &spec, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node Node, t_default_fc_spec &spec, const pugiutil::loc_data& loc_data)
Process_Fc_Values	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void Process_Fc_Values(pugi::xml_node Node, t_default_fc_spec &spec, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node Node, t_default_fc_spec &spec, const pugiutil::loc_data& loc_data)
Process_Fc_override	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static t_fc_override Process_Fc_override(pugi::xml_node node, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data)
Process_Fc_override	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static t_fc_override Process_Fc_override(pugi::xml_node node, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data)
QUEST	timing/slre.cpp	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon10	file:
R	../../libs/libarchfpga/src/physical_types.h	/^	float R = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
R	../../libs/libarchfpga/src/physical_types.h	/^        float R = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
R	route/rr_node.cpp	/^float t_rr_node::R() const {$/;"	f	class:t_rr_node	signature:() const
R	route/rr_node.h	/^        float R() const;$/;"	p	class:t_rr_node	access:public	signature:() const
R	route/rr_node.h	/^    float R;$/;"	m	struct:t_rr_rc_data	access:public
RANDOM	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:ScreenUpdatePriority::e_pad_loc_type
READ_ACTIVITY_H	base/read_activity.h	/^#define READ_ACTIVITY_H$/;"	d
READ_BLIF_H	base/read_blif.h	/^#define READ_BLIF_H$/;"	d
READ_NETLIST_H	base/read_netlist.h	/^#define READ_NETLIST_H$/;"	d
READ_OPTIONS_H	base/read_options.h	/^#define READ_OPTIONS_H$/;"	d
READ_PLACE_H	base/read_place.h	/^#define READ_PLACE_H$/;"	d
READ_ROUTE_H	base/read_route.h	/^#define READ_ROUTE_H$/;"	d
READ_SDC_H	timing/read_sdc.h	/^#define READ_SDC_H$/;"	d
READ_XML_ARCH_FILE_H	../../libs/libarchfpga/src/read_xml_arch_file.h	/^#define READ_XML_ARCH_FILE_H$/;"	d
READ_XML_UTIL_H	../../libs/libarchfpga/src/read_xml_util.h	/^#define READ_XML_UTIL_H$/;"	d
REBECCAPURPLE	../../libs/libeasygl/src/easygl_constants.h	/^    REBECCAPURPLE,$/;"	e	enum:color_types
RECEIVER	../../libs/libarchfpga/src/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
RED	../../libs/libeasygl/src/easygl_constants.h	/^    RED,$/;"	e	enum:color_types
REF_X	route/build_switchblocks.cpp	/^#define REF_X /;"	d	file:
REF_X	route/router_lookahead_map.cpp	/^#define REF_X /;"	d	file:
REF_Y	route/build_switchblocks.cpp	/^#define REF_Y /;"	d	file:
REF_Y	route/router_lookahead_map.cpp	/^#define REF_Y /;"	d	file:
REJECTED	place/place.cpp	/^	REJECTED, ACCEPTED, ABORTED$/;"	e	enum:e_swap_result	file:
REMOVE_CLUSTERED	pack/cluster.cpp	/^	REMOVE_CLUSTERED, LEAVE_CLUSTERED$/;"	e	enum:e_removal_policy	file:
REPRESENTATIVE_ENTRY_METHOD	route/router_lookahead_map.cpp	/^#define REPRESENTATIVE_ENTRY_METHOD /;"	d	file:
REQUIRED	../../libs/libpugiutil/src/pugixml_util.hpp	/^        REQUIRED,$/;"	e	enum:pugiutil::ReqOpt
RISING_EDGE	base/netlist_writer.cpp	/^            RISING_EDGE,$/;"	m	class:LatchInst::Type	file:	access:private
ROSYBROWN	../../libs/libeasygl/src/easygl_constants.h	/^    ROSYBROWN,$/;"	e	enum:color_types
ROUND	../../libs/libeasygl/src/easygl_constants.h	/^    BUTT = 0, ROUND$/;"	e	enum:line_caps
ROUTED_CLOCK	base/clock_modeling.h	/^    ROUTED_CLOCK \/\/Treat the clock pins as normal nets (i.e. routed)$/;"	e	enum:e_clock_modeling
ROUTE_BREADTH_FIRST_H	route/route_breadth_first.h	/^#define ROUTE_BREADTH_FIRST_H$/;"	d
ROUTE_BUDGETS_H	route/route_budgets.h	/^#define ROUTE_BUDGETS_H$/;"	d
ROUTE_PATH_WEIGHT	timing/path_delay.h	/^	#define ROUTE_PATH_WEIGHT /;"	d
ROUTING	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:ScreenUpdatePriority::pic_type
ROUTING_DELAY_CALCULATOR_H	timing/RoutingDelayCalculator.h	/^#define ROUTING_DELAY_CALCULATOR_H$/;"	d
ROUTING_PREDICTOR_ITERATION_ABORT_FACTOR_AGGRESSIVE	route/routing_predictor.h	/^constexpr float ROUTING_PREDICTOR_ITERATION_ABORT_FACTOR_AGGRESSIVE = 1.5;$/;"	v
ROUTING_PREDICTOR_ITERATION_ABORT_FACTOR_SAFE	route/routing_predictor.h	/^constexpr float ROUTING_PREDICTOR_ITERATION_ABORT_FACTOR_SAFE = 3;$/;"	v
ROUTING_PREDICTOR_MIN_ABSOLUTE_OVERUSE_THRESHOLD	route/routing_predictor.h	/^constexpr size_t ROUTING_PREDICTOR_MIN_ABSOLUTE_OVERUSE_THRESHOLD = 100;$/;"	v
ROYALBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    ROYALBLUE,$/;"	e	enum:color_types
RR_GRAPH2_H	route/rr_graph2.h	/^#define RR_GRAPH2_H$/;"	d
RR_GRAPH_AREA_H	route/rr_graph_area.h	/^#define RR_GRAPH_AREA_H$/;"	d
RR_GRAPH_H	route/rr_graph.h	/^#define RR_GRAPH_H$/;"	d
RR_GRAPH_INDEXED_DATA_H	route/rr_graph_indexed_data.h	/^#define RR_GRAPH_INDEXED_DATA_H$/;"	d
RR_GRAPH_NO_WARN	route/rr_graph.h	/^    RR_GRAPH_NO_WARN = 0x00,$/;"	e	enum:__anon6
RR_GRAPH_READER_H	route/rr_graph_reader.h	/^#define RR_GRAPH_READER_H$/;"	d
RR_GRAPH_SBOX_H	route/rr_graph_sbox.h	/^#define RR_GRAPH_SBOX_H$/;"	d
RR_GRAPH_UTIL_H	route/rr_graph_util.h	/^#define RR_GRAPH_UTIL_H$/;"	d
RR_GRAPH_WARN_CHAN_WIDTH_CHANGED	route/rr_graph.h	/^    RR_GRAPH_WARN_CHAN_WIDTH_CHANGED = 0x02$/;"	e	enum:__anon6
RR_GRAPH_WARN_FC_CLIPPED	route/rr_graph.h	/^    RR_GRAPH_WARN_FC_CLIPPED = 0x01,$/;"	e	enum:__anon6
RR_GRAPH_WRITER_H	route/rr_graph_writer.h	/^#define RR_GRAPH_WRITER_H$/;"	d
RR_NODE_H	route/rr_node.h	/^#define RR_NODE_H$/;"	d
RR_TYPES	base/vpr_types.h	/^constexpr std::array<t_rr_type, NUM_RR_TYPES> RR_TYPES = { {$/;"	m	class:ScreenUpdatePriority	access:private
RR_TYPES_H	route/rr_types.h	/^#define RR_TYPES_H$/;"	d
RTL_INT_H	../../libs/librtlnumber/src/include/rtl_int.hpp	/^#define RTL_INT_H$/;"	d
RTL_UTILS_H	../../libs/librtlnumber/src/include/rtl_utils.hpp	/^#define RTL_UTILS_H$/;"	d
RT_COMMIT	pack/cluster_router.cpp	/^enum e_commit_remove {RT_COMMIT, RT_REMOVE};$/;"	e	enum:e_commit_remove	file:
RT_REMOVE	pack/cluster_router.cpp	/^enum e_commit_remove {RT_COMMIT, RT_REMOVE};$/;"	e	enum:e_commit_remove	file:
R_minW_nmos	../../libs/libarchfpga/src/physical_types.h	/^	float R_minW_nmos;$/;"	m	struct:t_arch	access:public
R_minW_nmos	base/vpr_types.h	/^	float R_minW_nmos;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
R_minW_pmos	../../libs/libarchfpga/src/physical_types.h	/^	float R_minW_pmos;$/;"	m	struct:t_arch	access:public
R_minW_pmos	base/vpr_types.h	/^	float R_minW_pmos;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
R_upstream	route/route_common.h	/^	float R_upstream = 0.;$/;"	m	struct:t_heap	access:public
R_upstream	route/route_timing.cpp	/^    float R_upstream = 0.;$/;"	m	struct:t_timing_driven_node_costs	file:	access:public
R_upstream	route/route_tree_type.h	/^	float R_upstream;$/;"	m	struct:t_rt_node	access:public
R_upstream	route/router_lookahead_map.cpp	/^	float R_upstream;$/;"	m	class:PQ_Entry	file:	access:public
RandState	../../libs/libvtrutil/src/vtr_random.h	/^    typedef unsigned RandState;$/;"	t	namespace:vtr
Range	../../libs/libvtrutil/src/vtr_range.h	/^        Range(T b, T e): begin_(b), end_(e) {}$/;"	f	class:vtr::Range	access:public	signature:(T b, T e)
Range	../../libs/libvtrutil/src/vtr_range.h	/^class Range {$/;"	c	namespace:vtr
ReadLineTokens	../../libs/libvtrutil/src/vtr_util.cpp	/^std::vector<std::string> ReadLineTokens(FILE * InFile, int *LineNum) {$/;"	f	namespace:vtr	signature:(FILE * InFile, int *LineNum)
ReadLineTokens	../../libs/libvtrutil/src/vtr_util.h	/^    std::vector<std::string> ReadLineTokens(FILE * InFile, int *LineNum);$/;"	p	namespace:vtr	signature:(FILE * InFile, int *LineNum)
RecomputeCritIter	base/read_options.h	/^    argparse::ArgValue<int> RecomputeCritIter;$/;"	m	struct:t_options	access:public
Rect	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect(Point<T> bottom_left_val, Point<T> top_right_val);$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> bottom_left_val, Point<T> top_right_val)
Rect	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect(T left_val, T bottom_val, T right_val, T top_val);$/;"	p	class:vtr::Rect	access:public	signature:(T left_val, T bottom_val, T right_val, T top_val)
Rect	../../libs/libvtrutil/src/vtr_geometry.h	/^class Rect {$/;"	c	namespace:vtr
Rect	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T>::Rect(Point<T> bottom_left_val, Point<T> top_right_val)$/;"	f	class:vtr::Rect	signature:(Point<T> bottom_left_val, Point<T> top_right_val)
Rect	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T>::Rect(T left_val, T bottom_val, T right_val, T top_val)$/;"	f	class:vtr::Rect	signature:(T left_val, T bottom_val, T right_val, T top_val)
RectUnion	../../libs/libvtrutil/src/vtr_geometry.h	/^        RectUnion(std::vector<Rect<T>> rects);$/;"	p	class:vtr::RectUnion	access:public	signature:(std::vector<Rect<T>> rects)
RectUnion	../../libs/libvtrutil/src/vtr_geometry.h	/^class RectUnion {$/;"	c	namespace:vtr
RectUnion	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    RectUnion<T>::RectUnion(std::vector<Rect<T>> rectangles)$/;"	f	class:vtr::RectUnion	signature:(std::vector<Rect<T>> rectangles)
ReqOpt	../../libs/libpugiutil/src/pugixml_util.hpp	/^    enum ReqOpt {$/;"	g	namespace:pugiutil
Rmetal	../../libs/libarchfpga/src/physical_types.h	/^	float Rmetal;$/;"	m	struct:t_segment_inf	access:public
Rmetal	base/vpr_types.h	/^	float Rmetal = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
Rmetal	base/vpr_types.h	/^        float Rmetal() const { return seg_detail_->Rmetal; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
RouteBudgetsAlgorithm	base/read_options.cpp	/^struct RouteBudgetsAlgorithm {$/;"	s	file:
RouteBudgetsAlgorithm::default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:RouteBudgetsAlgorithm	access:public	signature:()
RouteBudgetsAlgorithm::from_str	base/read_options.cpp	/^    ConvertedValue<e_routing_budgets_algorithm> from_str(std::string str) {$/;"	f	struct:RouteBudgetsAlgorithm	access:public	signature:(std::string str)
RouteBudgetsAlgorithm::to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_routing_budgets_algorithm val) {$/;"	f	struct:RouteBudgetsAlgorithm	access:public	signature:(e_routing_budgets_algorithm val)
RouteChanWidth	base/read_options.h	/^    argparse::ArgValue<int> RouteChanWidth;$/;"	m	struct:t_options	access:public
RouteFile	base/read_options.h	/^    argparse::ArgValue<std::string> RouteFile;$/;"	m	struct:t_options	access:public
RouteFile	base/vpr_types.h	/^	std::string RouteFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
RouteStatus	base/vpr_types.h	/^        RouteStatus() = default;$/;"	p	class:ScreenUpdatePriority::RouteStatus	access:public	signature:()
RouteStatus	base/vpr_types.h	/^        RouteStatus(bool status_val, int chan_width_val)$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:(bool status_val, int chan_width_val)
RouteStatus	base/vpr_types.h	/^class RouteStatus {$/;"	c	class:ScreenUpdatePriority	access:private
RouteType	base/read_options.h	/^    argparse::ArgValue<e_route_type> RouteType;$/;"	m	struct:t_options	access:public
RouterAlgorithm	base/read_options.h	/^    argparse::ArgValue<e_router_algorithm> RouterAlgorithm;$/;"	m	struct:t_options	access:public
RouterCongestionMode	route/route_timing.cpp	/^enum class RouterCongestionMode {$/;"	c	file:
RouterCongestionMode::NORMAL	route/route_timing.cpp	/^    NORMAL,$/;"	m	class:RouterCongestionMode	file:	access:private
RouterLookahead	route/router_lookahead.h	/^class RouterLookahead {$/;"	c
RouterLookahead::get_expected_cost	route/router_lookahead.h	/^        virtual float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const = 0;$/;"	p	class:RouterLookahead	access:public	signature:(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const
RouterLookahead::~RouterLookahead	route/router_lookahead.h	/^        virtual ~RouterLookahead() {}$/;"	f	class:RouterLookahead	access:public	signature:()
RouterOpts	base/vpr_types.h	/^	t_router_opts RouterOpts; \/* router options *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
RouterStats	route/router_stats.h	/^struct RouterStats {$/;"	s
RouterStats::connections_routed	route/router_stats.h	/^    size_t connections_routed = 0;$/;"	m	struct:RouterStats	access:public
RouterStats::heap_pops	route/router_stats.h	/^    size_t heap_pops = 0;$/;"	m	struct:RouterStats	access:public
RouterStats::heap_pushes	route/router_stats.h	/^    size_t heap_pushes = 0;$/;"	m	struct:RouterStats	access:public
RouterStats::nets_routed	route/router_stats.h	/^    size_t nets_routed = 0;$/;"	m	struct:RouterStats	access:public
RoutingArch	base/vpr_types.h	/^	t_det_routing_arch RoutingArch; \/* routing architecture *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
RoutingContext	base/vpr_context.h	/^struct RoutingContext : public Context {$/;"	s	inherits:Context
RoutingContext::clb_opins_used_locally	base/vpr_context.h	/^    t_clb_opins_used clb_opins_used_locally; \/\/[0..cluster_ctx.clb_nlist.blocks().size()-1][0..num_class-1]$/;"	m	struct:RoutingContext	access:public
RoutingContext::net_rr_terminals	base/vpr_context.h	/^	vtr::vector<ClusterNetId, std::vector<int>> net_rr_terminals; \/* [0..num_nets-1][0..num_pins-1] *\/$/;"	m	struct:RoutingContext	access:public
RoutingContext::net_status	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_net_routing_status> net_status; \/\/[0..cluster_ctx.clb_nlist.nets().size()-1]$/;"	m	struct:RoutingContext	access:public
RoutingContext::route_bb	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_bb> route_bb; \/* [0..cluster_ctx.clb_nlist.nets().size()-1]*\/$/;"	m	struct:RoutingContext	access:public
RoutingContext::routing_id	base/vpr_context.h	/^    std::string routing_id;$/;"	m	struct:RoutingContext	access:public
RoutingContext::rr_blk_source	base/vpr_context.h	/^    vtr::vector<ClusterBlockId, std::vector<int>> rr_blk_source; \/* [0..num_blocks-1][0..num_class-1] *\/$/;"	m	struct:RoutingContext	access:public
RoutingContext::rr_node_route_inf	base/vpr_context.h	/^    std::vector<t_rr_node_route_inf> rr_node_route_inf; \/* [0..device_ctx.num_rr_nodes-1] *\/$/;"	m	struct:RoutingContext	access:public
RoutingContext::trace	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_traceback> trace;$/;"	m	struct:RoutingContext	access:public
RoutingContext::trace_nodes	base/vpr_context.h	/^    vtr::vector<ClusterNetId, std::unordered_set<int>> trace_nodes;$/;"	m	struct:RoutingContext	access:public
RoutingMetrics	route/route_timing.cpp	/^struct RoutingMetrics {$/;"	s	file:
RoutingMetrics::critical_path	route/route_timing.cpp	/^    tatum::TimingPathInfo critical_path;$/;"	m	struct:RoutingMetrics	file:	access:public
RoutingMetrics::hTNS	route/route_timing.cpp	/^    float hTNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
RoutingMetrics::hWNS	route/route_timing.cpp	/^    float hWNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
RoutingMetrics::sTNS	route/route_timing.cpp	/^    float sTNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
RoutingMetrics::sWNS	route/route_timing.cpp	/^    float sWNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
RoutingMetrics::used_wirelength	route/route_timing.cpp	/^    size_t used_wirelength = 0;$/;"	m	struct:RoutingMetrics	file:	access:public
RoutingPredictor	route/routing_predictor.cpp	/^RoutingPredictor::RoutingPredictor(size_t min_history, float history_factor)$/;"	f	class:RoutingPredictor	signature:(size_t min_history, float history_factor)
RoutingPredictor	route/routing_predictor.h	/^    RoutingPredictor(size_t min_history = 8, float history_factor = 0.5);$/;"	p	class:RoutingPredictor	access:public	signature:(size_t min_history = 8, float history_factor = 0.5)
RoutingPredictor	route/routing_predictor.h	/^class RoutingPredictor {$/;"	c
RoutingPredictor::RoutingPredictor	route/routing_predictor.cpp	/^RoutingPredictor::RoutingPredictor(size_t min_history, float history_factor)$/;"	f	class:RoutingPredictor	signature:(size_t min_history, float history_factor)
RoutingPredictor::RoutingPredictor	route/routing_predictor.h	/^    RoutingPredictor(size_t min_history = 8, float history_factor = 0.5);$/;"	p	class:RoutingPredictor	access:public	signature:(size_t min_history = 8, float history_factor = 0.5)
RoutingPredictor::add_iteration_overuse	route/routing_predictor.cpp	/^void RoutingPredictor::add_iteration_overuse(size_t iteration, size_t overused_rr_node_count) {$/;"	f	class:RoutingPredictor	signature:(size_t iteration, size_t overused_rr_node_count)
RoutingPredictor::add_iteration_overuse	route/routing_predictor.h	/^    void add_iteration_overuse(size_t iteration, size_t overused_rr_node_count);$/;"	p	class:RoutingPredictor	access:public	signature:(size_t iteration, size_t overused_rr_node_count)
RoutingPredictor::estimate_overuse_slope	route/routing_predictor.cpp	/^float RoutingPredictor::estimate_overuse_slope() {$/;"	f	class:RoutingPredictor	signature:()
RoutingPredictor::estimate_overuse_slope	route/routing_predictor.h	/^    float estimate_overuse_slope();$/;"	p	class:RoutingPredictor	access:public	signature:()
RoutingPredictor::estimate_success_iteration	route/routing_predictor.cpp	/^float RoutingPredictor::estimate_success_iteration() {$/;"	f	class:RoutingPredictor	signature:()
RoutingPredictor::estimate_success_iteration	route/routing_predictor.h	/^    float estimate_success_iteration();$/;"	p	class:RoutingPredictor	access:public	signature:()
RoutingPredictor::get_slope	route/routing_predictor.cpp	/^float RoutingPredictor::get_slope() {$/;"	f	class:RoutingPredictor	signature:()
RoutingPredictor::get_slope	route/routing_predictor.h	/^    float get_slope();$/;"	p	class:RoutingPredictor	access:public	signature:()
RoutingPredictor::history_factor_	route/routing_predictor.h	/^    float history_factor_;$/;"	m	class:RoutingPredictor	access:private
RoutingPredictor::iteration_overused_rr_node_counts_	route/routing_predictor.h	/^    std::vector<size_t> iteration_overused_rr_node_counts_;$/;"	m	class:RoutingPredictor	access:private
RoutingPredictor::iterations_	route/routing_predictor.h	/^    std::vector<size_t> iterations_;$/;"	m	class:RoutingPredictor	access:private
RoutingPredictor::min_history_	route/routing_predictor.h	/^    size_t min_history_;$/;"	m	class:RoutingPredictor	access:private
SADDLEBROWN	../../libs/libeasygl/src/easygl_constants.h	/^    SADDLEBROWN,$/;"	e	enum:color_types
SAFE	base/vpr_types.h	/^	OFF, SAFE, AGGRESSIVE$/;"	e	enum:ScreenUpdatePriority::e_routing_failure_predictor
SALMON	../../libs/libeasygl/src/easygl_constants.h	/^    SALMON,$/;"	e	enum:color_types
SANDYBROWN	../../libs/libeasygl/src/easygl_constants.h	/^    SANDYBROWN,$/;"	e	enum:color_types
SBOX_ERROR	route/rr_graph_sbox.cpp	/^#define SBOX_ERROR /;"	d	file:
SBType	../../libs/libarchfpga/src/physical_types.h	/^	enum e_switch_block_type SBType;$/;"	m	struct:t_arch	typeref:enum:t_arch::e_switch_block_type	access:public
SB_EDGE_STRAIGHT_ARROW_POSITION	draw/draw.cpp	/^constexpr float SB_EDGE_STRAIGHT_ARROW_POSITION = 0.95;$/;"	v
SB_EDGE_TURN_ARROW_POSITION	draw/draw.cpp	/^constexpr float SB_EDGE_TURN_ARROW_POSITION = 0.2;$/;"	v
SB_Side_Connection	../../libs/libarchfpga/src/physical_types.h	/^	SB_Side_Connection() = default;$/;"	p	class:SB_Side_Connection	access:public	signature:()
SB_Side_Connection	../../libs/libarchfpga/src/physical_types.h	/^	SB_Side_Connection(enum e_side from, enum e_side to)$/;"	f	class:SB_Side_Connection	access:public	signature:(enum e_side from, enum e_side to)
SB_Side_Connection	../../libs/libarchfpga/src/physical_types.h	/^class SB_Side_Connection{$/;"	c
SB_Side_Connection::SB_Side_Connection	../../libs/libarchfpga/src/physical_types.h	/^	SB_Side_Connection() = default;$/;"	p	class:SB_Side_Connection	access:public	signature:()
SB_Side_Connection::SB_Side_Connection	../../libs/libarchfpga/src/physical_types.h	/^	SB_Side_Connection(enum e_side from, enum e_side to)$/;"	f	class:SB_Side_Connection	access:public	signature:(enum e_side from, enum e_side to)
SB_Side_Connection::from_side	../../libs/libarchfpga/src/physical_types.h	/^	enum e_side from_side = TOP;$/;"	m	class:SB_Side_Connection	typeref:enum:SB_Side_Connection::e_side	access:public
SB_Side_Connection::operator <	../../libs/libarchfpga/src/physical_types.h	/^	bool operator < (const SB_Side_Connection &obj) const{$/;"	f	class:SB_Side_Connection	access:public	signature:(const SB_Side_Connection &obj) const
SB_Side_Connection::set_sides	../../libs/libarchfpga/src/physical_types.h	/^	void set_sides( enum e_side from, enum e_side to ){$/;"	f	class:SB_Side_Connection	access:public	signature:( enum e_side from, enum e_side to )
SB_Side_Connection::to_side	../../libs/libarchfpga/src/physical_types.h	/^	enum e_side to_side = TOP;$/;"	m	class:SB_Side_Connection	typeref:enum:SB_Side_Connection::e_side	access:public
SCALE_DELAY	base/vpr_types.h	/^    MINIMAX, SCALE_DELAY, DISABLE$/;"	e	enum:ScreenUpdatePriority::e_routing_budgets_algorithm
SCREEN	../../libs/libeasygl/src/graphics_state.h	/^    SCREEN = 0,$/;"	e	enum:__anon24
SDCFile	base/read_options.h	/^    argparse::ArgValue<std::string> SDCFile;$/;"	m	struct:t_options	access:public
SDCFile	base/vpr_types.h	/^    std::string SDCFile;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
SEAGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    SEAGREEN,$/;"	e	enum:color_types
SEASHELL	../../libs/libeasygl/src/easygl_constants.h	/^    SEASHELL,$/;"	e	enum:color_types
SEG_DETAILS_X	route/rr_graph2.h	/^	SEG_DETAILS_X, SEG_DETAILS_Y$/;"	e	enum:e_seg_details_type
SEG_DETAILS_Y	route/rr_graph2.h	/^	SEG_DETAILS_X, SEG_DETAILS_Y$/;"	e	enum:e_seg_details_type
SELECTED_COLOR	draw/draw.h	/^const color_types SELECTED_COLOR = GREEN;$/;"	v
SETUP	route/route_budgets.h	/^    SETUP, HOLD$/;"	e	enum:analysis_type
SETUPGRID_H	base/SetupGrid.h	/^#define SETUPGRID_H$/;"	d
SETUPVPR_H	base/SetupVPR.h	/^#define SETUPVPR_H$/;"	d
SHORT	../../libs/libarchfpga/src/physical_types.h	/^    SHORT,          \/\/A non-configurable electrically shorted connection (multi-driver)$/;"	m	class:SwitchType	access:private
SHORT_PATH_EXP	route/route_budgets.cpp	/^#define SHORT_PATH_EXP /;"	d	file:
SHOWSETUP_H	base/ShowSetup.h	/^#define SHOWSETUP_H$/;"	d
SIDES	../../libs/libarchfpga/src/physical_types.h	/^constexpr std::array<e_side, NUM_SIDES> SIDES = { {TOP, RIGHT, BOTTOM, LEFT} }; \/\/Set of all side orientations$/;"	v
SIDE_STRING	../../libs/libarchfpga/src/physical_types.h	/^constexpr std::array<const char*, NUM_SIDES> SIDE_STRING = { {"TOP", "RIGHT", "BOTTOM", "LEFT"} }; \/\/String versions of side orientations$/;"	v
SIENNA	../../libs/libeasygl/src/easygl_constants.h	/^    SIENNA,$/;"	e	enum:color_types
SIGNAL_HANLDER_H	base/vpr_signal_handler.h	/^#define SIGNAL_HANLDER_H$/;"	d
SILVER	../../libs/libeasygl/src/easygl_constants.h	/^    SILVER,$/;"	e	enum:color_types
SINK	base/netlist_fwd.h	/^	SINK,	\/\/The pin is a net sink$/;"	m	class:PinType	access:private
SINK_COST_INDEX	base/vpr_types.h	/^	SINK_COST_INDEX,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
SKYBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    SKYBLUE,$/;"	e	enum:color_types
SLATEBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    SLATEBLUE,$/;"	e	enum:color_types
SLATEGRAY	../../libs/libeasygl/src/easygl_constants.h	/^    SLATEGRAY,$/;"	e	enum:color_types
SLATEGREY	../../libs/libeasygl/src/easygl_constants.h	/^    SLATEGREY,$/;"	e	enum:color_types
SLRE_CASE_INSENSITIVE	timing/slre.h	/^enum slre_option {SLRE_CASE_INSENSITIVE = 1};$/;"	e	enum:slre_option
SLRE_FLOAT	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	e	enum:slre_capture
SLRE_H	timing/slre.h	/^#define SLRE_H$/;"	d
SLRE_INT	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	e	enum:slre_capture
SLRE_STRING	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	e	enum:slre_capture
SMALLEST	route/router_lookahead_map.cpp	/^	SMALLEST,	\/\/the smallest-delay cost recorded$/;"	e	enum:e_representative_entry_method	file:
SMALL_NET	place/place.cpp	/^#define SMALL_NET /;"	d	file:
SNOW	../../libs/libeasygl/src/easygl_constants.h	/^    SNOW,$/;"	e	enum:color_types
SOLID	../../libs/libeasygl/src/easygl_constants.h	/^    SOLID, DASHED$/;"	e	enum:line_types
SOURCE_COST_INDEX	base/vpr_types.h	/^	SOURCE_COST_INDEX = 0,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
SOURCE_PUGIXML_CPP	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^#define SOURCE_PUGIXML_CPP$/;"	d	file:
SPACE	timing/slre.cpp	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon10	file:
SPRINGGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    SPRINGGREEN,$/;"	e	enum:color_types
STAGE_AUTO	base/vpr_types.h	/^    STAGE_AUTO$/;"	e	enum:ScreenUpdatePriority::e_stage_action
STAGE_DO	base/vpr_types.h	/^    STAGE_DO,$/;"	e	enum:ScreenUpdatePriority::e_stage_action
STAGE_LOAD	base/vpr_types.h	/^    STAGE_LOAD,$/;"	e	enum:ScreenUpdatePriority::e_stage_action
STAGE_SKIP	base/vpr_types.h	/^    STAGE_SKIP = 0,$/;"	e	enum:ScreenUpdatePriority::e_stage_action
STAR	timing/slre.cpp	/^  END, BRANCH, ANY, EXACT, ANYOF, ANYBUT, OPEN, CLOSE, BOL, EOL, STAR, PLUS,$/;"	e	enum:__anon10	file:
STARQ	timing/slre.cpp	/^  STARQ, PLUSQ, QUEST, SPACE, NONSPACE, DIGIT$/;"	e	enum:__anon10	file:
STATIC	base/vpr_types.h	/^    STATIC, \/\/Router net bounding boxes are not updated$/;"	m	class:ScreenUpdatePriority::e_route_bb_update	access:private
STEELBLUE	../../libs/libeasygl/src/easygl_constants.h	/^    STEELBLUE,$/;"	e	enum:color_types
STRAIGHT	../../libs/libarchfpga/src/physical_types.h	/^    STRAIGHT,      \/\/Straight-through connections (i.e. vertical + horizontal)$/;"	m	class:e_sb_type	access:private
SUBSET	../../libs/libarchfpga/src/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL, CUSTOM$/;"	e	enum:e_switch_block_type
SUCCESS_EXIT_CODE	base/vpr_exit_codes.h	/^constexpr int SUCCESS_EXIT_CODE = 0; \/\/Everything OK$/;"	v
SURFACE_H	../../libs/libeasygl/src/Surface.h	/^#define SURFACE_H$/;"	d
SWITCH_TYPE_STRINGS	../../libs/libarchfpga/src/physical_types.h	/^constexpr std::array<const char*,size_t(SwitchType::NUM_SWITCH_TYPES)> SWITCH_TYPE_STRINGS = {{"MUX", "TRISTATE", "PASS_GATE", "SHORT", "BUFFER", "INVALID" }};$/;"	v
ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedActionTimer::ScopedActionTimer(std::string action_str)$/;"	f	class:vtr::ScopedActionTimer	signature:(std::string action_str)
ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ScopedActionTimer(const std::string action);$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:(const std::string action)
ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.h	/^    class ScopedActionTimer : public Timer {$/;"	c	namespace:vtr	inherits:Timer
ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedFinishTimer::ScopedFinishTimer(std::string action_str)$/;"	f	class:vtr::ScopedFinishTimer	signature:(std::string action_str)
ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ScopedFinishTimer(const std::string action);$/;"	p	class:vtr::ScopedFinishTimer	access:public	signature:(const std::string action)
ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^    class ScopedFinishTimer : public ScopedActionTimer {$/;"	c	namespace:vtr	inherits:ScopedActionTimer
ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedStartFinishTimer::ScopedStartFinishTimer(std::string action_str)$/;"	f	class:vtr::ScopedStartFinishTimer	signature:(std::string action_str)
ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ScopedStartFinishTimer(const std::string action);$/;"	p	class:vtr::ScopedStartFinishTimer	access:public	signature:(const std::string action)
ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^    class ScopedStartFinishTimer : public ScopedActionTimer {$/;"	c	namespace:vtr	inherits:ScopedActionTimer
ScreenUpdatePriority	base/vpr_types.h	/^enum class ScreenUpdatePriority {$/;"	c
ScreenUpdatePriority::AGGRESSIVE	base/vpr_types.h	/^	OFF, SAFE, AGGRESSIVE$/;"	e	enum:ScreenUpdatePriority::e_routing_failure_predictor
ScreenUpdatePriority::AUTO_SCHED	base/vpr_types.h	/^	AUTO_SCHED, USER_SCHED$/;"	e	enum:ScreenUpdatePriority::sched_type
ScreenUpdatePriority::BLK_FAILED_FEASIBLE	base/vpr_types.h	/^    BLK_FAILED_FEASIBLE,$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
ScreenUpdatePriority::BLK_FAILED_ROUTE	base/vpr_types.h	/^    BLK_FAILED_ROUTE,$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
ScreenUpdatePriority::BLK_PASSED	base/vpr_types.h	/^	BLK_PASSED,$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
ScreenUpdatePriority::BLK_STATUS_UNDEFINED	base/vpr_types.h	/^    BLK_STATUS_UNDEFINED$/;"	e	enum:ScreenUpdatePriority::e_block_pack_status
ScreenUpdatePriority::BOUNDING_BOX_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:ScreenUpdatePriority::e_place_algorithm
ScreenUpdatePriority::BREADTH_FIRST	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:ScreenUpdatePriority::e_router_algorithm
ScreenUpdatePriority::CHANX_COST_INDEX_START	base/vpr_types.h	/^	CHANX_COST_INDEX_START$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
ScreenUpdatePriority::DELAY_NORMALIZED	base/vpr_types.h	/^	DELAY_NORMALIZED, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
ScreenUpdatePriority::DELAY_NORMALIZED_FREQUENCY	base/vpr_types.h	/^	DELAY_NORMALIZED_FREQUENCY, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
ScreenUpdatePriority::DELAY_NORMALIZED_LENGTH	base/vpr_types.h	/^	DELAY_NORMALIZED_LENGTH, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
ScreenUpdatePriority::DELAY_NORMALIZED_LENGTH_FREQUENCY	base/vpr_types.h	/^	DELAY_NORMALIZED_LENGTH_FREQUENCY, $/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
ScreenUpdatePriority::DEMAND_ONLY	base/vpr_types.h	/^    DEMAND_ONLY$/;"	e	enum:ScreenUpdatePriority::e_base_cost_type
ScreenUpdatePriority::DETAILED	base/vpr_types.h	/^	GLOBAL, DETAILED$/;"	e	enum:ScreenUpdatePriority::e_route_type
ScreenUpdatePriority::DIRECTION_STRING	base/vpr_types.h	/^constexpr std::array<const char*, NUM_DIRECTIONS> DIRECTION_STRING = { {"INC_DIRECTION", "DEC_DIRECTION", "BI_DIRECTION", "NO_DIRECTION"} };$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::DISABLE	base/vpr_types.h	/^    MINIMAX, SCALE_DELAY, DISABLE$/;"	e	enum:ScreenUpdatePriority::e_routing_budgets_algorithm
ScreenUpdatePriority::EMPTY_BLOCK_ID	base/vpr_types.h	/^constexpr auto EMPTY_BLOCK_ID = ClusterBlockId(-1);$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::EMPTY_BLOCK_NAME	base/vpr_types.h	/^constexpr const char* EMPTY_BLOCK_NAME = "EMPTY";$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::FREE	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:ScreenUpdatePriority::e_pad_loc_type
ScreenUpdatePriority::GLOBAL	base/vpr_types.h	/^	GLOBAL, DETAILED$/;"	e	enum:ScreenUpdatePriority::e_route_type
ScreenUpdatePriority::INVALID_BLOCK_ID	base/vpr_types.h	/^constexpr auto INVALID_BLOCK_ID = ClusterBlockId(-2);$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::IPIN_COST_INDEX	base/vpr_types.h	/^	IPIN_COST_INDEX,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
ScreenUpdatePriority::MAJOR	base/vpr_types.h	/^    MAJOR = 1$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::MINIMAX	base/vpr_types.h	/^    MINIMAX, SCALE_DELAY, DISABLE$/;"	e	enum:ScreenUpdatePriority::e_routing_budgets_algorithm
ScreenUpdatePriority::MINOR	base/vpr_types.h	/^    MINOR = 0,$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::MOLECULE_FORCED_PACK	base/vpr_types.h	/^	MOLECULE_SINGLE_ATOM, MOLECULE_FORCED_PACK$/;"	e	enum:ScreenUpdatePriority::e_pack_pattern_molecule_type
ScreenUpdatePriority::MOLECULE_SINGLE_ATOM	base/vpr_types.h	/^	MOLECULE_SINGLE_ATOM, MOLECULE_FORCED_PACK$/;"	e	enum:ScreenUpdatePriority::e_pack_pattern_molecule_type
ScreenUpdatePriority::NO_FIXED_CHANNEL_WIDTH	base/vpr_types.h	/^constexpr int NO_FIXED_CHANNEL_WIDTH = -1;$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::NO_PICTURE	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:ScreenUpdatePriority::pic_type
ScreenUpdatePriority::NO_TIMING	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:ScreenUpdatePriority::e_router_algorithm
ScreenUpdatePriority::OFF	base/vpr_types.h	/^	OFF, SAFE, AGGRESSIVE$/;"	e	enum:ScreenUpdatePriority::e_routing_failure_predictor
ScreenUpdatePriority::OPIN_COST_INDEX	base/vpr_types.h	/^	OPIN_COST_INDEX,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
ScreenUpdatePriority::PACK_BRUTE_FORCE	base/vpr_types.h	/^	PACK_GREEDY, PACK_BRUTE_FORCE$/;"	e	enum:ScreenUpdatePriority::e_packer_algorithm
ScreenUpdatePriority::PACK_GREEDY	base/vpr_types.h	/^	PACK_GREEDY, PACK_BRUTE_FORCE$/;"	e	enum:ScreenUpdatePriority::e_packer_algorithm
ScreenUpdatePriority::PATH_TIMING_DRIVEN_PLACE	base/vpr_types.h	/^	BOUNDING_BOX_PLACE, PATH_TIMING_DRIVEN_PLACE$/;"	e	enum:ScreenUpdatePriority::e_place_algorithm
ScreenUpdatePriority::PLACEMENT	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:ScreenUpdatePriority::pic_type
ScreenUpdatePriority::PLACE_ALWAYS	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:ScreenUpdatePriority::pfreq
ScreenUpdatePriority::PLACE_NEVER	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:ScreenUpdatePriority::pfreq
ScreenUpdatePriority::PLACE_ONCE	base/vpr_types.h	/^	PLACE_NEVER, PLACE_ONCE, PLACE_ALWAYS$/;"	e	enum:ScreenUpdatePriority::pfreq
ScreenUpdatePriority::PlaceDelayModelType	base/vpr_types.h	/^enum class PlaceDelayModelType {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::PlaceDelayModelType::DELTA	base/vpr_types.h	/^    DELTA,          \/\/Delta x\/y based delay model$/;"	m	class:ScreenUpdatePriority::PlaceDelayModelType	access:private
ScreenUpdatePriority::PlaceDelayModelType::DELTA_OVERRIDE	base/vpr_types.h	/^    DELTA_OVERRIDE, \/\/Delta x\/y based delay model with special case delay overrides$/;"	m	class:ScreenUpdatePriority::PlaceDelayModelType	access:private
ScreenUpdatePriority::RANDOM	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:ScreenUpdatePriority::e_pad_loc_type
ScreenUpdatePriority::ROUTING	base/vpr_types.h	/^	NO_PICTURE, PLACEMENT, ROUTING$/;"	e	enum:ScreenUpdatePriority::pic_type
ScreenUpdatePriority::RR_TYPES	base/vpr_types.h	/^constexpr std::array<t_rr_type, NUM_RR_TYPES> RR_TYPES = { {$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::RouteStatus	base/vpr_types.h	/^class RouteStatus {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::RouteStatus::RouteStatus	base/vpr_types.h	/^        RouteStatus() = default;$/;"	p	class:ScreenUpdatePriority::RouteStatus	access:public	signature:()
ScreenUpdatePriority::RouteStatus::RouteStatus	base/vpr_types.h	/^        RouteStatus(bool status_val, int chan_width_val)$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:(bool status_val, int chan_width_val)
ScreenUpdatePriority::RouteStatus::chan_width	base/vpr_types.h	/^        int chan_width() const { return chan_width_; }$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:() const
ScreenUpdatePriority::RouteStatus::chan_width_	base/vpr_types.h	/^        int chan_width_ = -1;$/;"	m	class:ScreenUpdatePriority::RouteStatus	access:private
ScreenUpdatePriority::RouteStatus::operator bool	base/vpr_types.h	/^        operator bool() const { return success(); }$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:() const
ScreenUpdatePriority::RouteStatus::success	base/vpr_types.h	/^        bool success() const { return success_; }$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:() const
ScreenUpdatePriority::RouteStatus::success_	base/vpr_types.h	/^        bool success_ = false;$/;"	m	class:ScreenUpdatePriority::RouteStatus	access:private
ScreenUpdatePriority::SAFE	base/vpr_types.h	/^	OFF, SAFE, AGGRESSIVE$/;"	e	enum:ScreenUpdatePriority::e_routing_failure_predictor
ScreenUpdatePriority::SCALE_DELAY	base/vpr_types.h	/^    MINIMAX, SCALE_DELAY, DISABLE$/;"	e	enum:ScreenUpdatePriority::e_routing_budgets_algorithm
ScreenUpdatePriority::SINK_COST_INDEX	base/vpr_types.h	/^	SINK_COST_INDEX,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
ScreenUpdatePriority::SOURCE_COST_INDEX	base/vpr_types.h	/^	SOURCE_COST_INDEX = 0,$/;"	e	enum:ScreenUpdatePriority::e_cost_indices
ScreenUpdatePriority::STAGE_AUTO	base/vpr_types.h	/^    STAGE_AUTO$/;"	e	enum:ScreenUpdatePriority::e_stage_action
ScreenUpdatePriority::STAGE_DO	base/vpr_types.h	/^    STAGE_DO,$/;"	e	enum:ScreenUpdatePriority::e_stage_action
ScreenUpdatePriority::STAGE_LOAD	base/vpr_types.h	/^    STAGE_LOAD,$/;"	e	enum:ScreenUpdatePriority::e_stage_action
ScreenUpdatePriority::STAGE_SKIP	base/vpr_types.h	/^    STAGE_SKIP = 0,$/;"	e	enum:ScreenUpdatePriority::e_stage_action
ScreenUpdatePriority::TIMING_DRIVEN	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:ScreenUpdatePriority::e_router_algorithm
ScreenUpdatePriority::TN_CB_IPIN	base/vpr_types.h	/^	TN_CB_IPIN, \/* input pin to complex block *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_CB_OPIN	base/vpr_types.h	/^	TN_CB_OPIN, \/* output pin from complex block *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_CLOCK_OPIN	base/vpr_types.h	/^    TN_CLOCK_OPIN, \/* Output pin from an on-chip clock source - comes from TN_CLOCK_SOURCE *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_CLOCK_SOURCE	base/vpr_types.h	/^    TN_CLOCK_SOURCE, \/* An on-chip clock generator such as a pll *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_CONSTANT_GEN_SOURCE	base/vpr_types.h	/^	TN_CONSTANT_GEN_SOURCE \/* source of a constant logic 1 or 0 *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_FF_CLOCK	base/vpr_types.h	/^	TN_FF_CLOCK, \/* clock pin of flip-flop *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_FF_IPIN	base/vpr_types.h	/^	TN_FF_IPIN, \/* input pin to a flip-flop - goes to TN_FF_SINK *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_FF_OPIN	base/vpr_types.h	/^	TN_FF_OPIN, \/* output pin from a flip-flop - comes from TN_FF_SOURCE *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_FF_SINK	base/vpr_types.h	/^	TN_FF_SINK, \/* sink (D) pin of flip-flop *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_FF_SOURCE	base/vpr_types.h	/^	TN_FF_SOURCE, \/* source (Q) pin of flip-flop *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_INPAD_OPIN	base/vpr_types.h	/^	TN_INPAD_OPIN, \/* output from an input I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_INPAD_SOURCE	base/vpr_types.h	/^	TN_INPAD_SOURCE, \/* input to an input I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_INTERMEDIATE_NODE	base/vpr_types.h	/^	TN_INTERMEDIATE_NODE, \/* Used in post-packed timing graph only:$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_OUTPAD_IPIN	base/vpr_types.h	/^	TN_OUTPAD_IPIN, \/* input to an output I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_OUTPAD_SINK	base/vpr_types.h	/^	TN_OUTPAD_SINK, \/* output from an output I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_PRIMITIVE_IPIN	base/vpr_types.h	/^	TN_PRIMITIVE_IPIN, \/* input pin to a primitive (e.g. a LUT) *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::TN_PRIMITIVE_OPIN	base/vpr_types.h	/^	TN_PRIMITIVE_OPIN, \/* output pin from a primitive (e.g. a LUT) *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
ScreenUpdatePriority::USER	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:ScreenUpdatePriority::e_pad_loc_type
ScreenUpdatePriority::USER_SCHED	base/vpr_types.h	/^	AUTO_SCHED, USER_SCHED$/;"	e	enum:ScreenUpdatePriority::sched_type
ScreenUpdatePriority::e_base_cost_type	base/vpr_types.h	/^enum e_base_cost_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_block_pack_status	base/vpr_types.h	/^enum e_block_pack_status {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_cluster_seed	base/vpr_types.h	/^enum class e_cluster_seed {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_cluster_seed::BLEND	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
ScreenUpdatePriority::e_cluster_seed::MAX_INPUTS	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
ScreenUpdatePriority::e_cluster_seed::MAX_INPUT_PINS	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
ScreenUpdatePriority::e_cluster_seed::MAX_PINS	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
ScreenUpdatePriority::e_cluster_seed::TIMING	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
ScreenUpdatePriority::e_const_gen_inference	base/vpr_types.h	/^enum class e_const_gen_inference {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_const_gen_inference::COMB	base/vpr_types.h	/^    COMB, \/\/Only combinational constant generator inference$/;"	m	class:ScreenUpdatePriority::e_const_gen_inference	access:private
ScreenUpdatePriority::e_const_gen_inference::NONE	base/vpr_types.h	/^    NONE, \/\/No constant generator inference$/;"	m	class:ScreenUpdatePriority::e_const_gen_inference	access:private
ScreenUpdatePriority::e_cost_indices	base/vpr_types.h	/^enum e_cost_indices {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_incr_reroute_delay_ripup	base/vpr_types.h	/^enum class e_incr_reroute_delay_ripup {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_incr_reroute_delay_ripup::OFF	base/vpr_types.h	/^    OFF,$/;"	m	class:ScreenUpdatePriority::e_incr_reroute_delay_ripup	access:private
ScreenUpdatePriority::e_incr_reroute_delay_ripup::ON	base/vpr_types.h	/^    ON,$/;"	m	class:ScreenUpdatePriority::e_incr_reroute_delay_ripup	access:private
ScreenUpdatePriority::e_pack_pattern_molecule_type	base/vpr_types.h	/^enum e_pack_pattern_molecule_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_packer_algorithm	base/vpr_types.h	/^enum e_packer_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_pad_loc_type	base/vpr_types.h	/^enum e_pad_loc_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_place_algorithm	base/vpr_types.h	/^enum e_place_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_reducer	base/vpr_types.h	/^enum class e_reducer {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_reducer::ARITHMEAN	base/vpr_types.h	/^    ARITHMEAN,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
ScreenUpdatePriority::e_reducer::MAX	base/vpr_types.h	/^    MAX,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
ScreenUpdatePriority::e_reducer::MEDIAN	base/vpr_types.h	/^    MEDIAN,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
ScreenUpdatePriority::e_reducer::MIN	base/vpr_types.h	/^    MIN,$/;"	m	class:ScreenUpdatePriority::e_reducer	access:private
ScreenUpdatePriority::e_route_bb_update	base/vpr_types.h	/^enum class e_route_bb_update {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_route_bb_update::STATIC	base/vpr_types.h	/^    STATIC, \/\/Router net bounding boxes are not updated$/;"	m	class:ScreenUpdatePriority::e_route_bb_update	access:private
ScreenUpdatePriority::e_route_type	base/vpr_types.h	/^enum e_route_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_router_algorithm	base/vpr_types.h	/^enum e_router_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_router_lookahead	base/vpr_types.h	/^enum class e_router_lookahead {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_router_lookahead::CLASSIC	base/vpr_types.h	/^    CLASSIC, \/\/VPR's classic lookahead (assumes uniform wire types)$/;"	m	class:ScreenUpdatePriority::e_router_lookahead	access:private
ScreenUpdatePriority::e_router_lookahead::MAP	base/vpr_types.h	/^    MAP,     \/\/Lookahead considering different wire types (see Oleg Petelin's MASc Thesis)$/;"	m	class:ScreenUpdatePriority::e_router_lookahead	access:private
ScreenUpdatePriority::e_routing_budgets_algorithm	base/vpr_types.h	/^enum e_routing_budgets_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_routing_failure_predictor	base/vpr_types.h	/^enum e_routing_failure_predictor {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_stage_action	base/vpr_types.h	/^enum e_stage_action {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_timing_report_detail	base/vpr_types.h	/^enum class e_timing_report_detail {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_timing_report_detail::AGGREGATED	base/vpr_types.h	/^    AGGREGATED,         \/\/Show aggregated intra-block and inter-block delays$/;"	m	class:ScreenUpdatePriority::e_timing_report_detail	access:private
ScreenUpdatePriority::e_timing_report_detail::NETLIST	base/vpr_types.h	/^    NETLIST,            \/\/Only show netlist elements$/;"	m	class:ScreenUpdatePriority::e_timing_report_detail	access:private
ScreenUpdatePriority::e_tnode_type	base/vpr_types.h	/^enum e_tnode_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_unrelated_clustering	base/vpr_types.h	/^enum class e_unrelated_clustering {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::e_unrelated_clustering::OFF	base/vpr_types.h	/^    OFF, ON, AUTO	$/;"	m	class:ScreenUpdatePriority::e_unrelated_clustering	access:private
ScreenUpdatePriority::e_unrelated_clustering::ON	base/vpr_types.h	/^    OFF, ON, AUTO	$/;"	m	class:ScreenUpdatePriority::e_unrelated_clustering	access:private
ScreenUpdatePriority::pfreq	base/vpr_types.h	/^enum pfreq {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::pic_type	base/vpr_types.h	/^enum pic_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::sched_type	base/vpr_types.h	/^enum sched_type {$/;"	g	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_TokenPair	base/vpr_types.h	/^struct t_TokenPair {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_TokenPair::Enum	base/vpr_types.h	/^	int Enum;$/;"	m	struct:ScreenUpdatePriority::t_TokenPair	access:public
ScreenUpdatePriority::t_TokenPair::Str	base/vpr_types.h	/^	const char *Str;$/;"	m	struct:ScreenUpdatePriority::t_TokenPair	access:public
ScreenUpdatePriority::t_analysis_opts	base/vpr_types.h	/^struct t_analysis_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_analysis_opts::doAnalysis	base/vpr_types.h	/^    e_stage_action doAnalysis;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
ScreenUpdatePriority::t_analysis_opts::gen_post_synthesis_netlist	base/vpr_types.h	/^    bool gen_post_synthesis_netlist;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
ScreenUpdatePriority::t_analysis_opts::timing_report_detail	base/vpr_types.h	/^    e_timing_report_detail timing_report_detail;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
ScreenUpdatePriority::t_analysis_opts::timing_report_npaths	base/vpr_types.h	/^    int timing_report_npaths;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
ScreenUpdatePriority::t_analysis_opts::timing_report_skew	base/vpr_types.h	/^    bool timing_report_skew;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
ScreenUpdatePriority::t_annealing_sched	base/vpr_types.h	/^struct t_annealing_sched {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_annealing_sched::alpha_t	base/vpr_types.h	/^	float alpha_t;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
ScreenUpdatePriority::t_annealing_sched::exit_t	base/vpr_types.h	/^	float exit_t;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
ScreenUpdatePriority::t_annealing_sched::init_t	base/vpr_types.h	/^	float init_t;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
ScreenUpdatePriority::t_annealing_sched::inner_num	base/vpr_types.h	/^	float inner_num;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
ScreenUpdatePriority::t_annealing_sched::type	base/vpr_types.h	/^	enum sched_type type;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	typeref:enum:ScreenUpdatePriority::t_annealing_sched::sched_type	access:public
ScreenUpdatePriority::t_bb	base/vpr_types.h	/^struct t_bb {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_bb::xmax	base/vpr_types.h	/^	int xmax;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
ScreenUpdatePriority::t_bb::xmin	base/vpr_types.h	/^	int xmin;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
ScreenUpdatePriority::t_bb::ymax	base/vpr_types.h	/^	int ymax;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
ScreenUpdatePriority::t_bb::ymin	base/vpr_types.h	/^	int ymin;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
ScreenUpdatePriority::t_block_loc	base/vpr_types.h	/^struct t_block_loc {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_block_loc::is_fixed	base/vpr_types.h	/^	bool is_fixed = false;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
ScreenUpdatePriority::t_block_loc::nets_and_pins_synced_to_z_coordinate	base/vpr_types.h	/^    bool nets_and_pins_synced_to_z_coordinate = false;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
ScreenUpdatePriority::t_block_loc::x	base/vpr_types.h	/^    int x = OPEN;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
ScreenUpdatePriority::t_block_loc::y	base/vpr_types.h	/^    int y = OPEN;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
ScreenUpdatePriority::t_block_loc::z	base/vpr_types.h	/^    int z = OPEN;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
ScreenUpdatePriority::t_chan_details	base/vpr_types.h	/^typedef vtr::NdMatrix<t_chan_seg_details,3> t_chan_details;$/;"	t	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_chan_seg_details	base/vpr_types.h	/^class t_chan_seg_details {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_chan_seg_details::Cmetal	base/vpr_types.h	/^        float Cmetal() const { return seg_detail_->Cmetal; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::Cmetal_per_m	base/vpr_types.h	/^        float Cmetal_per_m() const { return seg_detail_->Cmetal_per_m; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::Rmetal	base/vpr_types.h	/^        float Rmetal() const { return seg_detail_->Rmetal; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::arch_opin_switch	base/vpr_types.h	/^        short arch_opin_switch() const { return seg_detail_->arch_opin_switch; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::arch_wire_switch	base/vpr_types.h	/^        short arch_wire_switch() const { return seg_detail_->arch_wire_switch; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::cb	base/vpr_types.h	/^        bool cb(int pos) const { return seg_detail_->cb[pos]; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int pos) const
ScreenUpdatePriority::t_chan_seg_details::direction	base/vpr_types.h	/^        e_direction direction() const { return seg_detail_->direction; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::group_size	base/vpr_types.h	/^        int group_size() const { return seg_detail_->group_size; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::group_start	base/vpr_types.h	/^        int group_start() const { return seg_detail_->group_start; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::index	base/vpr_types.h	/^        int index() const { return seg_detail_->index; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::length	base/vpr_types.h	/^        int length() const { return length_; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::length_	base/vpr_types.h	/^        int length_ = -1;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
ScreenUpdatePriority::t_chan_seg_details::longline	base/vpr_types.h	/^        bool longline() const { return seg_detail_->longline; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::sb	base/vpr_types.h	/^        bool sb(int pos) const { return seg_detail_->sb[pos]; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int pos) const
ScreenUpdatePriority::t_chan_seg_details::seg_detail_	base/vpr_types.h	/^        const t_seg_details* seg_detail_ = nullptr;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
ScreenUpdatePriority::t_chan_seg_details::seg_end	base/vpr_types.h	/^        int seg_end() const { return seg_end_; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::seg_end_	base/vpr_types.h	/^        int seg_end_ = -1;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
ScreenUpdatePriority::t_chan_seg_details::seg_start	base/vpr_types.h	/^        int seg_start() const { return seg_start_; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::seg_start_	base/vpr_types.h	/^        int seg_start_ = -1;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
ScreenUpdatePriority::t_chan_seg_details::set_length	base/vpr_types.h	/^        void set_length(int new_len) { length_ = new_len; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int new_len)
ScreenUpdatePriority::t_chan_seg_details::set_seg_end	base/vpr_types.h	/^        void set_seg_end(int new_end) { seg_end_ = new_end; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int new_end)
ScreenUpdatePriority::t_chan_seg_details::set_seg_start	base/vpr_types.h	/^        void set_seg_start(int new_start) { seg_start_ = new_start; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int new_start)
ScreenUpdatePriority::t_chan_seg_details::start	base/vpr_types.h	/^        int start() const { return seg_detail_->start; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_seg_details::t_chan_seg_details	base/vpr_types.h	/^        t_chan_seg_details() = default;$/;"	p	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:()
ScreenUpdatePriority::t_chan_seg_details::t_chan_seg_details	base/vpr_types.h	/^        t_chan_seg_details(const t_seg_details* init_seg_details)$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(const t_seg_details* init_seg_details)
ScreenUpdatePriority::t_chan_seg_details::type_name_ptr	base/vpr_types.h	/^        const char* type_name_ptr() const { return seg_detail_->type_name_ptr; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
ScreenUpdatePriority::t_chan_width	base/vpr_types.h	/^struct t_chan_width {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_chan_width::max	base/vpr_types.h	/^	int max = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_chan_width::x_list	base/vpr_types.h	/^    std::vector<int> x_list;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_chan_width::x_max	base/vpr_types.h	/^	int x_max = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_chan_width::x_min	base/vpr_types.h	/^	int x_min = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_chan_width::y_list	base/vpr_types.h	/^	std::vector<int> y_list;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_chan_width::y_max	base/vpr_types.h	/^	int y_max = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_chan_width::y_min	base/vpr_types.h	/^	int y_min = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
ScreenUpdatePriority::t_clb_opins_used	base/vpr_types.h	/^typedef vtr::vector<ClusterBlockId, std::vector<std::vector<int>>> t_clb_opins_used; \/\/[0..num_blocks-1][0..class-1][0..used_pins-1]$/;"	t	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_clock	base/vpr_types.h	/^struct t_clock {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_clock::fanout	base/vpr_types.h	/^	int fanout;$/;"	m	struct:ScreenUpdatePriority::t_clock	access:public
ScreenUpdatePriority::t_clock::is_netlist_clock	base/vpr_types.h	/^	bool is_netlist_clock; \/* Is this a netlist or virtual (external) clock? *\/$/;"	m	struct:ScreenUpdatePriority::t_clock	access:public
ScreenUpdatePriority::t_clock::name	base/vpr_types.h	/^	char * name;$/;"	m	struct:ScreenUpdatePriority::t_clock	access:public
ScreenUpdatePriority::t_cluster_placement_stats	base/vpr_types.h	/^struct t_cluster_placement_stats {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_cluster_placement_stats::curr_molecule	base/vpr_types.h	/^	const t_pack_molecule *curr_molecule; \/* current molecule being considered for packing *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
ScreenUpdatePriority::t_cluster_placement_stats::in_flight	base/vpr_types.h	/^	t_cluster_placement_primitive *in_flight; \/* ptrs to primitives currently being considered *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
ScreenUpdatePriority::t_cluster_placement_stats::invalid	base/vpr_types.h	/^	t_cluster_placement_primitive *invalid; \/* ptrs to primitives that are invalid *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
ScreenUpdatePriority::t_cluster_placement_stats::num_pb_types	base/vpr_types.h	/^	int num_pb_types; \/* num primitive pb_types inside complex block *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
ScreenUpdatePriority::t_cluster_placement_stats::tried	base/vpr_types.h	/^	t_cluster_placement_primitive *tried; \/* ptrs to primitives that are open but current logic block unable to pack to *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
ScreenUpdatePriority::t_cluster_placement_stats::valid_primitives	base/vpr_types.h	/^	t_cluster_placement_primitive **valid_primitives; \/* [0..num_pb_types-1] ptrs to linked list of valid primitives, for convenience, each linked list head is empty *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
ScreenUpdatePriority::t_det_routing_arch	base/vpr_types.h	/^struct t_det_routing_arch {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_det_routing_arch::Fs	base/vpr_types.h	/^	int Fs;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::R_minW_nmos	base/vpr_types.h	/^	float R_minW_nmos;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::R_minW_pmos	base/vpr_types.h	/^	float R_minW_pmos;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::delayless_switch	base/vpr_types.h	/^	short delayless_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::directionality	base/vpr_types.h	/^	enum e_directionality directionality; \/* UDSD by AY *\/$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	typeref:enum:ScreenUpdatePriority::t_det_routing_arch::e_directionality	access:public
ScreenUpdatePriority::t_det_routing_arch::global_route_switch	base/vpr_types.h	/^	short global_route_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::num_segment	base/vpr_types.h	/^	int num_segment;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::read_rr_graph_filename	base/vpr_types.h	/^    std::string read_rr_graph_filename;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::switch_block_type	base/vpr_types.h	/^	enum e_switch_block_type switch_block_type;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	typeref:enum:ScreenUpdatePriority::t_det_routing_arch::e_switch_block_type	access:public
ScreenUpdatePriority::t_det_routing_arch::switchblocks	base/vpr_types.h	/^	std::vector<t_switchblock_inf> switchblocks;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::wire_to_arch_ipin_switch	base/vpr_types.h	/^	int wire_to_arch_ipin_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::wire_to_rr_ipin_switch	base/vpr_types.h	/^	int wire_to_rr_ipin_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_det_routing_arch::write_rr_graph_filename	base/vpr_types.h	/^    std::string write_rr_graph_filename;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
ScreenUpdatePriority::t_ext_pin_util	base/vpr_types.h	/^struct t_ext_pin_util {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_ext_pin_util::input_pin_util	base/vpr_types.h	/^    float input_pin_util = 1.;$/;"	m	struct:ScreenUpdatePriority::t_ext_pin_util	access:public
ScreenUpdatePriority::t_ext_pin_util::output_pin_util	base/vpr_types.h	/^    float output_pin_util = 1.;$/;"	m	struct:ScreenUpdatePriority::t_ext_pin_util	access:public
ScreenUpdatePriority::t_ext_pin_util::t_ext_pin_util	base/vpr_types.h	/^    t_ext_pin_util() = default;$/;"	p	struct:ScreenUpdatePriority::t_ext_pin_util	access:public	signature:()
ScreenUpdatePriority::t_ext_pin_util::t_ext_pin_util	base/vpr_types.h	/^    t_ext_pin_util(float in, float out)$/;"	f	struct:ScreenUpdatePriority::t_ext_pin_util	access:public	signature:(float in, float out)
ScreenUpdatePriority::t_ext_pin_util_targets	base/vpr_types.h	/^class t_ext_pin_util_targets {$/;"	c	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_ext_pin_util_targets::defaults_	base/vpr_types.h	/^    t_ext_pin_util defaults_;$/;"	m	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:private
ScreenUpdatePriority::t_ext_pin_util_targets::get_pin_util	base/vpr_types.h	/^    t_ext_pin_util get_pin_util(std::string block_type_name) const;$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(std::string block_type_name) const
ScreenUpdatePriority::t_ext_pin_util_targets::overrides_	base/vpr_types.h	/^    std::map<std::string,t_ext_pin_util> overrides_;$/;"	m	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:private
ScreenUpdatePriority::t_ext_pin_util_targets::set_block_pin_util	base/vpr_types.h	/^    void set_block_pin_util(std::string block_type_name, t_ext_pin_util target);$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(std::string block_type_name, t_ext_pin_util target)
ScreenUpdatePriority::t_ext_pin_util_targets::set_default_pin_util	base/vpr_types.h	/^    void set_default_pin_util(t_ext_pin_util target);$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(t_ext_pin_util target)
ScreenUpdatePriority::t_ext_pin_util_targets::t_ext_pin_util_targets	base/vpr_types.h	/^    t_ext_pin_util_targets() = default;$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:()
ScreenUpdatePriority::t_ext_pin_util_targets::t_ext_pin_util_targets	base/vpr_types.h	/^    t_ext_pin_util_targets(float default_in_util, float default_out_util);$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(float default_in_util, float default_out_util)
ScreenUpdatePriority::t_file_name_opts	base/vpr_types.h	/^struct t_file_name_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_file_name_opts::ActFile	base/vpr_types.h	/^	std::string ActFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::ArchFile	base/vpr_types.h	/^    std::string ArchFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::BlifFile	base/vpr_types.h	/^	std::string BlifFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::CircuitName	base/vpr_types.h	/^	std::string CircuitName;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::CmosTechFile	base/vpr_types.h	/^	std::string CmosTechFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::NetFile	base/vpr_types.h	/^	std::string NetFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::PlaceFile	base/vpr_types.h	/^	std::string PlaceFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::PowerFile	base/vpr_types.h	/^	std::string PowerFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::RouteFile	base/vpr_types.h	/^	std::string RouteFile;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::out_file_prefix	base/vpr_types.h	/^	std::string out_file_prefix;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_file_name_opts::verify_file_digests	base/vpr_types.h	/^    bool verify_file_digests;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
ScreenUpdatePriority::t_grid_blocks	base/vpr_types.h	/^struct t_grid_blocks {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_grid_blocks::blocks	base/vpr_types.h	/^    std::vector<ClusterBlockId> blocks;$/;"	m	struct:ScreenUpdatePriority::t_grid_blocks	access:public
ScreenUpdatePriority::t_grid_blocks::usage	base/vpr_types.h	/^    int usage;$/;"	m	struct:ScreenUpdatePriority::t_grid_blocks	access:public
ScreenUpdatePriority::t_grid_tile	base/vpr_types.h	/^struct t_grid_tile {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_grid_tile::height_offset	base/vpr_types.h	/^	int height_offset = 0;$/;"	m	struct:ScreenUpdatePriority::t_grid_tile	access:public
ScreenUpdatePriority::t_grid_tile::type	base/vpr_types.h	/^	t_type_ptr type = nullptr;$/;"	m	struct:ScreenUpdatePriority::t_grid_tile	access:public
ScreenUpdatePriority::t_grid_tile::width_offset	base/vpr_types.h	/^	int width_offset = 0;$/;"	m	struct:ScreenUpdatePriority::t_grid_tile	access:public
ScreenUpdatePriority::t_io	base/vpr_types.h	/^struct t_io {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_io::clock_name	base/vpr_types.h	/^	char * clock_name; \/* Clock it was constrained on *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
ScreenUpdatePriority::t_io::delay	base/vpr_types.h	/^	float delay; \/* Delay through the I\/O in this constraint *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
ScreenUpdatePriority::t_io::file_line_number	base/vpr_types.h	/^	int file_line_number; \/* line in the SDC file I\/O was constrained on - used for error reporting *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
ScreenUpdatePriority::t_io::name	base/vpr_types.h	/^	char * name; \/* I\/O port name with an SDC constraint *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
ScreenUpdatePriority::t_legal_pos	base/vpr_types.h	/^struct t_legal_pos {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_legal_pos::x	base/vpr_types.h	/^	int x;$/;"	m	struct:ScreenUpdatePriority::t_legal_pos	access:public
ScreenUpdatePriority::t_legal_pos::y	base/vpr_types.h	/^	int y;$/;"	m	struct:ScreenUpdatePriority::t_legal_pos	access:public
ScreenUpdatePriority::t_legal_pos::z	base/vpr_types.h	/^	int z;$/;"	m	struct:ScreenUpdatePriority::t_legal_pos	access:public
ScreenUpdatePriority::t_linked_f_pointer	base/vpr_types.h	/^struct t_linked_f_pointer {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_linked_f_pointer::fptr	base/vpr_types.h	/^	float *fptr;$/;"	m	struct:ScreenUpdatePriority::t_linked_f_pointer	access:public
ScreenUpdatePriority::t_linked_f_pointer::next	base/vpr_types.h	/^	t_linked_f_pointer *next;$/;"	m	struct:ScreenUpdatePriority::t_linked_f_pointer	access:public
ScreenUpdatePriority::t_net_power	base/vpr_types.h	/^struct t_net_power {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_net_power::density	base/vpr_types.h	/^	float density;$/;"	m	struct:ScreenUpdatePriority::t_net_power	access:public
ScreenUpdatePriority::t_net_power::probability	base/vpr_types.h	/^	float probability;$/;"	m	struct:ScreenUpdatePriority::t_net_power	access:public
ScreenUpdatePriority::t_net_routing_status	base/vpr_types.h	/^struct t_net_routing_status {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_net_routing_status::is_fixed	base/vpr_types.h	/^    bool is_fixed = false; \/\/Whether the net is fixed (i.e. not to be re-routed)$/;"	m	struct:ScreenUpdatePriority::t_net_routing_status	access:public
ScreenUpdatePriority::t_net_routing_status::is_routed	base/vpr_types.h	/^    bool is_routed = false; \/\/Whether the net has been legally routed$/;"	m	struct:ScreenUpdatePriority::t_net_routing_status	access:public
ScreenUpdatePriority::t_netlist_opts	base/vpr_types.h	/^struct t_netlist_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_netlist_opts::absorb_buffer_luts	base/vpr_types.h	/^    bool absorb_buffer_luts = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_netlist_opts::const_gen_inference	base/vpr_types.h	/^    e_const_gen_inference const_gen_inference = e_const_gen_inference::COMB;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_netlist_opts::netlist_verbosity	base/vpr_types.h	/^    int netlist_verbosity = 1; \/\/Verbose output during netlist cleaning$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_netlist_opts::sweep_constant_primary_outputs	base/vpr_types.h	/^    bool sweep_constant_primary_outputs = false;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_netlist_opts::sweep_dangling_blocks	base/vpr_types.h	/^    bool sweep_dangling_blocks = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_netlist_opts::sweep_dangling_nets	base/vpr_types.h	/^    bool sweep_dangling_nets = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_netlist_opts::sweep_dangling_primary_ios	base/vpr_types.h	/^    bool sweep_dangling_primary_ios = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
ScreenUpdatePriority::t_override_constraint	base/vpr_types.h	/^struct t_override_constraint {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_override_constraint::constraint	base/vpr_types.h	/^	float constraint;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_override_constraint::file_line_number	base/vpr_types.h	/^	int file_line_number; \/* line in the SDC file clock was constrained on - used for error reporting *\/$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_override_constraint::num_multicycles	base/vpr_types.h	/^	int num_multicycles;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_override_constraint::num_sink	base/vpr_types.h	/^	int num_sink;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_override_constraint::num_source	base/vpr_types.h	/^	int num_source;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_override_constraint::sink_list	base/vpr_types.h	/^	char ** sink_list;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_override_constraint::source_list	base/vpr_types.h	/^	char ** source_list; \/* Array of net names of flip-flops or clocks *\/$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
ScreenUpdatePriority::t_pack_molecule	base/vpr_types.h	/^struct t_pack_molecule {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_pack_molecule::atom_block_ids	base/vpr_types.h	/^    std::vector<AtomBlockId> atom_block_ids; \/* [0..num_blocks-1] IDs of atom blocks that implements this molecule,$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::base_gain	base/vpr_types.h	/^	float base_gain; \/* Intrinsic "goodness" score for molecule independant of rest of netlist *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::chain_pattern	base/vpr_types.h	/^	t_model_chain_pattern *chain_pattern; \/* If this is a chain molecule, chain that this molecule matches *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::next	base/vpr_types.h	/^	t_pack_molecule *next;$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::num_blocks	base/vpr_types.h	/^	int num_blocks; \/* number of atom blocks of molecule *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::pack_pattern	base/vpr_types.h	/^	t_pack_patterns *pack_pattern; \/* If this is a forced_pack molecule, pattern this molecule matches *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::root	base/vpr_types.h	/^	int root; \/* root index of molecule, atom_block_ids[root] is the root atom block *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_pack_molecule::type	base/vpr_types.h	/^	enum e_pack_pattern_molecule_type type; \/* what kind of molecule is this? *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	typeref:enum:ScreenUpdatePriority::t_pack_molecule::e_pack_pattern_molecule_type	access:public
ScreenUpdatePriority::t_pack_molecule::valid	base/vpr_types.h	/^	bool valid; \/* Whether or not this molecule is still valid *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
ScreenUpdatePriority::t_packer_opts	base/vpr_types.h	/^struct t_packer_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_packer_opts::allow_unrelated_clustering	base/vpr_types.h	/^	e_unrelated_clustering allow_unrelated_clustering;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::alpha	base/vpr_types.h	/^	float alpha;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::auto_compute_inter_cluster_net_delay	base/vpr_types.h	/^	bool auto_compute_inter_cluster_net_delay;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::beta	base/vpr_types.h	/^	float beta;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::blif_file_name	base/vpr_types.h	/^	std::string blif_file_name;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::cluster_seed_type	base/vpr_types.h	/^	enum e_cluster_seed cluster_seed_type;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	typeref:enum:ScreenUpdatePriority::t_packer_opts::e_cluster_seed	access:public
ScreenUpdatePriority::t_packer_opts::connection_driven	base/vpr_types.h	/^	bool connection_driven;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::device_layout	base/vpr_types.h	/^    std::string device_layout;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::doPacking	base/vpr_types.h	/^	e_stage_action doPacking;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::enable_pin_feasibility_filter	base/vpr_types.h	/^    bool enable_pin_feasibility_filter;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::global_clocks	base/vpr_types.h	/^	bool global_clocks;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::hill_climbing_flag	base/vpr_types.h	/^	bool hill_climbing_flag;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::hmetis_input_file	base/vpr_types.h	/^	std::string hmetis_input_file;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::inter_cluster_net_delay	base/vpr_types.h	/^	float inter_cluster_net_delay;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::output_file	base/vpr_types.h	/^	std::string output_file;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::pack_verbosity	base/vpr_types.h	/^	int pack_verbosity;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::packer_algorithm	base/vpr_types.h	/^	enum e_packer_algorithm packer_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	typeref:enum:ScreenUpdatePriority::t_packer_opts::e_packer_algorithm	access:public
ScreenUpdatePriority::t_packer_opts::sdc_file_name	base/vpr_types.h	/^	std::string sdc_file_name;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::target_device_utilization	base/vpr_types.h	/^    float target_device_utilization;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::target_external_pin_util	base/vpr_types.h	/^    std::vector<std::string> target_external_pin_util;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_packer_opts::timing_driven	base/vpr_types.h	/^	bool timing_driven;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
ScreenUpdatePriority::t_pb	base/vpr_types.h	/^struct t_pb {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_pb::atom_pin_bit_index	base/vpr_types.h	/^    BitIndex atom_pin_bit_index(const t_pb_graph_pin* gpin) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const t_pb_graph_pin* gpin) const
ScreenUpdatePriority::t_pb::child_pbs	base/vpr_types.h	/^	t_pb **child_pbs = nullptr; \/* children pbs attached to this pb [0..num_child_pb_types - 1][0..child_type->num_pb - 1] *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::clock_net	base/vpr_types.h	/^	int clock_net = 0; \/* Records clock net driving a flip-flop, valid only for lowest-level, flip-flop PBs *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::find_pb	base/vpr_types.h	/^    const t_pb* find_pb(const t_pb_graph_node* gnode) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const t_pb_graph_node* gnode) const
ScreenUpdatePriority::t_pb::find_pb_for_model	base/vpr_types.h	/^    const t_pb* find_pb_for_model(const std::string& blif_model) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const std::string& blif_model) const
ScreenUpdatePriority::t_pb::get_mode	base/vpr_types.h	/^	t_mode* get_mode() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::get_num_child_types	base/vpr_types.h	/^	int get_num_child_types() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::get_num_children_of_type	base/vpr_types.h	/^	int get_num_children_of_type(int type_index) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(int type_index) const
ScreenUpdatePriority::t_pb::has_modes	base/vpr_types.h	/^	bool has_modes() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::hierarchical_type_name	base/vpr_types.h	/^    std::string hierarchical_type_name() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::is_primitive	base/vpr_types.h	/^    bool is_primitive() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::is_root	base/vpr_types.h	/^    bool is_root() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::mode	base/vpr_types.h	/^	int mode = 0; \/* mode that this pb is set to *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::name	base/vpr_types.h	/^	char *name = nullptr; \/* Name of this physical block *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::parent_pb	base/vpr_types.h	/^	t_pb *parent_pb = nullptr; \/* pointer to parent node *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::pb_graph_node	base/vpr_types.h	/^	t_pb_graph_node *pb_graph_node = nullptr; \/* pointer to pb_graph_node this pb corresponds to *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::pb_route	base/vpr_types.h	/^    t_pb_routes pb_route;$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::pb_stats	base/vpr_types.h	/^	t_pb_stats *pb_stats = nullptr; \/* statistics for current pb *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
ScreenUpdatePriority::t_pb::pin_rotations_	base/vpr_types.h	/^    std::map<const t_pb_graph_pin*,BitIndex> pin_rotations_; \/\/Contains the atom netlist port bit index associated$/;"	m	struct:ScreenUpdatePriority::t_pb	access:private
ScreenUpdatePriority::t_pb::root_pb	base/vpr_types.h	/^    const t_pb* root_pb() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
ScreenUpdatePriority::t_pb::set_atom_pin_bit_index	base/vpr_types.h	/^    void set_atom_pin_bit_index(const t_pb_graph_pin* gpin, BitIndex atom_pin_bit_idx) {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const t_pb_graph_pin* gpin, BitIndex atom_pin_bit_idx)
ScreenUpdatePriority::t_pb_route	base/vpr_types.h	/^struct t_pb_route {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_pb_route::atom_net_id	base/vpr_types.h	/^    AtomNetId atom_net_id; \/* which net in the atom netlist uses this pin *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
ScreenUpdatePriority::t_pb_route::driver_pb_pin_id	base/vpr_types.h	/^	int driver_pb_pin_id = OPEN; \/* The pb_pin id of the pb_pin that drives this pin *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
ScreenUpdatePriority::t_pb_route::pb_graph_pin	base/vpr_types.h	/^    const t_pb_graph_pin* pb_graph_pin = nullptr; \/* The graph pin associated with this node *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
ScreenUpdatePriority::t_pb_route::sink_pb_pin_ids	base/vpr_types.h	/^    std::vector<int> sink_pb_pin_ids; \/* The pb_pin id's of the pb_pins driven by this node *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
ScreenUpdatePriority::t_pb_routes	base/vpr_types.h	/^typedef vtr::flat_map2<int,t_pb_route> t_pb_routes;$/;"	t	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_pl_blocks_to_be_moved	base/vpr_types.h	/^struct t_pl_blocks_to_be_moved {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_pl_blocks_to_be_moved::moved_blocks	base/vpr_types.h	/^	t_pl_moved_block * moved_blocks;$/;"	m	struct:ScreenUpdatePriority::t_pl_blocks_to_be_moved	access:public
ScreenUpdatePriority::t_pl_blocks_to_be_moved::num_moved_blocks	base/vpr_types.h	/^	int num_moved_blocks;$/;"	m	struct:ScreenUpdatePriority::t_pl_blocks_to_be_moved	access:public
ScreenUpdatePriority::t_pl_moved_block	base/vpr_types.h	/^struct t_pl_moved_block {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_pl_moved_block::block_num	base/vpr_types.h	/^	ClusterBlockId block_num;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::swapped_from_is_empty	base/vpr_types.h	/^	int swapped_from_is_empty;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::swapped_to_was_empty	base/vpr_types.h	/^	int swapped_to_was_empty;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::xnew	base/vpr_types.h	/^	int xnew;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::xold	base/vpr_types.h	/^	int xold;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::ynew	base/vpr_types.h	/^	int ynew;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::yold	base/vpr_types.h	/^	int yold;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::znew	base/vpr_types.h	/^	int znew;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_pl_moved_block::zold	base/vpr_types.h	/^	int zold;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
ScreenUpdatePriority::t_place_region	base/vpr_types.h	/^struct t_place_region {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_place_region::capacity	base/vpr_types.h	/^	float capacity;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
ScreenUpdatePriority::t_place_region::cost	base/vpr_types.h	/^	float cost;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
ScreenUpdatePriority::t_place_region::inv_capacity	base/vpr_types.h	/^	float inv_capacity;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
ScreenUpdatePriority::t_place_region::occupancy	base/vpr_types.h	/^	float occupancy;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
ScreenUpdatePriority::t_placer_opts	base/vpr_types.h	/^struct t_placer_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_placer_opts::delay_model_reducer	base/vpr_types.h	/^    e_reducer delay_model_reducer;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::delay_model_type	base/vpr_types.h	/^    PlaceDelayModelType delay_model_type;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::delay_offset	base/vpr_types.h	/^    float delay_offset;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::delay_ramp_delta_threshold	base/vpr_types.h	/^    int delay_ramp_delta_threshold;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::delay_ramp_slope	base/vpr_types.h	/^    float delay_ramp_slope;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::doPlacement	base/vpr_types.h	/^	e_stage_action doPlacement;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::enable_timing_computations	base/vpr_types.h	/^	bool enable_timing_computations;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::inner_loop_recompute_divider	base/vpr_types.h	/^	int inner_loop_recompute_divider;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::pad_loc_file	base/vpr_types.h	/^    std::string pad_loc_file;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::pad_loc_type	base/vpr_types.h	/^	enum e_pad_loc_type pad_loc_type;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	typeref:enum:ScreenUpdatePriority::t_placer_opts::e_pad_loc_type	access:public
ScreenUpdatePriority::t_placer_opts::place_algorithm	base/vpr_types.h	/^	enum e_place_algorithm place_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	typeref:enum:ScreenUpdatePriority::t_placer_opts::e_place_algorithm	access:public
ScreenUpdatePriority::t_placer_opts::place_chan_width	base/vpr_types.h	/^	int place_chan_width;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::place_cost_exp	base/vpr_types.h	/^	float place_cost_exp;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::place_freq	base/vpr_types.h	/^	enum pfreq place_freq;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	typeref:enum:ScreenUpdatePriority::t_placer_opts::pfreq	access:public
ScreenUpdatePriority::t_placer_opts::post_place_timing_report_file	base/vpr_types.h	/^    std::string post_place_timing_report_file;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::recompute_crit_iter	base/vpr_types.h	/^	int recompute_crit_iter;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::seed	base/vpr_types.h	/^	int seed;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::td_place_exp_first	base/vpr_types.h	/^	float td_place_exp_first;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::td_place_exp_last	base/vpr_types.h	/^	float td_place_exp_last;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::timing_tradeoff	base/vpr_types.h	/^	float timing_tradeoff;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::tsu_abs_margin	base/vpr_types.h	/^    float tsu_abs_margin;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_placer_opts::tsu_rel_margin	base/vpr_types.h	/^    float tsu_rel_margin;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
ScreenUpdatePriority::t_power_opts	base/vpr_types.h	/^struct t_power_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_power_opts::do_power	base/vpr_types.h	/^	bool do_power; \/* Perform power estimation? *\/$/;"	m	struct:ScreenUpdatePriority::t_power_opts	access:public
ScreenUpdatePriority::t_prepacked_tnode_data	base/vpr_types.h	/^struct t_prepacked_tnode_data {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_prepacked_tnode_data::model_pin	base/vpr_types.h	/^	int model_port, model_pin; \/* technology mapped model pin *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::model_port	base/vpr_types.h	/^	int model_port, model_pin; \/* technology mapped model pin *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::model_port_ptr	base/vpr_types.h	/^	t_model_ports *model_port_ptr;$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::normalized_T_arr	base/vpr_types.h	/^	float normalized_T_arr; \/* arrival time (normalized with respect to max time) *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::normalized_slack	base/vpr_types.h	/^	float normalized_slack; \/* slack (normalized with respect to max slack) *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::normalized_total_critical_paths	base/vpr_types.h	/^	float normalized_total_critical_paths; \/* critical path count (normalized with respect to max count) *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::num_critical_input_paths	base/vpr_types.h	/^	long num_critical_input_paths, num_critical_output_paths; \/* count of critical paths fanning into\/out of this tnode *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_prepacked_tnode_data::num_critical_output_paths	base/vpr_types.h	/^	long num_critical_input_paths, num_critical_output_paths; \/* count of critical paths fanning into\/out of this tnode *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
ScreenUpdatePriority::t_router_opts	base/vpr_types.h	/^struct t_router_opts {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_router_opts::acc_fac	base/vpr_types.h	/^	float acc_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::astar_fac	base/vpr_types.h	/^	float astar_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::base_cost_type	base/vpr_types.h	/^	enum e_base_cost_type base_cost_type;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_base_cost_type	access:public
ScreenUpdatePriority::t_router_opts::bb_factor	base/vpr_types.h	/^	int bb_factor;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::bend_cost	base/vpr_types.h	/^	float bend_cost;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::congested_routing_iteration_threshold_frac	base/vpr_types.h	/^    float congested_routing_iteration_threshold_frac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::congestion_analysis	base/vpr_types.h	/^	bool congestion_analysis;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::criticality_exp	base/vpr_types.h	/^	float criticality_exp;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::doRouting	base/vpr_types.h	/^	e_stage_action doRouting;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::fanout_analysis	base/vpr_types.h	/^	bool fanout_analysis;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::first_iter_pres_fac	base/vpr_types.h	/^	float first_iter_pres_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::first_iteration_timing_report_file	base/vpr_types.h	/^    std::string first_iteration_timing_report_file;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::fixed_channel_width	base/vpr_types.h	/^	int fixed_channel_width;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::full_stats	base/vpr_types.h	/^	bool full_stats;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::high_fanout_threshold	base/vpr_types.h	/^    int high_fanout_threshold;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::incr_reroute_delay_ripup	base/vpr_types.h	/^    e_incr_reroute_delay_ripup incr_reroute_delay_ripup;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::initial_pres_fac	base/vpr_types.h	/^	float initial_pres_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::lookahead_type	base/vpr_types.h	/^    e_router_lookahead lookahead_type;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::max_convergence_count	base/vpr_types.h	/^    int max_convergence_count;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::max_criticality	base/vpr_types.h	/^	float max_criticality;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::max_router_iterations	base/vpr_types.h	/^	int max_router_iterations;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::min_channel_width_hint	base/vpr_types.h	/^    int min_channel_width_hint; \/\/Hint to binary search of what the minimum channel width is$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::min_incremental_reroute_fanout	base/vpr_types.h	/^	int min_incremental_reroute_fanout;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::pres_fac_mult	base/vpr_types.h	/^	float pres_fac_mult;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::reconvergence_cpd_threshold	base/vpr_types.h	/^    float reconvergence_cpd_threshold;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::route_bb_update	base/vpr_types.h	/^    e_route_bb_update route_bb_update;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::route_type	base/vpr_types.h	/^	enum e_route_type route_type;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_route_type	access:public
ScreenUpdatePriority::t_router_opts::router_algorithm	base/vpr_types.h	/^	enum e_router_algorithm router_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_router_algorithm	access:public
ScreenUpdatePriority::t_router_opts::router_debug_net	base/vpr_types.h	/^    int router_debug_net;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::router_debug_sink_rr	base/vpr_types.h	/^    int router_debug_sink_rr;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::routing_budgets_algorithm	base/vpr_types.h	/^	enum e_routing_budgets_algorithm routing_budgets_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_routing_budgets_algorithm	access:public
ScreenUpdatePriority::t_router_opts::routing_failure_predictor	base/vpr_types.h	/^	enum e_routing_failure_predictor routing_failure_predictor;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_routing_failure_predictor	access:public
ScreenUpdatePriority::t_router_opts::save_routing_per_iteration	base/vpr_types.h	/^    bool save_routing_per_iteration;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::switch_usage_analysis	base/vpr_types.h	/^    bool switch_usage_analysis;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::trim_empty_channels	base/vpr_types.h	/^	bool trim_empty_channels;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::trim_obs_channels	base/vpr_types.h	/^	bool trim_obs_channels;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_router_opts::verify_binary_search	base/vpr_types.h	/^	bool verify_binary_search;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
ScreenUpdatePriority::t_rr_node_indices	base/vpr_types.h	/^typedef std::vector<std::vector<std::vector<std::vector<std::vector<int>>>>> t_rr_node_indices; \/\/[0..num_rr_types-1][0..grid_width-1][0..grid_height-1][0..NUM_SIDES-1][0..max_ptc-1]$/;"	t	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_rr_node_route_inf	base/vpr_types.h	/^struct t_rr_node_route_inf {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_rr_node_route_inf::acc_cost	base/vpr_types.h	/^	float acc_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_node_route_inf::backward_path_cost	base/vpr_types.h	/^	float backward_path_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_node_route_inf::occ	base/vpr_types.h	/^        short occ() const { return occ_; }$/;"	f	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public	signature:() const
ScreenUpdatePriority::t_rr_node_route_inf::occ_	base/vpr_types.h	/^        short occ_ = 0;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:private
ScreenUpdatePriority::t_rr_node_route_inf::path_cost	base/vpr_types.h	/^	float path_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_node_route_inf::pres_cost	base/vpr_types.h	/^	float pres_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_node_route_inf::prev_edge	base/vpr_types.h	/^	short prev_edge;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_node_route_inf::prev_node	base/vpr_types.h	/^	int prev_node;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_node_route_inf::set_occ	base/vpr_types.h	/^        void set_occ(int new_occ) { occ_ = new_occ; }$/;"	f	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public	signature:(int new_occ)
ScreenUpdatePriority::t_rr_node_route_inf::target_flag	base/vpr_types.h	/^	short target_flag;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
ScreenUpdatePriority::t_rr_type	base/vpr_types.h	/^} t_rr_type;$/;"	m	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_seg_details	base/vpr_types.h	/^struct t_seg_details {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_seg_details::Cmetal	base/vpr_types.h	/^	float Cmetal = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::Cmetal_per_m	base/vpr_types.h	/^	float Cmetal_per_m = 0; \/* Used for power *\/$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::Rmetal	base/vpr_types.h	/^	float Rmetal = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::arch_opin_switch	base/vpr_types.h	/^	short arch_opin_switch = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::arch_wire_switch	base/vpr_types.h	/^	short arch_wire_switch = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::cb	base/vpr_types.h	/^	std::unique_ptr<bool[]> cb;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::direction	base/vpr_types.h	/^	enum e_direction direction = NO_DIRECTION;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	typeref:enum:ScreenUpdatePriority::t_seg_details::e_direction	access:public
ScreenUpdatePriority::t_seg_details::group_size	base/vpr_types.h	/^	int group_size = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::group_start	base/vpr_types.h	/^	int group_start = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::index	base/vpr_types.h	/^	int index = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::length	base/vpr_types.h	/^	int length = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::longline	base/vpr_types.h	/^	bool longline = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::sb	base/vpr_types.h	/^    std::unique_ptr<bool[]> sb;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::seg_end	base/vpr_types.h	/^	int seg_end = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::seg_start	base/vpr_types.h	/^	int seg_start = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::start	base/vpr_types.h	/^	int start = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::twisted	base/vpr_types.h	/^	bool twisted = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_seg_details::type_name_ptr	base/vpr_types.h	/^	const char *type_name_ptr = nullptr;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
ScreenUpdatePriority::t_slack	base/vpr_types.h	/^struct t_slack {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_slack::slack	base/vpr_types.h	/^	float ** slack;$/;"	m	struct:ScreenUpdatePriority::t_slack	access:public
ScreenUpdatePriority::t_slack::timing_criticality	base/vpr_types.h	/^	float ** timing_criticality;$/;"	m	struct:ScreenUpdatePriority::t_slack	access:public
ScreenUpdatePriority::t_tedge	base/vpr_types.h	/^struct t_tedge {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_tedge::Tdel	base/vpr_types.h	/^	float Tdel; \/* delay to go to to_node along this edge *\/$/;"	m	struct:ScreenUpdatePriority::t_tedge	access:public
ScreenUpdatePriority::t_tedge::to_node	base/vpr_types.h	/^	int to_node; \/* index of node at the sink end of this edge *\/$/;"	m	struct:ScreenUpdatePriority::t_tedge	access:public
ScreenUpdatePriority::t_timing_constraints	base/vpr_types.h	/^struct t_timing_constraints { \/* Container structure for all SDC timing constraints.$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_timing_constraints::cc_constraints	base/vpr_types.h	/^	t_override_constraint * cc_constraints; \/*  [0..num_cc_constraints - 1] array of such constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::cf_constraints	base/vpr_types.h	/^	t_override_constraint * cf_constraints; \/*  [0..num_cf_constraints - 1] array of such constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::constrained_clocks	base/vpr_types.h	/^	t_clock * constrained_clocks; \/* [0..timing_ctx.sdc->num_constrained_clocks - 1] array of clocks with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::constrained_inputs	base/vpr_types.h	/^	t_io * constrained_inputs; \/* [0..num_constrained_inputs - 1] array of inputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::constrained_outputs	base/vpr_types.h	/^	t_io * constrained_outputs; \/* [0..num_constrained_outputs - 1] array of outputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::domain_constraint	base/vpr_types.h	/^    vtr::Matrix<float> domain_constraint; \/* [0..num_constrained_clocks - 1 (source)][0..num_constrained_clocks - 1 (destination)] *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::fc_constraints	base/vpr_types.h	/^	t_override_constraint * fc_constraints; \/*  [0..num_fc_constraints - 1] *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::ff_constraints	base/vpr_types.h	/^	t_override_constraint * ff_constraints; \/*  [0..num_ff_constraints - 1] array of such constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_cc_constraints	base/vpr_types.h	/^	int num_cc_constraints; \/* number of special-case clock-to-clock constraints overriding default, calculated, timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_cf_constraints	base/vpr_types.h	/^	int num_cf_constraints; \/* number of special-case clock-to-flipflop constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_constrained_clocks	base/vpr_types.h	/^	int num_constrained_clocks; \/* number of clocks with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_constrained_inputs	base/vpr_types.h	/^	int num_constrained_inputs; \/* number of inputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_constrained_outputs	base/vpr_types.h	/^	int num_constrained_outputs; \/* number of outputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_fc_constraints	base/vpr_types.h	/^	int num_fc_constraints; \/* number of special-case flipflop-to-clock constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_constraints::num_ff_constraints	base/vpr_types.h	/^	int num_ff_constraints; \/* number of special-case flipflop-to-flipflop constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ScreenUpdatePriority::t_timing_inf	base/vpr_types.h	/^struct t_timing_inf {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_timing_inf::C_ipin_cblock	base/vpr_types.h	/^	float C_ipin_cblock;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
ScreenUpdatePriority::t_timing_inf::SDCFile	base/vpr_types.h	/^    std::string SDCFile;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
ScreenUpdatePriority::t_timing_inf::T_ipin_cblock	base/vpr_types.h	/^	float T_ipin_cblock;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
ScreenUpdatePriority::t_timing_inf::slack_definition	base/vpr_types.h	/^    std::string slack_definition;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
ScreenUpdatePriority::t_timing_inf::timing_analysis_enabled	base/vpr_types.h	/^	bool timing_analysis_enabled;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
ScreenUpdatePriority::t_timing_stats	base/vpr_types.h	/^struct t_timing_stats {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_timing_stats::cpd	base/vpr_types.h	/^	float ** cpd;$/;"	m	struct:ScreenUpdatePriority::t_timing_stats	access:public
ScreenUpdatePriority::t_timing_stats::least_slack	base/vpr_types.h	/^	float ** least_slack;$/;"	m	struct:ScreenUpdatePriority::t_timing_stats	access:public
ScreenUpdatePriority::t_tnode	base/vpr_types.h	/^struct t_tnode {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_tnode::T_arr	base/vpr_types.h	/^	float T_arr; \/* Arrival time of the last input signal to this node. *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::T_req	base/vpr_types.h	/^	float T_req; \/* Required arrival time of the last input signal to this node$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::backward_weight	base/vpr_types.h	/^	float forward_weight, backward_weight; \/* Weightings of the importance of paths$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::block	base/vpr_types.h	/^	ClusterBlockId block; \/* atom block primitive which this tnode is part of *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::clock_delay	base/vpr_types.h	/^	float clock_delay; \/* The time taken for a clock signal to get to the flip-flop or I\/O (assumed 0 for I\/Os). *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::clock_domain	base/vpr_types.h	/^	int clock_domain; \/* Index of the clock in timing_ctx.sdc->constrained_clocks which this flip-flop or I\/O is constrained on. *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::forward_weight	base/vpr_types.h	/^	float forward_weight, backward_weight; \/* Weightings of the importance of paths$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::is_comb_loop_breakpoint	base/vpr_types.h	/^	unsigned int is_comb_loop_breakpoint : 1; \/* Indicates that this tnode had input edges purposely$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::num_edges	base/vpr_types.h	/^	int num_edges;$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::out_edges	base/vpr_types.h	/^	t_tedge *out_edges; \/* [0..num_edges - 1] array of edges fanning out from this tnode.$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::pb_graph_pin	base/vpr_types.h	/^	t_pb_graph_pin *pb_graph_pin; \/* pb_graph_pin that this block is connected to *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::prepacked_data	base/vpr_types.h	/^	t_prepacked_tnode_data * prepacked_data;$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_tnode::type	base/vpr_types.h	/^	e_tnode_type type; \/* see the above enum *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
ScreenUpdatePriority::t_trace	base/vpr_types.h	/^struct t_trace {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_trace::index	base/vpr_types.h	/^	int index;$/;"	m	struct:ScreenUpdatePriority::t_trace	access:public
ScreenUpdatePriority::t_trace::iswitch	base/vpr_types.h	/^	short iswitch;$/;"	m	struct:ScreenUpdatePriority::t_trace	access:public
ScreenUpdatePriority::t_trace::next	base/vpr_types.h	/^	t_trace *next;$/;"	m	struct:ScreenUpdatePriority::t_trace	access:public
ScreenUpdatePriority::t_vpr_setup	base/vpr_types.h	/^struct t_vpr_setup {$/;"	s	class:ScreenUpdatePriority	access:private
ScreenUpdatePriority::t_vpr_setup::AnalysisOpts	base/vpr_types.h	/^    t_analysis_opts AnalysisOpts; \/* Analysis options *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::AnnealSched	base/vpr_types.h	/^	t_annealing_sched AnnealSched; \/* Placement option annealing schedule *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::FileNameOpts	base/vpr_types.h	/^	t_file_name_opts FileNameOpts; \/* File names *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::GraphPause	base/vpr_types.h	/^	int GraphPause; \/* user interactiveness graphics option *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::NetlistOpts	base/vpr_types.h	/^	t_netlist_opts NetlistOpts; \/* Options for packer *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::PackerOpts	base/vpr_types.h	/^	t_packer_opts PackerOpts; \/* Options for packer *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::PackerRRGraph	base/vpr_types.h	/^	std::vector <t_lb_type_rr_node> *PackerRRGraph;$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::PlacerOpts	base/vpr_types.h	/^	t_placer_opts PlacerOpts; \/* Options for placer *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::PowerOpts	base/vpr_types.h	/^	t_power_opts PowerOpts;$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::RouterOpts	base/vpr_types.h	/^	t_router_opts RouterOpts; \/* router options *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::RoutingArch	base/vpr_types.h	/^	t_det_routing_arch RoutingArch; \/* routing architecture *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::Segments	base/vpr_types.h	/^	t_segment_inf * Segments; \/* wires in routing architecture *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::ShowGraphics	base/vpr_types.h	/^	bool ShowGraphics; \/* option to show graphics *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::Timing	base/vpr_types.h	/^	t_timing_inf Timing; \/* timing information *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::TimingEnabled	base/vpr_types.h	/^	bool TimingEnabled; \/* Is VPR timing enabled *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::clock_modeling	base/vpr_types.h	/^    e_clock_modeling clock_modeling; \/\/How clocks should be handled$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::constant_net_delay	base/vpr_types.h	/^	float constant_net_delay; \/* timing information when place and route not run *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::constant_net_method	base/vpr_types.h	/^    e_constant_net_method constant_net_method; \/\/How constant nets should be handled$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::device_layout	base/vpr_types.h	/^    std::string device_layout;$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::exit_before_pack	base/vpr_types.h	/^    bool exit_before_pack; \/\/Exits early before starting packing (useful for collecting statistics without running\/loading any stages)$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::gen_netlist_as_blif	base/vpr_types.h	/^	bool gen_netlist_as_blif; \/* option to print out post-pack\/pre-place netlist as blif *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::library_models	base/vpr_types.h	/^	t_model * library_models; \/* blif models in VPR *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ScreenUpdatePriority::t_vpr_setup::user_models	base/vpr_types.h	/^	t_model * user_models; \/* blif models defined by the user *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
SdcCallback	timing/read_sdc.cpp	/^class SdcCallback : public sdcparse::Callback {$/;"	c	file:	inherits:sdcparse::Callback
SdcCallback::fname_	timing/read_sdc.cpp	/^        std::string fname_;$/;"	m	class:SdcCallback	file:	access:private
SdcCallback::got_commands	timing/read_sdc.cpp	/^        bool got_commands() { return got_commands_; }$/;"	f	class:SdcCallback	access:public	signature:()
SdcCallback::got_commands_	timing/read_sdc.cpp	/^        bool got_commands_ = false;$/;"	m	class:SdcCallback	file:	access:private
SdcCallback::lineno_	timing/read_sdc.cpp	/^        int lineno_ = -1;$/;"	m	class:SdcCallback	file:	access:private
SdcParseCallback2	timing/read_sdc2.cpp	/^        SdcParseCallback2(const AtomNetlist& netlist,$/;"	f	class:SdcParseCallback2	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& timing_constraints, tatum::TimingGraph& tg)
SdcParseCallback2	timing/read_sdc2.cpp	/^class SdcParseCallback2 : public sdcparse::Callback {$/;"	c	file:	inherits:sdcparse::Callback
SdcParseCallback2::SdcParseCallback2	timing/read_sdc2.cpp	/^        SdcParseCallback2(const AtomNetlist& netlist,$/;"	f	class:SdcParseCallback2	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& timing_constraints, tatum::TimingGraph& tg)
SdcParseCallback2::calculate_hold_constraint	timing/read_sdc2.cpp	/^        tatum::Time calculate_hold_constraint(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const
SdcParseCallback2::calculate_min_launch_to_capture_edge_time	timing/read_sdc2.cpp	/^        float calculate_min_launch_to_capture_edge_time(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const
SdcParseCallback2::calculate_setup_constraint	timing/read_sdc2.cpp	/^        tatum::Time calculate_setup_constraint(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const
SdcParseCallback2::disabled_domain_pairs_	timing/read_sdc2.cpp	/^        std::set<std::pair<tatum::DomainId,tatum::DomainId>> disabled_domain_pairs_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::fname_	timing/read_sdc2.cpp	/^        std::string fname_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::get_all_clocks	timing/read_sdc2.cpp	/^        std::set<tatum::DomainId> get_all_clocks() {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:()
SdcParseCallback2::get_clocks	timing/read_sdc2.cpp	/^        std::set<tatum::DomainId> get_clocks(const sdcparse::StringGroup& clock_group) {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(const sdcparse::StringGroup& clock_group)
SdcParseCallback2::get_pins	timing/read_sdc2.cpp	/^        std::set<AtomPinId> get_pins(const sdcparse::StringGroup& pin_group) {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(const sdcparse::StringGroup& pin_group)
SdcParseCallback2::get_ports	timing/read_sdc2.cpp	/^        std::set<AtomPinId> get_ports(const sdcparse::StringGroup& port_group) {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(const sdcparse::StringGroup& port_group)
SdcParseCallback2::hold_capture_cycle	timing/read_sdc2.cpp	/^        int hold_capture_cycle(tatum::DomainId from, tatum::DomainId to) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId from, tatum::DomainId to) const
SdcParseCallback2::hold_mcp_overrides_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>,int> hold_mcp_overrides_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::hold_override_constraints_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>, float> hold_override_constraints_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::lineno_	timing/read_sdc2.cpp	/^        int lineno_ = -1;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::lookup_	timing/read_sdc2.cpp	/^        const AtomLookup& lookup_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::netlist_	timing/read_sdc2.cpp	/^        const AtomNetlist& netlist_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::netlist_clock_drivers_	timing/read_sdc2.cpp	/^        std::set<AtomPinId> netlist_clock_drivers_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::netlist_primary_ios_	timing/read_sdc2.cpp	/^        std::map<std::string,AtomPinId> netlist_primary_ios_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::num_commands	timing/read_sdc2.cpp	/^        size_t num_commands() { return num_commands_; }$/;"	f	class:SdcParseCallback2	access:public	signature:()
SdcParseCallback2::num_commands_	timing/read_sdc2.cpp	/^        size_t num_commands_ = 0;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::resolve_clock_constraints	timing/read_sdc2.cpp	/^        void resolve_clock_constraints() {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:()
SdcParseCallback2::sdc_clocks_	timing/read_sdc2.cpp	/^        std::map<tatum::DomainId,sdcparse::CreateClock> sdc_clocks_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::sdc_units_to_seconds	timing/read_sdc2.cpp	/^        float sdc_units_to_seconds(float val) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(float val) const
SdcParseCallback2::seconds_to_sdc_units	timing/read_sdc2.cpp	/^        float seconds_to_sdc_units(float val) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(float val) const
SdcParseCallback2::setup_capture_cycle	timing/read_sdc2.cpp	/^        int setup_capture_cycle(tatum::DomainId from, tatum::DomainId to) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId from, tatum::DomainId to) const
SdcParseCallback2::setup_mcp_overrides_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>,int> setup_mcp_overrides_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::setup_override_constraints_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>, float> setup_override_constraints_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::tc_	timing/read_sdc2.cpp	/^        tatum::TimingConstraints& tc_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::tg_	timing/read_sdc2.cpp	/^        tatum::TimingGraph& tg_;$/;"	m	class:SdcParseCallback2	file:	access:private
SdcParseCallback2::unit_scale_	timing/read_sdc2.cpp	/^        float unit_scale_ = 1e-9;$/;"	m	class:SdcParseCallback2	file:	access:private
Seed	base/read_options.h	/^    argparse::ArgValue<int> Seed;$/;"	m	struct:t_options	access:public
Segments	../../libs/libarchfpga/src/physical_types.h	/^	t_segment_inf * Segments;$/;"	m	struct:t_arch	access:public
Segments	base/vpr_types.h	/^	t_segment_inf * Segments; \/* wires in routing architecture *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
SetupAnalysisOpts	base/SetupVPR.cpp	/^static void SetupAnalysisOpts(const t_options& Options, t_analysis_opts& analysis_opts) {$/;"	f	file:	signature:(const t_options& Options, t_analysis_opts& analysis_opts)
SetupAnalysisOpts	base/SetupVPR.cpp	/^static void SetupAnalysisOpts(const t_options& Options, t_analysis_opts& analysis_opts);$/;"	p	file:	signature:(const t_options& Options, t_analysis_opts& analysis_opts)
SetupAnnealSched	base/SetupVPR.cpp	/^static void SetupAnnealSched(const t_options& Options,$/;"	f	file:	signature:(const t_options& Options, t_annealing_sched *AnnealSched)
SetupAnnealSched	base/SetupVPR.cpp	/^static void SetupAnnealSched(const t_options& Options,$/;"	p	file:	signature:(const t_options& Options, t_annealing_sched *AnnealSched)
SetupEmptyType	../../libs/libarchfpga/src/arch_util.cpp	/^void SetupEmptyType(t_type_descriptor* cb_type_descriptors,$/;"	f	signature:(t_type_descriptor* cb_type_descriptors, t_type_ptr EMPTY_TYPE)
SetupEmptyType	../../libs/libarchfpga/src/arch_util.h	/^void SetupEmptyType(t_type_descriptor* cb_type_descriptors,$/;"	p	signature:(t_type_descriptor* cb_type_descriptors, t_type_ptr EMPTY_TYPE)
SetupHoldTimingInfo	timing/timing_info.h	/^class SetupHoldTimingInfo : public SetupTimingInfo, public HoldTimingInfo {$/;"	c	inherits:SetupTimingInfo,HoldTimingInfo
SetupHoldTimingInfo::setup_hold_analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> setup_hold_analyzer() const = 0;$/;"	p	class:SetupHoldTimingInfo	access:public	signature:() const
SetupNetlistOpts	base/SetupVPR.cpp	/^static void SetupNetlistOpts(const t_options& Options, t_netlist_opts& NetlistOpts) {$/;"	f	file:	signature:(const t_options& Options, t_netlist_opts& NetlistOpts)
SetupNetlistOpts	base/SetupVPR.cpp	/^static void SetupNetlistOpts(const t_options& Options, t_netlist_opts& NetlistOpts);$/;"	p	file:	signature:(const t_options& Options, t_netlist_opts& NetlistOpts)
SetupPackerOpts	base/SetupVPR.cpp	/^static void SetupPackerOpts(const t_options& Options,$/;"	p	file:	signature:(const t_options& Options, t_packer_opts *PackerOpts)
SetupPackerOpts	base/SetupVPR.cpp	/^void SetupPackerOpts(const t_options& Options,$/;"	f	signature:(const t_options& Options, t_packer_opts *PackerOpts)
SetupPinLocationsAndPinClasses	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void SetupPinLocationsAndPinClasses(pugi::xml_node Locations,$/;"	f	file:	signature:(pugi::xml_node Locations, t_type_descriptor * Type, const pugiutil::loc_data& loc_data)
SetupPinLocationsAndPinClasses	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static void SetupPinLocationsAndPinClasses(pugi::xml_node Locations,$/;"	p	file:	signature:(pugi::xml_node Locations, t_type_descriptor * Type, const pugiutil::loc_data& loc_data)
SetupPlacerOpts	base/SetupVPR.cpp	/^static void SetupPlacerOpts(const t_options& Options, t_placer_opts *PlacerOpts) {$/;"	f	file:	signature:(const t_options& Options, t_placer_opts *PlacerOpts)
SetupPlacerOpts	base/SetupVPR.cpp	/^static void SetupPlacerOpts(const t_options& Options,$/;"	p	file:	signature:(const t_options& Options, t_placer_opts *PlacerOpts)
SetupPowerOpts	base/SetupVPR.cpp	/^static void SetupPowerOpts(const t_options& Options, t_power_opts *power_opts,$/;"	f	file:	signature:(const t_options& Options, t_power_opts *power_opts, t_arch * Arch)
SetupPowerOpts	base/SetupVPR.cpp	/^static void SetupPowerOpts(const t_options& Options, t_power_opts *power_opts,$/;"	p	file:	signature:(const t_options& Options, t_power_opts *power_opts, t_arch * Arch)
SetupRouterOpts	base/SetupVPR.cpp	/^static void SetupRouterOpts(const t_options& Options, t_router_opts *RouterOpts) {$/;"	f	file:	signature:(const t_options& Options, t_router_opts *RouterOpts)
SetupRouterOpts	base/SetupVPR.cpp	/^static void SetupRouterOpts(const t_options& Options, t_router_opts *RouterOpts);$/;"	p	file:	signature:(const t_options& Options, t_router_opts *RouterOpts)
SetupRoutingArch	base/SetupVPR.cpp	/^static void SetupRoutingArch(const t_arch& Arch, t_det_routing_arch *RoutingArch);$/;"	p	file:	signature:(const t_arch& Arch, t_det_routing_arch *RoutingArch)
SetupRoutingArch	base/SetupVPR.cpp	/^static void SetupRoutingArch(const t_arch& Arch,$/;"	f	file:	signature:(const t_arch& Arch, t_det_routing_arch *RoutingArch)
SetupSlackCrit	timing/slack_evaluation.cpp	/^SetupSlackCrit::SetupSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)$/;"	f	class:SetupSlackCrit	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
SetupSlackCrit	timing/slack_evaluation.h	/^        SetupSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup);$/;"	p	class:SetupSlackCrit	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
SetupSlackCrit	timing/slack_evaluation.h	/^class SetupSlackCrit {$/;"	c
SetupSlackCrit::SetupSlackCrit	timing/slack_evaluation.cpp	/^SetupSlackCrit::SetupSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)$/;"	f	class:SetupSlackCrit	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
SetupSlackCrit::SetupSlackCrit	timing/slack_evaluation.h	/^        SetupSlackCrit(const AtomNetlist& netlist, const AtomLookup& netlist_lookup);$/;"	p	class:SetupSlackCrit	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup)
SetupSlackCrit::calc_pin_criticality	timing/slack_evaluation.cpp	/^float SetupSlackCrit::calc_pin_criticality(AtomPinId pin,$/;"	f	class:SetupSlackCrit	signature:(AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer, const std::map<DomainPair,float>& max_req, const std::map<DomainPair,float>& worst_slack)
SetupSlackCrit::calc_pin_criticality	timing/slack_evaluation.h	/^        float calc_pin_criticality(AtomPinId pin,$/;"	p	class:SetupSlackCrit	access:private	signature:(AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer, const std::map<DomainPair,float>& max_req, const std::map<DomainPair,float>& worst_slack)
SetupSlackCrit::netlist_	timing/slack_evaluation.h	/^        const AtomNetlist& netlist_;$/;"	m	class:SetupSlackCrit	access:private
SetupSlackCrit::netlist_lookup_	timing/slack_evaluation.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:SetupSlackCrit	access:private
SetupSlackCrit::pin_criticalities_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_criticalities_;$/;"	m	class:SetupSlackCrit	access:private
SetupSlackCrit::pin_slacks_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_slacks_;$/;"	m	class:SetupSlackCrit	access:private
SetupSlackCrit::setup_pin_criticality	timing/slack_evaluation.cpp	/^float SetupSlackCrit::setup_pin_criticality(AtomPinId pin) const { return pin_criticalities_[pin]; }$/;"	f	class:SetupSlackCrit	signature:(AtomPinId pin) const
SetupSlackCrit::setup_pin_criticality	timing/slack_evaluation.h	/^        float setup_pin_criticality(AtomPinId pin) const;$/;"	p	class:SetupSlackCrit	access:public	signature:(AtomPinId pin) const
SetupSlackCrit::setup_pin_slack	timing/slack_evaluation.cpp	/^float SetupSlackCrit::setup_pin_slack(AtomPinId pin) const { return pin_slacks_[pin]; }$/;"	f	class:SetupSlackCrit	signature:(AtomPinId pin) const
SetupSlackCrit::setup_pin_slack	timing/slack_evaluation.h	/^        float setup_pin_slack(AtomPinId pin) const;$/;"	p	class:SetupSlackCrit	access:public	signature:(AtomPinId pin) const
SetupSlackCrit::update_criticalities	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_criticalities	timing/slack_evaluation.h	/^        void update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:private	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_pin_slack	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_pin_slack(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_pin_slack	timing/slack_evaluation.h	/^        void update_pin_slack(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:private	signature:(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_slacks	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_slacks(const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_slacks	timing/slack_evaluation.h	/^        void update_slacks(const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:private	signature:(const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_slacks_and_criticalities	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
SetupSlackCrit::update_slacks_and_criticalities	timing/slack_evaluation.h	/^        void update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:public	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
SetupSwitches	base/SetupVPR.cpp	/^static void SetupSwitches(const t_arch& Arch,$/;"	f	file:	signature:(const t_arch& Arch, t_det_routing_arch *RoutingArch, const t_arch_switch_inf *ArchSwitches, int NumArchSwitches)
SetupSwitches	base/SetupVPR.cpp	/^static void SetupSwitches(const t_arch& Arch,$/;"	p	file:	signature:(const t_arch& Arch, t_det_routing_arch *RoutingArch, const t_arch_switch_inf *ArchSwitches, int NumArchSwitches)
SetupTiming	base/SetupVPR.cpp	/^static void SetupTiming(const t_options& Options, const t_arch& Arch,$/;"	f	file:	signature:(const t_options& Options, const t_arch& Arch, const bool TimingEnabled, t_timing_inf * Timing)
SetupTiming	base/SetupVPR.cpp	/^static void SetupTiming(const t_options& Options, const t_arch& Arch,$/;"	p	file:	signature:(const t_options& Options, const t_arch& Arch, const bool TimingEnabled, t_timing_inf * Timing)
SetupTimingInfo	timing/timing_info.h	/^class SetupTimingInfo : public virtual TimingInfo {$/;"	c	inherits:TimingInfo
SetupTimingInfo::critical_paths	timing/timing_info.h	/^        virtual std::vector<tatum::TimingPathInfo> critical_paths() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
SetupTimingInfo::least_slack_critical_path	timing/timing_info.h	/^        virtual tatum::TimingPathInfo least_slack_critical_path() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
SetupTimingInfo::longest_critical_path	timing/timing_info.h	/^        virtual tatum::TimingPathInfo longest_critical_path() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
SetupTimingInfo::setup_analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::SetupTimingAnalyzer> setup_analyzer() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
SetupTimingInfo::setup_pin_criticality	timing/timing_info.h	/^        virtual float setup_pin_criticality(AtomPinId pin) const  = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:(AtomPinId pin) const
SetupTimingInfo::setup_pin_slack	timing/timing_info.h	/^        virtual float setup_pin_slack(AtomPinId pin) const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:(AtomPinId pin) const
SetupTimingInfo::setup_total_negative_slack	timing/timing_info.h	/^        virtual float setup_total_negative_slack() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
SetupTimingInfo::setup_worst_negative_slack	timing/timing_info.h	/^        virtual float setup_worst_negative_slack() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
SetupTimingInfo::update_setup	timing/timing_info.h	/^        virtual void update_setup() = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:()
SetupVPR	base/SetupVPR.cpp	/^void SetupVPR(t_options *Options,$/;"	f	signature:(t_options *Options, const bool TimingEnabled, const bool readArchFile, t_file_name_opts *FileNameOpts, t_arch * Arch, t_model ** user_models, t_model ** library_models, t_netlist_opts* NetlistOpts, t_packer_opts *PackerOpts, t_placer_opts *PlacerOpts, t_annealing_sched *AnnealSched, t_router_opts *RouterOpts, t_analysis_opts* AnalysisOpts, t_det_routing_arch *RoutingArch, vector <t_lb_type_rr_node> **PackerRRGraphs, t_segment_inf ** Segments, t_timing_inf * Timing, bool * ShowGraphics, int *GraphPause, t_power_opts * PowerOpts)
SetupVPR	base/SetupVPR.h	/^void SetupVPR(t_options *Options,$/;"	p	signature:(t_options *Options, const bool TimingEnabled, const bool readArchFile, t_file_name_opts *FileNameOpts, t_arch * Arch, t_model ** user_models, t_model ** library_models, t_netlist_opts* NetlistOpts, t_packer_opts *PackerOpts, t_placer_opts *PlacerOpts, t_annealing_sched *AnnealSched, t_router_opts *RouterOpts, t_analysis_opts* AnalysisOpts, t_det_routing_arch *RoutingArch, std::vector<t_lb_type_rr_node> **PackerRRGraphs, t_segment_inf ** Segments, t_timing_inf * Timing, bool * ShowGraphics, int *GraphPause, t_power_opts * PowerOpts)
ShowAnalysisOpts	base/ShowSetup.cpp	/^static void ShowAnalysisOpts(const t_analysis_opts& AnalysisOpts) {$/;"	f	file:	signature:(const t_analysis_opts& AnalysisOpts)
ShowAnalysisOpts	base/ShowSetup.cpp	/^static void ShowAnalysisOpts(const t_analysis_opts& AnalysisOpts);$/;"	p	file:	signature:(const t_analysis_opts& AnalysisOpts)
ShowAnnealSched	base/ShowSetup.cpp	/^static void ShowAnnealSched(const t_annealing_sched& AnnealSched) {$/;"	f	file:	signature:(const t_annealing_sched& AnnealSched)
ShowAnnealSched	base/ShowSetup.cpp	/^static void ShowAnnealSched(const t_annealing_sched& AnnealSched);$/;"	p	file:	signature:(const t_annealing_sched& AnnealSched)
ShowGraphics	base/vpr_types.h	/^	bool ShowGraphics; \/* option to show graphics *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
ShowNetlistOpts	base/ShowSetup.cpp	/^static void ShowNetlistOpts(const t_netlist_opts& NetlistOpts) {$/;"	f	file:	signature:(const t_netlist_opts& NetlistOpts)
ShowNetlistOpts	base/ShowSetup.cpp	/^static void ShowNetlistOpts(const t_netlist_opts& NetlistOpts);$/;"	p	file:	signature:(const t_netlist_opts& NetlistOpts)
ShowPackerOpts	base/ShowSetup.cpp	/^static void ShowPackerOpts(const t_packer_opts& PackerOpts) {$/;"	f	file:	signature:(const t_packer_opts& PackerOpts)
ShowPackerOpts	base/ShowSetup.cpp	/^static void ShowPackerOpts(const t_packer_opts& PackerOpts);$/;"	p	file:	signature:(const t_packer_opts& PackerOpts)
ShowPlaceTiming	base/read_options.h	/^    argparse::ArgValue<bool> ShowPlaceTiming;$/;"	m	struct:t_options	access:public
ShowPlacerOpts	base/ShowSetup.cpp	/^static void ShowPlacerOpts(const t_placer_opts& PlacerOpts,$/;"	f	file:	signature:(const t_placer_opts& PlacerOpts, const t_annealing_sched& AnnealSched)
ShowPlacerOpts	base/ShowSetup.cpp	/^static void ShowPlacerOpts(const t_placer_opts& PlacerOpts,$/;"	p	file:	signature:(const t_placer_opts& PlacerOpts, const t_annealing_sched& AnnealSched)
ShowRouterOpts	base/ShowSetup.cpp	/^static void ShowRouterOpts(const t_router_opts& RouterOpts) {$/;"	f	file:	signature:(const t_router_opts& RouterOpts)
ShowRouterOpts	base/ShowSetup.cpp	/^static void ShowRouterOpts(const t_router_opts& RouterOpts);$/;"	p	file:	signature:(const t_router_opts& RouterOpts)
ShowRoutingArch	base/ShowSetup.cpp	/^static void ShowRoutingArch(const t_det_routing_arch& RoutingArch) {$/;"	f	file:	signature:(const t_det_routing_arch& RoutingArch)
ShowRoutingArch	base/ShowSetup.cpp	/^static void ShowRoutingArch(const t_det_routing_arch& RoutingArch);$/;"	p	file:	signature:(const t_det_routing_arch& RoutingArch)
ShowSetup	base/ShowSetup.cpp	/^void ShowSetup(const t_vpr_setup& vpr_setup) {$/;"	f	signature:(const t_vpr_setup& vpr_setup)
ShowSetup	base/ShowSetup.h	/^void ShowSetup(const t_vpr_setup& vpr_setup);$/;"	p	signature:(const t_vpr_setup& vpr_setup)
SlackDefinition	base/read_options.h	/^    argparse::ArgValue<std::string> SlackDefinition; \/\/TODO: eventually remove$/;"	m	struct:t_options	access:public
SpatialRouteTreeLookup	route/spatial_route_tree_lookup.h	/^typedef vtr::Matrix<std::vector<t_rt_node*>> SpatialRouteTreeLookup;$/;"	t
Str	base/vpr_types.h	/^	const char *Str;$/;"	m	struct:ScreenUpdatePriority::t_TokenPair	access:public
StringId	base/netlist.h	/^        typedef vtr::StrongId<string_id_tag> StringId;$/;"	t	class:Netlist	access:protected
StrongId	../../libs/libvtrutil/src/vtr_strong_id.h	/^        constexpr StrongId() : id_(sentinel) {}$/;"	f	class:vtr::StrongId	access:public	signature:()
StrongId	../../libs/libvtrutil/src/vtr_strong_id.h	/^        explicit constexpr StrongId(T id): id_(id) {}$/;"	f	class:vtr::StrongId	access:public	signature:(T id)
StrongId	../../libs/libvtrutil/src/vtr_strong_id.h	/^class StrongId {$/;"	c	namespace:vtr
Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::Surface()$/;"	f	class:Surface	signature:()
Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::Surface(const Surface& surface)$/;"	f	class:Surface	signature:(const Surface& surface)
Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::Surface(const char* filePath)$/;"	f	class:Surface	signature:(const char* filePath)
Surface	../../libs/libeasygl/src/Surface.h	/^        Surface();$/;"	p	class:Surface	access:public	signature:()
Surface	../../libs/libeasygl/src/Surface.h	/^        Surface(const Surface& surface);$/;"	p	class:Surface	access:public	signature:(const Surface& surface)
Surface	../../libs/libeasygl/src/Surface.h	/^        Surface(const char* filePath);$/;"	p	class:Surface	access:public	signature:(const char* filePath)
Surface	../../libs/libeasygl/src/Surface.h	/^class Surface {$/;"	c
Surface::Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::Surface()$/;"	f	class:Surface	signature:()
Surface::Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::Surface(const Surface& surface)$/;"	f	class:Surface	signature:(const Surface& surface)
Surface::Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::Surface(const char* filePath)$/;"	f	class:Surface	signature:(const char* filePath)
Surface::Surface	../../libs/libeasygl/src/Surface.h	/^        Surface();$/;"	p	class:Surface	access:public	signature:()
Surface::Surface	../../libs/libeasygl/src/Surface.h	/^        Surface(const Surface& surface);$/;"	p	class:Surface	access:public	signature:(const Surface& surface)
Surface::Surface	../../libs/libeasygl/src/Surface.h	/^        Surface(const char* filePath);$/;"	p	class:Surface	access:public	signature:(const char* filePath)
Surface::draw_surface	../../libs/libeasygl/src/Surface.h	/^        friend void draw_surface(const Surface& surface, float x, float y);$/;"	p	class:Surface	access:friend	signature:(const Surface& surface, float x, float y)
Surface::impl_	../../libs/libeasygl/src/Surface.h	/^        std::unique_ptr<SurfaceImpl> impl_;$/;"	m	class:Surface	access:private
Surface::operator =	../../libs/libeasygl/src/Surface.cpp	/^Surface& Surface::operator=(Surface rhs) {$/;"	f	class:Surface	signature:(Surface rhs)
Surface::operator =	../../libs/libeasygl/src/Surface.h	/^        Surface& operator=(Surface rhs); \/\/ assignment operator$/;"	p	class:Surface	access:public	signature:(Surface rhs)
Surface::setSurface	../../libs/libeasygl/src/Surface.cpp	/^void Surface::setSurface(const char* filePath) {$/;"	f	class:Surface	signature:(const char* filePath)
Surface::setSurface	../../libs/libeasygl/src/Surface.h	/^        void setSurface(const char* filePath);$/;"	p	class:Surface	access:public	signature:(const char* filePath)
Surface::swap	../../libs/libeasygl/src/Surface.h	/^        friend void swap(Surface& lhs, Surface& rhs);$/;"	p	class:Surface	access:friend	signature:(Surface& lhs, Surface& rhs)
Surface::~Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::~Surface() {$/;"	f	class:Surface	signature:()
Surface::~Surface	../../libs/libeasygl/src/Surface.h	/^        ~Surface();$/;"	p	class:Surface	access:public	signature:()
SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.cpp	/^SurfaceImpl::SurfaceImpl(const char* filePath)$/;"	f	class:SurfaceImpl	signature:(const char* filePath)
SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl() = default;$/;"	p	class:SurfaceImpl	access:public	signature:()
SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl(const char* filePath);$/;"	p	class:SurfaceImpl	access:public	signature:(const char* filePath)
SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^class SurfaceImpl {$/;"	c
SurfaceImpl::SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.cpp	/^SurfaceImpl::SurfaceImpl(const char* filePath)$/;"	f	class:SurfaceImpl	signature:(const char* filePath)
SurfaceImpl::SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl() = default;$/;"	p	class:SurfaceImpl	access:public	signature:()
SurfaceImpl::SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl(const char* filePath);$/;"	p	class:SurfaceImpl	access:public	signature:(const char* filePath)
SurfaceImpl::getSurface	../../libs/libeasygl/src/SurfaceImpl.cpp	/^cairo_surface_t* SurfaceImpl::getSurface() const {$/;"	f	class:SurfaceImpl	signature:() const
SurfaceImpl::getSurface	../../libs/libeasygl/src/SurfaceImpl.h	/^        cairo_surface_t* getSurface() const;$/;"	p	class:SurfaceImpl	access:public	signature:() const
SurfaceImpl::mSurface	../../libs/libeasygl/src/SurfaceImpl.h	/^        std::shared_ptr<cairo_surface_t> mSurface;$/;"	m	class:SurfaceImpl	access:private
SurfaceImpl::rhs	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl& operator=(const SurfaceImpl& rhs) = default; \/\/ assignment operator$/;"	m	class:SurfaceImpl	access:public
SurfaceImpl::setSurface	../../libs/libeasygl/src/SurfaceImpl.cpp	/^void SurfaceImpl::setSurface($/;"	f	class:SurfaceImpl	signature:( const char* filePath )
SurfaceImpl::setSurface	../../libs/libeasygl/src/SurfaceImpl.h	/^        void setSurface(const char* filePath);$/;"	p	class:SurfaceImpl	access:public	signature:(const char* filePath)
SurfaceImpl::surface	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl(const SurfaceImpl& surface) = default; \/\/ cctor$/;"	m	class:SurfaceImpl	access:public
SurfaceImpl::~SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^        ~SurfaceImpl() = default;$/;"	p	class:SurfaceImpl	access:public	signature:()
SwitchPointOrder	../../libs/libarchfpga/src/physical_types.h	/^enum class SwitchPointOrder {$/;"	c
SwitchPointOrder::FIXED	../../libs/libarchfpga/src/physical_types.h	/^    FIXED,      \/\/Switchpoints are ordered as specified in architecture$/;"	m	class:SwitchPointOrder	access:private
SwitchType	../../libs/libarchfpga/src/physical_types.h	/^enum class SwitchType {$/;"	c
SwitchType::BUFFER	../../libs/libarchfpga/src/physical_types.h	/^    BUFFER,         \/\/A non-configurable non-tristate-able buffer (uni-driver)$/;"	m	class:SwitchType	access:private
SwitchType::INVALID	../../libs/libarchfpga/src/physical_types.h	/^    INVALID,        \/\/Unspecified, usually an error$/;"	m	class:SwitchType	access:private
SwitchType::MUX	../../libs/libarchfpga/src/physical_types.h	/^    MUX = 0,        \/\/A configurable (buffered) mux (single-driver)$/;"	m	class:SwitchType	access:private
SwitchType::PASS_GATE	../../libs/libarchfpga/src/physical_types.h	/^    PASS_GATE,      \/\/A configurable pass transitor switch (multi-driver)$/;"	m	class:SwitchType	access:private
SwitchType::SHORT	../../libs/libarchfpga/src/physical_types.h	/^    SHORT,          \/\/A non-configurable electrically shorted connection (multi-driver)$/;"	m	class:SwitchType	access:private
SwitchType::TRISTATE	../../libs/libarchfpga/src/physical_types.h	/^    TRISTATE,       \/\/A configurable tristate-able buffer (multi-driver)$/;"	m	class:SwitchType	access:private
Switchblock_Lookup	route/build_switchblocks.h	/^	Switchblock_Lookup(){$/;"	f	class:Switchblock_Lookup	access:public	signature:()
Switchblock_Lookup	route/build_switchblocks.h	/^	Switchblock_Lookup(int set_x, int set_y, e_side set_from, e_side set_to){$/;"	f	class:Switchblock_Lookup	access:public	signature:(int set_x, int set_y, e_side set_from, e_side set_to)
Switchblock_Lookup	route/build_switchblocks.h	/^class Switchblock_Lookup{$/;"	c
Switchblock_Lookup::Switchblock_Lookup	route/build_switchblocks.h	/^	Switchblock_Lookup(){$/;"	f	class:Switchblock_Lookup	access:public	signature:()
Switchblock_Lookup::Switchblock_Lookup	route/build_switchblocks.h	/^	Switchblock_Lookup(int set_x, int set_y, e_side set_from, e_side set_to){$/;"	f	class:Switchblock_Lookup	access:public	signature:(int set_x, int set_y, e_side set_from, e_side set_to)
Switchblock_Lookup::from_side	route/build_switchblocks.h	/^	e_side from_side;	\/* source side of switchblock connection *\/$/;"	m	class:Switchblock_Lookup	access:public
Switchblock_Lookup::operator ==	route/build_switchblocks.h	/^	bool operator == (const Switchblock_Lookup &obj) const{$/;"	f	class:Switchblock_Lookup	access:public	signature:(const Switchblock_Lookup &obj) const
Switchblock_Lookup::set_coords	route/build_switchblocks.h	/^	void set_coords(int set_x, int set_y, e_side set_from, e_side set_to){$/;"	f	class:Switchblock_Lookup	access:public	signature:(int set_x, int set_y, e_side set_from, e_side set_to)
Switchblock_Lookup::to_side	route/build_switchblocks.h	/^	e_side to_side;		\/* destination side of switchblock connection *\/$/;"	m	class:Switchblock_Lookup	access:public
Switchblock_Lookup::x_coord	route/build_switchblocks.h	/^	int x_coord;		\/* x coordinate of switchblock connection *\/	\/\/TODO: redundant comment?? add range$/;"	m	class:Switchblock_Lookup	access:public
Switchblock_Lookup::y_coord	route/build_switchblocks.h	/^	int y_coord;		\/* y coordinate of switchblock connection *\/$/;"	m	class:Switchblock_Lookup	access:public
Switches	../../libs/libarchfpga/src/physical_types.h	/^	t_arch_switch_inf *Switches;$/;"	m	struct:t_arch	access:public
SyncModelsPbTypes	../../libs/libarchfpga/src/arch_util.cpp	/^void SyncModelsPbTypes(t_arch *arch,$/;"	f	signature:(t_arch *arch, const t_type_descriptor * Types, const int NumTypes)
SyncModelsPbTypes	../../libs/libarchfpga/src/arch_util.h	/^void SyncModelsPbTypes(t_arch *arch,$/;"	p	signature:(t_arch *arch, const t_type_descriptor * Types, const int NumTypes)
SyncModelsPbTypes_rec	../../libs/libarchfpga/src/arch_util.cpp	/^void SyncModelsPbTypes_rec(t_arch *arch,$/;"	f	signature:(t_arch *arch, t_pb_type * pb_type)
SyncModelsPbTypes_rec	../../libs/libarchfpga/src/arch_util.h	/^void SyncModelsPbTypes_rec(t_arch *arch,$/;"	p	signature:(t_arch *arch, t_pb_type * pb_type)
TABLENGTH	pack/output_blif.cpp	/^#define TABLENGTH /;"	d	file:
TAB_LENGTH	pack/output_clustering.cpp	/^#define TAB_LENGTH /;"	d	file:
TAN	../../libs/libeasygl/src/easygl_constants.h	/^    TAN,$/;"	e	enum:color_types
TEAL	../../libs/libeasygl/src/easygl_constants.h	/^    TEAL,$/;"	e	enum:color_types
TEMP_DECREASE_FAC	route/cb_metrics.h	/^#define TEMP_DECREASE_FAC /;"	d
THISTLE	../../libs/libeasygl/src/easygl_constants.h	/^    THISTLE, \/\/ A sort of desaturated purple, the colour of thistle flowers$/;"	e	enum:color_types
TIMING	base/vpr_types.h	/^	TIMING, MAX_INPUTS, BLEND, MAX_PINS, MAX_INPUT_PINS, BLEND2$/;"	m	class:ScreenUpdatePriority::e_cluster_seed	access:private
TIMING_DRIVEN	base/vpr_types.h	/^	BREADTH_FIRST, TIMING_DRIVEN, NO_TIMING$/;"	e	enum:ScreenUpdatePriority::e_router_algorithm
TIMING_GAIN_PATH_WEIGHT	timing/path_delay.h	/^	#define TIMING_GAIN_PATH_WEIGHT /;"	d
TIMING_PLACE	place/timing_place.h	/^#define TIMING_PLACE$/;"	d
TIMING_PLACE_LOOKUP_H	place/timing_place_lookup.h	/^#define TIMING_PLACE_LOOKUP_H$/;"	d
TN_CB_IPIN	base/vpr_types.h	/^	TN_CB_IPIN, \/* input pin to complex block *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_CB_OPIN	base/vpr_types.h	/^	TN_CB_OPIN, \/* output pin from complex block *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_CLOCK_OPIN	base/vpr_types.h	/^    TN_CLOCK_OPIN, \/* Output pin from an on-chip clock source - comes from TN_CLOCK_SOURCE *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_CLOCK_SOURCE	base/vpr_types.h	/^    TN_CLOCK_SOURCE, \/* An on-chip clock generator such as a pll *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_CONSTANT_GEN_SOURCE	base/vpr_types.h	/^	TN_CONSTANT_GEN_SOURCE \/* source of a constant logic 1 or 0 *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_FF_CLOCK	base/vpr_types.h	/^	TN_FF_CLOCK, \/* clock pin of flip-flop *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_FF_IPIN	base/vpr_types.h	/^	TN_FF_IPIN, \/* input pin to a flip-flop - goes to TN_FF_SINK *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_FF_OPIN	base/vpr_types.h	/^	TN_FF_OPIN, \/* output pin from a flip-flop - comes from TN_FF_SOURCE *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_FF_SINK	base/vpr_types.h	/^	TN_FF_SINK, \/* sink (D) pin of flip-flop *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_FF_SOURCE	base/vpr_types.h	/^	TN_FF_SOURCE, \/* source (Q) pin of flip-flop *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_INPAD_OPIN	base/vpr_types.h	/^	TN_INPAD_OPIN, \/* output from an input I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_INPAD_SOURCE	base/vpr_types.h	/^	TN_INPAD_SOURCE, \/* input to an input I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_INTERMEDIATE_NODE	base/vpr_types.h	/^	TN_INTERMEDIATE_NODE, \/* Used in post-packed timing graph only:$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_OUTPAD_IPIN	base/vpr_types.h	/^	TN_OUTPAD_IPIN, \/* input to an output I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_OUTPAD_SINK	base/vpr_types.h	/^	TN_OUTPAD_SINK, \/* output from an output I\/O pad *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_PRIMITIVE_IPIN	base/vpr_types.h	/^	TN_PRIMITIVE_IPIN, \/* input pin to a primitive (e.g. a LUT) *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TN_PRIMITIVE_OPIN	base/vpr_types.h	/^	TN_PRIMITIVE_OPIN, \/* output pin from a primitive (e.g. a LUT) *\/$/;"	e	enum:ScreenUpdatePriority::e_tnode_type
TOKENS	../../libs/libarchfpga/src/arch_types.h	/^#define TOKENS /;"	d
TOKENS	base/vpr_types.h	/^#define TOKENS /;"	d
TOKEN_CLOSE_SQUARE_BRACKET	util/token.h	/^	TOKEN_CLOSE_SQUARE_BRACKET,$/;"	e	enum:e_token_type
TOKEN_CLOSE_SQUIG_BRACKET	util/token.h	/^	TOKEN_CLOSE_SQUIG_BRACKET,$/;"	e	enum:e_token_type
TOKEN_COLON	util/token.h	/^	TOKEN_COLON,$/;"	e	enum:e_token_type
TOKEN_DOT	util/token.h	/^	TOKEN_DOT$/;"	e	enum:e_token_type
TOKEN_H	util/token.h	/^#define TOKEN_H$/;"	d
TOKEN_INT	util/token.h	/^	TOKEN_INT,$/;"	e	enum:e_token_type
TOKEN_NULL	util/token.h	/^	TOKEN_NULL,$/;"	e	enum:e_token_type
TOKEN_OPEN_SQUARE_BRACKET	util/token.h	/^	TOKEN_OPEN_SQUARE_BRACKET,$/;"	e	enum:e_token_type
TOKEN_OPEN_SQUIG_BRACKET	util/token.h	/^	TOKEN_OPEN_SQUIG_BRACKET,$/;"	e	enum:e_token_type
TOKEN_STRING	util/token.h	/^	TOKEN_STRING,$/;"	e	enum:e_token_type
TOMATO	../../libs/libeasygl/src/easygl_constants.h	/^    TOMATO,$/;"	e	enum:color_types
TRISTATE	../../libs/libarchfpga/src/physical_types.h	/^    TRISTATE,       \/\/A configurable tristate-able buffer (multi-driver)$/;"	m	class:SwitchType	access:private
TRUE	../../libs/libvtrutil/src/vtr_logic.h	/^        TRUE = 1,$/;"	m	class:vtr::LogicValue	access:private
TURNS	../../libs/libarchfpga/src/physical_types.h	/^    TURNS,         \/\/Turning connections only$/;"	m	class:e_sb_type	access:private
TURQUOISE	../../libs/libeasygl/src/easygl_constants.h	/^    TURQUOISE,$/;"	e	enum:color_types
T_AREA_HEIGHT	../../libs/libeasygl/src/graphics.cpp	/^#define T_AREA_HEIGHT	/;"	d	file:
T_arr	base/vpr_types.h	/^	float T_arr; \/* Arrival time of the last input signal to this node. *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
T_crit	power/power.h	/^	float T_crit;$/;"	m	struct:t_solution_inf	access:public
T_ipin_cblock	base/vpr_types.h	/^	float T_ipin_cblock;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
T_linear	route/rr_node.h	/^	float T_linear;$/;"	m	struct:t_rr_indexed_data	access:public
T_quadratic	route/rr_node.h	/^	float T_quadratic;$/;"	m	struct:t_rr_indexed_data	access:public
T_req	base/vpr_types.h	/^	float T_req; \/* Required arrival time of the last input signal to this node$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
Tdel	../../libs/libarchfpga/src/physical_types.cpp	/^float t_arch_switch_inf::Tdel(int fanin) const {$/;"	f	class:t_arch_switch_inf	signature:(int fanin) const
Tdel	../../libs/libarchfpga/src/physical_types.h	/^	float Tdel = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
Tdel	../../libs/libarchfpga/src/physical_types.h	/^        float Tdel(int fanin=UNDEFINED_FANIN) const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:(int fanin=UNDEFINED_FANIN) const
Tdel	base/vpr_types.h	/^	float Tdel; \/* delay to go to to_node along this edge *\/$/;"	m	struct:ScreenUpdatePriority::t_tedge	access:public
Tdel	route/route_tree_type.h	/^	float Tdel;$/;"	m	struct:t_rt_node	access:public
Tdel	timing/net_delay.cpp	/^	float Tdel;$/;"	m	struct:t_rc_node	file:	access:public
Tdel_map_	../../libs/libarchfpga/src/physical_types.h	/^        std::map<int, double> Tdel_map_;$/;"	m	struct:t_arch_switch_inf	access:private
Timer	../../libs/libvtrutil/src/vtr_time.cpp	/^Timer::Timer()$/;"	f	class:vtr::Timer	signature:()
Timer	../../libs/libvtrutil/src/vtr_time.h	/^            Timer();$/;"	p	class:vtr::Timer	access:public	signature:()
Timer	../../libs/libvtrutil/src/vtr_time.h	/^            Timer(Timer&&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&&)
Timer	../../libs/libvtrutil/src/vtr_time.h	/^            Timer(Timer&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&)
Timer	../../libs/libvtrutil/src/vtr_time.h	/^    class Timer {$/;"	c	namespace:vtr
Timing	base/vpr_types.h	/^	t_timing_inf Timing; \/* timing information *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
TimingContext	base/vpr_context.h	/^struct TimingContext : public Context {$/;"	s	inherits:Context
TimingContext::constraints	base/vpr_context.h	/^    std::shared_ptr<tatum::TimingConstraints> constraints;$/;"	m	struct:TimingContext	access:public
TimingContext::graph	base/vpr_context.h	/^    std::shared_ptr<tatum::TimingGraph> graph;$/;"	m	struct:TimingContext	access:public
TimingContext::num_tnode_levels	base/vpr_context.h	/^    int num_tnode_levels; \/* Number of levels in the timing graph. *\/$/;"	m	struct:TimingContext	access:public
TimingContext::num_tnodes	base/vpr_context.h	/^    int num_tnodes; \/* Number of nodes (pins) in the timing graph *\/$/;"	m	struct:TimingContext	access:public
TimingContext::sdc	base/vpr_context.h	/^    t_timing_constraints* sdc;$/;"	m	struct:TimingContext	access:public
TimingContext::stats	base/vpr_context.h	/^    timing_analysis_profile_info stats;$/;"	m	struct:TimingContext	access:public
TimingContext::timing_analysis_profile_info	base/vpr_context.h	/^    struct timing_analysis_profile_info {$/;"	s	struct:TimingContext	access:public
TimingContext::timing_analysis_profile_info::num_full_hold_updates	base/vpr_context.h	/^        size_t num_full_hold_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::num_full_setup_hold_updates	base/vpr_context.h	/^        size_t num_full_setup_hold_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::num_full_setup_updates	base/vpr_context.h	/^        size_t num_full_setup_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::num_full_updates	base/vpr_context.h	/^        size_t num_full_updates() const {$/;"	f	struct:TimingContext::timing_analysis_profile_info	access:public	signature:() const
TimingContext::timing_analysis_profile_info::num_old_sta_full_updates	base/vpr_context.h	/^        size_t num_old_sta_full_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::old_delay_annotation_wallclock_time	base/vpr_context.h	/^        double old_delay_annotation_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::old_sta_wallclock_time	base/vpr_context.h	/^        double old_sta_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::old_timing_analysis_wallclock_time	base/vpr_context.h	/^        double old_timing_analysis_wallclock_time() const {$/;"	f	struct:TimingContext::timing_analysis_profile_info	access:public	signature:() const
TimingContext::timing_analysis_profile_info::slack_wallclock_time	base/vpr_context.h	/^        double slack_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::sta_wallclock_time	base/vpr_context.h	/^        double sta_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
TimingContext::timing_analysis_profile_info::timing_analysis_wallclock_time	base/vpr_context.h	/^        double timing_analysis_wallclock_time() const {$/;"	f	struct:TimingContext::timing_analysis_profile_info	access:public	signature:() const
TimingContext::tnodes	base/vpr_context.h	/^    t_tnode* tnodes; \/* [0..num_tnodes - 1] nodes in the timing graph *\/$/;"	m	struct:TimingContext	access:public
TimingContext::tnodes_at_level	base/vpr_context.h	/^    std::vector<std::vector<int>> tnodes_at_level; \/* [0..num__tnode_levels - 1].  Count and list of tnodes at each level of$/;"	m	struct:TimingContext	access:public
TimingEnabled	base/vpr_types.h	/^	bool TimingEnabled; \/* Is VPR timing enabled *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
TimingGraphBuilder	timing/timing_graph_builder.cpp	/^TimingGraphBuilder::TimingGraphBuilder(const AtomNetlist& netlist,$/;"	f	class:TimingGraphBuilder	signature:(const AtomNetlist& netlist, AtomLookup& netlist_lookup)
TimingGraphBuilder	timing/timing_graph_builder.h	/^        TimingGraphBuilder(const AtomNetlist& netlist,$/;"	p	class:TimingGraphBuilder	access:public	signature:(const AtomNetlist& netlist, AtomLookup& netlist_lookup)
TimingGraphBuilder	timing/timing_graph_builder.h	/^class TimingGraphBuilder {$/;"	c
TimingGraphBuilder::TimingGraphBuilder	timing/timing_graph_builder.cpp	/^TimingGraphBuilder::TimingGraphBuilder(const AtomNetlist& netlist,$/;"	f	class:TimingGraphBuilder	signature:(const AtomNetlist& netlist, AtomLookup& netlist_lookup)
TimingGraphBuilder::TimingGraphBuilder	timing/timing_graph_builder.h	/^        TimingGraphBuilder(const AtomNetlist& netlist,$/;"	p	class:TimingGraphBuilder	access:public	signature:(const AtomNetlist& netlist, AtomLookup& netlist_lookup)
TimingGraphBuilder::add_block_to_timing_graph	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::add_block_to_timing_graph(const AtomBlockId blk) {$/;"	f	class:TimingGraphBuilder	signature:(const AtomBlockId blk)
TimingGraphBuilder::add_block_to_timing_graph	timing/timing_graph_builder.h	/^        void add_block_to_timing_graph(const AtomBlockId blk);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomBlockId blk)
TimingGraphBuilder::add_io_to_timing_graph	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::add_io_to_timing_graph(const AtomBlockId blk) {$/;"	f	class:TimingGraphBuilder	signature:(const AtomBlockId blk)
TimingGraphBuilder::add_io_to_timing_graph	timing/timing_graph_builder.h	/^        void add_io_to_timing_graph(const AtomBlockId blk);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomBlockId blk)
TimingGraphBuilder::add_net_to_timing_graph	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::add_net_to_timing_graph(const AtomNetId net) {$/;"	f	class:TimingGraphBuilder	signature:(const AtomNetId net)
TimingGraphBuilder::add_net_to_timing_graph	timing/timing_graph_builder.h	/^        void add_net_to_timing_graph(const AtomNetId net);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomNetId net)
TimingGraphBuilder::build	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::build() {$/;"	f	class:TimingGraphBuilder	signature:()
TimingGraphBuilder::build	timing/timing_graph_builder.h	/^        void build();$/;"	p	class:TimingGraphBuilder	access:private	signature:()
TimingGraphBuilder::find_associated_clock_pin	timing/timing_graph_builder.h	/^        const t_pb_graph_pin* find_associated_clock_pin(const AtomPinId pin);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomPinId pin)
TimingGraphBuilder::find_pb_graph_pin	timing/timing_graph_builder.h	/^        const t_pb_graph_pin* find_pb_graph_pin(const AtomPinId pin);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomPinId pin)
TimingGraphBuilder::find_scc_edge_to_break	timing/timing_graph_builder.cpp	/^tatum::EdgeId TimingGraphBuilder::find_scc_edge_to_break(std::vector<tatum::NodeId> scc) {$/;"	f	class:TimingGraphBuilder	signature:(std::vector<tatum::NodeId> scc)
TimingGraphBuilder::find_scc_edge_to_break	timing/timing_graph_builder.h	/^        tatum::EdgeId find_scc_edge_to_break(std::vector<tatum::NodeId> scc);$/;"	p	class:TimingGraphBuilder	access:private	signature:(std::vector<tatum::NodeId> scc)
TimingGraphBuilder::fix_comb_loops	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::fix_comb_loops() {$/;"	f	class:TimingGraphBuilder	signature:()
TimingGraphBuilder::fix_comb_loops	timing/timing_graph_builder.h	/^        void fix_comb_loops();$/;"	p	class:TimingGraphBuilder	access:private	signature:()
TimingGraphBuilder::is_netlist_clock_source	timing/timing_graph_builder.cpp	/^bool TimingGraphBuilder::is_netlist_clock_source(const AtomPinId pin) const {$/;"	f	class:TimingGraphBuilder	signature:(const AtomPinId pin) const
TimingGraphBuilder::is_netlist_clock_source	timing/timing_graph_builder.h	/^        bool is_netlist_clock_source(const AtomPinId pin) const;$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomPinId pin) const
TimingGraphBuilder::mark_clustering_net_delays	timing/timing_graph_builder.h	/^        void mark_clustering_net_delays(float inter_cluster_net_delay);$/;"	p	class:TimingGraphBuilder	access:private	signature:(float inter_cluster_net_delay)
TimingGraphBuilder::netlist_	timing/timing_graph_builder.h	/^        const AtomNetlist& netlist_;$/;"	m	class:TimingGraphBuilder	access:private
TimingGraphBuilder::netlist_clock_drivers_	timing/timing_graph_builder.h	/^        std::set<AtomPinId> netlist_clock_drivers_;$/;"	m	class:TimingGraphBuilder	access:private
TimingGraphBuilder::netlist_lookup_	timing/timing_graph_builder.h	/^        AtomLookup& netlist_lookup_;$/;"	m	class:TimingGraphBuilder	access:private
TimingGraphBuilder::opt_memory_layout	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::opt_memory_layout() {$/;"	f	class:TimingGraphBuilder	signature:()
TimingGraphBuilder::opt_memory_layout	timing/timing_graph_builder.h	/^        void opt_memory_layout();$/;"	p	class:TimingGraphBuilder	access:private	signature:()
TimingGraphBuilder::remap_ids	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::remap_ids(const tatum::GraphIdMaps& id_mapping) {$/;"	f	class:TimingGraphBuilder	signature:(const tatum::GraphIdMaps& id_mapping)
TimingGraphBuilder::remap_ids	timing/timing_graph_builder.h	/^        void remap_ids(const tatum::GraphIdMaps& id_mapping);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const tatum::GraphIdMaps& id_mapping)
TimingGraphBuilder::tg_	timing/timing_graph_builder.h	/^        std::unique_ptr<tatum::TimingGraph> tg_;$/;"	m	class:TimingGraphBuilder	access:private
TimingGraphBuilder::timing_graph	timing/timing_graph_builder.cpp	/^std::unique_ptr<TimingGraph> TimingGraphBuilder::timing_graph() {$/;"	f	class:TimingGraphBuilder	signature:()
TimingGraphBuilder::timing_graph	timing/timing_graph_builder.h	/^        std::unique_ptr<tatum::TimingGraph> timing_graph();$/;"	p	class:TimingGraphBuilder	access:public	signature:()
TimingInfo	timing/timing_info.h	/^class TimingInfo {$/;"	c
TimingInfo::analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::TimingAnalyzer> analyzer() const = 0;$/;"	p	class:TimingInfo	access:public	signature:() const
TimingInfo::set_warn_unconstrained	timing/timing_info.h	/^        virtual void set_warn_unconstrained(bool val) = 0;$/;"	p	class:TimingInfo	access:public	signature:(bool val)
TimingInfo::timing_constraints	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::TimingConstraints> timing_constraints() const = 0;$/;"	p	class:TimingInfo	access:public	signature:() const
TimingInfo::timing_graph	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::TimingGraph> timing_graph() const = 0;$/;"	p	class:TimingInfo	access:public	signature:() const
TimingInfo::update	timing/timing_info.h	/^        virtual void update() = 0;$/;"	p	class:TimingInfo	access:public	signature:()
TimingInfo::~TimingInfo	timing/timing_info.h	/^        virtual ~TimingInfo() = default;$/;"	p	class:TimingInfo	access:public	signature:()
TruthTable	base/atom_netlist.h	/^        typedef std::vector<std::vector<vtr::LogicValue>> TruthTable;$/;"	t	class:AtomNetlist	access:public
Type	base/netlist_writer.cpp	/^        enum class Type {$/;"	c	class:LatchInst	file:	access:public
UNDEFINED	../../libs/libarchfpga/src/arch_types.h	/^constexpr int UNDEFINED = -1;$/;"	v
UNDEFINED	base/vpr_types.h	/^#define UNDEFINED /;"	d
UNDEFINED_FANIN	../../libs/libarchfpga/src/physical_types.cpp	/^constexpr int t_arch_switch_inf::UNDEFINED_FANIN;$/;"	m	class:t_arch_switch_inf	file:
UNDEFINED_FANIN	../../libs/libarchfpga/src/physical_types.h	/^        static constexpr int UNDEFINED_FANIN = -1;$/;"	m	struct:t_arch_switch_inf	access:public
UNICODE	../../libs/libeasygl/src/graphics.cpp	/^#define UNICODE /;"	d	file:
UNIFORM	../../libs/libarchfpga/src/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
UNIMPLEMENTABLE_EXIT_CODE	base/vpr_exit_codes.h	/^constexpr int UNIMPLEMENTABLE_EXIT_CODE = 2; \/\/Could not implement (e.g. unroutable)$/;"	v
UNINITIALIZED_DELTA	place/timing_place_lookup.cpp	/^constexpr float UNINITIALIZED_DELTA = -1; \/\/Indicates the delta delay value has not been calculated$/;"	v
UNIVERSAL	../../libs/libarchfpga/src/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL, CUSTOM$/;"	e	enum:e_switch_block_type
UNI_DIRECTIONAL	../../libs/libarchfpga/src/physical_types.h	/^	UNI_DIRECTIONAL, BI_DIRECTIONAL$/;"	e	enum:e_directionality
UNKNOWN_CLASS	../../libs/libarchfpga/src/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
UNKOWN	../../libs/libvtrutil/src/vtr_logic.h	/^        UNKOWN = 3$/;"	m	class:vtr::LogicValue	access:private
UNK_EVAL	../../libs/librtlnumber/src/rtl_int.cpp	/^#define UNK_EVAL /;"	d	file:
UNSPECIFIED	../../libs/libarchfpga/src/arch_util.h	/^        static constexpr int UNSPECIFIED = -1;$/;"	m	class:InstPort	access:public
UN_SET	route/rr_graph2.cpp	/^constexpr short UN_SET = -1;$/;"	v
UPDATED_ONCE	place/place.cpp	/^#define UPDATED_ONCE /;"	d	file:
USER	base/vpr_types.h	/^	FREE, RANDOM, USER$/;"	e	enum:ScreenUpdatePriority::e_pad_loc_type
USER_SCHED	base/vpr_types.h	/^	AUTO_SCHED, USER_SCHED$/;"	e	enum:ScreenUpdatePriority::sched_type
USE_CAIRO_SURFACE	../../libs/libeasygl/src/SurfaceImpl.h	/^# define USE_CAIRO_SURFACE$/;"	d
UpdateAndCheckModels	../../libs/libarchfpga/src/arch_util.cpp	/^void UpdateAndCheckModels(t_arch *arch) {$/;"	f	signature:(t_arch *arch)
UpdateAndCheckModels	../../libs/libarchfpga/src/arch_util.h	/^void UpdateAndCheckModels(t_arch *arch);$/;"	p	signature:(t_arch *arch)
VCS_REVISION	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VCS_REVISION = "@VTR_VCS_REVISION@";$/;"	m	namespace:vtr	file:
VERSION	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VERSION = "@VTR_VERSION@";$/;"	m	namespace:vtr	file:
VERSION_MAJOR	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const size_t VERSION_MAJOR = @VTR_VERSION_MAJOR@;$/;"	m	namespace:vtr	file:
VERSION_MINOR	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const size_t VERSION_MINOR = @VTR_VERSION_MINOR@;$/;"	m	namespace:vtr	file:
VERSION_PATCH	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const size_t VERSION_PATCH = @VTR_VERSION_PATCH@;$/;"	m	namespace:vtr	file:
VERSION_PRERELEASE	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VERSION_PRERELEASE = "@VTR_VERSION_PRERELEASE@";$/;"	m	namespace:vtr	file:
VERSION_SHORT	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VERSION_SHORT = "@VTR_VERSION_SHORT@";$/;"	m	namespace:vtr	file:
VERTICAL	../../libs/libarchfpga/src/physical_types.h	/^    VERTICAL,      \/\/Vertical straight-through connections$/;"	m	class:e_sb_type	access:private
VIOLET	../../libs/libeasygl/src/easygl_constants.h	/^    VIOLET,$/;"	e	enum:color_types
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(){}$/;"	f	class:VNumber	access:public	signature:()
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(BitSpace::VerilogBits *other_bitstring, bool other_sign)$/;"	f	class:VNumber	access:private	signature:(BitSpace::VerilogBits *other_bitstring, bool other_sign)
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(VNumber&&) = default;$/;"	p	class:VNumber	access:public	signature:(VNumber&&)
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(const VNumber& other)$/;"	f	class:VNumber	access:public	signature:(const VNumber& other)
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(const std::string& verilog_string)$/;"	f	class:VNumber	access:public	signature:(const std::string& verilog_string)
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(int64_t numeric_value)$/;"	f	class:VNumber	access:public	signature:(int64_t numeric_value)
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(size_t len, BitSpace::bit_value_t initial_bits, bool input_sign)$/;"	f	class:VNumber	access:public	signature:(size_t len, BitSpace::bit_value_t initial_bits, bool input_sign)
VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^class VNumber $/;"	c
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(){}$/;"	f	class:VNumber	access:public	signature:()
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(BitSpace::VerilogBits *other_bitstring, bool other_sign)$/;"	f	class:VNumber	access:private	signature:(BitSpace::VerilogBits *other_bitstring, bool other_sign)
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(VNumber&&) = default;$/;"	p	class:VNumber	access:public	signature:(VNumber&&)
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(const VNumber& other)$/;"	f	class:VNumber	access:public	signature:(const VNumber& other)
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(const std::string& verilog_string)$/;"	f	class:VNumber	access:public	signature:(const std::string& verilog_string)
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(int64_t numeric_value)$/;"	f	class:VNumber	access:public	signature:(int64_t numeric_value)
VNumber::VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber(size_t len, BitSpace::bit_value_t initial_bits, bool input_sign)$/;"	f	class:VNumber	access:public	signature:(size_t len, BitSpace::bit_value_t initial_bits, bool input_sign)
VNumber::bitstring	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::VerilogBits *bitstring = nullptr;$/;"	m	class:VNumber	access:private
VNumber::bitwise	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber bitwise(VNumber& b, const BitSpace::bit_value_t lut[4][4])$/;"	f	class:VNumber	access:public	signature:(VNumber& b, const BitSpace::bit_value_t lut[4][4])
VNumber::bitwise_reduce	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber bitwise_reduce(const BitSpace::bit_value_t lut[4][4])$/;"	f	class:VNumber	access:public	signature:(const BitSpace::bit_value_t lut[4][4])
VNumber::get_bit_from_lsb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::bit_value_t get_bit_from_lsb(size_t index)$/;"	f	class:VNumber	access:public	signature:(size_t index)
VNumber::get_bit_from_msb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::bit_value_t get_bit_from_msb(size_t index)$/;"	f	class:VNumber	access:public	signature:(size_t index)
VNumber::get_padding_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::bit_value_t get_padding_bit()$/;"	f	class:VNumber	access:public	signature:()
VNumber::get_value	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    int64_t get_value()$/;"	f	class:VNumber	access:public	signature:()
VNumber::invert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber invert()$/;"	f	class:VNumber	access:public	signature:()
VNumber::is_dont_care_string	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool is_dont_care_string()$/;"	f	class:VNumber	access:public	signature:()
VNumber::is_negative	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool is_negative()$/;"	f	class:VNumber	access:public	signature:()
VNumber::is_signed	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool is_signed() const$/;"	f	class:VNumber	access:public	signature:() const
VNumber::msb_index	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    size_t msb_index()$/;"	f	class:VNumber	access:public	signature:()
VNumber::operator =	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber& operator=(VNumber&&) = default;$/;"	p	class:VNumber	access:public	signature:(VNumber&&)
VNumber::other	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber& operator=(const VNumber& other) = default;$/;"	m	class:VNumber	access:public
VNumber::set_bit_from_lsb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_bit_from_lsb(size_t index, BitSpace::bit_value_t val)$/;"	f	class:VNumber	access:public	signature:(size_t index, BitSpace::bit_value_t val)
VNumber::set_bit_from_msb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_bit_from_msb(size_t index, BitSpace::bit_value_t val)$/;"	f	class:VNumber	access:public	signature:(size_t index, BitSpace::bit_value_t val)
VNumber::set_value	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_value(const std::string& input)$/;"	f	class:VNumber	access:public	signature:(const std::string& input)
VNumber::set_value	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_value(int64_t in)$/;"	f	class:VNumber	access:public	signature:(int64_t in)
VNumber::sign	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool sign;$/;"	m	class:VNumber	access:private
VNumber::size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    size_t size()$/;"	f	class:VNumber	access:public	signature:()
VNumber::to_string	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    std::string to_string()$/;"	f	class:VNumber	access:public	signature:()
VNumber::twos_complement	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber twos_complement()$/;"	f	class:VNumber	access:public	signature:()
VNumber::~VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    ~VNumber()$/;"	f	class:VNumber	access:public	signature:()
VPR_API_H	base/vpr_api.h	/^#define VPR_API_H$/;"	d
VPR_ATOM_DELAY_CALC_H	timing/atom_delay_calc.h	/^#define VPR_ATOM_DELAY_CALC_H$/;"	d
VPR_ATOM_LOOKUP_FWD_H	base/atom_lookup_fwd.h	/^#define VPR_ATOM_LOOKUP_FWD_H$/;"	d
VPR_CHANNEL_STATS_H	route/channel_stats.h	/^#define VPR_CHANNEL_STATS_H$/;"	d
VPR_CHECK_ROUTE_H	route/check_route.h	/^#define VPR_CHECK_ROUTE_H$/;"	d
VPR_CLB_DELAY_CALC_H	timing/clb_delay_calc.h	/^#define VPR_CLB_DELAY_CALC_H$/;"	d
VPR_CONCRETE_TIMING_INFO_H	timing/concrete_timing_info.h	/^#define VPR_CONCRETE_TIMING_INFO_H$/;"	d
VPR_CONTEXT_H	base/vpr_context.h	/^#define VPR_CONTEXT_H$/;"	d
VPR_DELAY_TYPE	timing/DelayType.h	/^#define VPR_DELAY_TYPE$/;"	d
VPR_ERROR_ANALYSIS	util/vpr_error.h	/^	VPR_ERROR_ANALYSIS,$/;"	e	enum:e_vpr_error
VPR_ERROR_ARCH	util/vpr_error.h	/^	VPR_ERROR_ARCH,$/;"	e	enum:e_vpr_error
VPR_ERROR_ATOM_NETLIST	util/vpr_error.h	/^	VPR_ERROR_ATOM_NETLIST,$/;"	e	enum:e_vpr_error
VPR_ERROR_BLIF_F	util/vpr_error.h	/^	VPR_ERROR_BLIF_F,$/;"	e	enum:e_vpr_error
VPR_ERROR_CLB_NETLIST	util/vpr_error.h	/^	VPR_ERROR_CLB_NETLIST,$/;"	e	enum:e_vpr_error
VPR_ERROR_DRAW	util/vpr_error.h	/^	VPR_ERROR_DRAW,$/;"	e	enum:e_vpr_error
VPR_ERROR_H	util/vpr_error.h	/^#define VPR_ERROR_H$/;"	d
VPR_ERROR_IMPL_NETLIST_WRITER	util/vpr_error.h	/^	VPR_ERROR_IMPL_NETLIST_WRITER,$/;"	e	enum:e_vpr_error
VPR_ERROR_INTERRUPTED	util/vpr_error.h	/^	VPR_ERROR_INTERRUPTED,$/;"	e	enum:e_vpr_error
VPR_ERROR_NETLIST	util/vpr_error.h	/^	VPR_ERROR_NETLIST,$/;"	e	enum:e_vpr_error
VPR_ERROR_NET_F	util/vpr_error.h	/^	VPR_ERROR_NET_F,$/;"	e	enum:e_vpr_error
VPR_ERROR_OTHER	util/vpr_error.h	/^	VPR_ERROR_OTHER$/;"	e	enum:e_vpr_error
VPR_ERROR_PACK	util/vpr_error.h	/^	VPR_ERROR_PACK,$/;"	e	enum:e_vpr_error
VPR_ERROR_PLACE	util/vpr_error.h	/^	VPR_ERROR_PLACE,$/;"	e	enum:e_vpr_error
VPR_ERROR_PLACE_F	util/vpr_error.h	/^	VPR_ERROR_PLACE_F,$/;"	e	enum:e_vpr_error
VPR_ERROR_POWER	util/vpr_error.h	/^	VPR_ERROR_POWER,$/;"	e	enum:e_vpr_error
VPR_ERROR_ROUTE	util/vpr_error.h	/^	VPR_ERROR_ROUTE,$/;"	e	enum:e_vpr_error
VPR_ERROR_SDC	util/vpr_error.h	/^	VPR_ERROR_SDC,$/;"	e	enum:e_vpr_error
VPR_ERROR_TIMING	util/vpr_error.h	/^	VPR_ERROR_TIMING,$/;"	e	enum:e_vpr_error
VPR_ERROR_UNKNOWN	util/vpr_error.h	/^	VPR_ERROR_UNKNOWN = 0,$/;"	e	enum:e_vpr_error
VPR_EXIT_CODES_H	base/vpr_exit_codes.h	/^#define VPR_EXIT_CODES_H$/;"	d
VPR_HISTOGRAM_H	util/histogram.h	/^#define VPR_HISTOGRAM_H$/;"	d
VPR_PACK_REPORT_H	pack/pack_report.h	/^#define VPR_PACK_REPORT_H$/;"	d
VPR_PLACE_AND_ROUTE_H	base/place_and_route.h	/^#define VPR_PLACE_AND_ROUTE_H$/;"	d
VPR_PLACE_H	place/place.h	/^#define VPR_PLACE_H$/;"	d
VPR_READ_CIRCUIT_H	base/read_circuit.h	/^#define VPR_READ_CIRCUIT_H$/;"	d
VPR_READ_SDC2_H	timing/read_sdc2.h	/^#define VPR_READ_SDC2_H$/;"	d
VPR_ROUTER_LOOKAHEAD_H	route/router_lookahead.h	/^#define VPR_ROUTER_LOOKAHEAD_H$/;"	d
VPR_ROUTE_UTIL_H	route/route_util.h	/^#define VPR_ROUTE_UTIL_H$/;"	d
VPR_ROUTING_PREDICTOR_H	route/routing_predictor.h	/^#define VPR_ROUTING_PREDICTOR_H$/;"	d
VPR_SLACK_EVALUATOR	timing/slack_evaluation.h	/^#define VPR_SLACK_EVALUATOR$/;"	d
VPR_SPATIAL_ROUTE_TREE_LOOKUP_H	route/spatial_route_tree_lookup.h	/^#define VPR_SPATIAL_ROUTE_TREE_LOOKUP_H$/;"	d
VPR_TATUM_ERROR_H	base/vpr_tatum_error.h	/^#define VPR_TATUM_ERROR_H$/;"	d
VPR_THROW	util/vpr_error.h	/^#define VPR_THROW(/;"	d
VPR_TIMING_INFO_FWD_H	timing/timing_info_fwd.h	/^#define VPR_TIMING_INFO_FWD_H$/;"	d
VPR_TIMING_INFO_H	timing/timing_info.h	/^#define VPR_TIMING_INFO_H$/;"	d
VPR_TIMING_REPORTS_H	analysis/timing_reports.h	/^#define VPR_TIMING_REPORTS_H$/;"	d
VPR_TIMING_UTIL_H	timing/timing_util.h	/^#define VPR_TIMING_UTIL_H$/;"	d
VPR_TRACEBACK_H	route/route_traceback.h	/^#define VPR_TRACEBACK_H$/;"	d
VPR_TYPES_H	base/vpr_types.h	/^#define VPR_TYPES_H$/;"	d
VPR_UTILS_H	util/vpr_utils.h	/^#define VPR_UTILS_H$/;"	d
VRP_DOMAIN_PAIR_H	timing/DomainPair.h	/^#define VRP_DOMAIN_PAIR_H$/;"	d
VRP_TIMING_GRAPH_NAME_RESOLVER_H	timing/VprTimingGraphResolver.h	/^#define VRP_TIMING_GRAPH_NAME_RESOLVER_H$/;"	d
VTR_ASSERT	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT(/;"	d
VTR_ASSERT_DEBUG	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_DEBUG(/;"	d
VTR_ASSERT_DEBUG_ENABLED	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_DEBUG_ENABLED$/;"	d
VTR_ASSERT_DEBUG_MSG	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_DEBUG_MSG(/;"	d
VTR_ASSERT_ENABLED	../../libs/libvtrutil/src/vtr_assert.h	/^#define VTR_ASSERT_ENABLED$/;"	d
VTR_ASSERT_FUNCTION	../../libs/libvtrutil/src/vtr_assert.h	/^#   define VTR_ASSERT_FUNCTION /;"	d
VTR_ASSERT_FUNCTION	../../libs/libvtrutil/src/vtr_assert.h	/^#   undef VTR_ASSERT_FUNCTION$/;"	d
VTR_ASSERT_FUNCTION	../../libs/libvtrutil/src/vtr_assert.h	/^#define VTR_ASSERT_FUNCTION /;"	d
VTR_ASSERT_H	../../libs/libvtrutil/src/vtr_assert.h	/^#define VTR_ASSERT_H$/;"	d
VTR_ASSERT_IMPL	../../libs/libvtrutil/src/vtr_assert.h	/^#define VTR_ASSERT_IMPL(/;"	d
VTR_ASSERT_IMPL_NOP	../../libs/libvtrutil/src/vtr_assert.h	/^#define VTR_ASSERT_IMPL_NOP(/;"	d
VTR_ASSERT_LEVEL	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_LEVEL /;"	d
VTR_ASSERT_MSG	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_MSG(/;"	d
VTR_ASSERT_OPT	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_OPT(/;"	d
VTR_ASSERT_OPT_ENABLED	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_OPT_ENABLED$/;"	d
VTR_ASSERT_OPT_MSG	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_OPT_MSG(/;"	d
VTR_ASSERT_SAFE	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_SAFE(/;"	d
VTR_ASSERT_SAFE_ENABLED	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_SAFE_ENABLED$/;"	d
VTR_ASSERT_SAFE_MSG	../../libs/libvtrutil/src/vtr_assert.h	/^# define VTR_ASSERT_SAFE_MSG(/;"	d
VTR_BIMAP	../../libs/libvtrutil/src/vtr_bimap.h	/^#define VTR_BIMAP$/;"	d
VTR_CILK_H	../../libs/libvtrutil/src/vtr_cilk.h	/^#define VTR_CILK_H$/;"	d
VTR_CMAP_H	../../libs/libvtrutil/src/vtr_color_map.h	/^#define VTR_CMAP_H$/;"	d
VTR_DIGEST_H	../../libs/libvtrutil/src/vtr_digest.h	/^#define VTR_DIGEST_H$/;"	d
VTR_ERROR_H	../../libs/libvtrutil/src/vtr_error.h	/^#define VTR_ERROR_H$/;"	d
VTR_FLAT_MAP	../../libs/libvtrutil/src/vtr_flat_map.h	/^#define VTR_FLAT_MAP$/;"	d
VTR_GEOMETRY_H	../../libs/libvtrutil/src/vtr_geometry.h	/^#define VTR_GEOMETRY_H$/;"	d
VTR_HASH_H	../../libs/libvtrutil/src/vtr_hash.h	/^#define VTR_HASH_H$/;"	d
VTR_LINEAR_MAP_H	../../libs/libvtrutil/src/vtr_linear_map.h	/^#define VTR_LINEAR_MAP_H$/;"	d
VTR_LIST_H	../../libs/libvtrutil/src/vtr_list.h	/^#define VTR_LIST_H$/;"	d
VTR_LOG	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOG(/;"	d
VTR_LOGF	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGF(/;"	d
VTR_LOGF_ERROR	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGF_ERROR(/;"	d
VTR_LOGF_NOP	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGF_NOP(/;"	d
VTR_LOGF_WARN	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGF_WARN(/;"	d
VTR_LOGIC_H	../../libs/libvtrutil/src/vtr_logic.h	/^#define VTR_LOGIC_H$/;"	d
VTR_LOGV	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGV(/;"	d
VTR_LOGVF	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGVF(/;"	d
VTR_LOGVF_ERROR	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGVF_ERROR(/;"	d
VTR_LOGVF_NOP	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGVF_NOP(/;"	d
VTR_LOGVF_WARN	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGVF_WARN(/;"	d
VTR_LOGV_DEBUG	../../libs/libvtrutil/src/vtr_log.h	/^# define VTR_LOGV_DEBUG(/;"	d
VTR_LOGV_ERROR	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGV_ERROR(/;"	d
VTR_LOGV_NOP	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGV_NOP(/;"	d
VTR_LOGV_WARN	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOGV_WARN(/;"	d
VTR_LOG_DEBUG	../../libs/libvtrutil/src/vtr_log.h	/^# define VTR_LOG_DEBUG(/;"	d
VTR_LOG_ERROR	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOG_ERROR(/;"	d
VTR_LOG_H	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOG_H$/;"	d
VTR_LOG_NOP	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOG_NOP(/;"	d
VTR_LOG_WARN	../../libs/libvtrutil/src/vtr_log.h	/^#define VTR_LOG_WARN(/;"	d
VTR_MAP_UTIL_H	../../libs/libvtrutil/src/vtr_map_util.h	/^#define VTR_MAP_UTIL_H$/;"	d
VTR_MATH_H	../../libs/libvtrutil/src/vtr_math.h	/^#define VTR_MATH_H$/;"	d
VTR_MATRIX_H	../../libs/libvtrutil/src/vtr_matrix.h	/^#define VTR_MATRIX_H$/;"	d
VTR_MEMORY_H	../../libs/libvtrutil/src/vtr_memory.h	/^#define VTR_MEMORY_H$/;"	d
VTR_ND_MATRIX_H	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^#define VTR_ND_MATRIX_H$/;"	d
VTR_ND_OFFSET_MATRIX_H	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^#define VTR_ND_OFFSET_MATRIX_H$/;"	d
VTR_OSTREAM_GUARD_H	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^#define VTR_OSTREAM_GUARD_H$/;"	d
VTR_PAIR_UTIL_H	../../libs/libvtrutil/src/vtr_pair_util.h	/^#define VTR_PAIR_UTIL_H$/;"	d
VTR_PATH_H	../../libs/libvtrutil/src/vtr_path.h	/^#define VTR_PATH_H$/;"	d
VTR_RANDOM_H	../../libs/libvtrutil/src/vtr_random.h	/^#define VTR_RANDOM_H$/;"	d
VTR_RANGE_H	../../libs/libvtrutil/src/vtr_range.h	/^#define VTR_RANGE_H$/;"	d
VTR_RUSAGE_H	../../libs/libvtrutil/src/vtr_rusage.h	/^#define VTR_RUSAGE_H$/;"	d
VTR_SENTINELS_H	../../libs/libvtrutil/src/vtr_sentinels.h	/^#define VTR_SENTINELS_H$/;"	d
VTR_STRONG_ID_H	../../libs/libvtrutil/src/vtr_strong_id.h	/^#define VTR_STRONG_ID_H$/;"	d
VTR_TIME_H	../../libs/libvtrutil/src/vtr_time.h	/^#define VTR_TIME_H$/;"	d
VTR_UTIL_H	../../libs/libvtrutil/src/vtr_util.h	/^#define VTR_UTIL_H$/;"	d
VTR_VECTOR	../../libs/libvtrutil/src/vtr_vector.h	/^#define VTR_VECTOR$/;"	d
VTR_VECTOR_MAP	../../libs/libvtrutil/src/vtr_vector_map.h	/^#define VTR_VECTOR_MAP$/;"	d
VTR_VERSION_H	../../libs/libvtrutil/src/vtr_version.h	/^#define VTR_VERSION_H$/;"	d
V_ADD	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_ADD(VNumber& a);$/;"	p	signature:(VNumber& a)
V_ADD	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_ADD(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_ADD	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_ADD(VNumber& a)$/;"	f	signature:(VNumber& a)
V_ADD	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_ADD(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_BITWISE_AND	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_AND(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_AND	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_AND(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_BITWISE_AND	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_AND(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_AND	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_AND(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_BITWISE_NAND	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_NAND(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_NAND	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_NAND(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_BITWISE_NAND	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_NAND(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_NAND	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_NAND(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_BITWISE_NOR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_NOR(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_NOR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_NOR(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_BITWISE_NOR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_NOR(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_NOR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_NOR(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_BITWISE_NOT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_NOT(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_NOT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_NOT(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_OR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_OR(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_OR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_OR(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_BITWISE_OR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_OR(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_OR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_OR(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_BITWISE_XNOR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_XNOR(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_XNOR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_XNOR(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_BITWISE_XNOR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_XNOR(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_XNOR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_XNOR(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_BITWISE_XOR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_XOR(VNumber& a);$/;"	p	signature:(VNumber& a)
V_BITWISE_XOR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_BITWISE_XOR(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_BITWISE_XOR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_XOR(VNumber& a)$/;"	f	signature:(VNumber& a)
V_BITWISE_XOR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_BITWISE_XOR(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_CASE_EQUAL	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_CASE_EQUAL(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_CASE_EQUAL	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_CASE_EQUAL(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_CASE_NOT_EQUAL	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_CASE_NOT_EQUAL(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_CASE_NOT_EQUAL	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_CASE_NOT_EQUAL(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_DIV	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_DIV(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_DIV	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_DIV(VNumber& a_in, VNumber& b)$/;"	f	signature:(VNumber& a_in, VNumber& b)
V_EQUAL	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_EQUAL(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_EQUAL	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_EQUAL(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_GE	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_GE(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_GE	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_GE(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_GT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_GT(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_GT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_GT(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_LE	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_LE(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_LE	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_LE(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_LOGICAL_AND	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_LOGICAL_AND(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_LOGICAL_AND	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_LOGICAL_AND(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_LOGICAL_NOT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_LOGICAL_NOT(VNumber& a);$/;"	p	signature:(VNumber& a)
V_LOGICAL_NOT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_LOGICAL_NOT(VNumber& a)$/;"	f	signature:(VNumber& a)
V_LOGICAL_OR	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_LOGICAL_OR(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_LOGICAL_OR	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_LOGICAL_OR(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_LT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_LT(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_LT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_LT(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_MINUS	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_MINUS(VNumber& a);$/;"	p	signature:(VNumber& a)
V_MINUS	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_MINUS(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_MINUS	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_MINUS(VNumber& a)$/;"	f	signature:(VNumber& a)
V_MINUS	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_MINUS(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_MOD	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_MOD(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_MOD	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_MOD(VNumber& a_in, VNumber& b)$/;"	f	signature:(VNumber& a_in, VNumber& b)
V_MULTIPLY	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_MULTIPLY(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_MULTIPLY	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_MULTIPLY(VNumber& a_in, VNumber& b_in)$/;"	f	signature:(VNumber& a_in, VNumber& b_in)
V_NOT_EQUAL	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_NOT_EQUAL(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_NOT_EQUAL	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_NOT_EQUAL(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_POWER	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_POWER(VNumber& a,VNumber& b);$/;"	p	signature:(VNumber& a,VNumber& b)
V_POWER	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_POWER(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_SHIFT_LEFT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_SHIFT_LEFT(VNumber& a, VNumber& b);$/;"	p	signature:(VNumber& a, VNumber& b)
V_SHIFT_LEFT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_SHIFT_LEFT(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_SHIFT_RIGHT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_SHIFT_RIGHT(VNumber& a, VNumber& b);$/;"	p	signature:(VNumber& a, VNumber& b)
V_SHIFT_RIGHT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_SHIFT_RIGHT(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_SIGNED_SHIFT_LEFT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_SIGNED_SHIFT_LEFT(VNumber& a, VNumber& b);$/;"	p	signature:(VNumber& a, VNumber& b)
V_SIGNED_SHIFT_LEFT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_SIGNED_SHIFT_LEFT(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_SIGNED_SHIFT_RIGHT	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_SIGNED_SHIFT_RIGHT(VNumber& a, VNumber& b);$/;"	p	signature:(VNumber& a, VNumber& b)
V_SIGNED_SHIFT_RIGHT	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_SIGNED_SHIFT_RIGHT(VNumber& a, VNumber& b)$/;"	f	signature:(VNumber& a, VNumber& b)
V_TERNARY	../../libs/librtlnumber/src/include/rtl_int.hpp	/^VNumber V_TERNARY(VNumber& a, VNumber& b, VNumber& c);$/;"	p	signature:(VNumber& a, VNumber& b, VNumber& c)
V_TERNARY	../../libs/librtlnumber/src/rtl_int.cpp	/^VNumber V_TERNARY(VNumber& a_in, VNumber& b_in, VNumber& c_in)$/;"	f	signature:(VNumber& a_in, VNumber& b_in, VNumber& c_in)
V_TRUE	../../libs/librtlnumber/src/include/rtl_int.hpp	/^bool V_TRUE(VNumber& a);$/;"	p	signature:(VNumber& a)
V_TRUE	../../libs/librtlnumber/src/rtl_int.cpp	/^bool V_TRUE(VNumber& a)$/;"	f	signature:(VNumber& a)
Vdd	power/power.h	/^	float Vdd;$/;"	m	struct:t_power_tech	access:public
VerilogBits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits()$/;"	f	class:BitSpace::VerilogBits	access:private	signature:()
VerilogBits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits(size_t data_size, bit_value_t value_in)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t data_size, bit_value_t value_in)
VerilogBits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    class VerilogBits$/;"	c	namespace:BitSpace
ViridisColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^ViridisColorMap::ViridisColorMap(float min_val, float max_val)$/;"	f	class:vtr::ViridisColorMap	signature:(float min_val, float max_val)
ViridisColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        ViridisColorMap(float min, float max);$/;"	p	class:vtr::ViridisColorMap	access:public	signature:(float min, float max)
ViridisColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class ViridisColorMap : public ColorMap {$/;"	c	namespace:vtr	inherits:ColorMap
VprContext	base/vpr_context.h	/^class VprContext : public Context {$/;"	c	inherits:Context
VprContext::atom	base/vpr_context.h	/^        const AtomContext& atom() const { return atom_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::atom_	base/vpr_context.h	/^        AtomContext atom_;$/;"	m	class:VprContext	access:private
VprContext::clustering	base/vpr_context.h	/^        const ClusteringContext& clustering() const { return clustering_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::clustering_	base/vpr_context.h	/^        ClusteringContext clustering_;$/;"	m	class:VprContext	access:private
VprContext::device	base/vpr_context.h	/^        const DeviceContext& device() const { return device_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::device_	base/vpr_context.h	/^        DeviceContext device_;$/;"	m	class:VprContext	access:private
VprContext::force_pause_	base/vpr_context.h	/^        volatile sig_atomic_t force_pause_ = false;$/;"	m	class:VprContext	access:private
VprContext::forced_pause	base/vpr_context.h	/^        bool forced_pause() const { return force_pause_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::mutable_atom	base/vpr_context.h	/^        AtomContext& mutable_atom() { return atom_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::mutable_clustering	base/vpr_context.h	/^        ClusteringContext& mutable_clustering() { return clustering_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::mutable_device	base/vpr_context.h	/^        DeviceContext& mutable_device() { return device_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::mutable_placement	base/vpr_context.h	/^        PlacementContext& mutable_placement() { return placement_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::mutable_power	base/vpr_context.h	/^        PowerContext& mutable_power() { return power_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::mutable_routing	base/vpr_context.h	/^        RoutingContext& mutable_routing() { return routing_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::mutable_timing	base/vpr_context.h	/^        TimingContext& mutable_timing() { return timing_; }$/;"	f	class:VprContext	access:public	signature:()
VprContext::placement	base/vpr_context.h	/^        const PlacementContext& placement() const { return placement_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::placement_	base/vpr_context.h	/^        PlacementContext placement_;$/;"	m	class:VprContext	access:private
VprContext::power	base/vpr_context.h	/^        const PowerContext& power() const { return power_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::power_	base/vpr_context.h	/^        PowerContext power_;$/;"	m	class:VprContext	access:private
VprContext::routing	base/vpr_context.h	/^        const RoutingContext& routing() const { return routing_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::routing_	base/vpr_context.h	/^        RoutingContext routing_;$/;"	m	class:VprContext	access:private
VprContext::set_forced_pause	base/vpr_context.h	/^        void set_forced_pause(bool val) { force_pause_ = val; }$/;"	f	class:VprContext	access:public	signature:(bool val)
VprContext::timing	base/vpr_context.h	/^        const TimingContext& timing() const { return timing_; }$/;"	f	class:VprContext	access:public	signature:() const
VprContext::timing_	base/vpr_context.h	/^        TimingContext timing_;$/;"	m	class:VprContext	access:private
VprError	util/vpr_error.h	/^        VprError(t_vpr_error_type err_type,$/;"	f	class:VprError	access:public	signature:(t_vpr_error_type err_type, std::string msg=Ó, std::string file=Ó, size_t linenum=-1)
VprError	util/vpr_error.h	/^class VprError : public vtr::VtrError {$/;"	c	inherits:vtr::VtrError
VprError::VprError	util/vpr_error.h	/^        VprError(t_vpr_error_type err_type,$/;"	f	class:VprError	access:public	signature:(t_vpr_error_type err_type, std::string msg=Ó, std::string file=Ó, size_t linenum=-1)
VprError::type	util/vpr_error.h	/^        t_vpr_error_type type() const { return type_; }$/;"	f	class:VprError	access:public	signature:() const
VprError::type_	util/vpr_error.h	/^        t_vpr_error_type type_;$/;"	m	class:VprError	access:private
VprTimingGraphResolver	timing/VprTimingGraphResolver.cpp	/^VprTimingGraphResolver::VprTimingGraphResolver(const AtomNetlist& netlist, const AtomLookup& netlist_lookup,$/;"	f	class:VprTimingGraphResolver	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const tatum::TimingGraph& timing_graph, const AnalysisDelayCalculator& delay_calc)
VprTimingGraphResolver	timing/VprTimingGraphResolver.h	/^        VprTimingGraphResolver(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, $/;"	p	class:VprTimingGraphResolver	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const tatum::TimingGraph& timing_graph, const AnalysisDelayCalculator& delay_calc)
VprTimingGraphResolver	timing/VprTimingGraphResolver.h	/^class VprTimingGraphResolver : public tatum::TimingGraphNameResolver {$/;"	c	inherits:tatum::TimingGraphNameResolver
VprTimingGraphResolver::VprTimingGraphResolver	timing/VprTimingGraphResolver.cpp	/^VprTimingGraphResolver::VprTimingGraphResolver(const AtomNetlist& netlist, const AtomLookup& netlist_lookup,$/;"	f	class:VprTimingGraphResolver	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const tatum::TimingGraph& timing_graph, const AnalysisDelayCalculator& delay_calc)
VprTimingGraphResolver::VprTimingGraphResolver	timing/VprTimingGraphResolver.h	/^        VprTimingGraphResolver(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, $/;"	p	class:VprTimingGraphResolver	access:public	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const tatum::TimingGraph& timing_graph, const AnalysisDelayCalculator& delay_calc)
VprTimingGraphResolver::delay_calc_	timing/VprTimingGraphResolver.h	/^        const AnalysisDelayCalculator& delay_calc_;$/;"	m	class:VprTimingGraphResolver	access:private
VprTimingGraphResolver::detail_level	timing/VprTimingGraphResolver.cpp	/^e_timing_report_detail VprTimingGraphResolver::detail_level() const {$/;"	f	class:VprTimingGraphResolver	signature:() const
VprTimingGraphResolver::detail_level	timing/VprTimingGraphResolver.h	/^        e_timing_report_detail detail_level() const;$/;"	p	class:VprTimingGraphResolver	access:private	signature:() const
VprTimingGraphResolver::detail_level_	timing/VprTimingGraphResolver.h	/^        e_timing_report_detail detail_level_ = e_timing_report_detail::NETLIST;$/;"	m	class:VprTimingGraphResolver	access:private
VprTimingGraphResolver::edge_delay_breakdown	timing/VprTimingGraphResolver.cpp	/^tatum::EdgeDelayBreakdown VprTimingGraphResolver::edge_delay_breakdown(tatum::EdgeId edge, tatum::DelayType tatum_delay_type) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::EdgeId edge, tatum::DelayType tatum_delay_type) const
VprTimingGraphResolver::interconnect_delay_breakdown	timing/VprTimingGraphResolver.cpp	/^std::vector<tatum::DelayComponent> VprTimingGraphResolver::interconnect_delay_breakdown(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::EdgeId edge, DelayType delay_type) const
VprTimingGraphResolver::interconnect_delay_breakdown	timing/VprTimingGraphResolver.h	/^        std::vector<tatum::DelayComponent> interconnect_delay_breakdown(tatum::EdgeId edge, DelayType) const;$/;"	p	class:VprTimingGraphResolver	access:private	signature:(tatum::EdgeId edge, DelayType) const
VprTimingGraphResolver::netlist_	timing/VprTimingGraphResolver.h	/^        const AtomNetlist& netlist_;$/;"	m	class:VprTimingGraphResolver	access:private
VprTimingGraphResolver::netlist_lookup_	timing/VprTimingGraphResolver.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:VprTimingGraphResolver	access:private
VprTimingGraphResolver::node_name	timing/VprTimingGraphResolver.cpp	/^std::string VprTimingGraphResolver::node_name(tatum::NodeId node) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::NodeId node) const
VprTimingGraphResolver::node_type_name	timing/VprTimingGraphResolver.cpp	/^std::string VprTimingGraphResolver::node_type_name(tatum::NodeId node) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::NodeId node) const
VprTimingGraphResolver::override	timing/VprTimingGraphResolver.h	/^        std::string node_name(tatum::NodeId node) const override;$/;"	m	class:VprTimingGraphResolver	access:public
VprTimingGraphResolver::override	timing/VprTimingGraphResolver.h	/^        std::string node_type_name(tatum::NodeId node) const override;$/;"	m	class:VprTimingGraphResolver	access:public
VprTimingGraphResolver::override	timing/VprTimingGraphResolver.h	/^        tatum::EdgeDelayBreakdown edge_delay_breakdown(tatum::EdgeId edge, tatum::DelayType delay_type) const override;$/;"	m	class:VprTimingGraphResolver	access:public
VprTimingGraphResolver::set_detail_level	timing/VprTimingGraphResolver.cpp	/^void VprTimingGraphResolver::set_detail_level(e_timing_report_detail report_detail) {$/;"	f	class:VprTimingGraphResolver	signature:(e_timing_report_detail report_detail)
VprTimingGraphResolver::set_detail_level	timing/VprTimingGraphResolver.h	/^        void set_detail_level(e_timing_report_detail report_detail);$/;"	p	class:VprTimingGraphResolver	access:public	signature:(e_timing_report_detail report_detail)
VprTimingGraphResolver::timing_graph_	timing/VprTimingGraphResolver.h	/^        const tatum::TimingGraph& timing_graph_;$/;"	m	class:VprTimingGraphResolver	access:private
VtrError	../../libs/libvtrutil/src/vtr_error.h	/^        VtrError(std::string msg="", std::string new_filename="", size_t new_linenumber=-1)$/;"	f	class:vtr::VtrError	access:public	signature:(std::string msg=Ó, std::string new_filename=Ó, size_t new_linenumber=-1)
VtrError	../../libs/libvtrutil/src/vtr_error.h	/^class VtrError : public std::runtime_error {$/;"	c	namespace:vtr	inherits:std::runtime_error
WAITING_FOR_FIRST_CORNER_POINT	../../libs/libeasygl/src/graphics_state.h	/^    WAITING_FOR_FIRST_CORNER_POINT,$/;"	e	enum:__anon23
WAITING_FOR_SECOND_CORNER_POINT	../../libs/libeasygl/src/graphics_state.h	/^    WAITING_FOR_SECOND_CORNER_POINT$/;"	e	enum:__anon23
WHEAT	../../libs/libeasygl/src/easygl_constants.h	/^    WHEAT,$/;"	e	enum:color_types
WHITE	../../libs/libeasygl/src/easygl_constants.h	/^    WHITE = 0,$/;"	e	enum:color_types
WHITESMOKE	../../libs/libeasygl/src/easygl_constants.h	/^    WHITESMOKE,$/;"	e	enum:color_types
WILTON	../../libs/libarchfpga/src/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL, CUSTOM$/;"	e	enum:e_switch_block_type
WIN32_ButtonsWND	../../libs/libeasygl/src/graphics.cpp	/^WIN32_ButtonsWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {$/;"	f	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_ButtonsWND	../../libs/libeasygl/src/graphics.cpp	/^static LRESULT CALLBACK WIN32_ButtonsWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);$/;"	p	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_CREATE_ERROR	../../libs/libeasygl/src/graphics.cpp	/^static void WIN32_CREATE_ERROR() {$/;"	f	file:	signature:()
WIN32_CREATE_ERROR	../../libs/libeasygl/src/graphics.cpp	/^static void WIN32_CREATE_ERROR();$/;"	p	file:	signature:()
WIN32_DELETE_ERROR	../../libs/libeasygl/src/fontcache.cpp	/^void WIN32_DELETE_ERROR(); \/\/Forward declaration$/;"	p	file:	signature:()
WIN32_DELETE_ERROR	../../libs/libeasygl/src/graphics.cpp	/^void WIN32_DELETE_ERROR() {$/;"	f	signature:()
WIN32_DELETE_ERROR	../../libs/libeasygl/src/graphics.h	/^void WIN32_DELETE_ERROR();$/;"	p	signature:()
WIN32_DRAW_ERROR	../../libs/libeasygl/src/graphics.cpp	/^static void WIN32_DRAW_ERROR() {$/;"	f	file:	signature:()
WIN32_DRAW_ERROR	../../libs/libeasygl/src/graphics.cpp	/^static void WIN32_DRAW_ERROR();$/;"	p	file:	signature:()
WIN32_GraphicsWND	../../libs/libeasygl/src/graphics.cpp	/^WIN32_GraphicsWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {$/;"	f	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_GraphicsWND	../../libs/libeasygl/src/graphics.cpp	/^static LRESULT CALLBACK WIN32_GraphicsWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);$/;"	p	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_MainWND	../../libs/libeasygl/src/graphics.cpp	/^WIN32_MainWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {$/;"	f	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_MainWND	../../libs/libeasygl/src/graphics.cpp	/^static LRESULT CALLBACK WIN32_MainWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);$/;"	p	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_SELECT_ERROR	../../libs/libeasygl/src/graphics.cpp	/^static void WIN32_SELECT_ERROR() {$/;"	f	file:	signature:()
WIN32_SELECT_ERROR	../../libs/libeasygl/src/graphics.cpp	/^static void WIN32_SELECT_ERROR();$/;"	p	file:	signature:()
WIN32_StatusWND	../../libs/libeasygl/src/graphics.cpp	/^WIN32_StatusWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {$/;"	f	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WIN32_StatusWND	../../libs/libeasygl/src/graphics.cpp	/^static LRESULT CALLBACK WIN32_StatusWND(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);$/;"	p	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
WINDOW_DEACTIVATED	../../libs/libeasygl/src/graphics_state.h	/^    WINDOW_DEACTIVATED = 0,$/;"	e	enum:__anon23
WIRE_DRAWING_WIDTH	draw/draw.h	/^const float WIRE_DRAWING_WIDTH = 0.5;$/;"	v
WIRE_HOMOGENEITY	route/cb_metrics.h	/^	WIRE_HOMOGENEITY = 0,$/;"	e	enum:e_metric
WL	base/place_and_route.h	/^#define WL /;"	d
WNEED	base/place_and_route.h	/^#define WNEED /;"	d
Wire_Counting	route/cb_metrics.h	/^    Wire_Counting() = default;$/;"	p	class:Wire_Counting	access:public	signature:()
Wire_Counting	route/cb_metrics.h	/^class Wire_Counting{$/;"	c
Wire_Counting::Wire_Counting	route/cb_metrics.h	/^    Wire_Counting() = default;$/;"	p	class:Wire_Counting	access:public	signature:()
Wire_Counting::configs_used	route/cb_metrics.h	/^	std::map<int, long double> configs_used;$/;"	m	class:Wire_Counting	access:public
Wire_Counting::expectation_available	route/cb_metrics.h	/^	float expectation_available = 0.;$/;"	m	class:Wire_Counting	access:public
Wire_Counting::num_wires	route/cb_metrics.h	/^	int num_wires = 0;$/;"	m	class:Wire_Counting	access:public
Wire_Info	route/build_switchblocks.cpp	/^	Wire_Info(){$/;"	f	class:Wire_Info	access:public	signature:()
Wire_Info	route/build_switchblocks.cpp	/^	Wire_Info(int len, int wires, int st){$/;"	f	class:Wire_Info	access:public	signature:(int len, int wires, int st)
Wire_Info	route/build_switchblocks.cpp	/^class Wire_Info{$/;"	c	file:
Wire_Info::Wire_Info	route/build_switchblocks.cpp	/^	Wire_Info(){$/;"	f	class:Wire_Info	access:public	signature:()
Wire_Info::Wire_Info	route/build_switchblocks.cpp	/^	Wire_Info(int len, int wires, int st){$/;"	f	class:Wire_Info	access:public	signature:(int len, int wires, int st)
Wire_Info::length	route/build_switchblocks.cpp	/^	int length;		\/* the length of this type of wire segment in tiles *\/$/;"	m	class:Wire_Info	file:	access:public
Wire_Info::num_wires	route/build_switchblocks.cpp	/^	int num_wires;		\/* total number of wires in a channel segment (basically W) *\/$/;"	m	class:Wire_Info	file:	access:public
Wire_Info::set	route/build_switchblocks.cpp	/^	void set(int len, int wires, int st){$/;"	f	class:Wire_Info	access:public	signature:(int len, int wires, int st)
Wire_Info::start	route/build_switchblocks.cpp	/^	int start;		\/* the wire index at which this type starts in the channel segment (0..W-1) *\/$/;"	m	class:Wire_Info	file:	access:public
WirelengthInfo	route/route_timing.cpp	/^    WirelengthInfo(size_t available = 0u, size_t used = 0u)$/;"	f	class:WirelengthInfo	access:public	signature:(size_t available = 0u, size_t used = 0u)
WirelengthInfo	route/route_timing.cpp	/^class WirelengthInfo {$/;"	c	file:
WirelengthInfo::WirelengthInfo	route/route_timing.cpp	/^    WirelengthInfo(size_t available = 0u, size_t used = 0u)$/;"	f	class:WirelengthInfo	access:public	signature:(size_t available = 0u, size_t used = 0u)
WirelengthInfo::available_wirelength	route/route_timing.cpp	/^    size_t available_wirelength() const {$/;"	f	class:WirelengthInfo	access:public	signature:() const
WirelengthInfo::available_wirelength_	route/route_timing.cpp	/^    size_t available_wirelength_;$/;"	m	class:WirelengthInfo	file:	access:private
WirelengthInfo::used_wirelength	route/route_timing.cpp	/^    size_t used_wirelength() const {$/;"	f	class:WirelengthInfo	access:public	signature:() const
WirelengthInfo::used_wirelength_	route/route_timing.cpp	/^    size_t used_wirelength_;$/;"	m	class:WirelengthInfo	file:	access:private
WirelengthInfo::used_wirelength_ratio	route/route_timing.cpp	/^    float used_wirelength_ratio() const {$/;"	f	class:WirelengthInfo	access:public	signature:() const
X11	../../libs/libeasygl/src/fontcache.h	/^#define X11$/;"	d
X11	../../libs/libeasygl/src/graphics.h	/^#define X11$/;"	d
X11	../../libs/libeasygl/src/graphics_state.h	/^#define X11$/;"	d
XmlError	../../libs/libpugiutil/src/pugixml_util.hpp	/^            XmlError(std::string msg="", std::string new_filename="", size_t new_linenumber=-1)$/;"	f	class:pugiutil::XmlError	access:public	signature:(std::string msg=Ó, std::string new_filename=Ó, size_t new_linenumber=-1)
XmlError	../../libs/libpugiutil/src/pugixml_util.hpp	/^    class XmlError : public std::runtime_error {$/;"	c	namespace:pugiutil	inherits:std::runtime_error
XmlReadArch	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^void XmlReadArch(const char *ArchFile, const bool timing_enabled,$/;"	f	signature:(const char *ArchFile, const bool timing_enabled, t_arch *arch, t_type_descriptor ** Types, int *NumTypes)
XmlReadArch	../../libs/libarchfpga/src/read_xml_arch_file.h	/^XmlReadArch(const char *ArchFile, const bool timing_enabled,$/;"	p	signature:(const char *ArchFile, const bool timing_enabled, t_arch *arch, t_type_descriptor ** Types, int *NumTypes)
YELLOW	../../libs/libeasygl/src/easygl_constants.h	/^    YELLOW,$/;"	e	enum:color_types
YELLOWGREEN	../../libs/libeasygl/src/easygl_constants.h	/^    YELLOWGREEN,$/;"	e	enum:color_types
_0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _0 = 0x0;$/;"	m	namespace:BitSpace
_1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _1 = 0x1;$/;"	m	namespace:BitSpace
_All_0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_0 = static_cast<veri_internal_bits_t>(0x0000000000000000UL);$/;"	m	namespace:BitSpace
_All_1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_1 = static_cast<veri_internal_bits_t>(0x5555555555555555UL);$/;"	m	namespace:BitSpace
_All_x	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_x = static_cast<veri_internal_bits_t>(0xAAAAAAAAAAAAAAAAUL);$/;"	m	namespace:BitSpace
_All_z	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const veri_internal_bits_t _All_z = static_cast<veri_internal_bits_t>(0xFFFFFFFFFFFFFFFFUL);$/;"	m	namespace:BitSpace
_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_attribute_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_attribute_iterator&)
_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_named_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_named_node_iterator&)
_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_node_iterator&)
_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_attribute_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_attribute_iterator&)
_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_named_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_named_node_iterator&)
_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_node_iterator&)
__POWER_CMOS_TECH_H__	power/power_cmos_tech.h	/^#define __POWER_CMOS_TECH_H__$/;"	d
__POWER_COMPONENTS_H__	power/power_components.h	/^#define __POWER_COMPONENTS_H__$/;"	d
__POWER_H__	power/power.h	/^#define __POWER_H__$/;"	d
__POWER_LOW_LEVEL_H__	power/power_lowlevel.h	/^#define __POWER_LOW_LEVEL_H__$/;"	d
__POWER_MISC_H__	power/power_callibrate.h	/^#define __POWER_MISC_H__$/;"	d
__POWER_POWERSPICEDCOMPONENT_NMOS_H__	power/PowerSpicedComponent.h	/^#define __POWER_POWERSPICEDCOMPONENT_NMOS_H__$/;"	d
__POWER_TRANSISTOR_CNT_H__	power/power_sizing.h	/^#define __POWER_TRANSISTOR_CNT_H__$/;"	d
__POWER_UTIL_H__	power/power_util.h	/^#define __POWER_UTIL_H__$/;"	d
__anon12::color	draw/draw_types.h	/^	t_color color;$/;"	m	struct:__anon12	access:public
__anon12::node_highlighted	draw/draw_types.h	/^	bool node_highlighted;$/;"	m	struct:__anon12	access:public
__anon16::button	../../libs/libeasygl/src/easygl_constants.h	/^    unsigned int button; \/* indicates what button is pressed: left click is 1; right click is 3; *\/$/;"	m	struct:__anon16	access:public
__anon16::ctrl_pressed	../../libs/libeasygl/src/easygl_constants.h	/^    bool ctrl_pressed; \/* indicates whether a Ctrl key was pressed when a mouse button is pressed *\/$/;"	m	struct:__anon16	access:public
__anon16::shift_pressed	../../libs/libeasygl/src/easygl_constants.h	/^    bool shift_pressed; \/* indicates whether a Shift key was pressed when a mouse button is pressed *\/$/;"	m	struct:__anon16	access:public
__anon18::draw	../../libs/libeasygl/src/graphics.cpp	/^    XftDraw* draw;$/;"	m	struct:__anon18	file:	access:public
__anon18::enabled	../../libs/libeasygl/src/graphics.cpp	/^    bool enabled;$/;"	m	struct:__anon18	file:	access:public
__anon18::fcn	../../libs/libeasygl/src/graphics.cpp	/^    void(*fcn) (void(*drawscreen) ());$/;"	m	struct:__anon18	file:	access:public
__anon18::height	../../libs/libeasygl/src/graphics.cpp	/^    int height;$/;"	m	struct:__anon18	file:	access:public
__anon18::hwnd	../../libs/libeasygl/src/graphics.cpp	/^    HWND hwnd;$/;"	m	struct:__anon18	file:	access:public
__anon18::ispressed	../../libs/libeasygl/src/graphics.cpp	/^    bool ispressed;$/;"	m	struct:__anon18	file:	access:public
__anon18::poly	../../libs/libeasygl/src/graphics.cpp	/^    int poly[3][2];$/;"	m	struct:__anon18	file:	access:public
__anon18::text	../../libs/libeasygl/src/graphics.cpp	/^    char text[BUTTON_TEXT_LEN]; \/\/Space for terminator$/;"	m	struct:__anon18	file:	access:public
__anon18::type	../../libs/libeasygl/src/graphics.cpp	/^    t_button_type type;$/;"	m	struct:__anon18	file:	access:public
__anon18::width	../../libs/libeasygl/src/graphics.cpp	/^    int width;$/;"	m	struct:__anon18	file:	access:public
__anon18::win	../../libs/libeasygl/src/graphics.cpp	/^    Window win;$/;"	m	struct:__anon18	file:	access:public
__anon18::xleft	../../libs/libeasygl/src/graphics.cpp	/^    int xleft;$/;"	m	struct:__anon18	file:	access:public
__anon18::ytop	../../libs/libeasygl/src/graphics.cpp	/^    int ytop;$/;"	m	struct:__anon18	file:	access:public
__anon19::button	../../libs/libeasygl/src/graphics.cpp	/^    t_button *button;$/;"	m	struct:__anon19	file:	access:public
__anon19::num_buttons	../../libs/libeasygl/src/graphics.cpp	/^    int num_buttons;$/;"	m	struct:__anon19	file:	access:public
__anon20::display_height	../../libs/libeasygl/src/graphics.cpp	/^    int display_width, display_height;$/;"	m	struct:__anon20	file:	access:public
__anon20::display_width	../../libs/libeasygl/src/graphics.cpp	/^    int display_width, display_height;$/;"	m	struct:__anon20	file:	access:public
__anon20::init_xleft	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::init_xright	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::init_ybot	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::init_ytop	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ps_bot	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ps_left	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ps_right	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ps_top	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ps_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::ps_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::s_to_ps_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float s_to_ps_xmult, s_to_ps_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::s_to_ps_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float s_to_ps_xmult, s_to_ps_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::stow_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float stow_xmult, stow_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::stow_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float stow_xmult, stow_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::top_height	../../libs/libeasygl/src/graphics.cpp	/^    int top_width, top_height;$/;"	m	struct:__anon20	file:	access:public
__anon20::top_width	../../libs/libeasygl/src/graphics.cpp	/^    int top_width, top_height;$/;"	m	struct:__anon20	file:	access:public
__anon20::wtos_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float wtos_xmult, wtos_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::wtos_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float wtos_xmult, wtos_ymult;$/;"	m	struct:__anon20	file:	access:public
__anon20::xleft	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::xright	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ybot	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
__anon20::ytop	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
__anon21::panning_enabled	../../libs/libeasygl/src/graphics.cpp	/^    bool panning_enabled;$/;"	m	struct:__anon21	file:	access:public
__anon21::previous_x	../../libs/libeasygl/src/graphics.cpp	/^    int previous_x, previous_y;$/;"	m	struct:__anon21	file:	access:public
__anon21::previous_y	../../libs/libeasygl/src/graphics.cpp	/^    int previous_x, previous_y;$/;"	m	struct:__anon21	file:	access:public
__anon22::ps_xmult	../../libs/libeasygl/src/graphics.h	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon22	access:public
__anon22::ps_ymult	../../libs/libeasygl/src/graphics.h	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon22	access:public
__anon22::top_height	../../libs/libeasygl/src/graphics.h	/^    int top_width, top_height;$/;"	m	struct:__anon22	access:public
__anon22::top_width	../../libs/libeasygl/src/graphics.h	/^    int top_width, top_height;$/;"	m	struct:__anon22	access:public
__anon22::xleft	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
__anon22::xmult	../../libs/libeasygl/src/graphics.h	/^    float xmult, ymult;$/;"	m	struct:__anon22	access:public
__anon22::xright	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
__anon22::ybot	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
__anon22::ymult	../../libs/libeasygl/src/graphics.h	/^    float xmult, ymult;$/;"	m	struct:__anon22	access:public
__anon22::ytop	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_attribute_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_attribute_iterator&)
__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_named_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_named_node_iterator&)
__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_node_iterator&)
__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_attribute_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_attribute_iterator&)
__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_named_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_named_node_iterator&)
__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_node_iterator&)
_alloc	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* _alloc;$/;"	m	struct:xpath_parser	file:	access:public
_assert_Werr	../../libs/librtlnumber/src/include/rtl_utils.hpp	/^inline void _assert_Werr(bool cond, const char *FUNCT, int LINE, std::string error_string)$/;"	f	signature:(bool cond, const char *FUNCT, int LINE, std::string error_string)
_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_node_set::_assign(const_iterator begin_, const_iterator end_, type_t type_)$/;"	f	class:pugi::xpath_node_set	signature:(const_iterator begin_, const_iterator end_, type_t type_)
_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_variable_set::_assign(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(const xpath_variable_set& rhs)
_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _assign(const xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(const xpath_variable_set& rhs)
_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _assign(const_iterator begin, const_iterator end, type_t type);$/;"	p	class:pugi::xpath_node_set	access:private	signature:(const_iterator begin, const_iterator end, type_t type)
_attr	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_struct* _attr;$/;"	m	class:pugi::xml_attribute	access:private
_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute _attribute;$/;"	m	class:pugi::xpath_node	access:private
_axis	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _axis;$/;"	m	class:xpath_ast_node	file:	access:private
_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* _begin;$/;"	m	class:xpath_node_set_raw	file:	access:private
_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It _begin, _end;$/;"	m	class:pugi::xml_object_range	access:private
_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node* _begin;$/;"	m	class:pugi::xpath_node_set	access:private
_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _buffer;$/;"	m	class:xpath_string	file:	access:private
_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		char_t* _buffer;$/;"	m	class:pugi::xml_document	access:private
_busy_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _busy_size;$/;"	m	struct:xml_allocator	file:	access:public
_capacity	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _capacity;$/;"	m	class:compact_hash_table	file:	access:private
_clone	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::_clone(xpath_variable* var, xpath_variable** out_result)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable* var, xpath_variable** out_result)
_clone	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		static bool _clone(xpath_variable* var, xpath_variable** out_result);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(xpath_variable* var, xpath_variable** out_result)
_count	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _count;$/;"	m	class:compact_hash_table	file:	access:private
_cur	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _cur;$/;"	m	class:xpath_lexer	file:	access:private
_cur_lexeme	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lexeme_t _cur_lexeme;$/;"	m	class:xpath_lexer	file:	access:private
_cur_lexeme_contents	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_lexer_string _cur_lexeme_contents;$/;"	m	class:xpath_lexer	file:	access:private
_cur_lexeme_pos	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _cur_lexeme_pos;$/;"	m	class:xpath_lexer	file:	access:private
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t _data;$/;"	m	class:compact_pointer_parent	file:	access:private
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _data;$/;"	m	class:compact_pointer	file:	access:private
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _data;$/;"	m	class:compact_string	file:	access:private
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		} _data;$/;"	m	class:xpath_ast_node	typeref:union:xpath_ast_node::__anon30	file:	access:private
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_struct* xml_text::_data() const$/;"	f	class:pugi::xml_text	signature:() const
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _data() const;$/;"	p	class:pugi::xml_text	access:private	signature:() const
_data	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* _data[64];$/;"	m	class:pugi::xpath_variable_set	access:private
_data_new	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_struct* xml_text::_data_new()$/;"	f	class:pugi::xml_text	signature:()
_data_new	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _data_new();$/;"	p	class:pugi::xml_text	access:private	signature:()
_depth	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int _depth;$/;"	m	class:pugi::xml_tree_walker	access:private
_destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_variable_set::_destroy(xpath_variable* var)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable* var)
_destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		static void _destroy(xpath_variable* var);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(xpath_variable* var)
_drawcurve	../../libs/libeasygl/src/graphics.cpp	/^static void _drawcurve(t_point *points, int npoints, int fill) {$/;"	f	file:	signature:(t_point *points, int npoints, int fill)
_end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* _end;$/;"	m	class:xpath_node_set_raw	file:	access:private
_end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It _begin, _end;$/;"	m	class:pugi::xml_object_range	access:private
_end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node* _end;$/;"	m	class:pugi::xpath_node_set	access:private
_eos	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* _eos;$/;"	m	class:xpath_node_set_raw	file:	access:private
_error_handler	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		jmp_buf _error_handler;$/;"	m	struct:xpath_parser	file:	access:public
_find	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* xpath_variable_set::_find(const char_t* name) const$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name) const
_find	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* _find(const char_t* name) const;$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(const char_t* name) const
_flags	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _flags;$/;"	m	class:compact_header	file:	access:private
_hash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_hash_table* _hash;$/;"	m	struct:xml_allocator	file:	access:public
_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void* _impl;$/;"	m	class:pugi::xpath_query	access:private
_items	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		item_t* _items;$/;"	m	class:compact_hash_table	file:	access:private
_left	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* _left;$/;"	m	class:xpath_ast_node	file:	access:private
_length_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _length_heap;$/;"	m	class:xpath_string	file:	access:private
_lexer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_lexer _lexer;$/;"	m	struct:xpath_parser	file:	access:public
_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		char _memory[192];$/;"	m	class:pugi::xml_document	access:private
_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_node_set::_move(xpath_node_set& rhs)$/;"	f	class:pugi::xpath_node_set	signature:(xpath_node_set& rhs)
_move	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _move(xpath_node_set& rhs);$/;"	p	class:pugi::xpath_node_set	access:private	signature:(xpath_node_set& rhs)
_name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* _name;$/;"	m	class:pugi::xml_named_node_iterator	access:private
_next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* _next;$/;"	m	class:xpath_ast_node	file:	access:private
_next	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* _next;$/;"	m	class:pugi::xpath_variable	access:protected
_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _node;$/;"	m	class:pugi::xpath_node	access:private
_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _page;$/;"	m	class:compact_header	file:	access:private
_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _parent;$/;"	m	class:pugi::xml_attribute_iterator	access:private
_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _parent;$/;"	m	class:pugi::xml_named_node_iterator	access:private
_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _parent;$/;"	m	class:pugi::xml_node_iterator	access:private
_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _query;$/;"	m	struct:xpath_parser	file:	access:public
_radix_digit_to_bits	../../libs/librtlnumber/src/rtl_utils.cpp	/^inline static std::string _radix_digit_to_bits(const char digit, short radix,  const char *FUNCT, int LINE)$/;"	f	file:	signature:(const char digit, short radix, const char *FUNCT, int LINE)
_radix_digit_to_bits_str	../../libs/librtlnumber/src/rtl_utils.cpp	/^inline static std::string _radix_digit_to_bits_str(const char digit, short radix,  const char *FUNCT, int LINE)$/;"	f	file:	signature:(const char digit, short radix, const char *FUNCT, int LINE)
_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_parse_result* _result;$/;"	m	struct:xpath_parser	file:	access:public
_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_parse_result _result;$/;"	m	class:pugi::xpath_exception	access:private
_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_parse_result _result;$/;"	m	class:pugi::xpath_query	access:private
_rettype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _rettype;$/;"	m	class:xpath_ast_node	file:	access:private
_right	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* _right;$/;"	m	class:xpath_ast_node	file:	access:private
_root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* _root;$/;"	m	struct:xml_allocator	file:	access:public
_root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block* _root;$/;"	m	class:xpath_allocator	file:	access:private
_root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _root;$/;"	m	class:pugi::xml_node	access:protected
_root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _root;$/;"	m	class:pugi::xml_text	access:private
_root_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _root_size;$/;"	m	class:xpath_allocator	file:	access:private
_scratch	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t _scratch[32];$/;"	m	struct:xpath_parser	file:	access:public
_state	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator _state;$/;"	m	struct:xpath_allocator_capture	file:	access:public
_storage	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node _storage;$/;"	m	class:pugi::xpath_node_set	access:private
_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_variable_set::_swap(xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable_set& rhs)
_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _swap(xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(xpath_variable_set& rhs)
_target	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* _target;$/;"	m	struct:xpath_allocator_capture	file:	access:public
_test	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _test;$/;"	m	class:xpath_ast_node	file:	access:private
_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _type;$/;"	m	class:xpath_ast_node	file:	access:private
_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set::type_t _type;$/;"	m	class:xpath_node_set_raw	file:	access:private
_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		type_t _type;$/;"	m	class:pugi::xpath_node_set	access:private
_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_value_type _type;$/;"	m	class:pugi::xpath_variable	access:protected
_uses_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool _uses_heap;$/;"	m	class:xpath_string	file:	access:private
_variables	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_set* _variables;$/;"	m	struct:xpath_parser	file:	access:public
_wrap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		mutable xml_attribute _wrap;$/;"	m	class:pugi::xml_attribute_iterator	access:private
_wrap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		mutable xml_node _wrap;$/;"	m	class:pugi::xml_named_node_iterator	access:private
_wrap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		mutable xml_node _wrap;$/;"	m	class:pugi::xml_node_iterator	access:private
_x	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _x = 0x2;$/;"	m	namespace:BitSpace
_z	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t _z = 0x3;$/;"	m	namespace:BitSpace
absolute_length	../../libs/libarchfpga/src/physical_types.h	/^		float absolute_length;$/;"	m	union:t_port_power::__anon13	access:public
absolute_power_per_instance	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage absolute_power_per_instance; \/* User-provided absolute power per block *\/$/;"	m	struct:t_pb_type_power	access:public
absorb_buffer_luts	base/atom_netlist_utils.cpp	/^void absorb_buffer_luts(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
absorb_buffer_luts	base/atom_netlist_utils.h	/^void absorb_buffer_luts(AtomNetlist& netlist, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, int verbosity)
absorb_buffer_luts	base/read_options.h	/^    argparse::ArgValue<bool> absorb_buffer_luts;$/;"	m	struct:t_options	access:public
absorb_buffer_luts	base/vpr_types.h	/^    bool absorb_buffer_luts = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
acc_cost	base/vpr_types.h	/^	float acc_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
acc_fac	base/read_options.h	/^    argparse::ArgValue<float> acc_fac;$/;"	m	struct:t_options	access:public
acc_fac	base/vpr_types.h	/^	float acc_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
accept_move	route/cb_metrics.cpp	/^static bool accept_move(const double del_cost, const double temp);$/;"	p	file:	signature:(const double del_cost, const double temp)
accept_move	route/cb_metrics.cpp	/^static bool accept_move(const double del_cost, const double temp){$/;"	f	file:	signature:(const double del_cost, const double temp)
act_on_key_press	draw/draw.cpp	/^static void act_on_key_press(char \/*key_pressed*\/, int \/*keysym*\/) {$/;"	f	file:	signature:(char , int )
act_on_key_press	draw/draw.cpp	/^static void act_on_key_press(char \/*key_pressed*\/, int keysym) {$/;"	f	file:	signature:(char , int keysym)
act_on_key_press	draw/draw.cpp	/^static void act_on_key_press(char key_pressed, int keysym);$/;"	p	file:	signature:(char key_pressed, int keysym)
act_on_mouse_over	draw/draw.cpp	/^static void act_on_mouse_over(float mouse_x, float mouse_y) {$/;"	f	file:	signature:(float mouse_x, float mouse_y)
act_on_mouse_over	draw/draw.cpp	/^static void act_on_mouse_over(float x, float y);$/;"	p	file:	signature:(float x, float y)
action	../../libs/libvtrutil/src/vtr_time.cpp	/^std::string ScopedActionTimer::action() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
action	../../libs/libvtrutil/src/vtr_time.h	/^            std::string action() const;$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:() const
action_	../../libs/libvtrutil/src/vtr_time.h	/^            const std::string action_;$/;"	m	class:vtr::ScopedActionTimer	access:private
add	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* xpath_variable_set::add(const char_t* name, xpath_value_type type)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, xpath_value_type type)
add	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* add(const char_t* name, xpath_value_type type);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, xpath_value_type type)
add_activity_to_net	base/read_activity.cpp	/^static bool add_activity_to_net(const AtomNetlist& netlist, std::unordered_map<AtomNetId,t_net_power>& atom_net_power,$/;"	f	file:	signature:(const AtomNetlist& netlist, std::unordered_map<AtomNetId,t_net_power>& atom_net_power, char * net_name, float probability, float density)
add_activity_to_net	base/read_activity.cpp	/^static bool add_activity_to_net(const AtomNetlist& netlist, std::unordered_map<AtomNetId,t_net_power>& atom_net_power,$/;"	p	file:	signature:(const AtomNetlist& netlist, std::unordered_map<AtomNetId,t_net_power>& atom_net_power, char * net_name, float probability, float density)
add_all_children	draw/intra_logic_block.cpp	/^void add_all_children(const t_pb* pb, const ClusterBlockId clb_index,$/;"	f	signature:(const t_pb* pb, const ClusterBlockId clb_index, std::unordered_set< t_selected_sub_block_info::gnode_clb_pair, HashType>& set)
add_atom_as_target	pack/cluster_router.cpp	/^void add_atom_as_target(t_lb_router_data *router_data, const AtomBlockId blk_id) {$/;"	f	signature:(t_lb_router_data *router_data, const AtomBlockId blk_id)
add_atom_as_target	pack/cluster_router.h	/^void add_atom_as_target(t_lb_router_data *router_data, const AtomBlockId blk_id);$/;"	p	signature:(t_lb_router_data *router_data, const AtomBlockId blk_id)
add_block_to_timing_graph	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::add_block_to_timing_graph(const AtomBlockId blk) {$/;"	f	class:TimingGraphBuilder	signature:(const AtomBlockId blk)
add_block_to_timing_graph	timing/timing_graph_builder.h	/^        void add_block_to_timing_graph(const AtomBlockId blk);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomBlockId blk)
add_clock	timing/read_sdc.cpp	/^static void add_clock(std::string net_name) {$/;"	f	file:	signature:(std::string net_name)
add_clock	timing/read_sdc.cpp	/^static void add_clock(std::string net_name);$/;"	p	file:	signature:(std::string net_name)
add_cluster_molecule_candidates_by_connectivity_and_timing	pack/cluster.cpp	/^void add_cluster_molecule_candidates_by_connectivity_and_timing(t_pb* cur_pb,$/;"	f	signature:(t_pb* cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules)
add_cluster_molecule_candidates_by_connectivity_and_timing	pack/cluster.cpp	/^void add_cluster_molecule_candidates_by_connectivity_and_timing(t_pb* cur_pb,$/;"	p	file:	signature:(t_pb* cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules)
add_cluster_molecule_candidates_by_highfanout_connectivity	pack/cluster.cpp	/^void add_cluster_molecule_candidates_by_highfanout_connectivity(t_pb* cur_pb,$/;"	f	signature:(t_pb* cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules)
add_cluster_molecule_candidates_by_highfanout_connectivity	pack/cluster.cpp	/^void add_cluster_molecule_candidates_by_highfanout_connectivity(t_pb* cur_pb,$/;"	p	file:	signature:(t_pb* cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules)
add_cluster_molecule_candidates_by_transitive_connectivity	pack/cluster.cpp	/^void add_cluster_molecule_candidates_by_transitive_connectivity(t_pb* cur_pb,$/;"	f	signature:(t_pb* cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets, const ClusterBlockId cluster_index)
add_cluster_molecule_candidates_by_transitive_connectivity	pack/cluster.cpp	/^void add_cluster_molecule_candidates_by_transitive_connectivity(t_pb* cur_pb,$/;"	p	file:	signature:(t_pb* cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets, const ClusterBlockId cluster_index)
add_constant	../../libs/libvtrutil/src/picosha2.h	/^const word_t add_constant[64] = {$/;"	m	namespace:picosha2::detail
add_cost_entry	route/router_lookahead_map.cpp	/^	void add_cost_entry(float add_delay, float add_congestion){$/;"	f	class:Expansion_Cost_Entry	access:public	signature:(float add_delay, float add_congestion)
add_data_point	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::add_data_point(int num_inputs, float transistor_size,$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs, float transistor_size, float power)
add_data_point	power/PowerSpicedComponent.h	/^	void add_data_point(int num_inputs, float transistor_size, float power);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs, float transistor_size, float power)
add_edge	route/rr_node.cpp	/^short t_rr_node::add_edge(int sink_node, int iswitch) {$/;"	f	class:t_rr_node	signature:(int sink_node, int iswitch)
add_edge	route/rr_node.h	/^        short add_edge(int sink_node, int iswitch);$/;"	p	class:t_rr_node	access:public	signature:(int sink_node, int iswitch)
add_entry	power/PowerSpicedComponent.cpp	/^PowerCallibInputs * PowerSpicedComponent::add_entry(int num_inputs) {$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs)
add_entry	power/PowerSpicedComponent.h	/^	PowerCallibInputs * add_entry(int num_inputs);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs)
add_high_fanout_route_tree_to_heap	route/route_timing.cpp	/^static t_bb add_high_fanout_route_tree_to_heap(t_rt_node* rt_root, int target_node,$/;"	f	file:	signature:(t_rt_node* rt_root, int target_node, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, const SpatialRouteTreeLookup& spatial_rt_lookup, t_bb net_bounding_box, RouterStats& router_stats)
add_high_fanout_route_tree_to_heap	route/route_timing.cpp	/^static t_bb add_high_fanout_route_tree_to_heap(t_rt_node* rt_root, int target_node,$/;"	p	file:	signature:(t_rt_node* rt_root, int target_node, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, const SpatialRouteTreeLookup& spatial_route_tree_lookup, t_bb net_bounding_box, RouterStats& router_stats)
add_io_to_timing_graph	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::add_io_to_timing_graph(const AtomBlockId blk) {$/;"	f	class:TimingGraphBuilder	signature:(const AtomBlockId blk)
add_io_to_timing_graph	timing/timing_graph_builder.h	/^        void add_io_to_timing_graph(const AtomBlockId blk);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomBlockId blk)
add_iteration_overuse	route/routing_predictor.cpp	/^void RoutingPredictor::add_iteration_overuse(size_t iteration, size_t overused_rr_node_count) {$/;"	f	class:RoutingPredictor	signature:(size_t iteration, size_t overused_rr_node_count)
add_iteration_overuse	route/routing_predictor.h	/^    void add_iteration_overuse(size_t iteration, size_t overused_rr_node_count);$/;"	p	class:RoutingPredictor	access:public	signature:(size_t iteration, size_t overused_rr_node_count)
add_molecule_to_pb_stats_candidates	pack/cluster.cpp	/^static void add_molecule_to_pb_stats_candidates(t_pack_molecule *molecule,$/;"	f	file:	signature:(t_pack_molecule *molecule, map<AtomBlockId, float> &gain, t_pb *pb, int max_queue_size)
add_molecule_to_pb_stats_candidates	pack/cluster.cpp	/^static void add_molecule_to_pb_stats_candidates(t_pack_molecule *molecule,$/;"	p	file:	signature:(t_pack_molecule *molecule, map<AtomBlockId, float> &gain, t_pb *pb, int max_queue_size)
add_net	base/atom_netlist.cpp	/^AtomNetId AtomNetlist::add_net(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks) {$/;"	f	class:AtomNetlist	signature:(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks)
add_net	base/atom_netlist.h	/^        AtomNetId   add_net(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks);$/;"	p	class:AtomNetlist	access:public	signature:(const std::string name, AtomPinId driver, std::vector<AtomPinId> sinks)
add_net	base/netlist.h	/^        NetId   add_net(const std::string name, PinId driver, std::vector<PinId> sinks);$/;"	p	class:Netlist	access:protected	signature:(const std::string name, PinId driver, std::vector<PinId> sinks)
add_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::add_net(const std::string name, PinId driver, std::vector<PinId> sinks) {$/;"	f	class:Netlist	signature:(const std::string name, PinId driver, std::vector<PinId> sinks)
add_net_to_hash	base/read_netlist.cpp	/^static int add_net_to_hash(t_hash **nhash, const char *net_name, int *ncount) {$/;"	f	file:	signature:(t_hash **nhash, const char *net_name, int *ncount)
add_net_to_hash	base/read_netlist.cpp	/^static int add_net_to_hash(t_hash **nhash, const char *net_name,$/;"	p	file:	signature:(t_hash **nhash, const char *net_name, int *ncount)
add_net_to_timing_graph	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::add_net_to_timing_graph(const AtomNetId net) {$/;"	f	class:TimingGraphBuilder	signature:(const AtomNetId net)
add_net_to_timing_graph	timing/timing_graph_builder.h	/^        void add_net_to_timing_graph(const AtomNetId net);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomNetId net)
add_non_configurable_to_route_tree	route/route_tree_timing.cpp	/^static t_rt_node* add_non_configurable_to_route_tree(const int rr_node, const bool reached_by_non_configurable_edge, std::unordered_set<int>& visited) {$/;"	f	file:	signature:(const int rr_node, const bool reached_by_non_configurable_edge, std::unordered_set<int>& visited)
add_non_configurable_to_route_tree	route/route_tree_timing.cpp	/^static t_rt_node* add_non_configurable_to_route_tree(const int rr_node, const bool reached_by_non_configurable_edge, std::unordered_set<int>& visited);$/;"	p	file:	signature:(const int rr_node, const bool reached_by_non_configurable_edge, std::unordered_set<int>& visited)
add_override_constraint	timing/read_sdc.cpp	/^static void add_override_constraint(char ** from_list, int num_from, char ** to_list, int num_to,$/;"	f	file:	signature:(char ** from_list, int num_from, char ** to_list, int num_to, float constraint, int num_multicycles, bool domain_level_from, bool domain_level_to, bool make_copies)
add_override_constraint	timing/read_sdc.cpp	/^static void add_override_constraint(char ** from_list, int num_from, char ** to_list, int num_to,$/;"	p	file:	signature:(char ** from_list, int num_from, char ** to_list, int num_to, float constraint, int num_multicycles, bool domain_level_from, bool domain_level_to, bool make_copies)
add_pattern_name_to_hash	pack/prepack.cpp	/^static int add_pattern_name_to_hash(t_hash **nhash,$/;"	f	file:	signature:(t_hash **nhash, const char *pattern_name, int *ncount)
add_pattern_name_to_hash	pack/prepack.cpp	/^static int add_pattern_name_to_hash(t_hash **nhash,$/;"	p	file:	signature:(t_hash **nhash, const char *pattern_name, int *ncount)
add_pin_to_rt_terminals	pack/cluster_router.cpp	/^static void add_pin_to_rt_terminals(t_lb_router_data *router_data, const AtomPinId pin_id) {$/;"	f	file:	signature:(t_lb_router_data *router_data, const AtomPinId pin_id)
add_pin_to_rt_terminals	pack/cluster_router.cpp	/^static void add_pin_to_rt_terminals(t_lb_router_data *router_data, const AtomPinId pin_id);$/;"	p	file:	signature:(t_lb_router_data *router_data, const AtomPinId pin_id)
add_route_tree_node_to_heap	route/route_timing.cpp	/^static void add_route_tree_node_to_heap(t_rt_node* rt_node,$/;"	f	file:	signature:(t_rt_node* rt_node, int target_node, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, RouterStats& router_stats)
add_route_tree_node_to_heap	route/route_timing.cpp	/^static void add_route_tree_node_to_heap(t_rt_node* rt_node,$/;"	p	file:	signature:(t_rt_node* rt_node, int target_node, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, RouterStats& router_stats)
add_route_tree_to_heap	route/route_timing.cpp	/^static void add_route_tree_to_heap(t_rt_node * rt_node, int target_node,$/;"	f	file:	signature:(t_rt_node * rt_node, int target_node, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, RouterStats& router_stats)
add_route_tree_to_heap	route/route_timing.cpp	/^static void add_route_tree_to_heap(t_rt_node * rt_node, int target_node,$/;"	p	file:	signature:(t_rt_node * rt_node, int target_node, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, RouterStats& router_stats)
add_route_tree_to_rr_node_lookup	route/route_tree_timing.cpp	/^void add_route_tree_to_rr_node_lookup(t_rt_node* node) {$/;"	f	signature:(t_rt_node* node)
add_route_tree_to_rr_node_lookup	route/route_tree_timing.h	/^void add_route_tree_to_rr_node_lookup(t_rt_node* node);$/;"	p	signature:(t_rt_node* node)
add_rr_graph_C_from_switches	route/rr_graph_timing_params.cpp	/^void add_rr_graph_C_from_switches(float C_ipin_cblock) {$/;"	f	signature:(float C_ipin_cblock)
add_rr_graph_C_from_switches	route/rr_graph_timing_params.h	/^void add_rr_graph_C_from_switches(float C_ipin_cblock);$/;"	p	signature:(float C_ipin_cblock)
add_size	power/PowerSpicedComponent.cpp	/^void PowerCallibInputs::add_size(float transistor_size, float power) {$/;"	f	class:PowerCallibInputs	signature:(float transistor_size, float power)
add_size	power/PowerSpicedComponent.h	/^	void add_size(float transistor_size, float power = 0.);$/;"	p	class:PowerCallibInputs	access:public	signature:(float transistor_size, float power = 0.)
add_source_to_rt	pack/cluster_router.cpp	/^static void add_source_to_rt(t_lb_router_data *router_data, int inet) {$/;"	f	file:	signature:(t_lb_router_data *router_data, int inet)
add_source_to_rt	pack/cluster_router.cpp	/^static void add_source_to_rt(t_lb_router_data *router_data, int inet);$/;"	p	file:	signature:(t_lb_router_data *router_data, int inet)
add_subtree_to_route_tree	route/route_tree_timing.cpp	/^add_subtree_to_route_tree(t_heap *hptr, t_rt_node ** sink_rt_node_ptr) {$/;"	f	file:	signature:(t_heap *hptr, t_rt_node ** sink_rt_node_ptr)
add_subtree_to_route_tree	route/route_tree_timing.cpp	/^static t_rt_node *add_subtree_to_route_tree(t_heap *hptr,$/;"	p	file:	signature:(t_heap *hptr, t_rt_node ** sink_rt_node_ptr)
add_to_data_length	../../libs/libvtrutil/src/picosha2.h	/^	void add_to_data_length(word_t n) {$/;"	f	class:picosha2::hash256_one_by_one	access:private	signature:(word_t n)
add_to_heap	route/route_common.cpp	/^void add_to_heap(t_heap *hptr) {$/;"	f	signature:(t_heap *hptr)
add_to_heap	route/route_common.h	/^void add_to_heap(t_heap *hptr);$/;"	p	signature:(t_heap *hptr)
add_to_mod_list	route/route_common.cpp	/^void add_to_mod_list(int inode, std::vector<int>& modified_rr_node_inf) {$/;"	f	signature:(int inode, std::vector<int>& modified_rr_node_inf)
add_to_mod_list	route/route_common.h	/^void add_to_mod_list(int inode, std::vector<int>& modified_rr_node_inf);$/;"	p	signature:(int inode, std::vector<int>& modified_rr_node_inf)
add_to_rc_tree	timing/net_delay.cpp	/^static void add_to_rc_tree(t_rc_node * parent_rc, t_rc_node * child_rc,$/;"	f	file:	signature:(t_rc_node * parent_rc, t_rc_node * child_rc, short iswitch, int inode, t_linked_rc_edge ** rc_edge_free_list_ptr)
add_to_rc_tree	timing/net_delay.cpp	/^static void add_to_rc_tree(t_rc_node * parent_rc, t_rc_node * child_rc,$/;"	p	file:	signature:(t_rc_node * parent_rc, t_rc_node * child_rc, short iswitch, int inode, t_linked_rc_edge ** rc_edge_free_list_ptr)
add_to_rt	pack/cluster_router.cpp	/^static void add_to_rt(t_lb_trace *rt, int node_index, t_explored_node_tb *explored_node_tb, int irt_net) {$/;"	f	file:	signature:(t_lb_trace *rt, int node_index, t_explored_node_tb *explored_node_tb, int irt_net)
add_to_rt	pack/cluster_router.cpp	/^static void add_to_rt(t_lb_trace *rt, int node_index, t_explored_node_tb *explored_node_tb, int irt_net);$/;"	p	file:	signature:(t_lb_trace *rt, int node_index, t_explored_node_tb *explored_node_tb, int irt_net)
add_trace_non_configurable	route/route_common.cpp	/^static std::pair<t_trace*,t_trace*> add_trace_non_configurable(t_trace* head, t_trace* tail, int node, std::unordered_set<int>& trace_nodes) {$/;"	f	file:	signature:(t_trace* head, t_trace* tail, int node, std::unordered_set<int>& trace_nodes)
add_trace_non_configurable	route/route_common.cpp	/^static std::pair<t_trace*,t_trace*> add_trace_non_configurable(t_trace* head, t_trace* tail, int node, std::unordered_set<int>& visited);$/;"	p	file:	signature:(t_trace* head, t_trace* tail, int node, std::unordered_set<int>& visited)
add_trace_non_configurable_recurr	route/route_common.cpp	/^static std::pair<t_trace*,t_trace*> add_trace_non_configurable_recurr(int node, std::unordered_set<int>& trace_nodes, int depth) {$/;"	f	file:	signature:(int node, std::unordered_set<int>& trace_nodes, int depth)
add_trace_non_configurable_recurr	route/route_common.cpp	/^static std::pair<t_trace*,t_trace*> add_trace_non_configurable_recurr(int node, std::unordered_set<int>& visited, int depth=0);$/;"	p	file:	signature:(int node, std::unordered_set<int>& visited, int depth=0)
adjustButton	../../libs/libeasygl/src/graphics_state.h	/^    int adjustButton;$/;"	m	class:t_win32_state	access:public
adjustRect	../../libs/libeasygl/src/graphics_state.h	/^    RECT adjustRect;$/;"	m	class:t_win32_state	access:public
adjust_cb_metric	route/cb_metrics.cpp	/^void adjust_cb_metric(const e_metric metric, const float target, const float target_tolerance,$/;"	f	signature:(const e_metric metric, const float target, const float target_tolerance, const t_type_ptr block_type, int *****pin_to_track_connections, const e_pin_type pin_type, const int *Fc_array, const t_chan_width *chan_width_inf, const int num_segments, const t_segment_inf *segment_inf)
adjust_cb_metric	route/cb_metrics.h	/^void adjust_cb_metric(const e_metric metric, const float target, const float target_tolerance,$/;"	p	signature:(const e_metric metric, const float target, const float target_tolerance, const t_type_ptr block_type, int *****pin_to_track_connections, const e_pin_type pin_type, const int *Fc_array, const t_chan_width *chan_width_inf, const int num_segments, const t_segment_inf *segment_inf)
adjust_chan_details	route/rr_graph2.cpp	/^void adjust_chan_details($/;"	f	signature:( const DeviceGrid& grid, const t_chan_width* nodes_per_chan, t_chan_details& chan_details_x, t_chan_details& chan_details_y)
adjust_chan_details	route/rr_graph2.h	/^void adjust_chan_details($/;"	p	signature:( const DeviceGrid& grid, const t_chan_width *nodes_per_chan, t_chan_details& chan_details_x, t_chan_details& chan_details_y)
adjust_formula_result	route/build_switchblocks.cpp	/^static int adjust_formula_result(int dest_wire, int src_W, int dest_W, int connection_ind) {$/;"	f	file:	signature:(int dest_wire, int src_W, int dest_W, int connection_ind)
adjust_formula_result	route/build_switchblocks.cpp	/^static int adjust_formula_result(int dest_wire, int src_W, int dest_W, int connection_ind);$/;"	p	file:	signature:(int dest_wire, int src_W, int dest_W, int connection_ind)
adjust_highfanout_bounding_box	route/route_timing.cpp	/^static t_bb adjust_highfanout_bounding_box(t_bb highfanout_bb) {$/;"	f	file:	signature:(t_bb highfanout_bb)
adjust_highfanout_bounding_box	route/route_timing.cpp	/^static t_bb adjust_highfanout_bounding_box(t_bb highfanout_bb);$/;"	p	file:	signature:(t_bb highfanout_bb)
adjust_one_rr_occ_and_apcost	route/route_common.cpp	/^static void adjust_one_rr_occ_and_apcost(int inode, int add_or_sub,$/;"	f	file:	signature:(int inode, int add_or_sub, float pres_fac, float acc_fac)
adjust_one_rr_occ_and_apcost	route/route_common.cpp	/^static void adjust_one_rr_occ_and_apcost(int inode, int add_or_sub,$/;"	p	file:	signature:(int inode, int add_or_sub, float pres_fac, float acc_fac)
adjust_seg_details	route/rr_graph2.cpp	/^void adjust_seg_details($/;"	f	signature:( const int x, const int y, const DeviceGrid& grid, const t_chan_width* nodes_per_chan, t_chan_details& chan_details, const enum e_seg_details_type seg_details_type)
adjust_seg_details	route/rr_graph2.h	/^void adjust_seg_details($/;"	p	signature:( const int x, const int y, const DeviceGrid& grid, const t_chan_width *nodes_per_chan, t_chan_details& chan_details, const enum e_seg_details_type seg_details_type)
adjustwin	../../libs/libeasygl/src/graphics.cpp	/^adjustwin(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
adjustwin	../../libs/libeasygl/src/graphics.cpp	/^static void adjustwin(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
advance_to_next_block_side	route/rr_graph.cpp	/^static void advance_to_next_block_side(t_type_ptr Type, int& width_offset, int& height_offset, e_side& side) {$/;"	f	file:	signature:(t_type_ptr Type, int& width_offset, int& height_offset, e_side& side)
advance_to_next_block_side	route/rr_graph.cpp	/^static void advance_to_next_block_side(t_type_ptr Type, int& width_offset, int& height_offset, e_side& side);$/;"	p	file:	signature:(t_type_ptr Type, int& width_offset, int& height_offset, e_side& side)
alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			double alignment;$/;"	m	union:xpath_memory_block::__anon29	file:	access:public
all_valid	base/netlist_utils.h	/^bool all_valid(const Container& values) {$/;"	f	signature:(const Container& values)
alloc	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator alloc;$/;"	m	struct:xml_parser	file:	access:public
alloc	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator alloc;$/;"	m	struct:xpath_query_impl	file:	access:public
alloc	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void alloc() {$/;"	f	class:vtr::NdMatrixBase	access:private	signature:()
alloc	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void alloc() {$/;"	f	class:vtr::NdOffsetMatrixBase	access:private	signature:()
alloc_SRAM_values_from_truth_table	power/power_util.cpp	/^char * alloc_SRAM_values_from_truth_table(int LUT_size,$/;"	f	signature:(int LUT_size, const AtomNetlist::TruthTable& truth_table)
alloc_SRAM_values_from_truth_table	power/power_util.h	/^char * alloc_SRAM_values_from_truth_table(int LUT_size,$/;"	p	signature:(int LUT_size, const AtomNetlist::TruthTable& truth_table)
alloc_and_init_clustering	pack/cluster.cpp	/^static void alloc_and_init_clustering(const t_molecule_stats& max_molecule_stats,$/;"	f	file:	signature:(const t_molecule_stats& max_molecule_stats, t_cluster_placement_stats **cluster_placement_stats, t_pb_graph_node ***primitives_list, t_pack_molecule *molecules_head, int num_molecules)
alloc_and_init_clustering	pack/cluster.cpp	/^static void alloc_and_init_clustering(const t_molecule_stats& max_molecule_stats,$/;"	p	file:	signature:(const t_molecule_stats& max_molecule_stats, t_cluster_placement_stats **cluster_placement_stats, t_pb_graph_node ***primitives_list, t_pack_molecule *molecules_head, int num_molecules)
alloc_and_init_pattern_list_from_hash	pack/prepack.cpp	/^static t_pack_patterns *alloc_and_init_pattern_list_from_hash(const int ncount,$/;"	f	file:	signature:(const int ncount, t_hash **nhash)
alloc_and_init_pattern_list_from_hash	pack/prepack.cpp	/^static t_pack_patterns *alloc_and_init_pattern_list_from_hash(const int ncount,$/;"	p	file:	signature:(const int ncount, t_hash **nhash)
alloc_and_load_actual_fc	route/rr_graph.cpp	/^static std::vector<vtr::Matrix<int>> alloc_and_load_actual_fc(const int L_num_types, const t_type_ptr types, const int max_pins,$/;"	f	file:	signature:(const int L_num_types, const t_type_ptr types, const int max_pins, const int num_seg_types, const t_segment_inf * segment_inf, const int *sets_per_seg_type, const int max_chan_width, const e_fc_type fc_type, const enum e_directionality directionality, bool *Fc_clipped)
alloc_and_load_actual_fc	route/rr_graph.cpp	/^static std::vector<vtr::Matrix<int>> alloc_and_load_actual_fc(const int L_num_types, const t_type_ptr types, const int max_pins,$/;"	p	file:	signature:(const int L_num_types, const t_type_ptr types, const int max_pins, const int num_seg_types, const t_segment_inf * segment_inf, const int *sets_per_seg_type, const int max_chan_width, const e_fc_type fc_type, const enum e_directionality directionality, bool *Fc_clipped)
alloc_and_load_all_lb_type_rr_graph	pack/lb_type_rr_graph.cpp	/^std::vector<t_lb_type_rr_node> *alloc_and_load_all_lb_type_rr_graph() {$/;"	f	signature:()
alloc_and_load_all_lb_type_rr_graph	pack/lb_type_rr_graph.h	/^std::vector <t_lb_type_rr_node> *alloc_and_load_all_lb_type_rr_graph();$/;"	p	signature:()
alloc_and_load_all_pb_graphs	pack/pb_type_graph.cpp	/^void alloc_and_load_all_pb_graphs(bool load_power_structures) {$/;"	f	signature:(bool load_power_structures)
alloc_and_load_all_pb_graphs	pack/pb_type_graph.h	/^void alloc_and_load_all_pb_graphs(bool load_power_structures);$/;"	p	signature:(bool load_power_structures)
alloc_and_load_blk_pin_from_port_pin	util/vpr_utils.cpp	/^static void alloc_and_load_blk_pin_from_port_pin() {$/;"	f	file:	signature:()
alloc_and_load_blk_pin_from_port_pin	util/vpr_utils.cpp	/^static void alloc_and_load_blk_pin_from_port_pin();$/;"	p	file:	signature:()
alloc_and_load_chan_details	route/rr_graph2.cpp	/^void alloc_and_load_chan_details($/;"	f	signature:( const DeviceGrid& grid, const t_chan_width* nodes_per_chan, const bool trim_empty_channels, const bool trim_obs_channels, const int num_seg_details, const t_seg_details* seg_details, t_chan_details& chan_details_x, t_chan_details& chan_details_y)
alloc_and_load_chan_details	route/rr_graph2.h	/^void alloc_and_load_chan_details($/;"	p	signature:( const DeviceGrid& grid, const t_chan_width *nodes_per_chan, const bool trim_empty_channels, const bool trim_obs_channels, const int num_seg_details, const t_seg_details *seg_details, t_chan_details& chan_details_x, t_chan_details& chan_details_y)
alloc_and_load_clb_opins_used_locally	route/route_common.cpp	/^static t_clb_opins_used alloc_and_load_clb_opins_used_locally() {$/;"	f	file:	signature:()
alloc_and_load_clb_opins_used_locally	route/route_common.cpp	/^static t_clb_opins_used alloc_and_load_clb_opins_used_locally();$/;"	p	file:	signature:()
alloc_and_load_clb_to_clb_directs	route/rr_graph.cpp	/^static t_clb_to_clb_directs * alloc_and_load_clb_to_clb_directs(const t_direct_inf *directs, const int num_directs, int delayless_switch) {$/;"	f	file:	signature:(const t_direct_inf *directs, const int num_directs, int delayless_switch)
alloc_and_load_clb_to_clb_directs	route/rr_graph.cpp	/^static t_clb_to_clb_directs *alloc_and_load_clb_to_clb_directs(const t_direct_inf *directs, const int num_directs,$/;"	p	file:	signature:(const t_direct_inf *directs, const int num_directs, const int delayless_switch)
alloc_and_load_cluster_placement_stats	pack/cluster_placement.cpp	/^t_cluster_placement_stats *alloc_and_load_cluster_placement_stats() {$/;"	f	signature:()
alloc_and_load_cluster_placement_stats	pack/cluster_placement.h	/^t_cluster_placement_stats *alloc_and_load_cluster_placement_stats();$/;"	p	signature:()
alloc_and_load_complete_interc_edges	pack/pb_type_graph.cpp	/^static void alloc_and_load_complete_interc_edges($/;"	f	file:	signature:( t_interconnect *interconnect, t_pb_graph_pin *** input_pb_graph_node_pin_ptrs, const int num_input_sets, const int *num_input_ptrs, t_pb_graph_pin *** output_pb_graph_node_pin_ptrs, const int num_output_sets, const int *num_output_ptrs)
alloc_and_load_complete_interc_edges	pack/pb_type_graph.cpp	/^static void alloc_and_load_complete_interc_edges($/;"	p	file:	signature:( t_interconnect * interconnect, t_pb_graph_pin *** input_pb_graph_node_pin_ptrs, const int num_input_sets, const int *num_input_ptrs, t_pb_graph_pin *** output_pb_graph_node_pin_ptrs, const int num_output_sets, const int *num_output_ptrs)
alloc_and_load_default_child_for_pb_type	../../libs/libarchfpga/src/arch_util.cpp	/^void alloc_and_load_default_child_for_pb_type( t_pb_type *pb_type,$/;"	f	signature:( t_pb_type *pb_type, char *new_name, t_pb_type *copy)
alloc_and_load_default_child_for_pb_type	../../libs/libarchfpga/src/arch_util.h	/^void alloc_and_load_default_child_for_pb_type( t_pb_type *pb_type,$/;"	p	signature:( t_pb_type *pb_type, char *new_name, t_pb_type *copy)
alloc_and_load_direct_interc_edges	pack/pb_type_graph.cpp	/^static void alloc_and_load_direct_interc_edges($/;"	f	file:	signature:( t_interconnect *interconnect, t_pb_graph_pin *** input_pb_graph_node_pin_ptrs, const int num_input_sets, const int *num_input_ptrs, t_pb_graph_pin *** output_pb_graph_node_pin_ptrs, const int num_output_sets, const int *num_output_ptrs)
alloc_and_load_direct_interc_edges	pack/pb_type_graph.cpp	/^static void alloc_and_load_direct_interc_edges($/;"	p	file:	signature:( t_interconnect * interconnect, t_pb_graph_pin *** input_pb_graph_node_pin_ptrs, const int num_input_sets, const int *num_input_ptrs, t_pb_graph_pin *** output_pb_graph_node_pin_ptrs, const int num_output_sets, const int *num_output_ptrs)
alloc_and_load_echo_file_info	base/echo_files.cpp	/^void alloc_and_load_echo_file_info() {$/;"	f	signature:()
alloc_and_load_echo_file_info	base/echo_files.h	/^void alloc_and_load_echo_file_info();$/;"	p	signature:()
alloc_and_load_edges	route/rr_graph.cpp	/^void alloc_and_load_edges(std::vector<t_rr_node>& L_rr_node,$/;"	f	signature:(std::vector<t_rr_node>& L_rr_node, const t_rr_edge_info_set& rr_edges_to_create)
alloc_and_load_edges	route/rr_graph.cpp	/^void alloc_and_load_edges(std::vector<t_rr_node>& L_rr_node,$/;"	p	file:	signature:(std::vector<t_rr_node>& L_rr_node, const t_rr_edge_info_set& rr_edges_to_create)
alloc_and_load_for_fast_cost_update	place/place.cpp	/^static void alloc_and_load_for_fast_cost_update(float place_cost_exp) {$/;"	f	file:	signature:(float place_cost_exp)
alloc_and_load_for_fast_cost_update	place/place.cpp	/^static void alloc_and_load_for_fast_cost_update(float place_cost_exp);$/;"	p	file:	signature:(float place_cost_exp)
alloc_and_load_global_route_seg_details	route/rr_graph.cpp	/^static t_seg_details *alloc_and_load_global_route_seg_details($/;"	f	file:	signature:( const int global_route_switch, int * num_seg_details)
alloc_and_load_global_route_seg_details	route/rr_graph.cpp	/^static t_seg_details *alloc_and_load_global_route_seg_details($/;"	p	file:	signature:( const int global_route_switch, int * num_seg_details = nullptr)
alloc_and_load_idirect_from_blk_pin	util/vpr_utils.cpp	/^void alloc_and_load_idirect_from_blk_pin(t_direct_inf* directs, int num_directs,$/;"	f	signature:(t_direct_inf* directs, int num_directs, int *** idirect_from_blk_pin, int *** direct_type_from_blk_pin)
alloc_and_load_idirect_from_blk_pin	util/vpr_utils.h	/^void alloc_and_load_idirect_from_blk_pin(t_direct_inf* directs, int num_directs,$/;"	p	signature:(t_direct_inf* directs, int num_directs, int *** idirect_from_blk_pin, int *** direct_type_from_blk_pin)
alloc_and_load_imacro_from_iblk	place/place_macro.cpp	/^static void alloc_and_load_imacro_from_iblk(t_pl_macro * macros, int num_macros);$/;"	p	file:	signature:(t_pl_macro * macros, int num_macros)
alloc_and_load_imacro_from_iblk	place/place_macro.cpp	/^static void alloc_and_load_imacro_from_iblk(t_pl_macro *macros, int num_macros) {$/;"	f	file:	signature:(t_pl_macro *macros, int num_macros)
alloc_and_load_interconnect_pins	pack/pb_type_graph.cpp	/^static void alloc_and_load_interconnect_pins(t_interconnect_pins * interc_pins,$/;"	f	file:	signature:(t_interconnect_pins * interc_pins, t_interconnect * interconnect, t_pb_graph_pin *** input_pins, int num_input_sets, int * num_input_pins, t_pb_graph_pin *** output_pins, int num_output_sets, int * num_output_pins)
alloc_and_load_interconnect_pins	pack/pb_type_graph.cpp	/^static void alloc_and_load_interconnect_pins(t_interconnect_pins * interc_pins,$/;"	p	file:	signature:(t_interconnect_pins * interc_pins, t_interconnect * interconnect, t_pb_graph_pin *** input_pins, int num_input_sets, int * num_input_pins, t_pb_graph_pin *** output_pins, int num_output_sets, int * num_output_pins)
alloc_and_load_is_clock	pack/pack.cpp	/^static std::unordered_set<AtomNetId> alloc_and_load_is_clock(bool global_clocks);$/;"	p	file:	signature:(bool global_clocks)
alloc_and_load_is_clock	pack/pack.cpp	/^std::unordered_set<AtomNetId> alloc_and_load_is_clock(bool global_clocks) {$/;"	f	signature:(bool global_clocks)
alloc_and_load_lb_type_rr_graph_for_pb_graph_node	pack/lb_type_rr_graph.cpp	/^static void alloc_and_load_lb_type_rr_graph_for_pb_graph_node(const t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(const t_pb_graph_node *pb_graph_node, std::vector<t_lb_type_rr_node> &lb_type_rr_node_graph, const int ext_rr_index)
alloc_and_load_lb_type_rr_graph_for_pb_graph_node	pack/lb_type_rr_graph.cpp	/^static void alloc_and_load_lb_type_rr_graph_for_pb_graph_node(const t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(const t_pb_graph_node *pb_graph_node, std::vector<t_lb_type_rr_node> &lb_type_rr_node_graph, const int ext_rr_index)
alloc_and_load_lb_type_rr_graph_for_type	pack/lb_type_rr_graph.cpp	/^static void alloc_and_load_lb_type_rr_graph_for_type(const t_type_ptr lb_type,$/;"	f	file:	signature:(const t_type_ptr lb_type, std::vector<t_lb_type_rr_node> &lb_type_rr_node_graph)
alloc_and_load_lb_type_rr_graph_for_type	pack/lb_type_rr_graph.cpp	/^static void alloc_and_load_lb_type_rr_graph_for_type(const t_type_ptr lb_type,$/;"	p	file:	signature:(const t_type_ptr lb_type, std::vector<t_lb_type_rr_node> &lb_type_rr_node_graph)
alloc_and_load_mode_interconnect	pack/pb_type_graph.cpp	/^static void alloc_and_load_mode_interconnect($/;"	f	file:	signature:( t_pb_graph_node *pb_graph_parent_node, t_pb_graph_node **pb_graph_children_nodes, const t_mode * mode, bool load_power_structures)
alloc_and_load_mode_interconnect	pack/pb_type_graph.cpp	/^static void alloc_and_load_mode_interconnect($/;"	p	file:	signature:( t_pb_graph_node *pb_graph_parent_node, t_pb_graph_node **pb_graph_children_nodes, const t_mode * mode, bool load_power_structures)
alloc_and_load_mux_graph	power/power_util.cpp	/^static t_mux_node * alloc_and_load_mux_graph(int num_inputs, int levels) {$/;"	f	file:	signature:(int num_inputs, int levels)
alloc_and_load_mux_graph	power/power_util.cpp	/^static t_mux_node * alloc_and_load_mux_graph(int num_inputs, int levels);$/;"	p	file:	signature:(int num_inputs, int levels)
alloc_and_load_mux_graph_recursive	power/power_util.cpp	/^static void alloc_and_load_mux_graph_recursive(t_mux_node * node,$/;"	f	file:	signature:(t_mux_node * node, int num_primary_inputs, int level, int starting_pin_idx)
alloc_and_load_mux_graph_recursive	power/power_util.cpp	/^static void alloc_and_load_mux_graph_recursive(t_mux_node * node,$/;"	p	file:	signature:(t_mux_node * node, int num_primary_inputs, int level, int starting_pin_idx)
alloc_and_load_mux_interc_edges	pack/pb_type_graph.cpp	/^static void alloc_and_load_mux_interc_edges(t_interconnect * interconnect,$/;"	f	file:	signature:(t_interconnect * interconnect, t_pb_graph_pin *** input_pb_graph_node_pin_ptrs, const int num_input_sets, const int *num_input_ptrs, t_pb_graph_pin *** output_pb_graph_node_pin_ptrs, const int num_output_sets, const int *num_output_ptrs)
alloc_and_load_mux_interc_edges	pack/pb_type_graph.cpp	/^static void alloc_and_load_mux_interc_edges(t_interconnect * interconnect,$/;"	p	file:	signature:(t_interconnect * interconnect, t_pb_graph_pin *** input_pb_graph_node_pin_ptrs, const int num_input_sets, const int *num_input_ptrs, t_pb_graph_pin *** output_pb_graph_node_pin_ptrs, const int num_output_sets, const int *num_output_ptrs)
alloc_and_load_net_pin_indices	place/place.cpp	/^static void alloc_and_load_net_pin_indices() {$/;"	f	file:	signature:()
alloc_and_load_net_pin_indices	place/place.cpp	/^static void alloc_and_load_net_pin_indices();$/;"	p	file:	signature:()
alloc_and_load_netlist_clocks_and_ios	timing/read_sdc.cpp	/^static void alloc_and_load_netlist_clocks_and_ios() {$/;"	f	file:	signature:()
alloc_and_load_netlist_clocks_and_ios	timing/read_sdc.cpp	/^static void alloc_and_load_netlist_clocks_and_ios();$/;"	p	file:	signature:()
alloc_and_load_output_file_names	base/echo_files.cpp	/^void alloc_and_load_output_file_names(const std::string default_name) {$/;"	f	signature:(const std::string default_name)
alloc_and_load_output_file_names	base/echo_files.h	/^void alloc_and_load_output_file_names(const std::string default_name);$/;"	p	signature:(const std::string default_name)
alloc_and_load_pack_molecules	pack/prepack.cpp	/^t_pack_molecule *alloc_and_load_pack_molecules($/;"	f	signature:( t_pack_patterns *list_of_pack_patterns, std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode, const int num_packing_patterns)
alloc_and_load_pack_molecules	pack/prepack.h	/^t_pack_molecule *alloc_and_load_pack_molecules($/;"	p	signature:( t_pack_patterns *list_of_pack_patterns, std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode, const int num_packing_patterns)
alloc_and_load_pack_patterns	pack/prepack.cpp	/^t_pack_patterns *alloc_and_load_pack_patterns(int *num_packing_patterns) {$/;"	f	signature:(int *num_packing_patterns)
alloc_and_load_pack_patterns	pack/prepack.h	/^t_pack_patterns *alloc_and_load_pack_patterns(int *num_packing_patterns);$/;"	p	signature:(int *num_packing_patterns)
alloc_and_load_pb_graph	pack/pb_type_graph.cpp	/^static void alloc_and_load_pb_graph(t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(t_pb_graph_node *pb_graph_node, t_pb_graph_node *parent_pb_graph_node, t_pb_type *pb_type, const int index, bool load_power_structures, int& pin_count_in_cluster)
alloc_and_load_pb_graph	pack/pb_type_graph.cpp	/^static void alloc_and_load_pb_graph(t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(t_pb_graph_node *pb_graph_node, t_pb_graph_node *parent_pb_graph_node, t_pb_type *pb_type, const int index, bool load_power_structures, int& pin_count_in_cluster)
alloc_and_load_pb_graph_pin_lookup_from_index	util/vpr_utils.cpp	/^t_pb_graph_pin** alloc_and_load_pb_graph_pin_lookup_from_index(t_type_ptr type) {$/;"	f	signature:(t_type_ptr type)
alloc_and_load_pb_graph_pin_lookup_from_index	util/vpr_utils.h	/^t_pb_graph_pin** alloc_and_load_pb_graph_pin_lookup_from_index(t_type_ptr type);$/;"	p	signature:(t_type_ptr type)
alloc_and_load_pb_route	pack/cluster_router.cpp	/^t_pb_routes alloc_and_load_pb_route(const vector <t_intra_lb_net> *intra_lb_nets, t_pb_graph_node *pb_graph_head) {$/;"	f	signature:(const vector <t_intra_lb_net> *intra_lb_nets, t_pb_graph_node *pb_graph_head)
alloc_and_load_pb_route	pack/cluster_router.h	/^t_pb_routes alloc_and_load_pb_route(const vector <t_intra_lb_net> *intra_lb_nets, t_pb_graph_node *pb_graph_head);$/;"	p	signature:(const vector <t_intra_lb_net> *intra_lb_nets, t_pb_graph_node *pb_graph_head)
alloc_and_load_pb_stats	pack/cluster.cpp	/^static void alloc_and_load_pb_stats(t_pb *pb) {$/;"	f	file:	signature:(t_pb *pb)
alloc_and_load_perturb_ipins	route/rr_graph.cpp	/^static std::vector<std::vector<bool>> alloc_and_load_perturb_ipins($/;"	p	file:	signature:( const int L_num_types, const int num_seg_types, const int *sets_per_seg_type, const std::vector<vtr::Matrix<int>>&Fc_in, const std::vector<vtr::Matrix<int>>&Fc_out, const enum e_directionality directionality)
alloc_and_load_perturb_ipins	route/rr_graph.cpp	/^static std::vector<std::vector<bool>> alloc_and_load_perturb_ipins(const int L_num_types,$/;"	f	file:	signature:(const int L_num_types, const int num_seg_types, const int *sets_per_seg_type, const std::vector<vtr::Matrix<int>>&Fc_in, const std::vector<vtr::Matrix<int>>&Fc_out, const enum e_directionality directionality)
alloc_and_load_perturb_opins	route/rr_graph.cpp	/^static std::vector<bool> alloc_and_load_perturb_opins(const t_type_ptr type, const vtr::Matrix<int>& Fc_out, const int max_chan_width,$/;"	p	file:	signature:(const t_type_ptr type, const vtr::Matrix<int>& Fc_out, const int max_chan_width, const int num_seg_types, const t_segment_inf *segment_inf)
alloc_and_load_perturb_opins	route/rr_graph.cpp	/^static std::vector<bool> alloc_and_load_perturb_opins(const t_type_ptr type, const vtr::Matrix<int>& Fc_out,$/;"	f	file:	signature:(const t_type_ptr type, const vtr::Matrix<int>& Fc_out, const int max_chan_width, const int num_seg_types, const t_segment_inf *segment_inf)
alloc_and_load_pin_id_to_pb_mapping	util/vpr_utils.cpp	/^vtr::vector<ClusterBlockId, t_pb **> alloc_and_load_pin_id_to_pb_mapping() {$/;"	f	signature:()
alloc_and_load_pin_id_to_pb_mapping	util/vpr_utils.h	/^vtr::vector<ClusterBlockId, t_pb **> alloc_and_load_pin_id_to_pb_mapping();$/;"	p	signature:()
alloc_and_load_pin_locations_from_pb_graph	pack/pb_type_graph.cpp	/^static void alloc_and_load_pin_locations_from_pb_graph(t_type_descriptor *type) {$/;"	f	file:	signature:(t_type_descriptor *type)
alloc_and_load_pin_locations_from_pb_graph	pack/pb_type_graph.cpp	/^static void alloc_and_load_pin_locations_from_pb_graph(t_type_descriptor *type);$/;"	p	file:	signature:(t_type_descriptor *type)
alloc_and_load_pin_to_seg_type	route/rr_graph.cpp	/^static vtr::NdMatrix<int, 5> alloc_and_load_pin_to_seg_type($/;"	p	file:	signature:( const e_pin_type pin_type, const int seg_type_tracks, const int Fc, const t_type_ptr Type, const bool perturb_switch_pattern, const e_directionality directionality)
alloc_and_load_pin_to_seg_type	route/rr_graph.cpp	/^static vtr::NdMatrix<int, 5> alloc_and_load_pin_to_seg_type(const e_pin_type pin_type,$/;"	f	file:	signature:(const e_pin_type pin_type, const int num_seg_type_tracks, const int Fc, const t_type_ptr Type, const bool perturb_switch_pattern, const e_directionality directionality)
alloc_and_load_pin_to_track_map	route/rr_graph.cpp	/^static vtr::NdMatrix<std::vector<int>, 4> alloc_and_load_pin_to_track_map(const e_pin_type pin_type,$/;"	f	file:	signature:(const e_pin_type pin_type, const vtr::Matrix<int>& Fc, const t_type_ptr Type, const std::vector<bool>& perturb_switch_pattern, const e_directionality directionality, const int num_seg_types, const int *sets_per_seg_type)
alloc_and_load_pin_to_track_map	route/rr_graph.cpp	/^static vtr::NdMatrix<std::vector<int>, 4> alloc_and_load_pin_to_track_map(const e_pin_type pin_type,$/;"	p	file:	signature:(const e_pin_type pin_type, const vtr::Matrix<int>& Fc, const t_type_ptr Type, const std::vector<bool>& perturb_switch_pattern, const e_directionality directionality, const int num_seg_types, const int *sets_per_seg_type)
alloc_and_load_placement_macros	place/place_macro.cpp	/^int alloc_and_load_placement_macros(t_direct_inf* directs, int num_directs, t_pl_macro ** macros){$/;"	f	signature:(t_direct_inf* directs, int num_directs, t_pl_macro ** macros)
alloc_and_load_placement_macros	place/place_macro.h	/^int alloc_and_load_placement_macros(t_direct_inf* directs, int num_segments, t_pl_macro ** chains);$/;"	p	signature:(t_direct_inf* directs, int num_segments, t_pl_macro ** chains)
alloc_and_load_placement_structs	place/place.cpp	/^static void alloc_and_load_placement_structs($/;"	f	file:	signature:( float place_cost_exp, t_placer_opts placer_opts, t_direct_inf *directs, int num_directs)
alloc_and_load_placement_structs	place/place.cpp	/^static void alloc_and_load_placement_structs($/;"	p	file:	signature:( float place_cost_exp, t_placer_opts placer_opts, t_direct_inf *directs, int num_directs)
alloc_and_load_port_pin_from_blk_pin	util/vpr_utils.cpp	/^static void alloc_and_load_port_pin_from_blk_pin() {$/;"	f	file:	signature:()
alloc_and_load_port_pin_from_blk_pin	util/vpr_utils.cpp	/^static void alloc_and_load_port_pin_from_blk_pin();$/;"	p	file:	signature:()
alloc_and_load_port_pin_ptrs_from_string	pack/pb_type_graph.cpp	/^t_pb_graph_pin *** alloc_and_load_port_pin_ptrs_from_string(const int line_num,$/;"	f	signature:(const int line_num, const t_pb_graph_node *pb_graph_parent_node, t_pb_graph_node **pb_graph_children_nodes, const char * port_string, int ** num_ptrs, int * num_sets, const bool is_input_to_interc, const bool interconnect_error_check)
alloc_and_load_port_pin_ptrs_from_string	pack/pb_type_graph.h	/^t_pb_graph_pin *** alloc_and_load_port_pin_ptrs_from_string(const int line_num,$/;"	p	signature:(const int line_num, const t_pb_graph_node *pb_graph_parent_node, t_pb_graph_node **pb_graph_children_nodes, const char * port_string, int ** num_ptrs, int * num_sets, const bool is_input_to_interc, const bool interconnect_error_check)
alloc_and_load_pre_packing_timing_graph	timing/path_delay.cpp	/^t_slack * alloc_and_load_pre_packing_timing_graph(float inter_cluster_net_delay, t_timing_inf timing_inf,$/;"	f	signature:(float inter_cluster_net_delay, t_timing_inf timing_inf, const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode)
alloc_and_load_pre_packing_timing_graph	timing/path_delay.h	/^t_slack * alloc_and_load_pre_packing_timing_graph(float inter_cluster_net_delay, t_timing_inf timing_inf,$/;"	p	signature:(float inter_cluster_net_delay, t_timing_inf timing_inf, const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode)
alloc_and_load_rc_tree	timing/net_delay.cpp	/^alloc_and_load_rc_tree(ClusterNetId net_id, t_rc_node ** rc_node_free_list_ptr,$/;"	f	file:	signature:(ClusterNetId net_id, t_rc_node ** rc_node_free_list_ptr, t_linked_rc_edge ** rc_edge_free_list_ptr, t_linked_rc_ptr * rr_node_to_rc_node)
alloc_and_load_rc_tree	timing/net_delay.cpp	/^static t_rc_node *alloc_and_load_rc_tree(ClusterNetId net_id,$/;"	p	file:	signature:(ClusterNetId net_id, t_rc_node ** rc_node_free_list_ptr, t_linked_rc_edge ** rc_edge_free_list_ptr, t_linked_rc_ptr * rr_node_to_rc_node)
alloc_and_load_router_data	pack/cluster_router.cpp	/^t_lb_router_data *alloc_and_load_router_data(vector<t_lb_type_rr_node> *lb_type_graph, t_type_ptr type) {$/;"	f	signature:(vector<t_lb_type_rr_node> *lb_type_graph, t_type_ptr type)
alloc_and_load_router_data	pack/cluster_router.h	/^t_lb_router_data *alloc_and_load_router_data(vector<t_lb_type_rr_node> *lb_type_graph, t_type_ptr type);$/;"	p	signature:(vector<t_lb_type_rr_node> *lb_type_graph, t_type_ptr type)
alloc_and_load_rr_graph	route/rr_graph.cpp	/^static void alloc_and_load_rr_graph($/;"	p	file:	signature:( const int num_nodes, std::vector<t_rr_node>& L_rr_node, const int num_seg_types, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const t_track_to_pin_lookup& track_to_pin_lookup, const t_pin_to_track_lookup& opin_to_track_map, const vtr::NdMatrix<std::vector<int>, 3>& switch_block_conn, t_sb_connection_map *sb_conn_map, const DeviceGrid& grid, const int Fs, t_sblock_pattern& sblock_pattern, const std::vector<vtr::Matrix<int>>&Fc_out, vtr::NdMatrix<int, 3>& Fc_xofs, vtr::NdMatrix<int, 3>& Fc_yofs, const t_rr_node_indices& L_rr_node_indices, const int max_chan_width, const t_chan_width& chan_width, const int wire_to_ipin_switch, const int delayless_switch, const enum e_directionality directionality, bool * Fc_clipped, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs, bool is_global_graph)
alloc_and_load_rr_graph	route/rr_graph.cpp	/^static void alloc_and_load_rr_graph(const int num_nodes,$/;"	f	file:	signature:(const int num_nodes, std::vector<t_rr_node>& L_rr_node, const int num_seg_types, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const t_track_to_pin_lookup& track_to_pin_lookup, const t_pin_to_track_lookup& opin_to_track_map, const vtr::NdMatrix<std::vector<int>, 3>& switch_block_conn, t_sb_connection_map *sb_conn_map, const DeviceGrid& grid, const int Fs, t_sblock_pattern& sblock_pattern, const std::vector<vtr::Matrix<int>>&Fc_out, vtr::NdMatrix<int, 3>& Fc_xofs, vtr::NdMatrix<int, 3>& Fc_yofs, const t_rr_node_indices& L_rr_node_indices, const int max_chan_width, const t_chan_width& chan_width, const int wire_to_ipin_switch, const int delayless_switch, const enum e_directionality directionality, bool * Fc_clipped, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs, bool is_global_graph)
alloc_and_load_rr_indexed_data	route/rr_graph_indexed_data.cpp	/^void alloc_and_load_rr_indexed_data(const t_segment_inf * segment_inf,$/;"	f	signature:(const t_segment_inf * segment_inf, const int num_segment, const t_rr_node_indices& L_rr_node_indices, const int nodes_per_chan, int wire_to_ipin_switch, enum e_base_cost_type base_cost_type)
alloc_and_load_rr_indexed_data	route/rr_graph_indexed_data.h	/^void alloc_and_load_rr_indexed_data(const t_segment_inf * segment_inf,$/;"	p	signature:(const t_segment_inf * segment_inf, int num_segment, const t_rr_node_indices& L_rr_node_indices, int nodes_per_chan, int wire_to_ipin_switch, enum e_base_cost_type base_cost_type)
alloc_and_load_rr_node_indices	route/rr_graph2.cpp	/^t_rr_node_indices alloc_and_load_rr_node_indices($/;"	f	signature:( const int max_chan_width, const DeviceGrid& grid, int *index, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y)
alloc_and_load_rr_node_indices	route/rr_graph2.h	/^t_rr_node_indices alloc_and_load_rr_node_indices($/;"	p	signature:( const int max_chan_width, const DeviceGrid& grid, int *index, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y)
alloc_and_load_rr_node_route_structs	route/route_common.cpp	/^void alloc_and_load_rr_node_route_structs() {$/;"	f	signature:()
alloc_and_load_rr_node_route_structs	route/route_common.h	/^void alloc_and_load_rr_node_route_structs();$/;"	p	signature:()
alloc_and_load_rr_switch_inf	route/rr_graph.cpp	/^static int alloc_and_load_rr_switch_inf(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos,$/;"	f	file:	signature:(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos, const int wire_to_arch_ipin_switch, int *wire_to_rr_ipin_switch)
alloc_and_load_rr_switch_inf	route/rr_graph.cpp	/^static int alloc_and_load_rr_switch_inf(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos,$/;"	p	file:	signature:(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos, const int wire_to_arch_ipin_switch, int *wire_to_rr_ipin_switch)
alloc_and_load_seg_details	route/rr_graph2.cpp	/^t_seg_details *alloc_and_load_seg_details($/;"	f	signature:( int *max_chan_width, const int max_len, const int num_seg_types, const t_segment_inf * segment_inf, const bool use_full_seg_groups, const bool is_global_graph, const enum e_directionality directionality, int * num_seg_details)
alloc_and_load_seg_details	route/rr_graph2.h	/^t_seg_details *alloc_and_load_seg_details($/;"	p	signature:( int *max_chan_width, const int max_len, const int num_seg_types, const t_segment_inf *segment_inf, const bool use_full_seg_groups, const bool is_global_graph, const enum e_directionality directionality, int *num_seg_details = nullptr)
alloc_and_load_sharable_switch_trans	route/rr_graph_area.cpp	/^alloc_and_load_sharable_switch_trans(int num_switch,$/;"	f	file:	signature:(int num_switch, float R_minW_nmos, float R_minW_pmos)
alloc_and_load_sharable_switch_trans	route/rr_graph_area.cpp	/^static float *alloc_and_load_sharable_switch_trans(int num_switch,$/;"	p	file:	signature:(int num_switch, float R_minW_nmos, float R_minW_pmos)
alloc_and_load_switch_block_conn	route/rr_graph_sbox.cpp	/^vtr::NdMatrix<std::vector<int>,3> alloc_and_load_switch_block_conn(const size_t nodes_per_chan,$/;"	f	signature:(const size_t nodes_per_chan, const e_switch_block_type switch_block_type, const int Fs)
alloc_and_load_switch_block_conn	route/rr_graph_sbox.h	/^vtr::NdMatrix<std::vector<int>,3> alloc_and_load_switch_block_conn(size_t nodes_per_chan,$/;"	p	signature:(size_t nodes_per_chan, enum e_switch_block_type switch_block_type, int Fs)
alloc_and_load_switchblock_permutations	route/build_switchblocks.cpp	/^t_sb_connection_map * alloc_and_load_switchblock_permutations($/;"	f	signature:( const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const DeviceGrid& grid, vector<t_switchblock_inf> switchblocks, t_chan_width *nodes_per_chan, e_directionality directionality, vtr::RandState& rand_state)
alloc_and_load_switchblock_permutations	route/build_switchblocks.h	/^t_sb_connection_map * alloc_and_load_switchblock_permutations(const t_chan_details& chan_details_x, const t_chan_details& chan_details_y,$/;"	p	signature:(const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const DeviceGrid& grid, std::vector<t_switchblock_inf> switchblocks, t_chan_width *nodes_per_chan, enum e_directionality directionality, vtr::RandState& rand_state)
alloc_and_load_timing_graph	timing/path_delay.cpp	/^t_slack * alloc_and_load_timing_graph(t_timing_inf timing_inf) {$/;"	f	signature:(t_timing_inf timing_inf)
alloc_and_load_timing_graph	timing/path_delay.h	/^t_slack * alloc_and_load_timing_graph(t_timing_inf timing_inf);$/;"	p	signature:(t_timing_inf timing_inf)
alloc_and_load_timing_graph_levels	timing/path_delay2.cpp	/^int alloc_and_load_timing_graph_levels() {$/;"	f	signature:()
alloc_and_load_timing_graph_levels	timing/path_delay2.h	/^int alloc_and_load_timing_graph_levels();$/;"	p	signature:()
alloc_and_load_tnode_fanin_and_check_edges	timing/path_delay2.cpp	/^alloc_and_load_tnode_fanin_and_check_edges(int *num_sinks_ptr) {$/;"	f	file:	signature:(int *num_sinks_ptr)
alloc_and_load_tnode_fanin_and_check_edges	timing/path_delay2.cpp	/^static int *alloc_and_load_tnode_fanin_and_check_edges(int *num_sinks_ptr);$/;"	p	file:	signature:(int *num_sinks_ptr)
alloc_and_load_tnode_lookup_from_pin_id	timing/path_delay.cpp	/^vtr::vector<ClusterBlockId, std::vector<int>> alloc_and_load_tnode_lookup_from_pin_id() {$/;"	f	signature:()
alloc_and_load_tnode_lookup_from_pin_id	timing/path_delay.h	/^vtr::vector<ClusterBlockId, std::vector<int>> alloc_and_load_tnode_lookup_from_pin_id();$/;"	p	signature:()
alloc_and_load_tnodes	timing/path_delay.cpp	/^static void alloc_and_load_tnodes(const t_timing_inf &timing_inf) {$/;"	f	file:	signature:(const t_timing_inf &timing_inf)
alloc_and_load_tnodes	timing/path_delay.cpp	/^static void alloc_and_load_tnodes(const t_timing_inf &timing_inf);$/;"	p	file:	signature:(const t_timing_inf &timing_inf)
alloc_and_load_tnodes_from_prepacked_netlist	timing/path_delay.cpp	/^static void alloc_and_load_tnodes_from_prepacked_netlist(float inter_cluster_net_delay,$/;"	f	file:	signature:(float inter_cluster_net_delay, const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode)
alloc_and_load_tnodes_from_prepacked_netlist	timing/path_delay.cpp	/^static void alloc_and_load_tnodes_from_prepacked_netlist(float inter_cluster_net_delay,$/;"	p	file:	signature:(float inter_cluster_net_delay, const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode)
alloc_and_load_track_to_pin_lookup	route/rr_graph.cpp	/^static vtr::NdMatrix<std::vector<int>, 4> alloc_and_load_track_to_pin_lookup($/;"	f	file:	signature:( vtr::NdMatrix<std::vector<int>, 4> pin_to_track_map, const vtr::Matrix<int>& Fc, const int type_width, const int type_height, const int num_pins, const int max_chan_width, const int num_seg_types)
alloc_and_load_track_to_pin_lookup	route/rr_graph.cpp	/^static vtr::NdMatrix<std::vector<int>, 4> alloc_and_load_track_to_pin_lookup($/;"	p	file:	signature:( vtr::NdMatrix<std::vector<int>, 4> pin_to_track_map, const vtr::Matrix<int>& Fc, const int width, const int height, const int num_pins, const int max_chan_width, const int num_seg_types)
alloc_and_load_try_swap_structs	place/place.cpp	/^static void alloc_and_load_try_swap_structs() {$/;"	f	file:	signature:()
alloc_and_load_try_swap_structs	place/place.cpp	/^static void alloc_and_load_try_swap_structs();$/;"	p	file:	signature:()
alloc_and_load_unsharable_switch_trans	route/rr_graph_area.cpp	/^alloc_and_load_unsharable_switch_trans(int num_switch, float trans_sram_bit,$/;"	f	file:	signature:(int num_switch, float trans_sram_bit, float R_minW_nmos)
alloc_and_load_unsharable_switch_trans	route/rr_graph_area.cpp	/^static float *alloc_and_load_unsharable_switch_trans(int num_switch,$/;"	p	file:	signature:(int num_switch, float trans_sram_bit, float R_minW_nmos)
alloc_budget_memory	route/route_budgets.cpp	/^void route_budgets::alloc_budget_memory() {$/;"	f	class:route_budgets	signature:()
alloc_budget_memory	route/route_budgets.h	/^    void alloc_budget_memory();$/;"	p	class:route_budgets	access:private	signature:()
alloc_cost_map	route/router_lookahead_map.cpp	/^static void alloc_cost_map(int num_segments);$/;"	p	file:	signature:(int num_segments)
alloc_cost_map	route/router_lookahead_map.cpp	/^static void alloc_cost_map(int num_segments){$/;"	f	file:	signature:(int num_segments)
alloc_crit	place/timing_place.cpp	/^static void alloc_crit(vtr::t_chunk *chunk_list_ptr) {$/;"	f	file:	signature:(vtr::t_chunk *chunk_list_ptr)
alloc_crit	place/timing_place.cpp	/^static void alloc_crit(vtr::t_chunk *chunk_list_ptr);$/;"	p	file:	signature:(vtr::t_chunk *chunk_list_ptr)
alloc_draw_structs	draw/draw.cpp	/^void alloc_draw_structs(const t_arch* arch) {$/;"	f	signature:(const t_arch* arch)
alloc_draw_structs	draw/draw.h	/^void alloc_draw_structs(const t_arch* arch);$/;"	p	signature:(const t_arch* arch)
alloc_hash_table	util/hash.cpp	/^alloc_hash_table() {$/;"	f	signature:()
alloc_hash_table	util/hash.h	/^t_hash **alloc_hash_table();$/;"	p	signature:()
alloc_heap_data	route/route_common.cpp	/^alloc_heap_data() {$/;"	f	signature:()
alloc_heap_data	route/route_common.h	/^t_heap *alloc_heap_data();$/;"	p	signature:()
alloc_ivector_and_copy_int_list	../../libs/libvtrutil/src/vtr_matrix.cpp	/^void alloc_ivector_and_copy_int_list(t_linked_int ** list_head_ptr,$/;"	f	namespace:vtr	signature:(t_linked_int ** list_head_ptr, int num_items, std::vector<int> *ivec, t_linked_int ** free_list_head_ptr)
alloc_ivector_and_copy_int_list	../../libs/libvtrutil/src/vtr_matrix.h	/^    void alloc_ivector_and_copy_int_list(t_linked_int ** list_head_ptr,$/;"	p	namespace:vtr	signature:(t_linked_int ** list_head_ptr, int num_items, std::vector<int> *ivec, t_linked_int ** free_list_head_ptr)
alloc_legal_placements	place/place.cpp	/^static void alloc_legal_placements() {$/;"	f	file:	signature:()
alloc_legal_placements	place/place.cpp	/^static void alloc_legal_placements();$/;"	p	file:	signature:()
alloc_linked_rc_edge	timing/net_delay.cpp	/^alloc_linked_rc_edge(t_linked_rc_edge ** rc_edge_free_list_ptr) {$/;"	f	file:	signature:(t_linked_rc_edge ** rc_edge_free_list_ptr)
alloc_linked_rc_edge	timing/net_delay.cpp	/^static t_linked_rc_edge *alloc_linked_rc_edge($/;"	p	file:	signature:( t_linked_rc_edge ** rc_edge_free_list_ptr)
alloc_linked_rt_edge	route/route_tree_timing.cpp	/^alloc_linked_rt_edge() {$/;"	f	file:	signature:()
alloc_linked_rt_edge	route/route_tree_timing.cpp	/^static t_linked_rt_edge *alloc_linked_rt_edge();$/;"	p	file:	signature:()
alloc_lookups_and_criticalities	place/timing_place.cpp	/^std::unique_ptr<PlaceDelayModel> alloc_lookups_and_criticalities(t_chan_width_dist chan_width_dist,$/;"	f	signature:(t_chan_width_dist chan_width_dist, t_placer_opts placer_opts, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, const t_direct_inf *directs, const int num_directs)
alloc_lookups_and_criticalities	place/timing_place.h	/^std::unique_ptr<PlaceDelayModel> alloc_lookups_and_criticalities(t_chan_width_dist chan_width_dist,$/;"	p	signature:(t_chan_width_dist chan_width_dist, t_placer_opts place_opts, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, const t_direct_inf *directs, const int num_directs)
alloc_net_delay	timing/net_delay.cpp	/^vtr::vector<ClusterNetId, float *> alloc_net_delay(vtr::t_chunk *chunk_list_ptr){$/;"	f	signature:(vtr::t_chunk *chunk_list_ptr)
alloc_net_delay	timing/net_delay.h	/^vtr::vector<ClusterNetId, float *> alloc_net_delay(vtr::t_chunk *chunk_list_ptr);$/;"	p	signature:(vtr::t_chunk *chunk_list_ptr)
alloc_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* alloc_node()$/;"	f	struct:xpath_parser	access:public	signature:()
alloc_pb_route	base/read_netlist.cpp	/^static t_pb_routes alloc_pb_route(t_pb_graph_node *pb_graph_node);$/;"	p	file:	signature:(t_pb_graph_node *pb_graph_node)
alloc_pb_route	base/read_netlist.cpp	/^static t_pb_routes alloc_pb_route(t_pb_graph_node* \/*pb_graph_node*\/) {$/;"	f	file:	signature:(t_pb_graph_node* )
alloc_pin_classes_in_pb_graph_node	pack/cluster_feasibility_filter.cpp	/^static void alloc_pin_classes_in_pb_graph_node($/;"	f	file:	signature:( t_pb_graph_node *pb_graph_node)
alloc_pin_classes_in_pb_graph_node	pack/cluster_feasibility_filter.cpp	/^static void alloc_pin_classes_in_pb_graph_node($/;"	p	file:	signature:( t_pb_graph_node *pb_graph_node)
alloc_rc_node	timing/net_delay.cpp	/^alloc_rc_node(t_rc_node ** rc_node_free_list_ptr) {$/;"	f	file:	signature:(t_rc_node ** rc_node_free_list_ptr)
alloc_rc_node	timing/net_delay.cpp	/^static t_rc_node *alloc_rc_node(t_rc_node ** rc_node_free_list_ptr);$/;"	p	file:	signature:(t_rc_node ** rc_node_free_list_ptr)
alloc_route_structs	route/route_export.h	/^t_clb_opins_used alloc_route_structs();$/;"	p	signature:()
alloc_route_tree_timing_structs	route/route_tree_timing.cpp	/^bool alloc_route_tree_timing_structs(bool exists_ok) {$/;"	f	signature:(bool exists_ok)
alloc_route_tree_timing_structs	route/route_tree_timing.h	/^bool alloc_route_tree_timing_structs(bool exists_ok = false);$/;"	p	signature:(bool exists_ok = false)
alloc_routing_structs	route/router_delay_profiling.cpp	/^void alloc_routing_structs($/;"	f	signature:( t_chan_width chan_width, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, const t_direct_inf *directs, const int num_directs)
alloc_routing_structs	route/router_delay_profiling.h	/^void alloc_routing_structs($/;"	p	signature:( t_chan_width chan_width, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, const t_direct_inf *directs, const int num_directs)
alloc_rr_switch_inf	route/rr_graph.cpp	/^static int alloc_rr_switch_inf(t_arch_switch_fanin& arch_switch_fanins) {$/;"	f	file:	signature:(t_arch_switch_fanin& arch_switch_fanins)
alloc_rr_switch_inf	route/rr_graph.cpp	/^static int alloc_rr_switch_inf(t_arch_switch_fanin& switch_fanin);$/;"	p	file:	signature:(t_arch_switch_fanin& switch_fanin)
alloc_rt_node	route/route_tree_timing.cpp	/^alloc_rt_node() {$/;"	f	file:	signature:()
alloc_rt_node	route/route_tree_timing.cpp	/^static t_rt_node *alloc_rt_node();$/;"	p	file:	signature:()
alloc_saved_routing	route/route_common.cpp	/^vtr::vector<ClusterNetId, t_trace *> alloc_saved_routing() {$/;"	f	signature:()
alloc_saved_routing	route/route_export.h	/^vtr::vector<ClusterNetId, t_trace *> alloc_saved_routing();$/;"	p	signature:()
alloc_sblock_pattern_lookup	route/rr_graph2.cpp	/^t_sblock_pattern alloc_sblock_pattern_lookup($/;"	f	signature:( const DeviceGrid& grid, const int max_chan_width)
alloc_sblock_pattern_lookup	route/rr_graph2.h	/^t_sblock_pattern alloc_sblock_pattern_lookup($/;"	p	signature:( const DeviceGrid& grid, const int max_chan_width)
alloc_slacks	timing/path_delay.cpp	/^static t_slack * alloc_slacks() {$/;"	f	file:	signature:()
alloc_slacks	timing/path_delay.cpp	/^static t_slack * alloc_slacks();$/;"	p	file:	signature:()
alloc_state	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator* alloc_state;$/;"	m	struct:xml_parser	file:	access:public
alloc_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* alloc_string(const xpath_lexer_string& value)$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& value)
alloc_timing_driven_route_structs	route/route_timing.cpp	/^void alloc_timing_driven_route_structs(float **pin_criticality_ptr,$/;"	f	signature:(float **pin_criticality_ptr, int **sink_order_ptr, t_rt_node *** rt_node_of_sink_ptr)
alloc_timing_driven_route_structs	route/route_timing.h	/^void alloc_timing_driven_route_structs(float **pin_criticality_ptr,$/;"	p	signature:(float **pin_criticality_ptr, int **sink_order_ptr, t_rt_node *** rt_node_of_sink_ptr)
alloc_timing_stats	timing/path_delay.cpp	/^static void alloc_timing_stats() {$/;"	f	file:	signature:()
alloc_timing_stats	timing/path_delay.cpp	/^static void alloc_timing_stats();$/;"	p	file:	signature:()
alloc_trace_data	route/route_common.cpp	/^alloc_trace_data() {$/;"	f	signature:()
alloc_trace_data	route/route_common.h	/^t_trace* alloc_trace_data();$/;"	p	signature:()
allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static allocation_function allocate;$/;"	m	struct:xml_memory_management_function_storage	file:	access:public
allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate(size_t size)$/;"	f	class:xpath_allocator	access:public	signature:(size_t size)
allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> allocation_function xml_memory_management_function_storage<T>::allocate = default_allocate;$/;"	m	class:xml_memory_management_function_storage	file:
allocate_and_load_critical_path	timing/path_delay.cpp	/^vtr::t_linked_int * allocate_and_load_critical_path(const t_timing_inf &timing_inf) {$/;"	f	signature:(const t_timing_inf &timing_inf)
allocate_and_load_critical_path	timing/path_delay.h	/^vtr::t_linked_int *allocate_and_load_critical_path(const t_timing_inf &timing_inf);$/;"	p	signature:(const t_timing_inf &timing_inf)
allocate_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline xml_attribute_struct* allocate_attribute(xml_allocator& alloc)$/;"	f	signature:(xml_allocator& alloc)
allocate_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_memory(size_t size, xml_memory_page*& out_page)$/;"	f	struct:xml_allocator	access:public	signature:(size_t size, xml_memory_page*& out_page)
allocate_memory_oob	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_memory_oob(size_t size, xml_memory_page*& out_page);$/;"	p	struct:xml_allocator	file:	access:public	signature:(size_t size, xml_memory_page*& out_page)
allocate_memory_oob	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE void* xml_allocator::allocate_memory_oob(size_t size, xml_memory_page*& out_page)$/;"	f	class:xml_allocator	signature:(size_t size, xml_memory_page*& out_page)
allocate_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline xml_node_struct* allocate_node(xml_allocator& alloc, xml_node_type type)$/;"	f	signature:(xml_allocator& alloc, xml_node_type type)
allocate_nothrow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_nothrow(size_t size)$/;"	f	class:xpath_allocator	access:public	signature:(size_t size)
allocate_object	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_object(size_t size, xml_memory_page*& out_page)$/;"	f	struct:xml_allocator	access:public	signature:(size_t size, xml_memory_page*& out_page)
allocate_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* allocate_page(size_t data_size)$/;"	f	struct:xml_allocator	access:public	signature:(size_t data_size)
allocate_slack_using_delays_and_criticalities	route/route_budgets.cpp	/^void route_budgets::allocate_slack_using_delays_and_criticalities(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
allocate_slack_using_delays_and_criticalities	route/route_budgets.h	/^    void allocate_slack_using_delays_and_criticalities(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
allocate_slack_using_weights	route/route_budgets.cpp	/^void route_budgets::allocate_slack_using_weights(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
allocate_slack_using_weights	route/route_budgets.h	/^    void allocate_slack_using_weights(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
allocate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* allocate_string(size_t length)$/;"	f	struct:xml_allocator	access:public	signature:(size_t length)
allocate_xbar	route/cb_metrics.cpp	/^static void allocate_xbar(const int rows, const int cols, const float num, t_xbar_matrix *xbar){$/;"	f	file:	signature:(const int rows, const int cols, const float num, t_xbar_matrix *xbar)
allocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef void* (*allocation_function)(size_t size);$/;"	t	namespace:pugi
allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator* allocator;$/;"	m	struct:xml_memory_page	file:	access:public
allow_insert_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool allow_insert_attribute(xml_node_type parent)$/;"	f	signature:(xml_node_type parent)
allow_insert_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool allow_insert_child(xml_node_type parent, xml_node_type child)$/;"	f	signature:(xml_node_type parent, xml_node_type child)
allow_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool allow_move(xml_node parent, xml_node child)$/;"	f	signature:(xml_node parent, xml_node child)
allow_unrelated_clustering	base/read_options.h	/^    argparse::ArgValue<e_unrelated_clustering> allow_unrelated_clustering;$/;"	m	struct:t_options	access:public
allow_unrelated_clustering	base/vpr_types.h	/^	e_unrelated_clustering allow_unrelated_clustering;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
alpha	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t alpha = 255;$/;"	m	class:t_color	access:public
alpha	base/vpr_types.h	/^	float alpha;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
alpha_clustering	base/read_options.h	/^    argparse::ArgValue<float> alpha_clustering;$/;"	m	struct:t_options	access:public
alpha_t	base/vpr_types.h	/^	float alpha_t;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
analysis_type	route/route_budgets.h	/^enum analysis_type {$/;"	g
analyze_conn_blocks	route/cb_metrics.cpp	/^void analyze_conn_blocks(const int *****opin_cb, const int *****ipin_cb, const t_type_ptr block_type, const int *Fc_array_out,$/;"	f	signature:(const int *****opin_cb, const int *****ipin_cb, const t_type_ptr block_type, const int *Fc_array_out, const int *Fc_array_in, const t_chan_width *chan_width_inf)
analyze_conn_blocks	route/cb_metrics.h	/^void analyze_conn_blocks(const int *****opin_cb, const int *****ipin_cb, const t_type_ptr block_type, const int *Fc_array_out,$/;"	p	signature:(const int *****opin_cb, const int *****ipin_cb, const t_type_ptr block_type, const int *Fc_array_out, const int *Fc_array_in, const t_chan_width *chan_width_inf)
analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::TimingAnalyzer> analyzer() const = 0;$/;"	p	class:TimingInfo	access:public	signature:() const
anchored	timing/slre.cpp	/^  int anchored;   \/\/ Must match from string start$/;"	m	struct:slre	file:	access:public
angnorm	../../libs/libeasygl/src/graphics.cpp	/^angnorm(float ang) {$/;"	f	file:	signature:(float ang)
anneal_sched_type	base/read_options.h	/^    argparse::ArgValue<sched_type> anneal_sched_type;$/;"	m	struct:t_options	access:public
annealer	route/cb_metrics.cpp	/^static bool annealer(const e_metric metric, const int nodes_per_chan, const t_type_ptr block_type,$/;"	f	file:	signature:(const e_metric metric, const int nodes_per_chan, const t_type_ptr block_type, const e_pin_type pin_type, const int Fc, const int num_pin_type_pins, const float target_metric, const float target_metric_tolerance, int *****pin_to_track_connections, Conn_Block_Metrics *cb_metrics)
annealer	route/cb_metrics.cpp	/^static bool annealer(const e_metric metric, const int nodes_per_chan, const t_type_ptr block_type,$/;"	p	file:	signature:(const e_metric metric, const int nodes_per_chan, const t_type_ptr block_type, const e_pin_type pin_type, const int Fc, const int num_pin_type_pins, const float target_metric, const float target_metric_tolerance, int *****pin_to_track_connections, Conn_Block_Metrics *cb_metrics)
annotate_draw_rr_node_costs	draw/draw.h	/^void annotate_draw_rr_node_costs(ClusterNetId net, int sink_rr_node);$/;"	p	signature:(ClusterNetId net, int sink_rr_node)
annotations	../../libs/libarchfpga/src/physical_types.h	/^	t_pin_to_pin_annotation *annotations = nullptr; \/* [0..num_annotations-1] *\/$/;"	m	struct:t_pb_type	access:public
annotations	../../libs/libarchfpga/src/physical_types.h	/^	t_pin_to_pin_annotation *annotations; \/* [0..num_annotations-1] *\/$/;"	m	struct:t_interconnect	access:public
any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer	access:public	signature:(value_type result, uint32_t ch)
any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer	access:public	signature:(value_type result, uint32_t ch)
any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer	access:public	signature:(value_type result, uint32_t ch)
anyof	timing/slre.cpp	/^static void anyof(struct slre *r, const char **re) {$/;"	f	file:	signature:(struct slre *r, const char **re)
append	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void append(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw	access:public	signature:(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)
append	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void append(const xpath_string& o, xpath_allocator* alloc)$/;"	f	class:xpath_string	access:public	signature:(const xpath_string& o, xpath_allocator* alloc)
append_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::append_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
append_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void append_attribute(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f	signature:(xml_attribute_struct* attr, xml_node_struct* node)
append_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute append_attribute(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
append_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_node::append_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_node	signature:(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
append_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result append_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_node	access:public	signature:(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_child(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_child(xml_node_type type_)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_)
append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_child(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_child(xml_node_type type = node_element);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type = node_element)
append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::append_copy(const xml_attribute& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto)
append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_copy(const xml_node& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto)
append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute append_copy(const xml_attribute& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto)
append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_copy(const xml_node& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto)
append_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_move(const xml_node& moved)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved)
append_move	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_move(const xml_node& moved);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved)
append_new_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE xml_attribute_struct* append_new_attribute(xml_node_struct* node, xml_allocator& alloc)$/;"	f	signature:(xml_node_struct* node, xml_allocator& alloc)
append_new_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE xml_node_struct* append_new_node(xml_node_struct* node, xml_allocator& alloc, xml_node_type type = node_element)$/;"	f	signature:(xml_node_struct* node, xml_allocator& alloc, xml_node_type type = node_element)
append_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void append_node(xml_node_struct* child, xml_node_struct* node)$/;"	f	signature:(xml_node_struct* child, xml_node_struct* node)
apply_combinational_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_combinational_default_timing_constraints(const AtomNetlist& netlist,$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& tc)
apply_combinational_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_combinational_default_timing_constraints(const AtomNetlist& netlist,$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& timing_constraints)
apply_create_clock	timing/read_sdc.cpp	/^static bool apply_create_clock(const sdcparse::CreateClock& sdc_create_clock, int lineno) {$/;"	f	file:	signature:(const sdcparse::CreateClock& sdc_create_clock, int lineno)
apply_create_clock	timing/read_sdc.cpp	/^static bool apply_create_clock(const sdcparse::CreateClock& sdc_create_clock, int lineno);$/;"	p	file:	signature:(const sdcparse::CreateClock& sdc_create_clock, int lineno)
apply_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_default_timing_constraints(const AtomNetlist& netlist,$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& tc)
apply_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_default_timing_constraints(const AtomNetlist& netlist,$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& timing_constraints)
apply_multi_clock_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_multi_clock_default_timing_constraints(const AtomNetlist& netlist,$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, const std::set<AtomPinId>& clock_drivers, tatum::TimingConstraints& tc)
apply_multi_clock_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_multi_clock_default_timing_constraints(const AtomNetlist& netlist,$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, const std::set<AtomPinId>& clock_drivers, tatum::TimingConstraints& timing_constraints)
apply_predicate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void apply_predicate(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, bool once)
apply_predicate_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void apply_predicate_boolean(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)
apply_predicate_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void apply_predicate_number(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)
apply_predicate_number_const	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void apply_predicate_number_const(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack)
apply_predicates	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void apply_predicates(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, nodeset_eval_t eval)
apply_rpn_op	../../libs/libarchfpga/src/expr_eval.cpp	/^static int apply_rpn_op( const Formula_Object &arg1, const Formula_Object &arg2,$/;"	f	file:	signature:( const Formula_Object &arg1, const Formula_Object &arg2, const Formula_Object &op )
apply_rpn_op	../../libs/libarchfpga/src/expr_eval.cpp	/^static int apply_rpn_op( const Formula_Object &arg1, const Formula_Object &arg2,$/;"	p	file:	signature:( const Formula_Object &arg1, const Formula_Object &arg2, const Formula_Object &op )
apply_set_clock_groups	timing/read_sdc.cpp	/^static bool apply_set_clock_groups(const sdcparse::SetClockGroups& sdc_set_clock_groups, int lineno) {$/;"	f	file:	signature:(const sdcparse::SetClockGroups& sdc_set_clock_groups, int lineno)
apply_set_clock_groups	timing/read_sdc.cpp	/^static bool apply_set_clock_groups(const sdcparse::SetClockGroups& sdc_set_clock_groups, int lineno);$/;"	p	file:	signature:(const sdcparse::SetClockGroups& sdc_set_clock_groups, int lineno)
apply_set_false_path	timing/read_sdc.cpp	/^static bool apply_set_false_path(const sdcparse::SetFalsePath& sdc_set_false_path) {$/;"	f	file:	signature:(const sdcparse::SetFalsePath& sdc_set_false_path)
apply_set_false_path	timing/read_sdc.cpp	/^static bool apply_set_false_path(const sdcparse::SetFalsePath& sdc_set_false_path);$/;"	p	file:	signature:(const sdcparse::SetFalsePath& sdc_set_false_path)
apply_set_io_delay	timing/read_sdc.cpp	/^static bool apply_set_io_delay(const sdcparse::SetIoDelay& sdc_set_io_delay, int lineno) {$/;"	f	file:	signature:(const sdcparse::SetIoDelay& sdc_set_io_delay, int lineno)
apply_set_io_delay	timing/read_sdc.cpp	/^static bool apply_set_io_delay(const sdcparse::SetIoDelay& sdc_set_io_delay, int lineno);$/;"	p	file:	signature:(const sdcparse::SetIoDelay& sdc_set_io_delay, int lineno)
apply_set_min_max_delay	timing/read_sdc.cpp	/^static bool apply_set_min_max_delay(const sdcparse::SetMinMaxDelay& sdc_set_min_max_delay) {$/;"	f	file:	signature:(const sdcparse::SetMinMaxDelay& sdc_set_min_max_delay)
apply_set_min_max_delay	timing/read_sdc.cpp	/^static bool apply_set_min_max_delay(const sdcparse::SetMinMaxDelay& sdc_set_min_max_delay);$/;"	p	file:	signature:(const sdcparse::SetMinMaxDelay& sdc_set_min_max_delay)
apply_set_multicycle_path	timing/read_sdc.cpp	/^static bool apply_set_multicycle_path(const sdcparse::SetMulticyclePath& sdc_set_multicycle_path) {$/;"	f	file:	signature:(const sdcparse::SetMulticyclePath& sdc_set_multicycle_path)
apply_set_multicycle_path	timing/read_sdc.cpp	/^static bool apply_set_multicycle_path(const sdcparse::SetMulticyclePath& sdc_set_multicycle_path);$/;"	p	file:	signature:(const sdcparse::SetMulticyclePath& sdc_set_multicycle_path)
apply_single_clock_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_single_clock_default_timing_constraints(const AtomNetlist& netlist,$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, const AtomPinId clock_driver, tatum::TimingConstraints& tc)
apply_single_clock_default_timing_constraints	timing/read_sdc2.cpp	/^void apply_single_clock_default_timing_constraints(const AtomNetlist& netlist,$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, const AtomPinId clock_driver, tatum::TimingConstraints& timing_constraints)
arch	base/vpr_context.h	/^    t_arch arch;$/;"	m	struct:DeviceContext	access:public
arch	base/vpr_context.h	/^    t_power_arch* arch;$/;"	m	struct:PowerContext	access:public
arch_file_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static const char* arch_file_name = nullptr;$/;"	v	file:
arch_info	draw/draw_types.h	/^    const t_arch* arch_info = nullptr;$/;"	m	struct:t_draw_state	access:public
arch_opin_switch	../../libs/libarchfpga/src/physical_types.h	/^	short arch_opin_switch;$/;"	m	struct:t_segment_inf	access:public
arch_opin_switch	base/vpr_types.h	/^	short arch_opin_switch = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
arch_opin_switch	base/vpr_types.h	/^        short arch_opin_switch() const { return seg_detail_->arch_opin_switch; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
arch_switch_inf	base/vpr_context.h	/^    t_arch_switch_inf *arch_switch_inf; \/* [0..(num_arch_switches-1)] *\/$/;"	m	struct:DeviceContext	access:public
arch_wire_switch	../../libs/libarchfpga/src/physical_types.h	/^	short arch_wire_switch;$/;"	m	struct:t_segment_inf	access:public
arch_wire_switch	base/vpr_types.h	/^	short arch_wire_switch = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
arch_wire_switch	base/vpr_types.h	/^        short arch_wire_switch() const { return seg_detail_->arch_wire_switch; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
archfpga_throw	../../libs/libarchfpga/src/arch_error.cpp	/^void archfpga_throw(const char* filename, int line, const char* fmt, ...) {$/;"	f	signature:(const char* filename, int line, const char* fmt, ...)
archfpga_throw	../../libs/libarchfpga/src/arch_error.h	/^void archfpga_throw(const char* filename, int line, const char* fmt, ...);$/;"	p	signature:(const char* filename, int line, const char* fmt, ...)
architecture_id	../../libs/libarchfpga/src/physical_types.h	/^    char* architecture_id; \/\/Secure hash digest of the architecture file to uniquely identify this architecture$/;"	m	struct:t_arch	access:public
are_contiguous	base/netlist_utils.h	/^bool are_contiguous(vtr::vector_map<T, T>& values) {$/;"	f	signature:(vtr::vector_map<T, T>& values)
area	../../libs/libarchfpga/src/physical_types.h	/^	float area = 0;$/;"	m	struct:t_type_descriptor	access:public
area	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::area() const {$/;"	f	class:t_bound_box	signature:() const
area	../../libs/libeasygl/src/graphics_types.h	/^    float area() const;$/;"	p	class:t_bound_box	access:public	signature:() const
arithmean	../../libs/libvtrutil/src/vtr_math.h	/^    double arithmean(Container c) {$/;"	f	namespace:vtr	signature:(Container c)
arithmean	../../libs/libvtrutil/src/vtr_math.h	/^    double arithmean(InputIterator first, InputIterator last, double init=0.) {$/;"	f	namespace:vtr	signature:(InputIterator first, InputIterator last, double init=0.)
as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::as_bool(bool def) const$/;"	f	class:pugi::xml_attribute	signature:(bool def) const
as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::as_bool(bool def) const$/;"	f	class:pugi::xml_text	signature:(bool def) const
as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool as_bool(bool def = false) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(bool def = false) const
as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool as_bool(bool def = false) const;$/;"	p	class:pugi::xml_text	access:public	signature:(bool def = false) const
as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xml_attribute::as_double(double def) const$/;"	f	class:pugi::xml_attribute	signature:(double def) const
as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xml_text::as_double(double def) const$/;"	f	class:pugi::xml_text	signature:(double def) const
as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double as_double(double def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(double def = 0) const
as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double as_double(double def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(double def = 0) const
as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN float xml_attribute::as_float(float def) const$/;"	f	class:pugi::xml_attribute	signature:(float def) const
as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN float xml_text::as_float(float def) const$/;"	f	class:pugi::xml_text	signature:(float def) const
as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		float as_float(float def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(float def = 0) const
as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		float as_float(float def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(float def = 0) const
as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int xml_attribute::as_int(int def) const$/;"	f	class:pugi::xml_attribute	signature:(int def) const
as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int xml_text::as_int(int def) const$/;"	f	class:pugi::xml_text	signature:(int def) const
as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int as_int(int def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(int def = 0) const
as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int as_int(int def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(int def = 0) const
as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN long long xml_attribute::as_llong(long long def) const$/;"	f	class:pugi::xml_attribute	signature:(long long def) const
as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN long long xml_text::as_llong(long long def) const$/;"	f	class:pugi::xml_text	signature:(long long def) const
as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		long long as_llong(long long def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(long long def = 0) const
as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		long long as_llong(long long def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(long long def = 0) const
as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_attribute::as_string(const char_t* def) const$/;"	f	class:pugi::xml_attribute	signature:(const char_t* def) const
as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_text::as_string(const char_t* def) const$/;"	f	class:pugi::xml_text	signature:(const char_t* def) const
as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* def = PUGIXML_TEXT(Ó)) const
as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;$/;"	p	class:pugi::xml_text	access:public	signature:(const char_t* def = PUGIXML_TEXT(Ó)) const
as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned int xml_attribute::as_uint(unsigned int def) const$/;"	f	class:pugi::xml_attribute	signature:(unsigned int def) const
as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned int xml_text::as_uint(unsigned int def) const$/;"	f	class:pugi::xml_text	signature:(unsigned int def) const
as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned int as_uint(unsigned int def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned int def = 0) const
as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned int as_uint(unsigned int def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned int def = 0) const
as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned long long xml_attribute::as_ullong(unsigned long long def) const$/;"	f	class:pugi::xml_attribute	signature:(unsigned long long def) const
as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned long long xml_text::as_ullong(unsigned long long def) const$/;"	f	class:pugi::xml_text	signature:(unsigned long long def) const
as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned long long as_ullong(unsigned long long def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned long long def = 0) const
as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned long long as_ullong(unsigned long long def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned long long def = 0) const
as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t>& str)$/;"	f	namespace:pugi	signature:(const std::basic_string<wchar_t>& str)
as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const wchar_t* str)$/;"	f	namespace:pugi	signature:(const wchar_t* str)
as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str);$/;"	p	namespace:pugi	signature:(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str)
as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const wchar_t* str);$/;"	p	namespace:pugi	signature:(const wchar_t* str)
as_utf8_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t as_utf8_begin(const wchar_t* str, size_t length)$/;"	f	signature:(const wchar_t* str, size_t length)
as_utf8_end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void as_utf8_end(char* buffer, size_t size, const wchar_t* str, size_t length)$/;"	f	signature:(char* buffer, size_t size, const wchar_t* str, size_t length)
as_utf8_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::string as_utf8_impl(const wchar_t* str, size_t length)$/;"	f	signature:(const wchar_t* str, size_t length)
as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const char* str)$/;"	f	namespace:pugi	signature:(const char* str)
as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const std::string& str)$/;"	f	namespace:pugi	signature:(const std::string& str)
as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const char* str);$/;"	p	namespace:pugi	signature:(const char* str)
as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str);$/;"	p	namespace:pugi	signature:(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str)
as_wide_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::basic_string<wchar_t> as_wide_impl(const char* str, size_t size)$/;"	f	signature:(const char* str, size_t size)
aspect_ratio	../../libs/libarchfpga/src/physical_types.h	/^    float aspect_ratio = 1.;                    \/\/Aspect ratio for auto-sized devices (only valid for$/;"	m	struct:t_grid_def	access:public
assert	../../libs/libvtrutil/src/vtr_assert.cpp	/^namespace vtr { namespace assert {$/;"	n	namespace:vtr	file:
assert	../../libs/libvtrutil/src/vtr_assert.h	/^namespace vtr { namespace assert {$/;"	n	namespace:vtr
assert_Werr	../../libs/librtlnumber/src/include/rtl_utils.hpp	/^#define assert_Werr(/;"	d
assess_swap	place/place.cpp	/^static e_swap_result assess_swap(float delta_c, float t) {$/;"	f	file:	signature:(float delta_c, float t)
assess_swap	place/place.cpp	/^static e_swap_result assess_swap(float delta_c, float t);$/;"	p	file:	signature:(float delta_c, float t)
assignments_	base/netlist_writer.cpp	/^        std::vector<Assignment> assignments_; \/\/Set of assignments (i.e. net-to-net connections)$/;"	m	class:NetlistWriterVisitor	file:	access:private
associate_pin_with_block	base/netlist.h	/^        void associate_pin_with_block(const PinId pin_id, const PortType type, const BlockId blk_id);$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id, const PortType type, const BlockId blk_id)
associate_pin_with_block	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::associate_pin_with_block(const PinId pin_id, const PortType type, const BlockId blk_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const PortType type, const BlockId blk_id)
associate_pin_with_net	base/netlist.h	/^        int associate_pin_with_net(const PinId pin_id, const PinType type, const NetId net_id);$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id, const PinType type, const NetId net_id)
associate_pin_with_net	base/netlist.tpp	/^int Netlist<BlockId, PortId, PinId, NetId>::associate_pin_with_net(const PinId pin_id, const PinType type, const NetId net_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const PinType type, const NetId net_id)
associate_pin_with_port	base/netlist.h	/^        void associate_pin_with_port(const PinId pin_id, const PortId port_id);$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id, const PortId port_id)
associate_pin_with_port	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::associate_pin_with_port(const PinId pin_id, const PortId port_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const PortId port_id)
associate_port_with_block	base/netlist.h	/^        void associate_port_with_block(const PortId port_id, const PortType type, const BlockId blk_id);$/;"	p	class:Netlist	access:protected	signature:(const PortId port_id, const PortType type, const BlockId blk_id)
associate_port_with_block	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::associate_port_with_block(const PortId port_id, const PortType type, const BlockId blk_id) {$/;"	f	class:Netlist	signature:(const PortId port_id, const PortType type, const BlockId blk_id)
associated_clock_pin	../../libs/libarchfpga/src/physical_types.h	/^    t_pb_graph_pin* associated_clock_pin = nullptr; \/* For sequentail elements, the associated clock *\/$/;"	m	struct:t_pb_graph_pin	access:public
ast_filter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_filter,						\/\/ select * from left where right$/;"	e	enum:ast_type_t	file:
ast_func_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_boolean,				\/\/ boolean(left)$/;"	e	enum:ast_type_t	file:
ast_func_ceiling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_ceiling,				\/\/ ceiling(left)$/;"	e	enum:ast_type_t	file:
ast_func_concat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_concat,				\/\/ concat(left, right, siblings)$/;"	e	enum:ast_type_t	file:
ast_func_contains	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_contains,				\/\/ contains(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_count	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_count,					\/\/ count(left)$/;"	e	enum:ast_type_t	file:
ast_func_false	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_false,					\/\/ false()$/;"	e	enum:ast_type_t	file:
ast_func_floor	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_floor,					\/\/ floor(left)$/;"	e	enum:ast_type_t	file:
ast_func_id	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_id,					\/\/ id(left)$/;"	e	enum:ast_type_t	file:
ast_func_lang	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_lang,					\/\/ lang(left)$/;"	e	enum:ast_type_t	file:
ast_func_last	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_last,					\/\/ last()$/;"	e	enum:ast_type_t	file:
ast_func_local_name_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_local_name_0,			\/\/ local-name()$/;"	e	enum:ast_type_t	file:
ast_func_local_name_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_local_name_1,			\/\/ local-name(left)$/;"	e	enum:ast_type_t	file:
ast_func_name_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_name_0,				\/\/ name()$/;"	e	enum:ast_type_t	file:
ast_func_name_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_name_1,				\/\/ name(left)$/;"	e	enum:ast_type_t	file:
ast_func_namespace_uri_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_namespace_uri_0,		\/\/ namespace-uri()$/;"	e	enum:ast_type_t	file:
ast_func_namespace_uri_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_namespace_uri_1,		\/\/ namespace-uri(left)$/;"	e	enum:ast_type_t	file:
ast_func_normalize_space_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_normalize_space_0,		\/\/ normalize-space()$/;"	e	enum:ast_type_t	file:
ast_func_normalize_space_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_normalize_space_1,		\/\/ normalize-space(left)$/;"	e	enum:ast_type_t	file:
ast_func_not	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_not,					\/\/ not(left)$/;"	e	enum:ast_type_t	file:
ast_func_number_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_number_0,				\/\/ number()$/;"	e	enum:ast_type_t	file:
ast_func_number_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_number_1,				\/\/ number(left)$/;"	e	enum:ast_type_t	file:
ast_func_position	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_position,				\/\/ position()$/;"	e	enum:ast_type_t	file:
ast_func_round	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_round,					\/\/ round(left)$/;"	e	enum:ast_type_t	file:
ast_func_starts_with	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_starts_with,			\/\/ starts_with(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_string_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_string_0,				\/\/ string()$/;"	e	enum:ast_type_t	file:
ast_func_string_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_string_1,				\/\/ string(left)$/;"	e	enum:ast_type_t	file:
ast_func_string_length_0	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_string_length_0,		\/\/ string-length()$/;"	e	enum:ast_type_t	file:
ast_func_string_length_1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_string_length_1,		\/\/ string-length(left)$/;"	e	enum:ast_type_t	file:
ast_func_substring_2	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_substring_2,			\/\/ substring(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_substring_3	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_substring_3,			\/\/ substring(left, right, third)$/;"	e	enum:ast_type_t	file:
ast_func_substring_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_substring_after,		\/\/ substring-after(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_substring_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_substring_before,		\/\/ substring-before(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_sum	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_sum,					\/\/ sum(left)$/;"	e	enum:ast_type_t	file:
ast_func_translate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_translate,				\/\/ translate(left, right, third)$/;"	e	enum:ast_type_t	file:
ast_func_true	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_func_true,					\/\/ true()$/;"	e	enum:ast_type_t	file:
ast_number_constant	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_number_constant,			\/\/ number constant$/;"	e	enum:ast_type_t	file:
ast_op_add	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_add,						\/\/ left + right$/;"	e	enum:ast_type_t	file:
ast_op_and	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_and,						\/\/ left and right$/;"	e	enum:ast_type_t	file:
ast_op_divide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_divide,					\/\/ left \/ right$/;"	e	enum:ast_type_t	file:
ast_op_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_equal,					\/\/ left = right$/;"	e	enum:ast_type_t	file:
ast_op_greater	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_greater,					\/\/ left > right$/;"	e	enum:ast_type_t	file:
ast_op_greater_or_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_greater_or_equal,		\/\/ left >= right$/;"	e	enum:ast_type_t	file:
ast_op_less	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_less,					\/\/ left < right$/;"	e	enum:ast_type_t	file:
ast_op_less_or_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_less_or_equal,			\/\/ left <= right$/;"	e	enum:ast_type_t	file:
ast_op_mod	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_mod,						\/\/ left % right$/;"	e	enum:ast_type_t	file:
ast_op_multiply	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_multiply,				\/\/ left * right$/;"	e	enum:ast_type_t	file:
ast_op_negate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_negate,					\/\/ left - right$/;"	e	enum:ast_type_t	file:
ast_op_not_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_not_equal,				\/\/ left != right$/;"	e	enum:ast_type_t	file:
ast_op_or	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_or,						\/\/ left or right$/;"	e	enum:ast_type_t	file:
ast_op_subtract	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_subtract,				\/\/ left - right$/;"	e	enum:ast_type_t	file:
ast_op_union	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_op_union,					\/\/ left | right$/;"	e	enum:ast_type_t	file:
ast_opt_compare_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_opt_compare_attribute		\/\/ @name = 'string'$/;"	e	enum:ast_type_t	file:
ast_opt_translate_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_opt_translate_table,		\/\/ translate(left, right, third) where right\/third are constants$/;"	e	enum:ast_type_t	file:
ast_predicate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_predicate,					\/\/ apply predicate to set; next points to next predicate$/;"	e	enum:ast_type_t	file:
ast_step	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_step,						\/\/ process set left with step$/;"	e	enum:ast_type_t	file:
ast_step_root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_step_root,					\/\/ select root node$/;"	e	enum:ast_type_t	file:
ast_string_constant	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_string_constant,			\/\/ string constant$/;"	e	enum:ast_type_t	file:
ast_type_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum ast_type_t$/;"	g	file:
ast_unknown	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_unknown,$/;"	e	enum:ast_type_t	file:
ast_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ast_variable,					\/\/ variable$/;"	e	enum:ast_type_t	file:
astar_fac	base/read_options.h	/^    argparse::ArgValue<float> astar_fac;$/;"	m	struct:t_options	access:public
astar_fac	base/vpr_types.h	/^	float astar_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
astar_fac	route/route_timing.h	/^    float astar_fac = 1.2;$/;"	m	struct:t_conn_cost_params	access:public
asttype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			ast_type_t asttype;$/;"	m	struct:xpath_parser::binary_op_t	file:	access:public
at	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const mapped_type& at(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
at	../../libs/libvtrutil/src/vtr_flat_map.h	/^        mapped_type& at(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
at	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const mapped_type& at(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
at	../../libs/libvtrutil/src/vtr_linear_map.h	/^        mapped_type& at(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
at	../../libs/libvtrutil/src/vtr_vector.h	/^        const_reference at(const key_type id) const {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id) const
at	../../libs/libvtrutil/src/vtr_vector.h	/^        reference at(const key_type id) {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id)
atoT	../../libs/libvtrutil/src/vtr_util.cpp	/^T atoT(const std::string& value, const std::string& type_name) {$/;"	f	namespace:vtr	signature:(const std::string& value, const std::string& type_name)
atod	../../libs/libvtrutil/src/vtr_util.cpp	/^double atod(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
atod	../../libs/libvtrutil/src/vtr_util.h	/^    double atod(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
atof	../../libs/libvtrutil/src/vtr_util.cpp	/^float atof(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
atof	../../libs/libvtrutil/src/vtr_util.h	/^    float atof(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
atoi	../../libs/libvtrutil/src/vtr_util.cpp	/^int atoi(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
atoi	../../libs/libvtrutil/src/vtr_util.h	/^    int atoi(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
atom	base/vpr_context.h	/^        const AtomContext& atom() const { return atom_; }$/;"	f	class:VprContext	access:public	signature:() const
atom_	base/vpr_context.h	/^        AtomContext atom_;$/;"	m	class:VprContext	access:private
atom_block_ids	base/vpr_types.h	/^    std::vector<AtomBlockId> atom_block_ids; \/* [0..num_blocks-1] IDs of atom blocks that implements this molecule,$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
atom_clb	base/atom_lookup.cpp	/^ClusterBlockId AtomLookup::atom_clb(const AtomBlockId blk_id) const {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id) const
atom_clb	base/atom_lookup.h	/^        ClusterBlockId atom_clb(const AtomBlockId blk_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id) const
atom_clock_to_q_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_clock_to_q_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
atom_clock_to_q_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_clock_to_q_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
atom_clock_to_q_delay	timing/atom_delay_calc.h	/^        float atom_clock_to_q_delay(const AtomPinId clk_pin, const AtomPinId output_pin, const DelayType delay_type) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId clk_pin, const AtomPinId output_pin, const DelayType delay_type) const
atom_clock_to_q_delay	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_clock_to_q_delay(const AtomPinId \/*clock_pin*\/, const AtomPinId pin, const DelayType delay_type) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId , const AtomPinId pin, const DelayType delay_type) const
atom_combinational_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_combinational_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
atom_combinational_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_combinational_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
atom_combinational_delay	timing/atom_delay_calc.h	/^        float atom_combinational_delay(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const
atom_combinational_delay	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_combinational_delay(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId src_pin, const AtomPinId sink_pin, const DelayType delay_type) const
atom_delay_calc_	timing/PostClusterDelayCalculator.h	/^    AtomDelayCalc atom_delay_calc_;$/;"	m	class:PostClusterDelayCalculator	access:private
atom_hold_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
atom_hold_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
atom_hold_time	timing/atom_delay_calc.h	/^        float atom_hold_time(const AtomPinId clk_pin, const AtomPinId input_pin) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId clk_pin, const AtomPinId input_pin) const
atom_hold_time	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_hold_time(const AtomPinId \/*clock_pin*\/, const AtomPinId pin) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId , const AtomPinId pin) const
atom_net	base/atom_lookup.cpp	/^AtomNetId AtomLookup::atom_net(const ClusterNetId clb_net_index) const {$/;"	f	class:AtomLookup	signature:(const ClusterNetId clb_net_index) const
atom_net	base/atom_lookup.h	/^        AtomNetId atom_net(const ClusterNetId clb_net_index) const;$/;"	p	class:AtomLookup	access:public	signature:(const ClusterNetId clb_net_index) const
atom_net_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_net_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
atom_net_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_net_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
atom_net_id	base/vpr_types.h	/^    AtomNetId atom_net_id; \/* which net in the atom netlist uses this pin *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
atom_net_id	pack/pack_types.h	/^    AtomNetId atom_net_id;              \/* index of atom net this intra_lb_net represents *\/$/;"	m	struct:t_intra_lb_net	access:public
atom_net_power	base/vpr_context.h	/^    std::unordered_map<AtomNetId,t_net_power> atom_net_power;$/;"	m	struct:PowerContext	access:public
atom_net_to_clb_net_	base/atom_lookup.h	/^        vtr::bimap<AtomNetId,ClusterNetId, vtr::linear_map, vtr::linear_map> atom_net_to_clb_net_;$/;"	m	class:AtomLookup	access:private
atom_pb	base/atom_lookup.cpp	/^const t_pb* AtomLookup::atom_pb(const AtomBlockId blk_id) const {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id) const
atom_pb	base/atom_lookup.h	/^        const t_pb* atom_pb(const AtomBlockId blk_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id) const
atom_pb_graph_node	base/atom_lookup.cpp	/^const t_pb_graph_node* AtomLookup::atom_pb_graph_node(const AtomBlockId blk_id) const {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id) const
atom_pb_graph_node	base/atom_lookup.h	/^        const t_pb_graph_node* atom_pb_graph_node(const AtomBlockId blk_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id) const
atom_pin_arch_name	base/atom_netlist_utils.cpp	/^std::string atom_pin_arch_name(const AtomNetlist& netlist, const AtomPinId pin) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomPinId pin)
atom_pin_arch_name	base/atom_netlist_utils.h	/^std::string atom_pin_arch_name(const AtomNetlist& netlist, const AtomPinId pin);$/;"	p	signature:(const AtomNetlist& netlist, const AtomPinId pin)
atom_pin_bit_index	base/vpr_types.h	/^    BitIndex atom_pin_bit_index(const t_pb_graph_pin* gpin) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const t_pb_graph_pin* gpin) const
atom_pin_classic_tnode	base/atom_lookup.cpp	/^int AtomLookup::atom_pin_classic_tnode(const AtomPinId pin_id) const {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin_id) const
atom_pin_classic_tnode	base/atom_lookup.h	/^        int atom_pin_classic_tnode(const AtomPinId pin_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin_id) const
atom_pin_draw_coord	draw/draw.cpp	/^t_point atom_pin_draw_coord(AtomPinId pin) {$/;"	f	signature:(AtomPinId pin)
atom_pin_draw_coord	draw/draw.h	/^t_point atom_pin_draw_coord(AtomPinId pin);$/;"	p	signature:(AtomPinId pin)
atom_pin_iterator	base/clustered_netlist_utils.h	/^        typedef std::vector<AtomPinId>::const_iterator      atom_pin_iterator;$/;"	t	class:ClusteredPinAtomPinsLookup	access:public
atom_pin_pb_graph_pin	base/atom_lookup.cpp	/^const t_pb_graph_pin* AtomLookup::atom_pin_pb_graph_pin(AtomPinId atom_pin) const {$/;"	f	class:AtomLookup	signature:(AtomPinId atom_pin) const
atom_pin_pb_graph_pin	base/atom_lookup.h	/^        const t_pb_graph_pin* atom_pin_pb_graph_pin(AtomPinId atom_pin) const;$/;"	p	class:AtomLookup	access:public	signature:(AtomPinId atom_pin) const
atom_pin_range	base/clustered_netlist_utils.h	/^        typedef typename vtr::Range<atom_pin_iterator>   atom_pin_range;$/;"	t	class:ClusteredPinAtomPinsLookup	access:public
atom_pin_tnode	base/atom_lookup.cpp	/^tatum::NodeId AtomLookup::atom_pin_tnode(const AtomPinId pin, BlockTnode block_tnode_type) const {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin, BlockTnode block_tnode_type) const
atom_pin_tnode	base/atom_lookup.h	/^        tatum::NodeId atom_pin_tnode(const AtomPinId pin, BlockTnode block_tnode_type=BlockTnode::EXTERNAL) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin, BlockTnode block_tnode_type=BlockTnode::EXTERNAL) const
atom_pin_tnode_external_	base/atom_lookup.h	/^        vtr::linear_map<AtomPinId,tatum::NodeId> atom_pin_tnode_external_;$/;"	m	class:AtomLookup	access:private
atom_pin_tnode_internal_	base/atom_lookup.h	/^        vtr::linear_map<AtomPinId,tatum::NodeId> atom_pin_tnode_internal_;$/;"	m	class:AtomLookup	access:private
atom_pin_to_classic_tnode_	base/atom_lookup.h	/^        vtr::bimap<AtomPinId,int,vtr::linear_map,linear_map_classic_tnode> atom_pin_to_classic_tnode_;$/;"	m	class:AtomLookup	access:private
atom_pin_to_pb_graph_pin_	base/atom_lookup.h	/^        vtr::vector_map<AtomPinId,const t_pb_graph_pin*> atom_pin_to_pb_graph_pin_;$/;"	m	class:AtomLookup	access:private
atom_pins	pack/pack_types.h	/^    std::vector<AtomPinId> atom_pins;	\/* AtomPin's associated with each terminal *\/$/;"	m	struct:t_intra_lb_net	access:public
atom_setup_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time atom_setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
atom_setup_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::atom_setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
atom_setup_time	timing/atom_delay_calc.h	/^        float atom_setup_time(const AtomPinId clk_pin, const AtomPinId input_pin) const;$/;"	p	class:AtomDelayCalc	access:public	signature:(const AtomPinId clk_pin, const AtomPinId input_pin) const
atom_setup_time	timing/atom_delay_calc.inl	/^inline float AtomDelayCalc::atom_setup_time(const AtomPinId \/*clock_pin*\/, const AtomPinId pin) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId , const AtomPinId pin) const
atom_to_clb_	base/atom_lookup.h	/^        vtr::vector_map<AtomBlockId,ClusterBlockId> atom_to_clb_;$/;"	m	class:AtomLookup	access:private
atom_to_pb_	base/atom_lookup.h	/^        vtr::bimap<AtomBlockId,const t_pb*, vtr::linear_map, std::unordered_map> atom_to_pb_;$/;"	m	class:AtomLookup	access:private
atoms_added	pack/pack_types.h	/^    std::map<AtomBlockId, bool> *atoms_added;		\/* map that records which atoms are added to cluster router *\/$/;"	m	struct:t_lb_router_data	access:public
atou	../../libs/libvtrutil/src/vtr_util.cpp	/^unsigned atou(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
atou	../../libs/libvtrutil/src/vtr_util.h	/^    unsigned atou(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
attr_iterator	base/netlist.h	/^        typedef typename std::unordered_map<std::string, std::string>::const_iterator   attr_iterator;$/;"	t	class:Netlist	access:public
attr_range	base/netlist.h	/^        typedef typename vtr::Range<attr_iterator>  attr_range;$/;"	t	class:Netlist	access:public
attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_, xml_attribute& hint_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, xml_attribute& hint_) const
attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xpath_node::attribute() const$/;"	f	class:pugi::xpath_node	signature:() const
attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute attribute() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute attribute(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute attribute(const char_t* name, xml_attribute& hint) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, xml_attribute& hint) const
attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute_iterator attribute_iterator;$/;"	t	class:pugi::xml_node	access:public
attribute_to_bool	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static bool attribute_to_bool(const pugi::xml_node node,$/;"	f	file:	signature:(const pugi::xml_node node, const pugi::xml_attribute attr, const pugiutil::loc_data& loc_data)
attribute_to_bool	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static bool attribute_to_bool(const pugi::xml_node node,$/;"	p	file:	signature:(const pugi::xml_node node, const pugi::xml_attribute attr, const pugiutil::loc_data& loc_data)
attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_object_range<xml_attribute_iterator> xml_node::attributes() const$/;"	f	class:pugi::xml_node	signature:() const
attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range<xml_attribute_iterator> attributes() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
attributes	../../libs/libeasygl/src/graphics_state.h	/^    XWindowAttributes attributes;$/;"	m	class:t_x11_state	access:public
attributes_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::attribute_iterator xml_node::attributes_begin() const$/;"	f	class:pugi::xml_node	signature:() const
attributes_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		attribute_iterator attributes_begin() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
attributes_end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::attribute_iterator xml_node::attributes_end() const$/;"	f	class:pugi::xml_node	signature:() const
attributes_end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		attribute_iterator attributes_end() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
auto_compute_inter_cluster_net_delay	base/vpr_types.h	/^	bool auto_compute_inter_cluster_net_delay;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
auto_deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		auto_deleter(T* data_, D deleter_): data(data_), deleter(deleter_)$/;"	f	struct:auto_deleter	access:public	signature:(T* data_, D deleter_)
auto_deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T, typename D = void(*)(T*)> struct auto_deleter$/;"	s	file:
auto_deleter::auto_deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		auto_deleter(T* data_, D deleter_): data(data_), deleter(deleter_)$/;"	f	struct:auto_deleter	access:public	signature:(T* data_, D deleter_)
auto_deleter::data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* data;$/;"	m	struct:auto_deleter	file:	access:public
auto_deleter::deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		D deleter;$/;"	m	struct:auto_deleter	file:	access:public
auto_deleter::release	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* release()$/;"	f	struct:auto_deleter	access:public	signature:()
auto_deleter::~auto_deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~auto_deleter()$/;"	f	struct:auto_deleter	access:public	signature:()
auto_size_device_grid	base/SetupGrid.cpp	/^static DeviceGrid auto_size_device_grid(std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float maximum_device_utilization) {$/;"	f	file:	signature:(std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float maximum_device_utilization)
auto_size_device_grid	base/SetupGrid.cpp	/^static DeviceGrid auto_size_device_grid(std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float maximum_device_utilization);$/;"	p	file:	signature:(std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float maximum_device_utilization)
autosize_buffer	../../libs/libarchfpga/src/physical_types.h	/^	bool autosize_buffer; \/* autosize clock buffers *\/$/;"	m	struct:t_clock_network	access:public
av_bb_cost	place/place.cpp	/^	double av_cost, av_bb_cost, av_timing_cost,$/;"	m	struct:t_placer_statistics	file:	access:public
av_cost	place/place.cpp	/^	double av_cost, av_bb_cost, av_timing_cost,$/;"	m	struct:t_placer_statistics	file:	access:public
av_delay_cost	place/place.cpp	/^	       sum_of_squares, av_delay_cost;$/;"	m	struct:t_placer_statistics	file:	access:public
av_timing_cost	place/place.cpp	/^	double av_cost, av_bb_cost, av_timing_cost,$/;"	m	struct:t_placer_statistics	file:	access:public
available_wirelength	route/route_timing.cpp	/^    size_t available_wirelength() const {$/;"	f	class:WirelengthInfo	access:public	signature:() const
available_wirelength_	route/route_timing.cpp	/^    size_t available_wirelength_;$/;"	m	class:WirelengthInfo	file:	access:private
axis	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static const axis_t axis;$/;"	m	struct:axis_to_type	file:	access:public
axis	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <axis_t N> const axis_t axis_to_type<N>::axis = N;$/;"	m	class:axis_to_type	file:
axis_ancestor	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_ancestor,$/;"	e	enum:axis_t	file:
axis_ancestor_or_self	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_ancestor_or_self,$/;"	e	enum:axis_t	file:
axis_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_attribute,$/;"	e	enum:axis_t	file:
axis_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_child,$/;"	e	enum:axis_t	file:
axis_descendant	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_descendant,$/;"	e	enum:axis_t	file:
axis_descendant_or_self	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_descendant_or_self,$/;"	e	enum:axis_t	file:
axis_following	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_following,$/;"	e	enum:axis_t	file:
axis_following_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_following_sibling,$/;"	e	enum:axis_t	file:
axis_namespace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_namespace,$/;"	e	enum:axis_t	file:
axis_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_parent,$/;"	e	enum:axis_t	file:
axis_preceding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_preceding,$/;"	e	enum:axis_t	file:
axis_preceding_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_preceding_sibling,$/;"	e	enum:axis_t	file:
axis_self	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_self$/;"	e	enum:axis_t	file:
axis_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum axis_t$/;"	g	file:
axis_to_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <axis_t N> struct axis_to_type$/;"	s	file:
axis_to_type::axis	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static const axis_t axis;$/;"	m	struct:axis_to_type	file:	access:public
axis_to_type::axis	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <axis_t N> const axis_t axis_to_type<N>::axis = N;$/;"	m	class:axis_to_type	file:
b	../../libs/libvtrutil/src/vtr_color_map.h	/^    T b;$/;"	m	struct:vtr::Color	access:public
background_color	../../libs/libeasygl/src/graphics_state.h	/^    t_color background_color = t_color(0xFF, 0xFF, 0xCC);$/;"	m	struct:t_gl_state	access:public
backward_cost	route/route_timing.cpp	/^    float backward_cost = 0.;$/;"	m	struct:t_timing_driven_node_costs	file:	access:public
backward_expand_pack_pattern_from_edge	pack/prepack.cpp	/^static void backward_expand_pack_pattern_from_edge($/;"	f	file:	signature:( const t_pb_graph_edge* expansion_edge, t_pack_patterns *list_of_packing_patterns, const int curr_pattern_index, t_pb_graph_pin *destination_pin, t_pack_pattern_block *destination_block, int *L_num_blocks)
backward_expand_pack_pattern_from_edge	pack/prepack.cpp	/^static void backward_expand_pack_pattern_from_edge($/;"	p	file:	signature:( const t_pb_graph_edge* expansion_edge, t_pack_patterns *list_of_packing_patterns, const int curr_pattern_index, t_pb_graph_pin *destination_pin, t_pack_pattern_block *destination_block, int *L_num_blocks)
backward_infer_pattern	pack/prepack.cpp	/^static void backward_infer_pattern(t_pb_graph_pin *pb_graph_pin) {$/;"	f	file:	signature:(t_pb_graph_pin *pb_graph_pin)
backward_infer_pattern	pack/prepack.cpp	/^static void backward_infer_pattern(t_pb_graph_pin *pb_graph_pin);$/;"	p	file:	signature:(t_pb_graph_pin *pb_graph_pin)
backward_path_cost	base/vpr_types.h	/^	float backward_path_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
backward_path_cost	route/route_common.h	/^	float backward_path_cost = 0.;$/;"	m	struct:t_heap	access:public
backward_weight	base/vpr_types.h	/^	float forward_weight, backward_weight; \/* Weightings of the importance of paths$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
bad_attribute	../../libs/libarchfpga/src/read_xml_util.cpp	/^void bad_attribute(const pugi::xml_attribute attr,$/;"	f	signature:(const pugi::xml_attribute attr, const pugi::xml_node node, const pugiutil::loc_data& loc_data, const std::vector<std::string> expected_attributes)
bad_attribute	../../libs/libarchfpga/src/read_xml_util.h	/^void bad_attribute(const pugi::xml_attribute attr,$/;"	p	signature:(const pugi::xml_attribute attr, const pugi::xml_node node, const pugiutil::loc_data& loc_data, const std::vector<std::string> expected_attributes=std::vector<std::string>())
bad_attribute_value	../../libs/libarchfpga/src/read_xml_util.cpp	/^void bad_attribute_value(const pugi::xml_attribute attr,$/;"	f	signature:(const pugi::xml_attribute attr, const pugi::xml_node node, const pugiutil::loc_data& loc_data, const std::vector<std::string> expected_values)
bad_attribute_value	../../libs/libarchfpga/src/read_xml_util.h	/^void bad_attribute_value(const pugi::xml_attribute attr,$/;"	p	signature:(const pugi::xml_attribute attr, const pugi::xml_node node, const pugiutil::loc_data& loc_data, const std::vector<std::string> expected_attributes=std::vector<std::string>())
bad_tag	../../libs/libarchfpga/src/read_xml_util.cpp	/^void bad_tag(const pugi::xml_node node,$/;"	f	signature:(const pugi::xml_node node, const pugiutil::loc_data& loc_data, const pugi::xml_node parent_node, const std::vector<std::string> expected_tags)
bad_tag	../../libs/libarchfpga/src/read_xml_util.h	/^void bad_tag(const pugi::xml_node node,$/;"	p	signature:(const pugi::xml_node node, const pugiutil::loc_data& loc_data, const pugi::xml_node parent_node=pugi::xml_node(), const std::vector<std::string> expected_tags=std::vector<std::string>())
base_cost	../../libs/libarchfpga/src/cad_types.h	/^	float base_cost; \/* base cost of pattern eg. If a group of logical blocks match a pattern of smaller primitives, that is better than the same group using bigger primitives *\/$/;"	m	struct:t_pack_patterns	access:public
base_cost	../../libs/libarchfpga/src/cad_types.h	/^	float base_cost; \/* cost independant of current status of packing *\/$/;"	m	struct:t_cluster_placement_primitive	access:public
base_cost	route/rr_node.h	/^	float base_cost;$/;"	m	struct:t_rr_indexed_data	access:public
base_cost_type	base/read_options.h	/^    argparse::ArgValue<e_base_cost_type> base_cost_type;$/;"	m	struct:t_options	access:public
base_cost_type	base/vpr_types.h	/^	enum e_base_cost_type base_cost_type;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_base_cost_type	access:public
base_delay_model_	place/place_delay_model.h	/^        std::unique_ptr<PlaceDelayModel> base_delay_model_;$/;"	m	class:OverrideDelayModel	access:private
base_gain	base/vpr_types.h	/^	float base_gain; \/* Intrinsic "goodness" score for molecule independant of rest of netlist *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
basename	../../libs/libvtrutil/src/vtr_path.cpp	/^std::string basename(const std::string& path) {$/;"	f	namespace:vtr	signature:(const std::string& path)
basename	../../libs/libvtrutil/src/vtr_path.h	/^    std::string basename(const std::string& path);$/;"	p	namespace:vtr	signature:(const std::string& path)
bb_coords	place/place.cpp	/^static vtr::vector<ClusterNetId, t_bb> bb_coords, bb_num_on_edges;$/;"	v	file:
bb_cost	place/place.cpp	/^    float bb_cost;$/;"	m	struct:t_placer_costs	file:	access:public
bb_cost	place/place.cpp	/^    float bb_cost;$/;"	m	struct:t_placer_prev_inverse_costs	file:	access:public
bb_factor	base/read_options.h	/^    argparse::ArgValue<int> bb_factor;$/;"	m	struct:t_options	access:public
bb_factor	base/vpr_types.h	/^	int bb_factor;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
bb_num_on_edges	place/place.cpp	/^static vtr::vector<ClusterNetId, t_bb> bb_coords, bb_num_on_edges;$/;"	v	file:
bb_updated_before	place/place.cpp	/^static vtr::vector<ClusterNetId, char> bb_updated_before;$/;"	v	file:
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* begin;$/;"	m	struct:xpath_lexer_string	file:	access:public
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* begin() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)$/;"	v
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_tree_walker::begin(xml_node&)$/;"	f	class:pugi::xml_tree_walker	signature:(xml_node&)
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::iterator xml_node::begin() const$/;"	f	class:pugi::xml_node	signature:() const
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::const_iterator xpath_node_set::begin() const$/;"	f	class:pugi::xpath_node_set	signature:() const
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It begin() const { return _begin; }$/;"	f	class:pugi::xml_object_range	access:public	signature:() const
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const_iterator begin() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		iterator begin() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual bool begin(xml_node& node);$/;"	p	class:pugi::xml_tree_walker	access:public	signature:(xml_node& node)
begin	../../libs/libvtrutil/src/vtr_bimap.h	/^        iterator begin() const { return map_.begin(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
begin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          begin()     const   { return vec_.begin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
begin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator                begin()             { return vec_.begin(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
begin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          begin()     const   { return vec_.begin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
begin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator                begin()             { return vec_.begin(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
begin	../../libs/libvtrutil/src/vtr_range.h	/^        T begin() { return begin_; }$/;"	f	class:vtr::Range	access:public	signature:()
begin	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_iterator begin() const { return vec_.begin(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
begin	../../libs/libvtrutil/src/vtr_vector_map.h	/^        iterator begin() { return vec_.begin(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
begin	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::const_reverse_iterator begin() const { return values_.crbegin(); }$/;"	f	class:LogicVec	access:public	signature:() const
begin	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::reverse_iterator begin() { return values_.rbegin(); }$/;"	f	class:LogicVec	access:public	signature:()
begin_	../../libs/libvtrutil/src/vtr_range.h	/^        T begin_;$/;"	m	class:vtr::Range	access:private
begin_index	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t begin_index(size_t i) const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(size_t i) const
begin_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t begin_index() const { return begin_index_; }$/;"	f	class:vtr::DimRange	access:public	signature:() const
begin_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t begin_index(size_t i) const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(size_t i) const
begin_index_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t begin_index_ = 0;$/;"	m	class:vtr::DimRange	access:private
bend_cost	base/read_options.h	/^    argparse::ArgValue<float> bend_cost;$/;"	m	struct:t_options	access:public
bend_cost	base/vpr_types.h	/^	float bend_cost;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
bend_cost	route/route_timing.h	/^    float bend_cost = 1.;$/;"	m	struct:t_conn_cost_params	access:public
beta	base/vpr_types.h	/^	float beta;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
beta_clustering	base/read_options.h	/^    argparse::ArgValue<float> beta_clustering;$/;"	m	struct:t_options	access:public
bimap	../../libs/libvtrutil/src/vtr_bimap.h	/^class bimap {$/;"	c	namespace:vtr
binary_not	power/power_callibrate.cpp	/^static char binary_not(char c) {$/;"	f	file:	signature:(char c)
binary_not	power/power_callibrate.cpp	/^static char binary_not(char c);$/;"	p	file:	signature:(char c)
binary_op_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			binary_op_t(): asttype(ast_unknown), rettype(xpath_type_none), precedence(0)$/;"	f	struct:xpath_parser::binary_op_t	access:public	signature:()
binary_op_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			binary_op_t(ast_type_t asttype_, xpath_value_type rettype_, int precedence_): asttype(asttype_), rettype(rettype_), precedence(precedence_)$/;"	f	struct:xpath_parser::binary_op_t	access:public	signature:(ast_type_t asttype_, xpath_value_type rettype_, int precedence_)
binary_op_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		struct binary_op_t$/;"	s	struct:xpath_parser	file:	access:public
binary_search_place_and_route	base/place_and_route.cpp	/^int binary_search_place_and_route(t_placer_opts placer_opts,$/;"	f	signature:(t_placer_opts placer_opts, t_annealing_sched annealing_sched, t_router_opts router_opts, const t_analysis_opts& analysis_opts, t_file_name_opts filename_opts, const t_arch* arch, bool verify_binary_search, int min_chan_width_hint, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, vtr::vector<ClusterNetId, float *> &net_delay, const t_timing_inf& timing_inf, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc)
binary_search_place_and_route	base/place_and_route.h	/^int binary_search_place_and_route(t_placer_opts placer_opts,$/;"	p	signature:(t_placer_opts placer_opts, t_annealing_sched annealing_sched, t_router_opts router_opts, const t_analysis_opts& analysis_opts, t_file_name_opts filename_opts, const t_arch* arch, bool verify_binary_search, int min_chan_width_hint, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, vtr::vector<ClusterNetId, float *> &net_delay, const t_timing_inf& timing_inf, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc)
binomial_coefficient	route/cb_metrics.cpp	/^static long double binomial_coefficient(const int n, const int k){$/;"	f	file:	signature:(const int n, const int k)
bit_size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t bit_size;$/;"	m	class:BitSpace::VerilogBits	access:private
bit_to_c	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static char bit_to_c(bit_value_t bit)$/;"	f	namespace:BitSpace	signature:(bit_value_t bit)
bit_value_t	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    typedef uint8_t bit_value_t;$/;"	t	namespace:BitSpace
bits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        T bits = _All_x;$/;"	m	class:BitSpace::BitFields	access:private
bits	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        std::vector<BitFields<veri_internal_bits_t>> bits;$/;"	m	class:BitSpace::VerilogBits	access:private
bitstring	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::VerilogBits *bitstring = nullptr;$/;"	m	class:VNumber	access:private
bitwise	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber bitwise(VNumber& b, const BitSpace::bit_value_t lut[4][4])$/;"	f	class:VNumber	access:public	signature:(VNumber& b, const BitSpace::bit_value_t lut[4][4])
bitwise_reduce	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits *bitwise_reduce(const bit_value_t lut[4][4])$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(const bit_value_t lut[4][4])
bitwise_reduce	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber bitwise_reduce(const BitSpace::bit_value_t lut[4][4])$/;"	f	class:VNumber	access:public	signature:(const BitSpace::bit_value_t lut[4][4])
blif_file_name	base/vpr_types.h	/^	std::string blif_file_name;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
blif_format_	base/read_blif.cpp	/^        e_circuit_format blif_format_ = e_circuit_format::BLIF;$/;"	m	struct:BlifAllocCallback	file:	access:private
blif_model	../../libs/libarchfpga/src/physical_types.h	/^	char* blif_model = nullptr;$/;"	m	struct:t_pb_type	access:public
blif_models_	base/read_blif.cpp	/^        std::vector<AtomNetlist> blif_models_;$/;"	m	struct:BlifAllocCallback	file:	access:private
blif_models_black_box_	base/read_blif.cpp	/^        std::vector<bool> blif_models_black_box_;$/;"	m	struct:BlifAllocCallback	file:	access:private
blif_os_	base/netlist_writer.cpp	/^        std::ostream& blif_os_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
blk_index	place/place_macro.h	/^	ClusterBlockId blk_index;$/;"	m	struct:t_pl_macro_member	access:public
blk_info	draw/draw_types.h	/^    std::vector<t_draw_pb_type_info> blk_info;$/;"	m	struct:t_draw_coords	access:public
block	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block block;$/;"	m	struct:xpath_query_impl	file:	access:public
block	base/vpr_types.h	/^	ClusterBlockId block; \/* atom block primitive which this tnode is part of *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
block_attrs	base/netlist.h	/^        attr_range          block_attrs(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_attrs	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::attr_range Netlist<BlockId, PortId, PinId, NetId>::block_attrs(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_attrs_	base/netlist.h	/^        vtr::vector_map<BlockId, std::unordered_map<std::string,std::string>>       block_attrs_;         \/\/Attributes of each block$/;"	m	class:Netlist	access:private
block_clock_pins	base/netlist.h	/^        pin_range           block_clock_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_clock_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_clock_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_clock_ports	base/netlist.h	/^        port_range          block_clock_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_clock_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_clock_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_color	draw/draw_types.h	/^	vtr::vector<ClusterBlockId, t_color> block_color;$/;"	m	struct:t_draw_state	access:public
block_contains_primary_input	base/clustered_netlist.cpp	/^bool ClusteredNetlist::block_contains_primary_input(const ClusterBlockId blk) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk) const
block_contains_primary_input	base/clustered_netlist.h	/^        bool block_contains_primary_input(const ClusterBlockId blk) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk) const
block_contains_primary_output	base/clustered_netlist.cpp	/^bool ClusteredNetlist::block_contains_primary_output(const ClusterBlockId blk) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk) const
block_contains_primary_output	base/clustered_netlist.h	/^        bool block_contains_primary_output(const ClusterBlockId blk) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk) const
block_id	../../libs/libarchfpga/src/cad_types.h	/^	int block_id;$/;"	m	struct:t_pack_pattern_block	access:public
block_id_map_	base/netlist.h	/^        vtr::vector_map<BlockId, BlockId> block_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
block_ids_	base/netlist.h	/^        vtr::vector_map<BlockId, BlockId>                   block_ids_;                \/\/Valid block ids$/;"	m	class:Netlist	access:private
block_input_pins	base/netlist.h	/^        pin_range           block_input_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_input_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_input_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_input_ports	base/netlist.h	/^        port_range          block_input_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_input_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_input_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_is_combinational	base/netlist.h	/^        bool                block_is_combinational(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_is_combinational	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::block_is_combinational(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<BlockId, BlockId>::const_iterator              block_iterator;$/;"	t	class:Netlist	access:public
block_locs	base/vpr_context.h	/^    vtr::vector_map<ClusterBlockId, t_block_loc> block_locs;$/;"	m	struct:PlacementContext	access:public
block_logical_pins_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterBlockId, std::vector<ClusterPinId>> block_logical_pins_; \/\/The logical pin associated with each physical block pin$/;"	m	class:ClusteredNetlist	access:private
block_model	base/atom_netlist.cpp	/^const t_model* AtomNetlist::block_model(const AtomBlockId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId id) const
block_model	base/atom_netlist.h	/^        const t_model* block_model(const AtomBlockId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId id) const
block_models_	base/atom_netlist.h	/^        vtr::vector_map<AtomBlockId, const t_model*>        block_models_;             \/\/Architecture model of each block$/;"	m	class:AtomNetlist	access:private
block_name	base/netlist.h	/^        const std::string&  block_name(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::block_name(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_name_to_block_id_	base/netlist.h	/^        vtr::vector_map<StringId,BlockId>               block_name_to_block_id_;$/;"	m	class:Netlist	access:private
block_names_	base/netlist.h	/^        vtr::vector_map<BlockId, StringId>                  block_names_;              \/\/Name of each block$/;"	m	class:Netlist	access:private
block_net	base/clustered_netlist.cpp	/^ClusterNetId ClusteredNetlist::block_net(const ClusterBlockId blk_id, const int phys_pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id, const int phys_pin_index) const
block_net	base/clustered_netlist.h	/^        ClusterNetId block_net(const ClusterBlockId blk_id, const int pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk_id, const int pin_index) const
block_num	base/vpr_types.h	/^	ClusterBlockId block_num;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
block_num_clock_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_clock_pins_;     \/\/Number of clock pins on each block$/;"	m	class:Netlist	access:private
block_num_clock_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_clock_ports_;    \/\/Clock ports of each block$/;"	m	class:Netlist	access:private
block_num_input_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_input_pins_;     \/\/Number of input pins on each block$/;"	m	class:Netlist	access:private
block_num_input_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_input_ports_;    \/\/Input ports of each block$/;"	m	class:Netlist	access:private
block_num_output_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_output_pins_;    \/\/Number of output pins on each block$/;"	m	class:Netlist	access:private
block_num_output_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, unsigned>                  block_num_output_ports_;   \/\/Output ports of each block$/;"	m	class:Netlist	access:private
block_output_pins	base/netlist.h	/^        pin_range           block_output_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_output_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_output_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_output_ports	base/netlist.h	/^        port_range          block_output_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_output_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_output_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_params	base/netlist.h	/^        param_range         block_params(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_params	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::param_range Netlist<BlockId, PortId, PinId, NetId>::block_params(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_params_	base/netlist.h	/^        vtr::vector_map<BlockId, std::unordered_map<std::string,std::string>>       block_params_;        \/\/Parameters of each block$/;"	m	class:Netlist	access:private
block_pb	base/clustered_netlist.cpp	/^t_pb* ClusteredNetlist::block_pb(const ClusterBlockId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId id) const
block_pb	base/clustered_netlist.h	/^        t_pb* block_pb(const ClusterBlockId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId id) const
block_pbs_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterBlockId, t_pb*>                     block_pbs_;         \/\/Physical block representing the clustering & internal hierarchy of each CLB$/;"	m	class:ClusteredNetlist	access:private
block_pin	base/clustered_netlist.cpp	/^ClusterPinId ClusteredNetlist::block_pin(const ClusterBlockId blk, const int phys_pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk, const int phys_pin_index) const
block_pin	base/clustered_netlist.h	/^        ClusterPinId block_pin(const ClusterBlockId blk, const int phys_pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk, const int phys_pin_index) const
block_pin_net_index	base/clustered_netlist.cpp	/^int ClusteredNetlist::block_pin_net_index(const ClusterBlockId blk_id, const int pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id, const int pin_index) const
block_pin_net_index	base/clustered_netlist.h	/^        int block_pin_net_index(const ClusterBlockId blk_id, const int pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk_id, const int pin_index) const
block_pins	base/netlist.h	/^        pin_range           block_pins(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::block_pins(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_pins_	base/netlist.h	/^        vtr::vector_map<BlockId, std::vector<PinId>>        block_pins_;               \/\/Pins of each block$/;"	m	class:Netlist	access:private
block_ports	base/netlist.h	/^        port_range          block_ports(const BlockId blk_id) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id) const
block_ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::block_ports(const BlockId blk_id) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id) const
block_ports_	base/netlist.h	/^        vtr::vector_map<BlockId, std::vector<PortId>>       block_ports_;              \/\/Ports of each block$/;"	m	class:Netlist	access:private
block_range	base/netlist.h	/^        typedef typename vtr::Range<block_iterator> block_range;$/;"	t	class:Netlist	access:public
block_to_pb_gnode_	timing/PreClusterDelayCalculator.h	/^    const std::unordered_map<AtomBlockId,t_pb_graph_node*> block_to_pb_gnode_;$/;"	m	class:PreClusterDelayCalculator	access:private
block_truth_table	base/atom_netlist.cpp	/^const AtomNetlist::TruthTable& AtomNetlist::block_truth_table (const AtomBlockId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId id) const
block_truth_table	base/atom_netlist.h	/^        const TruthTable& block_truth_table(const AtomBlockId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId id) const
block_truth_tables_	base/atom_netlist.h	/^        vtr::vector_map<AtomBlockId,TruthTable>             block_truth_tables_;       \/\/Truth tables of each block$/;"	m	class:AtomNetlist	access:private
block_type	../../libs/libarchfpga/src/physical_types.h	/^    std::string block_type; \/\/The block type name$/;"	m	struct:t_grid_loc_def	access:public
block_type	base/atom_netlist.cpp	/^AtomBlockType AtomNetlist::block_type (const AtomBlockId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId id) const
block_type	base/atom_netlist.h	/^        AtomBlockType block_type(const AtomBlockId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId id) const
block_type	base/clustered_netlist.cpp	/^t_type_ptr ClusteredNetlist::block_type(const ClusterBlockId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId id) const
block_type	base/clustered_netlist.h	/^        t_type_ptr block_type(const ClusterBlockId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId id) const
block_type_class_index_to_pin_names	util/vpr_utils.cpp	/^std::vector<std::string> block_type_class_index_to_pin_names(t_type_ptr type, int class_index) {$/;"	f	signature:(t_type_ptr type, int class_index)
block_type_class_index_to_pin_names	util/vpr_utils.h	/^std::vector<std::string> block_type_class_index_to_pin_names(t_type_ptr type, int class_index);$/;"	p	signature:(t_type_ptr type, int class_index)
block_type_colors	draw/draw.cpp	/^const std::vector<color_types> block_type_colors = {$/;"	v
block_type_contains_blif_model	util/vpr_utils.cpp	/^bool block_type_contains_blif_model(t_type_ptr type, std::string blif_model_name) {$/;"	f	signature:(t_type_ptr type, std::string blif_model_name)
block_type_contains_blif_model	util/vpr_utils.cpp	/^static bool block_type_contains_blif_model(t_type_ptr type, const std::regex& blif_model_regex) {$/;"	f	file:	signature:(t_type_ptr type, const std::regex& blif_model_regex)
block_type_contains_blif_model	util/vpr_utils.cpp	/^static bool block_type_contains_blif_model(t_type_ptr type, const std::regex& blif_model_regex);$/;"	p	file:	signature:(t_type_ptr type, const std::regex& blif_model_regex)
block_type_contains_blif_model	util/vpr_utils.h	/^bool block_type_contains_blif_model(t_type_ptr type, std::string blif_model_name);$/;"	p	signature:(t_type_ptr type, std::string blif_model_name)
block_type_pin_index_to_name	util/vpr_utils.cpp	/^std::string block_type_pin_index_to_name(t_type_ptr type, int pin_index) {$/;"	f	signature:(t_type_ptr type, int pin_index)
block_type_pin_index_to_name	util/vpr_utils.h	/^std::string block_type_pin_index_to_name(t_type_ptr type, int pin_index);$/;"	p	signature:(t_type_ptr type, int pin_index)
block_types	base/vpr_context.h	/^    t_type_descriptor *block_types;$/;"	m	struct:DeviceContext	access:public
block_types_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterBlockId, t_type_ptr>                block_types_;       \/\/The type of physical block this user circuit block is mapped to$/;"	m	class:ClusteredNetlist	access:private
block_types_	util/vpr_utils.h	/^        t_type_descriptor* block_types_;$/;"	m	class:IntraLbPbPinLookup	access:private
blocks	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block blocks[2];$/;"	m	struct:xpath_stack_data	file:	access:public
blocks	base/netlist.h	/^        block_range blocks() const;$/;"	p	class:Netlist	access:public	signature:() const
blocks	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::block_range Netlist<BlockId, PortId, PinId, NetId>::blocks() const {$/;"	f	class:Netlist	signature:() const
blocks	base/vpr_types.h	/^    std::vector<ClusterBlockId> blocks;$/;"	m	struct:ScreenUpdatePriority::t_grid_blocks	access:public
blocks_affected	place/place.cpp	/^static t_pl_blocks_to_be_moved blocks_affected;$/;"	v	file:
blue	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t blue = 0;$/;"	m	class:t_color	access:public
bottom	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::bottom() const {$/;"	f	class:t_bound_box	signature:() const
bottom	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::bottom() {$/;"	f	class:t_bound_box	signature:()
bottom	../../libs/libeasygl/src/graphics_types.h	/^    const float& bottom() const;$/;"	p	class:t_bound_box	access:public	signature:() const
bottom	../../libs/libeasygl/src/graphics_types.h	/^    float& bottom();$/;"	p	class:t_bound_box	access:public	signature:()
bottom_left	../../libs/libeasygl/src/graphics_types.cpp	/^const t_point& t_bound_box::bottom_left() const {$/;"	f	class:t_bound_box	signature:() const
bottom_left	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_bound_box::bottom_left() {$/;"	f	class:t_bound_box	signature:()
bottom_left	../../libs/libeasygl/src/graphics_types.h	/^    const t_point& bottom_left() const;$/;"	p	class:t_bound_box	access:public	signature:() const
bottom_left	../../libs/libeasygl/src/graphics_types.h	/^    t_point& bottom_left();$/;"	p	class:t_bound_box	access:public	signature:()
bottom_left	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> bottom_left() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
bottom_left	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Point<T> Rect<T>::bottom_left() const {$/;"	f	class:vtr::Rect	signature:() const
bottom_left_	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> bottom_left_;$/;"	m	class:vtr::Rect	access:private
bottomleft	../../libs/libeasygl/src/graphics_types.h	/^    t_point bottomleft;$/;"	m	class:t_bound_box	access:private
bounding_box	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect<T> bounding_box() const;$/;"	p	class:vtr::Line	access:public	signature:() const
bounding_box	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect<T> bounding_box() const;$/;"	p	class:vtr::RectUnion	access:public	signature:() const
bounding_box	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T> Line<T>::bounding_box() const {$/;"	f	class:vtr::Line	signature:() const
bounding_box	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T> RectUnion<T>::bounding_box() const {$/;"	f	class:vtr::RectUnion	signature:() const
breadth_first_add_source_to_heap	route/route_breadth_first.cpp	/^static void breadth_first_add_source_to_heap(ClusterNetId net_id) {$/;"	f	file:	signature:(ClusterNetId net_id)
breadth_first_add_source_to_heap	route/route_breadth_first.cpp	/^static void breadth_first_add_source_to_heap(ClusterNetId net_id);$/;"	p	file:	signature:(ClusterNetId net_id)
breadth_first_add_to_heap_expand_non_configurable	route/route_breadth_first.cpp	/^static void breadth_first_add_to_heap_expand_non_configurable(const float path_cost, const float bend_cost,$/;"	f	file:	signature:(const float path_cost, const float bend_cost, const int from_node, const int to_node, const int iconn)
breadth_first_add_to_heap_expand_non_configurable	route/route_breadth_first.cpp	/^static void breadth_first_add_to_heap_expand_non_configurable(const float path_cost, const float bend_cost,$/;"	p	file:	signature:(const float path_cost, const float bend_cost, const int from_node, const int to_node, const int iconn)
breadth_first_expand_neighbours	route/route_breadth_first.cpp	/^static void breadth_first_expand_neighbours(int inode, float pcost,$/;"	f	file:	signature:(int inode, float pcost, ClusterNetId net_id, float bend_cost)
breadth_first_expand_neighbours	route/route_breadth_first.cpp	/^static void breadth_first_expand_neighbours(int inode, float pcost,$/;"	p	file:	signature:(int inode, float pcost, ClusterNetId net_id, float bend_cost)
breadth_first_expand_non_configurable_recurr	route/route_breadth_first.cpp	/^static void breadth_first_expand_non_configurable_recurr(const float path_cost, const float bend_cost,$/;"	f	file:	signature:(const float path_cost, const float bend_cost, t_heap* current, const int from_node, const int to_node, const int iconn, std::set<int>& visited)
breadth_first_expand_non_configurable_recurr	route/route_breadth_first.cpp	/^static void breadth_first_expand_non_configurable_recurr(const float path_cost, const float bend_cost,$/;"	p	file:	signature:(const float path_cost, const float bend_cost, t_heap* current, const int from_node, const int to_node, const int iconn, std::set<int>& visited)
breadth_first_expand_trace_segment	route/route_breadth_first.cpp	/^static void breadth_first_expand_trace_segment(t_trace *start_ptr,$/;"	f	file:	signature:(t_trace *start_ptr, int remaining_connections_to_sink, std::vector<int>& modified_rr_node_inf)
breadth_first_expand_trace_segment	route/route_breadth_first.cpp	/^static void breadth_first_expand_trace_segment(t_trace *start_ptr,$/;"	p	file:	signature:(t_trace *start_ptr, int remaining_connections_to_sink, std::vector<int>& modified_rr_node_inf)
breadth_first_route_net	route/route_breadth_first.cpp	/^static bool breadth_first_route_net(ClusterNetId net_id, float bend_cost) {$/;"	f	file:	signature:(ClusterNetId net_id, float bend_cost)
breadth_first_route_net	route/route_breadth_first.cpp	/^static bool breadth_first_route_net(ClusterNetId net_id, float bend_cost);$/;"	p	file:	signature:(ClusterNetId net_id, float bend_cost)
break_timing_graph_combinational_loop	timing/path_delay2.cpp	/^void break_timing_graph_combinational_loop(std::vector<int>& loop_tnodes) {$/;"	f	signature:(std::vector<int>& loop_tnodes)
break_timing_graph_combinational_loop	timing/path_delay2.cpp	/^void break_timing_graph_combinational_loop(std::vector<int>& loop_tnodes);$/;"	p	file:	signature:(std::vector<int>& loop_tnodes)
break_timing_graph_combinational_loops	timing/path_delay2.cpp	/^void break_timing_graph_combinational_loops(std::vector<std::vector<int> >& tnode_comb_loops) {$/;"	f	signature:(std::vector<std::vector<int> >& tnode_comb_loops)
break_timing_graph_combinational_loops	timing/path_delay2.cpp	/^void break_timing_graph_combinational_loops(std::vector<std::vector<int> >& tnode_comb_loops);$/;"	p	file:	signature:(std::vector<std::vector<int> >& tnode_comb_loops)
bsig0	../../libs/libvtrutil/src/picosha2.h	/^inline word_t bsig0(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
bsig1	../../libs/libvtrutil/src/picosha2.h	/^inline word_t bsig1(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
buf_size	../../libs/libarchfpga/src/physical_types.h	/^	float buf_size = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
buf_size	../../libs/libarchfpga/src/physical_types.h	/^        float buf_size = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
buf_size_type	../../libs/libarchfpga/src/physical_types.h	/^        BufferSize buf_size_type = BufferSize::AUTO;$/;"	m	struct:t_arch_switch_inf	access:public
bufcapacity	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			bufcapacity = bufcapacitybytes \/ (sizeof(char_t) + 4)$/;"	e	enum:xml_buffered_writer::__anon27	file:
bufcapacitybytes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			bufcapacitybytes =$/;"	e	enum:xml_buffered_writer::__anon27	file:
buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t buffer[bufcapacity];$/;"	m	class:xml_buffered_writer	file:	access:public
buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* buffer;$/;"	m	struct:xml_extra_buffer	file:	access:public
buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* buffer;$/;"	m	struct:xml_document_struct	file:	access:public
buffer_	../../libs/libvtrutil/src/picosha2.h	/^	std::vector<byte_t> buffer_;$/;"	m	class:picosha2::hash256_one_by_one	access:private
buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float buffer_size; \/* if not autosized, the clock buffer size *\/$/;"	m	struct:t_clock_network	access:public
buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float buffer_size;$/;"	m	struct:t_pb_graph_pin_power	access:public
buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float buffer_size;$/;"	m	struct:t_port_power	access:public
buffer_size_inf	power/power.h	/^	t_power_buffer_size_inf * buffer_size_inf;$/;"	m	struct:t_power_tech	access:public
buffer_type	../../libs/libarchfpga/src/physical_types.h	/^	e_power_buffer_type buffer_type;$/;"	m	struct:t_port_power	access:public
buffered	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_arch_switch_inf::buffered() const {$/;"	f	class:t_arch_switch_inf	signature:() const
buffered	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_rr_switch_inf::buffered() const {$/;"	f	class:t_rr_switch_inf	signature:() const
buffered	../../libs/libarchfpga/src/physical_types.h	/^        bool buffered() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
buffered	../../libs/libarchfpga/src/physical_types.h	/^        bool buffered() const;$/;"	p	struct:t_rr_switch_inf	access:public	signature:() const
bufsize	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t bufsize;$/;"	m	class:xml_buffered_writer	file:	access:public
bufsize	../../libs/libvtrutil/src/vtr_util.h	/^    constexpr size_t bufsize = 32768; \/* Maximum line length for various parsing proc. *\/$/;"	m	namespace:vtr
build	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::build() {$/;"	f	class:TimingGraphBuilder	signature:()
build	timing/timing_graph_builder.h	/^        void build();$/;"	p	class:TimingGraphBuilder	access:private	signature:()
build_bidir_rr_opins	route/rr_graph.cpp	/^static void build_bidir_rr_opins(const int i, const int j, const e_side side,$/;"	f	file:	signature:(const int i, const int j, const e_side side, const t_rr_node_indices& L_rr_node_indices, const std::vector<t_rr_node>& rr_nodes, const t_pin_to_track_lookup& opin_to_track_map, const std::vector<vtr::Matrix<int>>&Fc_out, t_rr_edge_info_set& rr_edges_to_create, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const DeviceGrid& grid, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs, const int num_seg_types)
build_bidir_rr_opins	route/rr_graph.cpp	/^static void build_bidir_rr_opins(const int i, const int j, const e_side side,$/;"	p	file:	signature:(const int i, const int j, const e_side side, const t_rr_node_indices& L_rr_node_indices, const std::vector<t_rr_node>& rr_nodes, const t_pin_to_track_lookup& opin_to_track_map, const std::vector<vtr::Matrix<int>>&Fc_out, t_rr_edge_info_set& created_rr_edges, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const DeviceGrid& grid, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs, const int num_seg_types)
build_default_menu	../../libs/libeasygl/src/graphics.cpp	/^build_default_menu() {$/;"	f	file:	signature:()
build_default_menu	../../libs/libeasygl/src/graphics.cpp	/^static void build_default_menu();$/;"	p	file:	signature:()
build_device_grid	base/SetupGrid.cpp	/^static DeviceGrid build_device_grid(const t_grid_def& grid_def, size_t grid_width, size_t grid_height, bool warn_out_of_range, const std::vector<t_type_ptr> limiting_resources) {$/;"	f	file:	signature:(const t_grid_def& grid_def, size_t grid_width, size_t grid_height, bool warn_out_of_range, const std::vector<t_type_ptr> limiting_resources)
build_device_grid	base/SetupGrid.cpp	/^static DeviceGrid build_device_grid(const t_grid_def& grid_def, size_t width, size_t height, bool warn_out_of_range=true, std::vector<t_type_ptr> limiting_resources=std::vector<t_type_ptr>());$/;"	p	file:	signature:(const t_grid_def& grid_def, size_t width, size_t height, bool warn_out_of_range=true, std::vector<t_type_ptr> limiting_resources=std::vector<t_type_ptr>())
build_from_to_lists	timing/read_sdc.cpp	/^static bool build_from_to_lists(char ***from_list, int *num_from, bool* domain_level_from,$/;"	f	file:	signature:(char ***from_list, int *num_from, bool* domain_level_from, char ***to_list, int *num_to, bool* domain_level_to, const sdcparse::StringGroup& from_group, const sdcparse::StringGroup& to_group)
build_from_to_lists	timing/read_sdc.cpp	/^static bool build_from_to_lists(char ***from_list, int *num_from, bool* domain_level_from,$/;"	p	file:	signature:(char ***from_list, int *num_from, bool* domain_level_from, char ***to_list, int *num_to, bool* domain_level_to, const sdcparse::StringGroup& from_group, const sdcparse::StringGroup& to_group)
build_heap	route/route_common.cpp	/^	void build_heap() {$/;"	f	namespace:heap_	signature:()
build_heap	route/route_common.h	/^	void build_heap();$/;"	p	namespace:heap_	signature:()
build_histogram	util/histogram.cpp	/^std::vector<HistogramBucket> build_histogram(std::vector<float> values, size_t num_bins, float min_value, float max_value) {$/;"	f	signature:(std::vector<float> values, size_t num_bins, float min_value, float max_value)
build_histogram	util/histogram.h	/^std::vector<HistogramBucket> build_histogram(std::vector<float> values, size_t num_bins,$/;"	p	signature:(std::vector<float> values, size_t num_bins, float min_value=std::numeric_limits<float>::quiet_NaN(), float max_value=std::numeric_limits<float>::quiet_NaN())
build_id_maps	base/netlist.h	/^        IdRemapper build_id_maps();$/;"	p	class:Netlist	access:protected	signature:()
build_id_maps	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::IdRemapper Netlist<BlockId, PortId, PinId, NetId>::build_id_maps() {$/;"	f	class:Netlist	signature:()
build_loc_data	../../libs/libpugiutil/src/pugixml_loc.cpp	/^void loc_data::build_loc_data() {$/;"	f	class:pugiutil::loc_data	signature:()
build_loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            void build_loc_data();$/;"	p	class:pugiutil::loc_data	access:private	signature:()
build_route_tree_spatial_lookup	route/spatial_route_tree_lookup.cpp	/^SpatialRouteTreeLookup build_route_tree_spatial_lookup(ClusterNetId net, t_rt_node* rt_root) {$/;"	f	signature:(ClusterNetId net, t_rt_node* rt_root)
build_route_tree_spatial_lookup	route/spatial_route_tree_lookup.h	/^SpatialRouteTreeLookup build_route_tree_spatial_lookup(ClusterNetId net, t_rt_node* rt_root);$/;"	p	signature:(ClusterNetId net, t_rt_node* rt_root)
build_rr_chan	route/rr_graph.cpp	/^static void build_rr_chan($/;"	p	file:	signature:( const int i, const int j, const t_rr_type chan_type, const t_track_to_pin_lookup& track_to_pin_lookup, t_sb_connection_map *sb_conn_map, const vtr::NdMatrix<std::vector<int>, 3>& switch_block_conn, const int cost_index_offset, const int max_chan_width, const DeviceGrid& grid, const int tracks_per_chan, t_sblock_pattern& sblock_pattern, const int Fs_per_side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const t_rr_node_indices& L_rr_node_indices, t_rr_edge_info_set& created_rr_edges, std::vector<t_rr_node>& L_rr_node, const int wire_to_ipin_switch, const enum e_directionality directionality)
build_rr_chan	route/rr_graph.cpp	/^static void build_rr_chan(const int x_coord, const int y_coord, const t_rr_type chan_type,$/;"	f	file:	signature:(const int x_coord, const int y_coord, const t_rr_type chan_type, const t_track_to_pin_lookup& track_to_pin_lookup, t_sb_connection_map *sb_conn_map, const vtr::NdMatrix<std::vector<int>, 3>& switch_block_conn, const int cost_index_offset, const int max_chan_width, const DeviceGrid& grid, const int tracks_per_chan, t_sblock_pattern& sblock_pattern, const int Fs_per_side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const t_rr_node_indices& L_rr_node_indices, t_rr_edge_info_set& rr_edges_to_create, std::vector<t_rr_node>& L_rr_node, const int wire_to_ipin_switch, const enum e_directionality directionality)
build_rr_graph	route/rr_graph.cpp	/^static void build_rr_graph($/;"	f	file:	signature:( const t_graph_type graph_type, const int L_num_types, const t_type_ptr types, const DeviceGrid& grid, t_chan_width nodes_per_chan, const enum e_switch_block_type sb_type, const int Fs, const vector<t_switchblock_inf> switchblocks, const int num_seg_types, const int num_arch_switches, const t_segment_inf * segment_inf, const int global_route_switch, const int wire_to_arch_ipin_switch, const int delayless_switch, const float R_minW_nmos, const float R_minW_pmos, const enum e_base_cost_type base_cost_type, const bool trim_empty_channels, const bool trim_obs_channels, const t_direct_inf *directs, const int num_directs, int *wire_to_rr_ipin_switch, int *num_rr_switches, int *Warnings)
build_rr_graph	route/rr_graph.cpp	/^static void build_rr_graph($/;"	p	file:	signature:( const t_graph_type graph_type, const int L_num_types, const t_type_ptr types, const DeviceGrid& grid, t_chan_width nodes_per_chan, const enum e_switch_block_type sb_type, const int Fs, const vector<t_switchblock_inf> switchblocks, const int num_seg_types, const int num_arch_switches, const t_segment_inf * segment_inf, const int global_route_switch, const int wire_to_arch_ipin_switch, const int delayless_switch, const float R_minW_nmos, const float R_minW_pmos, const enum e_base_cost_type base_cost_type, const bool trim_empty_channels, const bool trim_obs_channels, const t_direct_inf *directs, const int num_directs, int *wire_to_rr_ipin_switch, int *num_rr_switches, int *Warnings)
build_rr_sinks_sources	route/rr_graph.cpp	/^static void build_rr_sinks_sources($/;"	p	file:	signature:( const int i, const int j, std::vector<t_rr_node>& L_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_rr_node_indices& L_rr_node_indices, const int delayless_switch, const DeviceGrid& grid)
build_rr_sinks_sources	route/rr_graph.cpp	/^static void build_rr_sinks_sources(const int i, const int j,$/;"	f	file:	signature:(const int i, const int j, std::vector<t_rr_node>& L_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_rr_node_indices& L_rr_node_indices, const int delayless_switch, const DeviceGrid& grid)
build_unidir_rr_opins	route/rr_graph.cpp	/^static void build_unidir_rr_opins($/;"	p	file:	signature:( const int i, const int j, const e_side side, const DeviceGrid& grid, const std::vector<vtr::Matrix<int>>&Fc_out, const int max_chan_width, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, vtr::NdMatrix<int, 3>& Fc_xofs, vtr::NdMatrix<int, 3>& Fc_yofs, t_rr_edge_info_set& created_rr_edges, bool * Fc_clipped, const t_rr_node_indices& L_rr_node_indices, const std::vector<t_rr_node>& rr_nodes, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs, const int num_seg_types)
build_unidir_rr_opins	route/rr_graph.cpp	/^static void build_unidir_rr_opins(const int i, const int j, const e_side side,$/;"	f	file:	signature:(const int i, const int j, const e_side side, const DeviceGrid& grid, const std::vector<vtr::Matrix<int>>&Fc_out, const int max_chan_width, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, vtr::NdMatrix<int, 3>& Fc_xofs, vtr::NdMatrix<int, 3>& Fc_yofs, t_rr_edge_info_set& rr_edges_to_create, bool * Fc_clipped, const t_rr_node_indices& L_rr_node_indices, const std::vector<t_rr_node>& rr_nodes, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs, const int num_seg_types)
busy_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t busy_size;$/;"	m	struct:xml_memory_page	file:	access:public
button	../../libs/libeasygl/src/easygl_constants.h	/^    unsigned int button; \/* indicates what button is pressed: left click is 1; right click is 3; *\/$/;"	m	struct:__anon16	access:public
button	../../libs/libeasygl/src/graphics.cpp	/^    t_button *button;$/;"	m	struct:__anon19	file:	access:public
button_state	../../libs/libeasygl/src/graphics.cpp	/^static t_button_state button_state = {nullptr, 0};$/;"	v	file:
by_component	base/vpr_context.h	/^    t_power_components by_component;$/;"	m	struct:PowerContext	access:public
byte_t	../../libs/libvtrutil/src/picosha2.h	/^typedef unsigned char byte_t;$/;"	t	namespace:picosha2
bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string bytes_to_hex_string(InIter first, InIter last){$/;"	f	namespace:picosha2	signature:(InIter first, InIter last)
bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string bytes_to_hex_string(const InContainer& bytes){$/;"	f	namespace:picosha2	signature:(const InContainer& bytes)
bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void bytes_to_hex_string(InIter first, InIter last, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(InIter first, InIter last, std::string& hex_str)
bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void bytes_to_hex_string(const InContainer& bytes, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const InContainer& bytes, std::string& hex_str)
c_str	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* c_str() const$/;"	f	class:xpath_string	access:public	signature:() const
c_to_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static bit_value_t c_to_bit(char c)$/;"	f	namespace:BitSpace	signature:(char c)
cairo_surface	../../libs/libeasygl/src/graphics_state.h	/^    cairo_surface_t *cairo_surface = nullptr;$/;"	m	class:t_x11_state	access:public
cairo_surface_t	../../libs/libeasygl/src/SurfaceImpl.h	/^typedef void cairo_surface_t;$/;"	t
calc_buffer_stage_effort	power/power_util.cpp	/^float calc_buffer_stage_effort(int N, float final_stage_size) {$/;"	f	signature:(int N, float final_stage_size)
calc_buffer_stage_effort	power/power_util.h	/^float calc_buffer_stage_effort(int N, float final_stage_size);$/;"	p	signature:(int N, float final_stage_size)
calc_current_bb	route/route_timing.cpp	/^static t_bb calc_current_bb(const t_trace* head) {$/;"	f	file:	signature:(const t_trace* head)
calc_current_bb	route/route_timing.cpp	/^static t_bb calc_current_bb(const t_trace* head);$/;"	p	file:	signature:(const t_trace* head)
calc_edge_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time calc_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id, DelayType delay_type) const
calc_edge_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::calc_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge, DelayType delay_type) const
calc_max_molecules_stats	pack/cluster.cpp	/^static t_molecule_stats calc_max_molecules_stats(const t_pack_molecule* molecule_head) {$/;"	f	file:	signature:(const t_pack_molecule* molecule_head)
calc_max_molecules_stats	pack/cluster.cpp	/^static t_molecule_stats calc_max_molecules_stats(const t_pack_molecule* molecule_head);$/;"	p	file:	signature:(const t_pack_molecule* molecule_head)
calc_molecule_stats	pack/cluster.cpp	/^static t_molecule_stats calc_molecule_stats(const t_pack_molecule* molecule) {$/;"	f	file:	signature:(const t_pack_molecule* molecule)
calc_molecule_stats	pack/cluster.cpp	/^static t_molecule_stats calc_molecule_stats(const t_pack_molecule* molecule);$/;"	p	file:	signature:(const t_pack_molecule* molecule)
calc_pin_criticality	timing/slack_evaluation.cpp	/^float HoldSlackCrit::calc_pin_criticality(AtomPinId pin,$/;"	f	class:HoldSlackCrit	signature:(AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer, const float scale, const float shift)
calc_pin_criticality	timing/slack_evaluation.cpp	/^float SetupSlackCrit::calc_pin_criticality(AtomPinId pin,$/;"	f	class:SetupSlackCrit	signature:(AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer, const std::map<DomainPair,float>& max_req, const std::map<DomainPair,float>& worst_slack)
calc_pin_criticality	timing/slack_evaluation.h	/^        float calc_pin_criticality(AtomPinId pin,$/;"	p	class:HoldSlackCrit	access:private	signature:(AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer, const float scale, const float shift)
calc_pin_criticality	timing/slack_evaluation.h	/^        float calc_pin_criticality(AtomPinId pin,$/;"	p	class:SetupSlackCrit	access:private	signature:(AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer, const std::map<DomainPair,float>& max_req, const std::map<DomainPair,float>& worst_slack)
calc_placer_stats	place/place.cpp	/^static void calc_placer_stats(t_placer_statistics& stats, float& success_rat, double& std_dev, const t_placer_costs& costs, const int move_lim) {$/;"	f	file:	signature:(t_placer_statistics& stats, float& success_rat, double& std_dev, const t_placer_costs& costs, const int move_lim)
calc_placer_stats	place/place.cpp	/^static void calc_placer_stats(t_placer_statistics& stats, float& success_rat, double& std_dev, const t_placer_costs& costs, const int move_lim);$/;"	p	file:	signature:(t_placer_statistics& stats, float& success_rat, double& std_dev, const t_placer_costs& costs, const int move_lim)
calc_relaxed_criticality	timing/timing_util.cpp	/^float calc_relaxed_criticality(const std::map<DomainPair, float>& domains_max_req,$/;"	f	signature:(const std::map<DomainPair, float>& domains_max_req, const std::map<DomainPair, float>& domains_worst_slack, const tatum::TimingTags::tag_range tags)
calc_relaxed_criticality	timing/timing_util.h	/^float calc_relaxed_criticality(const std::map<DomainPair,float>& domains_max_req,$/;"	p	signature:(const std::map<DomainPair,float>& domains_max_req, const std::map<DomainPair,float>& domains_worst_slack, const tatum::TimingTags::tag_range tags)
calc_size	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t calc_size() const {$/;"	f	class:vtr::NdMatrixBase	access:private	signature:() const
calculate_all_path_delays_from_rr_node	route/router_delay_profiling.cpp	/^std::vector<float> calculate_all_path_delays_from_rr_node(int src_rr_node, const t_router_opts& router_opts) {$/;"	f	signature:(int src_rr_node, const t_router_opts& router_opts)
calculate_all_path_delays_from_rr_node	route/router_delay_profiling.h	/^std::vector<float> calculate_all_path_delays_from_rr_node(int src_rr_node, const t_router_opts& router_opts);$/;"	p	signature:(int src_rr_node, const t_router_opts& router_opts)
calculate_clb_net_pin_criticality	timing/timing_util.cpp	/^float calculate_clb_net_pin_criticality(const SetupTimingInfo& timing_info, const ClusteredPinAtomPinsLookup& pin_lookup, ClusterPinId clb_pin) {$/;"	f	signature:(const SetupTimingInfo& timing_info, const ClusteredPinAtomPinsLookup& pin_lookup, ClusterPinId clb_pin)
calculate_clb_net_pin_criticality	timing/timing_util.h	/^float calculate_clb_net_pin_criticality(const SetupTimingInfo& timing_info, const ClusteredPinAtomPinsLookup& pin_lookup, ClusterPinId clb_pin);$/;"	p	signature:(const SetupTimingInfo& timing_info, const ClusteredPinAtomPinsLookup& pin_lookup, ClusterPinId clb_pin)
calculate_clb_pin_slack	route/route_budgets.cpp	/^float route_budgets::calculate_clb_pin_slack(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info,$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type type, AtomPinId &atom_pin)
calculate_clb_pin_slack	route/route_budgets.h	/^    float calculate_clb_pin_slack(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info,$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type type, AtomPinId &atom_pin)
calculate_constraint	timing/read_sdc.cpp	/^static float calculate_constraint(t_sdc_clock source_domain, t_sdc_clock sink_domain) {$/;"	f	file:	signature:(t_sdc_clock source_domain, t_sdc_clock sink_domain)
calculate_constraint	timing/read_sdc.cpp	/^static float calculate_constraint(t_sdc_clock source_domain, t_sdc_clock sink_domain);$/;"	p	file:	signature:(t_sdc_clock source_domain, t_sdc_clock sink_domain)
calculate_delay	route/router_delay_profiling.cpp	/^bool calculate_delay(int source_node, int sink_node,$/;"	f	signature:(int source_node, int sink_node, const t_router_opts& router_opts, float *net_delay)
calculate_delay	route/router_delay_profiling.h	/^bool calculate_delay(int source_node, int sink_node,$/;"	p	signature:(int source_node, int sink_node, const t_router_opts& router_opts, float *net_delay)
calculate_delay_targets	route/route_budgets.cpp	/^void route_budgets::calculate_delay_targets() {$/;"	f	class:route_budgets	signature:()
calculate_delay_targets	route/route_budgets.cpp	/^void route_budgets::calculate_delay_targets(ClusterNetId net_id, ClusterPinId pin_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, ClusterPinId pin_id)
calculate_delay_targets	route/route_budgets.h	/^    void calculate_delay_targets();$/;"	p	class:route_budgets	access:private	signature:()
calculate_delay_targets	route/route_budgets.h	/^    void calculate_delay_targets(ClusterNetId net_id, ClusterPinId pin_id);$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, ClusterPinId pin_id)
calculate_device_utilization	base/SetupGrid.cpp	/^float calculate_device_utilization(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts) {$/;"	f	signature:(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts)
calculate_device_utilization	base/SetupGrid.h	/^float calculate_device_utilization(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts);$/;"	p	signature:(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts)
calculate_hold_constraint	timing/read_sdc2.cpp	/^        tatum::Time calculate_hold_constraint(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const
calculate_min_launch_to_capture_edge_time	timing/read_sdc2.cpp	/^        float calculate_min_launch_to_capture_edge_time(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const
calculate_overuse_info	route/route_timing.cpp	/^static OveruseInfo calculate_overuse_info() {$/;"	f	file:	signature:()
calculate_overuse_info	route/route_timing.cpp	/^static OveruseInfo calculate_overuse_info();$/;"	p	file:	signature:()
calculate_routing_avail	route/route_util.cpp	/^vtr::Matrix<float> calculate_routing_avail(t_rr_type rr_type) {$/;"	f	signature:(t_rr_type rr_type)
calculate_routing_avail	route/route_util.h	/^vtr::Matrix<float> calculate_routing_avail(t_rr_type rr_type);$/;"	p	signature:(t_rr_type rr_type)
calculate_routing_usage	route/route_util.cpp	/^vtr::Matrix<float> calculate_routing_usage(t_rr_type rr_type) {$/;"	f	signature:(t_rr_type rr_type)
calculate_routing_usage	route/route_util.h	/^vtr::Matrix<float> calculate_routing_usage(t_rr_type rr_type);$/;"	p	signature:(t_rr_type rr_type)
calculate_setup_constraint	timing/read_sdc2.cpp	/^        tatum::Time calculate_setup_constraint(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId launch_domain, tatum::DomainId capture_domain) const
calculate_wirelength_info	route/route_timing.cpp	/^static WirelengthInfo calculate_wirelength_info() {$/;"	f	file:	signature:()
calculate_wirelength_info	route/route_timing.cpp	/^static WirelengthInfo calculate_wirelength_info();$/;"	p	file:	signature:()
callibrate	power/PowerSpicedComponent.cpp	/^void PowerCallibInputs::callibrate() {$/;"	f	class:PowerCallibInputs	signature:()
callibrate	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::callibrate() {$/;"	f	class:PowerSpicedComponent	signature:()
callibrate	power/PowerSpicedComponent.h	/^	void callibrate();$/;"	p	class:PowerCallibInputs	access:public	signature:()
callibrate	power/PowerSpicedComponent.h	/^	void callibrate();$/;"	p	class:PowerSpicedComponent	access:public	signature:()
calloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* calloc(size_t nelem, size_t size) {$/;"	f	namespace:vtr	signature:(size_t nelem, size_t size)
calloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* calloc(size_t nelem, size_t size);$/;"	p	namespace:vtr	signature:(size_t nelem, size_t size)
cap	timing/slre.cpp	/^struct cap {$/;"	s	file:
cap::len	timing/slre.cpp	/^  int len;          \/\/ Substring length$/;"	m	struct:cap	file:	access:public
cap::ptr	timing/slre.cpp	/^  const char *ptr;  \/\/ Pointer to the substring$/;"	m	struct:cap	file:	access:public
capacitance	../../libs/libarchfpga/src/physical_types.h	/^	float capacitance;$/;"	m	struct:t_pb_graph_edge	access:public
capacity	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t capacity;$/;"	m	struct:xpath_memory_block	file:	access:public
capacity	../../libs/libarchfpga/src/physical_types.h	/^	int capacity = 0;$/;"	m	struct:t_type_descriptor	access:public
capacity	../../libs/libvtrutil/src/vtr_vector_map.h	/^        size_t capacity() const { return vec_.capacity(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
capacity	base/vpr_types.h	/^	float capacity;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
capacity	pack/pack_types.h	/^	short capacity;			\/* Number of nets that can simultaneously use this node *\/$/;"	m	struct:t_lb_type_rr_node	access:public
capacity	route/rr_node.cpp	/^short t_rr_node::capacity() const {$/;"	f	class:t_rr_node	signature:() const
capacity	route/rr_node.h	/^        short capacity() const;$/;"	p	class:t_rr_node	access:public	signature:() const
capacity_	route/rr_node.h	/^        uint16_t capacity_ = 0;$/;"	m	class:t_rr_node	access:private
capture	timing/DomainPair.h	/^    tatum::DomainId capture;$/;"	m	struct:DomainPair	access:public
capture	timing/slre.cpp	/^static const char *capture(const struct cap *caps, int num_caps, va_list ap) {$/;"	f	file:	signature:(const struct cap *caps, int num_caps, va_list ap)
capture_float	timing/slre.cpp	/^static const char *capture_float(const struct cap *cap, void *p, size_t len) {$/;"	f	file:	signature:(const struct cap *cap, void *p, size_t len)
capture_int	timing/slre.cpp	/^static const char *capture_int(const struct cap *cap, void *p, size_t len) {$/;"	f	file:	signature:(const struct cap *cap, void *p, size_t len)
capture_string	timing/slre.cpp	/^static const char *capture_string(const struct cap *cap, void *p, size_t len) {$/;"	f	file:	signature:(const struct cap *cap, void *p, size_t len)
casecmp	timing/slre.cpp	/^static int casecmp(const void *p1, const void *p2, size_t len) {$/;"	f	file:	signature:(const void *p1, const void *p2, size_t len)
cb	../../libs/libarchfpga/src/physical_types.h	/^	bool *cb;$/;"	m	struct:t_segment_inf	access:public
cb	base/vpr_types.h	/^	std::unique_ptr<bool[]> cb;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
cb	base/vpr_types.h	/^        bool cb(int pos) const { return seg_detail_->cb[pos]; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int pos) const
cb_len	../../libs/libarchfpga/src/physical_types.h	/^	int cb_len;$/;"	m	struct:t_segment_inf	access:public
cb_type_descriptors	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static t_type_descriptor *cb_type_descriptors;$/;"	v	file:
cbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          cbegin()    const   { return vec_.begin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
cbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          cbegin()    const   { return vec_.begin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
cc_constraints	base/vpr_types.h	/^	t_override_constraint * cc_constraints; \/*  [0..num_cc_constraints - 1] array of such constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
cell_instances_	base/netlist_writer.cpp	/^        std::vector<std::shared_ptr<Instance>> cell_instances_; \/\/Set of cell instances$/;"	m	class:NetlistWriterVisitor	file:	access:private
cend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          cend()      const   { return vec_.end(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
cend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          cend()      const   { return vec_.end(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
cf_constraints	base/vpr_types.h	/^	t_override_constraint * cf_constraints; \/*  [0..num_cf_constraints - 1] array of such constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
ch	../../libs/libvtrutil/src/picosha2.h	/^inline word_t ch(word_t x, word_t y, word_t z){$/;"	f	namespace:picosha2::detail	signature:(word_t x, word_t y, word_t z)
chain_pattern	base/vpr_types.h	/^	t_model_chain_pattern *chain_pattern; \/* If this is a chain molecule, chain that this molecule matches *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
chain_root_pin	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_pin *chain_root_pin; \/* pointer to logic block input pin that drives this chain from the preceding logic block *\/$/;"	m	struct:t_pack_patterns	access:public
chan_width	base/vpr_context.h	/^    t_chan_width chan_width;$/;"	m	struct:DeviceContext	access:public
chan_width	base/vpr_types.h	/^        int chan_width() const { return chan_width_; }$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:() const
chan_width_	base/vpr_types.h	/^        int chan_width_ = -1;$/;"	m	class:ScreenUpdatePriority::RouteStatus	access:private
chan_x_dist	../../libs/libarchfpga/src/physical_types.h	/^	t_chan chan_x_dist;$/;"	m	struct:t_chan_width_dist	access:public
chan_y_dist	../../libs/libarchfpga/src/physical_types.h	/^	t_chan chan_y_dist;$/;"	m	struct:t_chan_width_dist	access:public
change_button_text	../../libs/libeasygl/src/graphics.cpp	/^void change_button_text(const char *button_name, const char *new_button_text) {$/;"	f	signature:(const char *button_name, const char *new_button_text)
change_button_text	../../libs/libeasygl/src/graphics.cpp	/^void change_button_text(const char* \/*button_text*\/, const char* \/*new_button_text*\/) { }$/;"	f	signature:(const char* , const char* )
change_button_text	../../libs/libeasygl/src/graphics.h	/^void change_button_text(const char *button_text, const char *new_button_text);$/;"	p	signature:(const char *button_text, const char *new_button_text)
change_graphics_background	../../libs/libeasygl/src/graphics.cpp	/^void change_graphics_background(const t_color & background)$/;"	f	signature:(const t_color & background)
change_graphics_background	../../libs/libeasygl/src/graphics.h	/^void change_graphics_background(const t_color& background);	\/\/ <Addition\/Mod: Charles>$/;"	p	signature:(const t_color& background)
channel_width	power/power.h	/^	int channel_width;$/;"	m	struct:t_solution_inf	access:public
channel_widths_unchanged	route/rr_graph.cpp	/^bool channel_widths_unchanged(const t_chan_width& current, const t_chan_width& proposed) {$/;"	f	signature:(const t_chan_width& current, const t_chan_width& proposed)
channel_widths_unchanged	route/rr_graph.cpp	/^bool channel_widths_unchanged(const t_chan_width& current, const t_chan_width& proposed);$/;"	p	file:	signature:(const t_chan_width& current, const t_chan_width& proposed)
chanx_chany_adjacent	route/check_route.cpp	/^static int chanx_chany_adjacent(int chanx_node, int chany_node) {$/;"	f	file:	signature:(int chanx_node, int chany_node)
chanx_chany_adjacent	route/check_route.cpp	/^static int chanx_chany_adjacent(int chanx_node, int chany_node);$/;"	p	file:	signature:(int chanx_node, int chany_node)
chanx_place_cost_fac	place/place.cpp	/^static float** chanx_place_cost_fac; \/\/[0...device_ctx.grid.width()-2]$/;"	v	file:
chany_place_cost_fac	place/place.cpp	/^static float** chany_place_cost_fac; \/\/[0...device_ctx.grid.height()-2]$/;"	v	file:
char_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)$/;"	v
char_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
char_t	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef PUGIXML_CHAR char_t;$/;"	t	namespace:pugi
chartype_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum chartype_t$/;"	g	file:
chartype_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const unsigned char chartype_table[256] =$/;"	v	file:
chartypex_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum chartypex_t$/;"	g	file:
chartypex_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const unsigned char chartypex_table[256] =$/;"	v	file:
checkTokenType	util/token.cpp	/^bool checkTokenType(const t_token token, enum e_token_type token_type) {$/;"	f	signature:(const t_token token, enum e_token_type token_type)
checkTokenType	util/token.h	/^bool checkTokenType(const t_token token, enum e_token_type token_type);$/;"	p	signature:(const t_token token, enum e_token_type token_type)
check_adjacent	route/check_route.cpp	/^static bool check_adjacent(int from_node, int to_node) {$/;"	f	file:	signature:(int from_node, int to_node)
check_adjacent	route/check_route.cpp	/^static bool check_adjacent(int from_node, int to_node);$/;"	p	file:	signature:(int from_node, int to_node)
check_all_tracks_reach_pins	route/rr_graph.cpp	/^static void check_all_tracks_reach_pins($/;"	p	file:	signature:( t_type_ptr type, int *****tracks_connected_to_pin, int max_chan_width, int Fc, enum e_pin_type ipin_or_opin)
check_all_tracks_reach_pins	route/rr_graph.cpp	/^static void check_all_tracks_reach_pins(t_type_ptr type,$/;"	f	file:	signature:(t_type_ptr type, int *****tracks_connected_to_pin, int max_chan_width, int Fc, enum e_pin_type ipin_or_opin)
check_bidir_switchblock	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void check_bidir_switchblock(const t_permutation_map *permutation_map );$/;"	p	file:	signature:(const t_permutation_map *permutation_map )
check_bidir_switchblock	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void check_bidir_switchblock(const t_permutation_map *permutation_map ){$/;"	f	file:	signature:(const t_permutation_map *permutation_map )
check_clb_conn	base/check_netlist.cpp	/^static int check_clb_conn(ClusterBlockId iblk, int num_conn) {$/;"	f	file:	signature:(ClusterBlockId iblk, int num_conn)
check_clb_conn	base/check_netlist.cpp	/^static int check_clb_conn(ClusterBlockId iblk, int num_conn);$/;"	p	file:	signature:(ClusterBlockId iblk, int num_conn)
check_clb_internal_nets	base/check_netlist.cpp	/^static int check_clb_internal_nets(ClusterBlockId iblk) {$/;"	f	file:	signature:(ClusterBlockId iblk)
check_clb_internal_nets	base/check_netlist.cpp	/^static int check_clb_internal_nets(ClusterBlockId iblk);$/;"	p	file:	signature:(ClusterBlockId iblk)
check_cluster_atom_blocks	pack/cluster.cpp	/^static void check_cluster_atom_blocks(t_pb *pb, std::unordered_set<AtomBlockId>& blocks_checked) {$/;"	f	file:	signature:(t_pb *pb, std::unordered_set<AtomBlockId>& blocks_checked)
check_cluster_atom_blocks	pack/cluster.cpp	/^static void check_cluster_atom_blocks(t_pb *pb, std::unordered_set<AtomBlockId>& blocks_checked);$/;"	p	file:	signature:(t_pb *pb, std::unordered_set<AtomBlockId>& blocks_checked)
check_clustering	pack/cluster.cpp	/^static void check_clustering() {$/;"	f	file:	signature:()
check_clustering	pack/cluster.cpp	/^static void check_clustering();$/;"	p	file:	signature:()
check_connections_to_global_clb_pins	base/check_netlist.cpp	/^static void check_connections_to_global_clb_pins(ClusterNetId net_id) {$/;"	f	file:	signature:(ClusterNetId net_id)
check_connections_to_global_clb_pins	base/check_netlist.cpp	/^static void check_connections_to_global_clb_pins(ClusterNetId net_id);$/;"	p	file:	signature:(ClusterNetId net_id)
check_file_name_extension	../../libs/libvtrutil/src/vtr_util.cpp	/^bool check_file_name_extension(const char* file_name,$/;"	f	namespace:vtr	signature:(const char* file_name, const char* file_extension)
check_file_name_extension	../../libs/libvtrutil/src/vtr_util.h	/^    bool check_file_name_extension(const char* file_name,$/;"	p	namespace:vtr	signature:(const char* file_name, const char* file_extension)
check_for_duplicated_names	base/check_netlist.cpp	/^static int check_for_duplicated_names() {$/;"	f	file:	signature:()
check_for_duplicated_names	base/check_netlist.cpp	/^static int check_for_duplicated_names();$/;"	p	file:	signature:()
check_if_budgets_in_bounds	route/route_budgets.cpp	/^void route_budgets::check_if_budgets_in_bounds() {$/;"	f	class:route_budgets	signature:()
check_if_budgets_in_bounds	route/route_budgets.cpp	/^void route_budgets::check_if_budgets_in_bounds(ClusterNetId net_id, ClusterPinId pin_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, ClusterPinId pin_id)
check_if_budgets_in_bounds	route/route_budgets.h	/^    void check_if_budgets_in_bounds();$/;"	p	class:route_budgets	access:private	signature:()
check_if_budgets_in_bounds	route/route_budgets.h	/^    void check_if_budgets_in_bounds(ClusterNetId net_id, ClusterPinId pin_id);$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, ClusterPinId pin_id)
check_init	../../libs/liblog/src/log.cpp	/^static void check_init() {$/;"	f	file:	signature:()
check_init	../../libs/liblog/src/log.cpp	/^static void check_init();$/;"	p	file:	signature:()
check_input_pins_equivalence	pack/pb_type_graph.cpp	/^static bool check_input_pins_equivalence(const t_pb_graph_pin* cur_pin,$/;"	f	file:	signature:(const t_pb_graph_pin* cur_pin, const int i_pin, map<int, int>& logic_equivalent_pins_map, int* line_num)
check_input_pins_equivalence	pack/pb_type_graph.cpp	/^static bool check_input_pins_equivalence(const t_pb_graph_pin* cur_pin,$/;"	p	file:	signature:(const t_pb_graph_pin* cur_pin, const int i_pin, map<int, int>& edges_map, int* line_num)
check_leaf_pb_model_timing_consistency	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^bool check_leaf_pb_model_timing_consistency(const t_pb_type* pb_type, const t_arch& arch) {$/;"	f	signature:(const t_pb_type* pb_type, const t_arch& arch)
check_leaf_pb_model_timing_consistency	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^bool check_leaf_pb_model_timing_consistency(const t_pb_type* pb_type, const t_arch& arch);$/;"	p	file:	signature:(const t_pb_type* pb_type, const t_arch& arch)
check_locally_used_clb_opins	route/check_route.cpp	/^static void check_locally_used_clb_opins(const t_clb_opins_used&  clb_opins_used_locally,$/;"	p	file:	signature:(const t_clb_opins_used& clb_opins_used_locally, enum e_route_type route_type)
check_locally_used_clb_opins	route/check_route.cpp	/^static void check_locally_used_clb_opins(const t_clb_opins_used& clb_opins_used_locally,$/;"	f	file:	signature:(const t_clb_opins_used& clb_opins_used_locally, enum e_route_type route_type)
check_lookahead_pins_used	pack/cluster.cpp	/^static bool check_lookahead_pins_used(t_pb *cur_pb, t_ext_pin_util max_external_pin_util) {$/;"	f	file:	signature:(t_pb *cur_pb, t_ext_pin_util max_external_pin_util)
check_lookahead_pins_used	pack/cluster.cpp	/^static bool check_lookahead_pins_used(t_pb *cur_pb, t_ext_pin_util max_external_pin_util);$/;"	p	file:	signature:(t_pb *cur_pb, t_ext_pin_util max_external_pin_util)
check_macro_can_be_placed	place/place.cpp	/^static int check_macro_can_be_placed(int imacro, int itype, int x, int y, int z) {$/;"	f	file:	signature:(int imacro, int itype, int x, int y, int z)
check_macro_can_be_placed	place/place.cpp	/^static int check_macro_can_be_placed(int imacro, int itype, int x, int y, int z);$/;"	p	file:	signature:(int imacro, int itype, int x, int y, int z)
check_model_clocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^bool check_model_clocks(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model) {$/;"	f	signature:(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model)
check_model_clocks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^bool check_model_clocks(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model);$/;"	p	file:	signature:(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model)
check_model_combinational_sinks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^bool check_model_combinational_sinks(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model) {$/;"	f	signature:(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model)
check_model_combinational_sinks	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^bool check_model_combinational_sinks(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model);$/;"	p	file:	signature:(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model)
check_my_atof_2D	util/token.cpp	/^bool check_my_atof_2D(const int max_i, const int max_j,$/;"	f	signature:(const int max_i, const int max_j, const char *instring, int * num_entries)
check_my_atof_2D	util/token.h	/^bool check_my_atof_2D(const int max_i, const int max_j,$/;"	p	signature:(const int max_i, const int max_j, const char *instring, int* num_entries)
check_netlist	base/check_netlist.cpp	/^void check_netlist() {$/;"	f	signature:()
check_netlist	base/check_netlist.h	/^void check_netlist();$/;"	p	signature:()
check_node	../../libs/libpugiutil/src/pugixml_util.cpp	/^    bool check_node(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& tag_name, const loc_data& loc_data, const ReqOpt req_opt)
check_node	../../libs/libpugiutil/src/pugixml_util.hpp	/^    bool check_node(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& tag_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
check_node_and_range	route/check_route.cpp	/^static void check_node_and_range(int inode, enum e_route_type route_type) {$/;"	f	file:	signature:(int inode, enum e_route_type route_type)
check_node_and_range	route/check_route.cpp	/^static void check_node_and_range(int inode, enum e_route_type route_type);$/;"	p	file:	signature:(int inode, enum e_route_type route_type)
check_non_configurable_edges	route/check_route.cpp	/^static bool check_non_configurable_edges(ClusterNetId net, const t_non_configurable_rr_sets& non_configurable_rr_sets) {$/;"	f	file:	signature:(ClusterNetId net, const t_non_configurable_rr_sets& non_configurable_rr_sets)
check_non_configurable_edges	route/check_route.cpp	/^static bool check_non_configurable_edges(ClusterNetId net, const t_non_configurable_rr_sets& non_configurable_rr_sets);$/;"	p	file:	signature:(ClusterNetId net, const t_non_configurable_rr_sets& non_configurable_rr_sets)
check_pb_graph	pack/pb_type_graph.cpp	/^static int check_pb_graph() {$/;"	f	file:	signature:()
check_pb_graph	pack/pb_type_graph.cpp	/^static int check_pb_graph();$/;"	p	file:	signature:()
check_pb_node_rec	pack/pb_type_graph.cpp	/^static void check_pb_node_rec(const t_pb_graph_node* pb_graph_node);$/;"	p	file:	signature:(const t_pb_graph_node* pb_graph_node)
check_pb_node_rec	pack/pb_type_graph.cpp	/^static void check_pb_node_rec(const t_pb_graph_node* pb_graph_node){$/;"	f	file:	signature:(const t_pb_graph_node* pb_graph_node)
check_place	place/place.cpp	/^static void check_place(const t_placer_costs& costs,$/;"	f	file:	signature:(const t_placer_costs& costs, const PlaceDelayModel& delay_model, enum e_place_algorithm place_algorithm)
check_place	place/place.cpp	/^static void check_place(const t_placer_costs& costs,$/;"	p	file:	signature:(const t_placer_costs& costs, const PlaceDelayModel& delay_model, enum e_place_algorithm place_algorithm)
check_repeated_edges_at_pb_pin	pack/pb_type_graph.cpp	/^static void check_repeated_edges_at_pb_pin(t_pb_graph_pin* cur_pin);$/;"	p	file:	signature:(t_pb_graph_pin* cur_pin)
check_repeated_edges_at_pb_pin	pack/pb_type_graph.cpp	/^static void check_repeated_edges_at_pb_pin(t_pb_graph_pin* cur_pin){$/;"	f	file:	signature:(t_pb_graph_pin* cur_pin)
check_route	route/check_route.cpp	/^void check_route(enum e_route_type route_type, int num_switches) {$/;"	f	signature:(enum e_route_type route_type, int num_switches)
check_route	route/check_route.h	/^void check_route(enum e_route_type route_type, int num_switches);$/;"	p	signature:(enum e_route_type route_type, int num_switches)
check_rr_edge	route/check_rr_graph.cpp	/^static void check_rr_edge(int from_node, int from_edge, int to_node);$/;"	p	file:	signature:(int from_node, int from_edge, int to_node)
check_rr_edge	route/check_rr_graph.cpp	/^static void check_rr_edge(int from_node, int iedge, int to_node) {$/;"	f	file:	signature:(int from_node, int iedge, int to_node)
check_rr_graph	route/check_rr_graph.cpp	/^void check_rr_graph(const t_graph_type graph_type,$/;"	f	signature:(const t_graph_type graph_type, const DeviceGrid& grid, const int num_rr_switches, const t_type_ptr types)
check_rr_graph	route/check_rr_graph.h	/^void check_rr_graph(const t_graph_type graph_type,$/;"	p	signature:(const t_graph_type graph_type, const DeviceGrid& grid, const int num_rr_switches, const t_type_ptr types)
check_rr_node	route/check_rr_graph.cpp	/^void check_rr_node(int inode, enum e_route_type route_type, const DeviceContext& device_ctx) {$/;"	f	signature:(int inode, enum e_route_type route_type, const DeviceContext& device_ctx)
check_rr_node	route/check_rr_graph.h	/^void check_rr_node(int inode, enum e_route_type route_type, const DeviceContext& device_ctx);$/;"	p	signature:(int inode, enum e_route_type route_type, const DeviceContext& device_ctx)
check_sink	route/check_route.cpp	/^static void check_sink(int inode, ClusterNetId net_id, bool * pin_done) {$/;"	f	file:	signature:(int inode, ClusterNetId net_id, bool * pin_done)
check_sink	route/check_route.cpp	/^static void check_sink(int inode, ClusterNetId net_id, bool * pin_done);$/;"	p	file:	signature:(int inode, ClusterNetId net_id, bool * pin_done)
check_source	route/check_route.cpp	/^static void check_source(int inode, ClusterNetId net_id) {$/;"	f	file:	signature:(int inode, ClusterNetId net_id)
check_source	route/check_route.cpp	/^static void check_source(int inode, ClusterNetId net_id);$/;"	p	file:	signature:(int inode, ClusterNetId net_id)
check_string_to_number_format	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool check_string_to_number_format(const char_t* string)$/;"	f	signature:(const char_t* string)
check_switch	route/check_route.cpp	/^static void check_switch(t_trace *tptr, int num_switch) {$/;"	f	file:	signature:(t_trace *tptr, int num_switch)
check_switch	route/check_route.cpp	/^static void check_switch(t_trace *tptr, int num_switch);$/;"	p	file:	signature:(t_trace *tptr, int num_switch)
check_switchblock	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void check_switchblock(const t_switchblock_inf* sb, const t_arch* arch){$/;"	f	signature:(const t_switchblock_inf* sb, const t_arch* arch)
check_switchblock	../../libs/libarchfpga/src/parse_switchblocks.h	/^void check_switchblock(const t_switchblock_inf *sb, const t_arch* arch);$/;"	p	signature:(const t_switchblock_inf *sb, const t_arch* arch)
check_timing_graph	timing/path_delay2.cpp	/^void check_timing_graph() {$/;"	f	signature:()
check_timing_graph	timing/path_delay2.h	/^void check_timing_graph();$/;"	p	signature:()
check_unbuffered_edges	route/check_rr_graph.cpp	/^static void check_unbuffered_edges(int from_node) {$/;"	f	file:	signature:(int from_node)
check_unbuffered_edges	route/check_rr_graph.cpp	/^static void check_unbuffered_edges(int from_node);$/;"	p	file:	signature:(int from_node)
check_unidir_switchblock	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void check_unidir_switchblock(const t_switchblock_inf *sb );$/;"	p	file:	signature:(const t_switchblock_inf *sb )
check_unidir_switchblock	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void check_unidir_switchblock(const t_switchblock_inf *sb ){$/;"	f	file:	signature:(const t_switchblock_inf *sb )
check_wireconn	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void check_wireconn(const t_arch* arch, const t_wireconn_inf& wireconn) {$/;"	f	file:	signature:(const t_arch* arch, const t_wireconn_inf& wireconn)
check_wireconn	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void check_wireconn(const t_arch* arch, const t_wireconn_inf& wireconn);$/;"	p	file:	signature:(const t_arch* arch, const t_wireconn_inf& wireconn)
checkpoint	base/vpr_signal_handler.cpp	/^void checkpoint() {$/;"	f	signature:()
checkpoint	base/vpr_signal_handler.cpp	/^void checkpoint();$/;"	p	file:	signature:()
child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::child(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node child(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
child	route/route_tree_type.h	/^	t_rt_node *child;$/;"	m	struct:t_linked_rt_edge	access:public
child	timing/net_delay.cpp	/^	t_rc_node *child;$/;"	m	struct:t_linked_rc_edge	file:	access:public
child_list	route/route_tree_type.h	/^		t_linked_rt_edge *child_list;$/;"	m	union:t_rt_node::__anon7	access:public
child_list	timing/net_delay.cpp	/^		t_linked_rc_edge *child_list;$/;"	m	union:t_rc_node::__anon11	file:	access:public
child_pb_graph_nodes	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node ***child_pb_graph_nodes; \/* [0..num_modes-1][0..num_pb_type_in_mode-1][0..num_pb-1] *\/$/;"	m	struct:t_pb_graph_node	access:public
child_pbs	base/vpr_types.h	/^	t_pb **child_pbs = nullptr; \/* children pbs attached to this pb [0..num_child_pb_types - 1][0..child_type->num_pb - 1] *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::child_value() const$/;"	f	class:pugi::xml_node	signature:() const
child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::child_value(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* child_value() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* child_value(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
children	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_object_range<xml_named_node_iterator> xml_node::children(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
children	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_object_range<xml_node_iterator> xml_node::children() const$/;"	f	class:pugi::xml_node	signature:() const
children	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range<xml_named_node_iterator> children(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
children	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range<xml_node_iterator> children() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
children	power/power.h	/^	t_mux_node * children; \/* Multiplexers that drive the inputs [0..num_inputs-1] *\/$/;"	m	struct:t_mux_node	access:public
chunk_delete	../../libs/libvtrutil/src/vtr_memory.h	/^    void chunk_delete(T* obj, t_chunk * \/*chunk_info*\/) {$/;"	f	namespace:vtr	signature:(T* obj, t_chunk * )
chunk_malloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* chunk_malloc(size_t size, t_chunk *chunk_info) {$/;"	f	namespace:vtr	signature:(size_t size, t_chunk *chunk_info)
chunk_malloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* chunk_malloc(size_t size, t_chunk *chunk_info);$/;"	p	namespace:vtr	signature:(size_t size, t_chunk *chunk_info)
chunk_new	../../libs/libvtrutil/src/vtr_memory.h	/^    T* chunk_new(t_chunk *chunk_info) {$/;"	f	namespace:vtr	signature:(t_chunk *chunk_info)
chunk_ptr_head	../../libs/libvtrutil/src/vtr_memory.h	/^        t_linked_vptr *chunk_ptr_head = nullptr;$/;"	m	struct:vtr::t_chunk	access:public
cilk_for	../../libs/libvtrutil/src/vtr_cilk.h	/^    #define cilk_for /;"	d
cilk_spawn	../../libs/libvtrutil/src/vtr_cilk.h	/^    #define cilk_spawn /;"	d
cilk_sync	../../libs/libvtrutil/src/vtr_cilk.h	/^    #define cilk_sync /;"	d
circuit_format	base/read_options.h	/^    argparse::ArgValue<e_circuit_format> circuit_format;$/;"	m	struct:t_options	access:public
class_inf	../../libs/libarchfpga/src/physical_types.h	/^	t_class *class_inf = nullptr; \/* [0..num_class-1] *\/$/;"	m	struct:t_type_descriptor	access:public
class_num	route/rr_node.cpp	/^short t_rr_node::class_num() const {$/;"	f	class:t_rr_node	signature:() const
class_num	route/rr_node.h	/^            int16_t class_num;$/;"	m	union:t_rr_node::__anon9	access:public
class_num	route/rr_node.h	/^        short class_num() const; \/\/Same as ptc_num() but checks that type() is consistent$/;"	p	class:t_rr_node	access:public	signature:() const
class_type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pb_type_class class_type = UNKNOWN_CLASS;$/;"	m	struct:t_pb_type	typeref:enum:t_pb_type::e_pb_type_class	access:public
classic_tnode_atom_pin	base/atom_lookup.cpp	/^AtomPinId AtomLookup::classic_tnode_atom_pin(const int tnode_index) const {$/;"	f	class:AtomLookup	signature:(const int tnode_index) const
classic_tnode_atom_pin	base/atom_lookup.h	/^        AtomPinId classic_tnode_atom_pin(const int tnode_index) const;$/;"	p	class:AtomLookup	access:public	signature:(const int tnode_index) const
classic_wire_lookahead_cost	route/router_lookahead.cpp	/^float ClassicLookahead::classic_wire_lookahead_cost(int inode, int target_node, float criticality, float R_upstream) const {$/;"	f	class:ClassicLookahead	signature:(int inode, int target_node, float criticality, float R_upstream) const
classic_wire_lookahead_cost	route/router_lookahead.h	/^        float classic_wire_lookahead_cost(int node, int target_node, float criticality, float R_upstream) const;$/;"	p	class:ClassicLookahead	access:private	signature:(int node, int target_node, float criticality, float R_upstream) const
clb_delay_calc_	timing/PostClusterDelayCalculator.h	/^    ClbDelayCalc clb_delay_calc_;$/;"	m	class:PostClusterDelayCalculator	access:private
clb_index	draw/intra_logic_block.h	/^		ClusterBlockId clb_index;$/;"	m	struct:t_selected_sub_block_info::clb_pin_tuple	access:public
clb_index	draw/intra_logic_block.h	/^		const ClusterBlockId clb_index;$/;"	m	struct:t_selected_sub_block_info::gnode_clb_pair	access:public
clb_input_to_internal_sink_delay	timing/clb_delay_calc.h	/^        float clb_input_to_internal_sink_delay(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:public	signature:(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const
clb_input_to_internal_sink_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::clb_input_to_internal_sink_delay(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(const ClusterBlockId block_id, const int pin_index, int internal_sink_pin, DelayType delay_type) const
clb_net	base/atom_lookup.cpp	/^ClusterNetId AtomLookup::clb_net(const AtomNetId net_id) const {$/;"	f	class:AtomLookup	signature:(const AtomNetId net_id) const
clb_net	base/atom_lookup.h	/^		ClusterNetId clb_net(const AtomNetId net_id) const;$/;"	p	class:AtomLookup	access:public	signature:(const AtomNetId net_id) const
clb_net_density	power/power_util.cpp	/^float clb_net_density(ClusterNetId net_idx) {$/;"	f	signature:(ClusterNetId net_idx)
clb_net_density	power/power_util.h	/^float clb_net_density(ClusterNetId net_idx);$/;"	p	signature:(ClusterNetId net_idx)
clb_net_power	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_net_power> clb_net_power;$/;"	m	struct:PowerContext	access:public
clb_net_prob	power/power_util.cpp	/^float clb_net_prob(ClusterNetId net_idx) {$/;"	f	signature:(ClusterNetId net_idx)
clb_net_prob	power/power_util.h	/^float clb_net_prob(ClusterNetId net_idx);$/;"	p	signature:(ClusterNetId net_idx)
clb_nlist	base/vpr_context.h	/^	ClusteredNetlist clb_nlist;$/;"	m	struct:ClusteringContext	access:public
clb_opins_used_locally	base/vpr_context.h	/^    t_clb_opins_used clb_opins_used_locally; \/\/[0..cluster_ctx.clb_nlist.blocks().size()-1][0..num_class-1]$/;"	m	struct:RoutingContext	access:public
clb_pin_tuple	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple(ClusterBlockId clb_index_, const t_pb_graph_node* pb_gnode_) :$/;"	f	class:t_selected_sub_block_info::clb_pin_tuple	signature:(ClusterBlockId clb_index_, const t_pb_graph_node* pb_gnode_)
clb_pin_tuple	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple(const AtomPinId atom_pin) {$/;"	f	class:t_selected_sub_block_info::clb_pin_tuple	signature:(const AtomPinId atom_pin)
clb_pin_tuple	draw/intra_logic_block.h	/^		clb_pin_tuple(ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode);$/;"	p	struct:t_selected_sub_block_info::clb_pin_tuple	access:public	signature:(ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode)
clb_pin_tuple	draw/intra_logic_block.h	/^		clb_pin_tuple(const AtomPinId atom_pin);$/;"	p	struct:t_selected_sub_block_info::clb_pin_tuple	access:public	signature:(const AtomPinId atom_pin)
clb_pin_tuple	draw/intra_logic_block.h	/^	struct clb_pin_tuple {$/;"	s	struct:t_selected_sub_block_info	access:public
clean_and_reorder_ids	base/netlist_utils.h	/^vtr::vector_map<Id, Id> clean_and_reorder_ids(const vtr::vector_map<Id, Id>& id_map) {$/;"	f	signature:(const vtr::vector_map<Id, Id>& id_map)
clean_and_reorder_values	base/netlist_utils.h	/^vtr::vector_map<Id, T> clean_and_reorder_values(const vtr::vector_map<Id, T>& values, const vtr::vector_map<Id, Id>& id_map) {$/;"	f	signature:(const vtr::vector_map<Id, T>& values, const vtr::vector_map<Id, Id>& id_map)
clean_blocks	base/netlist.h	/^        void clean_blocks(const vtr::vector_map<BlockId, BlockId>& block_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map)
clean_blocks	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_blocks(const vtr::vector_map<BlockId, BlockId>& block_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map)
clean_blocks_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_blocks_impl(const vtr::vector_map<AtomBlockId,AtomBlockId>& block_id_map) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomBlockId,AtomBlockId>& block_id_map)
clean_blocks_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_blocks_impl(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& block_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& block_id_map)
clean_blocks_impl	base/netlist.h	/^        virtual void clean_blocks_impl(const vtr::vector_map<BlockId, BlockId>& block_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map)
clean_nets	base/netlist.h	/^        void clean_nets(const vtr::vector_map<NetId, NetId>& net_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<NetId, NetId>& net_id_map)
clean_nets	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_nets(const vtr::vector_map<NetId, NetId>& net_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<NetId, NetId>& net_id_map)
clean_nets_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_nets_impl(const vtr::vector_map<AtomNetId, AtomNetId>& \/*net_id_map*\/) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomNetId, AtomNetId>& )
clean_nets_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_nets_impl(const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map)
clean_nets_impl	base/netlist.h	/^        virtual void clean_nets_impl(const vtr::vector_map<NetId, NetId>& net_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<NetId, NetId>& net_id_map)
clean_pins	base/netlist.h	/^        void clean_pins(const vtr::vector_map<PinId, PinId>& pin_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
clean_pins	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_pins(const vtr::vector_map<PinId, PinId>& pin_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
clean_pins_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_pins_impl(const vtr::vector_map<AtomPinId, AtomPinId>& \/*pin_id_map*\/) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPinId, AtomPinId>& )
clean_pins_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_pins_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map)
clean_pins_impl	base/netlist.h	/^        virtual void clean_pins_impl(const vtr::vector_map<PinId, PinId>& pin_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
clean_ports	base/netlist.h	/^        void clean_ports(const vtr::vector_map<PortId, PortId>& port_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map)
clean_ports	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::clean_ports(const vtr::vector_map<PortId, PortId>& port_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<PortId, PortId>& port_id_map)
clean_ports_impl	base/atom_netlist.cpp	/^void AtomNetlist::clean_ports_impl(const vtr::vector_map<AtomPortId,AtomPortId>& port_id_map) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPortId,AtomPortId>& port_id_map)
clean_ports_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::clean_ports_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map)
clean_ports_impl	base/netlist.h	/^        virtual void clean_ports_impl(const vtr::vector_map<PortId, PortId>& port_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map)
clear	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void clear()$/;"	f	class:compact_hash_table	access:public	signature:()
clear	../../libs/libeasygl/src/fontcache.cpp	/^void FontCache::clear() {$/;"	f	class:FontCache	signature:()
clear	../../libs/libeasygl/src/fontcache.h	/^    void clear();$/;"	p	class:FontCache	access:public	signature:()
clear	../../libs/libvtrutil/src/vtr_bimap.h	/^        void clear() { map_.clear(); inverse_map_.clear(); }$/;"	f	class:vtr::bimap	access:public	signature:()
clear	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void clear() { vec_.clear(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
clear	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void clear() { vec_.clear(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
clear	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void clear() {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:()
clear	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void clear() {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:()
clear	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void clear() { vec_.clear(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
clear	base/device_grid.cpp	/^void DeviceGrid::clear() {$/;"	f	class:DeviceGrid	signature:()
clear	base/device_grid.h	/^        void clear();$/;"	p	class:DeviceGrid	access:public	signature:()
clear	draw/intra_logic_block.cpp	/^void t_selected_sub_block_info::clear() {$/;"	f	class:t_selected_sub_block_info	signature:()
clear	draw/intra_logic_block.h	/^	void clear();$/;"	p	struct:t_selected_sub_block_info	access:public	signature:()
clear	pack/cluster_router.cpp	/^		void clear() {$/;"	f	class:reservable_pq	access:public	signature:()
clear	route/cb_metrics.h	/^	void clear(){$/;"	f	class:Conn_Block_Metrics	access:public	signature:()
clear_cache	timing/PostClusterDelayCalculator.h	/^    void clear_cache();$/;"	p	class:PostClusterDelayCalculator	access:public	signature:()
clear_cache	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::clear_cache() {$/;"	f	class:PostClusterDelayCalculator	signature:()
clear_cost_entries	route/router_lookahead_map.cpp	/^	void clear_cost_entries(){$/;"	f	class:Expansion_Cost_Entry	access:public	signature:()
clear_draw_rr_annotations	draw/draw.h	/^void clear_draw_rr_annotations();$/;"	p	signature:()
clear_force_reroute_for_connection	route/connection_based_routing.h	/^	void clear_force_reroute_for_connection(int rr_sink_node);$/;"	p	class:Connection_based_routing_resources	access:public	signature:(int rr_sink_node)
clear_force_reroute_for_connection	route/route_timing.cpp	/^void Connection_based_routing_resources::clear_force_reroute_for_connection(int rr_sink_node) {$/;"	f	class:Connection_based_routing_resources	signature:(int rr_sink_node)
clear_force_reroute_for_net	route/connection_based_routing.h	/^	void clear_force_reroute_for_net();$/;"	p	class:Connection_based_routing_resources	access:public	signature:()
clear_force_reroute_for_net	route/route_timing.cpp	/^void Connection_based_routing_resources::clear_force_reroute_for_net() {$/;"	f	class:Connection_based_routing_resources	signature:()
clearscreen	../../libs/libeasygl/src/graphics.cpp	/^clearscreen() {$/;"	f	signature:()
clearscreen	../../libs/libeasygl/src/graphics.cpp	/^void clearscreen(void) { }$/;"	f	signature:(void)
clearscreen	../../libs/libeasygl/src/graphics.h	/^void clearscreen();$/;"	p	signature:()
clock	../../libs/libarchfpga/src/logic_types.h	/^    std::string clock; \/* The clock associated with this pin (if the pin is sequential) *\/$/;"	m	struct:t_model_ports	access:public
clock	../../libs/libarchfpga/src/physical_types.h	/^	char *clock;$/;"	m	struct:t_pin_to_pin_annotation	access:public
clock_arch	base/vpr_context.h	/^    t_clock_arch * clock_arch;$/;"	m	struct:DeviceContext	access:public
clock_delay	base/vpr_types.h	/^	float clock_delay; \/* The time taken for a clock signal to get to the flip-flop or I\/O (assumed 0 for I\/Os). *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
clock_domain	base/vpr_types.h	/^	int clock_domain; \/* Index of the clock in timing_ctx.sdc->constrained_clocks which this flip-flop or I\/O is constrained on. *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
clock_inf	../../libs/libarchfpga/src/physical_types.h	/^	t_clock_network *clock_inf; \/* Details about each clock *\/$/;"	m	struct:t_clock_arch	access:public
clock_modeling	base/read_options.h	/^    argparse::ArgValue<e_clock_modeling> clock_modeling;$/;"	m	struct:t_options	access:public
clock_modeling	base/vpr_types.h	/^    e_clock_modeling clock_modeling; \/\/How clocks should be handled$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
clock_name	base/vpr_types.h	/^	char * clock_name; \/* Clock it was constrained on *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
clock_names	timing/read_sdc.cpp	/^	char ** clock_names;$/;"	m	struct:t_sdc_exclusive_group	file:	access:public
clock_net	base/vpr_types.h	/^	int clock_net = 0; \/* Records clock net driving a flip-flop, valid only for lowest-level, flip-flop PBs *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
clock_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **clock_pins; \/* [0..num_clock_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:t_pb_graph_node	access:public
clocks	../../libs/libarchfpga/src/physical_types.h	/^	t_clock_arch * clocks;$/;"	m	struct:t_arch	access:public
close_font	../../libs/libeasygl/src/fontcache.cpp	/^void FontCache::close_font(font_ptr \/*font*\/) {$/;"	f	class:FontCache	signature:(font_ptr )
close_font	../../libs/libeasygl/src/fontcache.cpp	/^void FontCache::close_font(font_ptr font) {$/;"	f	class:FontCache	signature:(font_ptr font)
close_font	../../libs/libeasygl/src/fontcache.h	/^    static void close_font(font_ptr font);$/;"	p	class:FontCache	access:private	signature:(font_ptr font)
close_graphics	../../libs/libeasygl/src/graphics.cpp	/^close_graphics() {$/;"	f	signature:()
close_graphics	../../libs/libeasygl/src/graphics.cpp	/^void close_graphics(void) { }$/;"	f	signature:(void)
close_graphics	../../libs/libeasygl/src/graphics.h	/^void close_graphics();$/;"	p	signature:()
close_postscript	../../libs/libeasygl/src/graphics.cpp	/^void close_postscript() {$/;"	f	signature:()
close_postscript	../../libs/libeasygl/src/graphics.cpp	/^void close_postscript(void) { }$/;"	f	signature:(void)
close_postscript	../../libs/libeasygl/src/graphics.h	/^void close_postscript();$/;"	p	signature:()
cluster_placement_primitive	../../libs/libarchfpga/src/physical_types.h	/^	t_cluster_placement_primitive *cluster_placement_primitive; \/* pointer to indexing structure useful during packing stage *\/$/;"	m	struct:t_pb_graph_node	access:public
cluster_seed_type	base/read_options.h	/^    argparse::ArgValue<e_cluster_seed> cluster_seed_type;$/;"	m	struct:t_options	access:public
cluster_seed_type	base/vpr_types.h	/^	enum e_cluster_seed cluster_seed_type;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	typeref:enum:ScreenUpdatePriority::t_packer_opts::e_cluster_seed	access:public
clustered_pin_connected_atom_pins_	base/clustered_netlist_utils.h	/^        vtr::vector<ClusterPinId,std::vector<AtomPinId>> clustered_pin_connected_atom_pins_;$/;"	m	class:ClusteredPinAtomPinsLookup	access:private
clustering	base/vpr_context.h	/^        const ClusteringContext& clustering() const { return clustering_; }$/;"	f	class:VprContext	access:public	signature:() const
clustering_	base/vpr_context.h	/^        ClusteringContext clustering_;$/;"	m	class:VprContext	access:private
clustering_xml_block	pack/output_clustering.cpp	/^static void clustering_xml_block(pugi::xml_node parent_node, t_type_ptr type, t_pb * pb, int pb_index, const t_pb_routes& pb_route) {$/;"	f	file:	signature:(pugi::xml_node parent_node, t_type_ptr type, t_pb * pb, int pb_index, const t_pb_routes& pb_route)
clustering_xml_interconnect_text	pack/output_clustering.cpp	/^static std::string clustering_xml_interconnect_text(t_type_ptr type, int inode, const t_pb_routes& pb_route) {$/;"	f	file:	signature:(t_type_ptr type, int inode, const t_pb_routes& pb_route)
clustering_xml_net_text	pack/output_clustering.cpp	/^static const char * clustering_xml_net_text(AtomNetId net_id) {$/;"	f	file:	signature:(AtomNetId net_id)
clustering_xml_open_block	pack/output_clustering.cpp	/^static void clustering_xml_open_block(pugi::xml_node parent_node, t_type_ptr type, t_pb_graph_node * pb_graph_node,$/;"	f	file:	signature:(pugi::xml_node parent_node, t_type_ptr type, t_pb_graph_node * pb_graph_node, int pb_index, bool is_used, const t_pb_routes& pb_route)
code	timing/slre.cpp	/^  unsigned char code[256];$/;"	m	struct:slre	file:	access:public
code_size	timing/slre.cpp	/^  int code_size;$/;"	m	struct:slre	file:	access:public
coincident	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool coincident(Point<T> point) const;$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> point) const
coincident	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool coincident(Point<T> point) const;$/;"	p	class:vtr::RectUnion	access:public	signature:(Point<T> point) const
coincident	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool Rect<T>::coincident(Point<T> point) const {$/;"	f	class:vtr::Rect	signature:(Point<T> point) const
coincident	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool RectUnion<T>::coincident(Point<T> point) const {$/;"	f	class:vtr::RectUnion	signature:(Point<T> point) const
col	../../libs/libpugiutil/src/pugixml_loc.cpp	/^std::size_t loc_data::col(std::ptrdiff_t offset) const {$/;"	f	class:pugiutil::loc_data	signature:(std::ptrdiff_t offset) const
col	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t col(pugi::xml_node node) const {$/;"	f	class:pugiutil::loc_data	access:public	signature:(pugi::xml_node node) const
col	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t col(std::ptrdiff_t offset) const;$/;"	p	class:pugiutil::loc_data	access:public	signature:(std::ptrdiff_t offset) const
collect_congested_rr_nodes	route/route_common.cpp	/^std::vector<int> collect_congested_rr_nodes() {$/;"	f	signature:()
collect_congested_rr_nodes	route/route_export.h	/^std::vector<int> collect_congested_rr_nodes();$/;"	p	signature:()
collect_pb_atoms	draw/intra_logic_block.cpp	/^std::vector<AtomBlockId> collect_pb_atoms(const t_pb* pb) {$/;"	f	signature:(const t_pb* pb)
collect_pb_atoms	draw/intra_logic_block.cpp	/^std::vector<AtomBlockId> collect_pb_atoms(const t_pb* pb);$/;"	p	file:	signature:(const t_pb* pb)
collect_pb_atoms_recurr	draw/intra_logic_block.cpp	/^void collect_pb_atoms_recurr(const t_pb* pb, std::vector<AtomBlockId>& atoms) {$/;"	f	signature:(const t_pb* pb, std::vector<AtomBlockId>& atoms)
collect_pb_atoms_recurr	draw/intra_logic_block.cpp	/^void collect_pb_atoms_recurr(const t_pb* pb, std::vector<AtomBlockId>& atoms);$/;"	p	file:	signature:(const t_pb* pb, std::vector<AtomBlockId>& atoms)
collect_route_tree_connections	route/route_tree_timing.cpp	/^void collect_route_tree_connections(const t_rt_node* node, std::set<std::tuple<int,int,int>>& connections) {$/;"	f	signature:(const t_rt_node* node, std::set<std::tuple<int,int,int>>& connections)
collect_route_tree_connections	route/route_tree_timing.cpp	/^void collect_route_tree_connections(const t_rt_node* node, std::set<std::tuple<int,int,int>>& connections);$/;"	p	file:	signature:(const t_rt_node* node, std::set<std::tuple<int,int,int>>& connections)
collect_rr_node_nets	route/route_common.cpp	/^std::vector<std::set<ClusterNetId>> collect_rr_node_nets() {$/;"	f	signature:()
collect_rr_node_nets	route/route_export.h	/^std::vector<std::set<ClusterNetId>> collect_rr_node_nets();$/;"	p	signature:()
color	../../libs/libvtrutil/src/vtr_color_map.cpp	/^Color<float> ColorMap::color(float value) const {$/;"	f	class:vtr::ColorMap	signature:(float value) const
color	../../libs/libvtrutil/src/vtr_color_map.h	/^        Color<float> color(float value) const;$/;"	p	class:vtr::ColorMap	access:public	signature:(float value) const
color	draw/draw_types.h	/^	t_color color;$/;"	m	struct:__anon12	access:public
color2hsl	draw/hsl.cpp	/^hsl color2hsl(t_color color) {$/;"	f	signature:(t_color color)
color2hsl	draw/hsl.h	/^hsl   color2hsl(t_color in);$/;"	p	signature:(t_color in)
color_data_	../../libs/libvtrutil/src/vtr_color_map.h	/^        std::vector<Color<float>> color_data_;$/;"	m	class:vtr::ColorMap	access:private
color_map	draw/draw_types.h	/^    std::unique_ptr<const vtr::ColorMap> color_map = nullptr;$/;"	m	struct:t_draw_state	access:public
color_types	../../libs/libeasygl/src/easygl_constants.h	/^enum color_types {$/;"	g
colormap_to_use	../../libs/libeasygl/src/graphics_state.h	/^    Colormap colormap_to_use;$/;"	m	class:t_x11_state	access:public
combinational_sink_ports	../../libs/libarchfpga/src/logic_types.h	/^    std::vector<std::string> combinational_sink_ports; \/* The other ports on this model which are combinationally driven by this port *\/$/;"	m	struct:t_model_ports	access:public
combine_two_xbars	route/cb_metrics.cpp	/^static t_xbar_matrix combine_two_xbars(const t_xbar_matrix *xbar1, const t_xbar_matrix *xbar2){$/;"	f	file:	signature:(const t_xbar_matrix *xbar1, const t_xbar_matrix *xbar2)
commit_lookahead_pins_used	pack/cluster.cpp	/^static void commit_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:	signature:(t_pb *cur_pb)
commit_lookahead_pins_used	pack/cluster.cpp	/^static void commit_lookahead_pins_used(t_pb *cur_pb);$/;"	p	file:	signature:(t_pb *cur_pb)
commit_primitive	pack/cluster_placement.cpp	/^void commit_primitive(t_cluster_placement_stats *cluster_placement_stats,$/;"	f	signature:(t_cluster_placement_stats *cluster_placement_stats, const t_pb_graph_node *primitive)
commit_primitive	pack/cluster_placement.h	/^void commit_primitive(t_cluster_placement_stats *cluster_placement_stats,$/;"	p	signature:(t_cluster_placement_stats *cluster_placement_stats, const t_pb_graph_node *primitive)
commit_remove_rt	pack/cluster_router.cpp	/^static void commit_remove_rt(t_lb_trace *rt, t_lb_router_data *router_data, e_commit_remove op) {$/;"	f	file:	signature:(t_lb_trace *rt, t_lb_router_data *router_data, e_commit_remove op)
commit_remove_rt	pack/cluster_router.cpp	/^static void commit_remove_rt(t_lb_trace *rt, t_lb_router_data *router_data, e_commit_remove op);$/;"	p	file:	signature:(t_lb_trace *rt, t_lb_router_data *router_data, e_commit_remove op)
commonly_used	base/vpr_context.h	/^    t_power_commonly_used* commonly_used;$/;"	m	struct:PowerContext	access:public
comp	../../libs/libvtrutil/src/vtr_flat_map.h	/^        Compare comp;$/;"	m	class:vtr::flat_map::value_compare	access:private
comp_bb_cost	place/place.cpp	/^static float comp_bb_cost(e_cost_methods method) {$/;"	f	file:	signature:(e_cost_methods method)
comp_bb_cost	place/place.cpp	/^static float comp_bb_cost(e_cost_methods method);$/;"	p	file:	signature:(e_cost_methods method)
comp_td_costs	place/place.cpp	/^static void comp_td_costs(const PlaceDelayModel& delay_model, float *timing_cost, float *connection_delay_sum) {$/;"	f	file:	signature:(const PlaceDelayModel& delay_model, float *timing_cost, float *connection_delay_sum)
comp_td_costs	place/place.cpp	/^static void comp_td_costs(const PlaceDelayModel& delay_model, float *timing_cost, float *connection_delay_sum);$/;"	p	file:	signature:(const PlaceDelayModel& delay_model, float *timing_cost, float *connection_delay_sum)
comp_td_point_to_point_delay	place/place.cpp	/^static float comp_td_point_to_point_delay(const PlaceDelayModel& delay_model, ClusterNetId net_id, int ipin) {$/;"	f	file:	signature:(const PlaceDelayModel& delay_model, ClusterNetId net_id, int ipin)
comp_td_point_to_point_delay	place/place.cpp	/^static float comp_td_point_to_point_delay(const PlaceDelayModel& delay_model, ClusterNetId net_id, int ipin);$/;"	p	file:	signature:(const PlaceDelayModel& delay_model, ClusterNetId net_id, int ipin)
comp_td_point_to_point_delays	place/place.cpp	/^static void comp_td_point_to_point_delays(const PlaceDelayModel& delay_model) {$/;"	f	file:	signature:(const PlaceDelayModel& delay_model)
comp_td_point_to_point_delays	place/place.cpp	/^static void comp_td_point_to_point_delays(const PlaceDelayModel& delay_model);$/;"	p	file:	signature:(const PlaceDelayModel& delay_model)
comp_width	base/place_and_route.cpp	/^static float comp_width(t_chan * chan, float x, float separation) {$/;"	f	file:	signature:(t_chan * chan, float x, float separation)
comp_width	base/place_and_route.cpp	/^static float comp_width(t_chan * chan, float x, float separation);$/;"	p	file:	signature:(t_chan * chan, float x, float separation)
compact_alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t compact_alignment = 1 << compact_alignment_log2;$/;"	v	file:
compact_alignment_log2	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t compact_alignment_log2 = 2;$/;"	v	file:
compact_get_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_memory_page* compact_get_page(const void* object, int header_offset)$/;"	f	signature:(const void* object, int header_offset)
compact_get_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <int header_offset, typename T> PUGI__FN_NO_INLINE T* compact_get_value(const void* object)$/;"	f	signature:(const void* object)
compact_hash_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_hash_table(): _items(0), _capacity(0), _count(0)$/;"	f	class:compact_hash_table	access:public	signature:()
compact_hash_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class compact_hash_table$/;"	c	file:
compact_hash_table::_capacity	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _capacity;$/;"	m	class:compact_hash_table	file:	access:private
compact_hash_table::_count	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _count;$/;"	m	class:compact_hash_table	file:	access:private
compact_hash_table::_items	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		item_t* _items;$/;"	m	class:compact_hash_table	file:	access:private
compact_hash_table::clear	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void clear()$/;"	f	class:compact_hash_table	access:public	signature:()
compact_hash_table::compact_hash_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_hash_table(): _items(0), _capacity(0), _count(0)$/;"	f	class:compact_hash_table	access:public	signature:()
compact_hash_table::find	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void** find(const void* key)$/;"	f	class:compact_hash_table	access:public	signature:(const void* key)
compact_hash_table::hash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static unsigned int hash(const void* key)$/;"	f	class:compact_hash_table	file:	access:private	signature:(const void* key)
compact_hash_table::insert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void** insert(const void* key)$/;"	f	class:compact_hash_table	access:public	signature:(const void* key)
compact_hash_table::item_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		struct item_t$/;"	s	class:compact_hash_table	file:	access:private
compact_hash_table::item_t::key	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const void* key;$/;"	m	struct:compact_hash_table::item_t	file:	access:public
compact_hash_table::item_t::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			void* value;$/;"	m	struct:compact_hash_table::item_t	file:	access:public
compact_hash_table::rehash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool rehash();$/;"	p	class:compact_hash_table	file:	access:private	signature:()
compact_hash_table::rehash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE bool compact_hash_table::rehash()$/;"	f	class:compact_hash_table	signature:()
compact_hash_table::reserve	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool reserve()$/;"	f	class:compact_hash_table	access:public	signature:()
compact_header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_header(xml_memory_page* page, unsigned int flags)$/;"	f	class:compact_header	access:public	signature:(xml_memory_page* page, unsigned int flags)
compact_header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class compact_header$/;"	c	file:
compact_header::_flags	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _flags;$/;"	m	class:compact_header	file:	access:private
compact_header::_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _page;$/;"	m	class:compact_header	file:	access:private
compact_header::compact_header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_header(xml_memory_page* page, unsigned int flags)$/;"	f	class:compact_header	access:public	signature:(xml_memory_page* page, unsigned int flags)
compact_header::get_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* get_page() const$/;"	f	class:compact_header	access:public	signature:() const
compact_header::operator &	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uintptr_t operator&(uintptr_t mod) const$/;"	f	class:compact_header	access:public	signature:(uintptr_t mod) const
compact_header::operator &=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator&=(uintptr_t mod)$/;"	f	class:compact_header	access:public	signature:(uintptr_t mod)
compact_header::operator |=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator|=(uintptr_t mod)$/;"	f	class:compact_header	access:public	signature:(uintptr_t mod)
compact_page_marker	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint32_t* compact_page_marker;$/;"	m	struct:xml_memory_page	file:	access:public
compact_pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_pointer(): _data(0)$/;"	f	class:compact_pointer	access:public	signature:()
compact_pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T, int header_offset, int start = -126> class compact_pointer$/;"	c	file:
compact_pointer::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _data;$/;"	m	class:compact_pointer	file:	access:private
compact_pointer::compact_pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_pointer(): _data(0)$/;"	f	class:compact_pointer	access:public	signature:()
compact_pointer::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* operator->() const$/;"	f	class:compact_pointer	access:public	signature:() const
compact_pointer::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(T* value)$/;"	f	class:compact_pointer	access:public	signature:(T* value)
compact_pointer::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(const compact_pointer& rhs)$/;"	f	class:compact_pointer	access:public	signature:(const compact_pointer& rhs)
compact_pointer::operator T*	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		operator T*() const$/;"	f	class:compact_pointer	access:public	signature:() const
compact_pointer_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_pointer_parent(): _data(0)$/;"	f	class:compact_pointer_parent	access:public	signature:()
compact_pointer_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T, int header_offset> class compact_pointer_parent$/;"	c	file:
compact_pointer_parent::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t _data;$/;"	m	class:compact_pointer_parent	file:	access:private
compact_pointer_parent::compact_pointer_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_pointer_parent(): _data(0)$/;"	f	class:compact_pointer_parent	access:public	signature:()
compact_pointer_parent::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* operator->() const$/;"	f	class:compact_pointer_parent	access:public	signature:() const
compact_pointer_parent::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(T* value)$/;"	f	class:compact_pointer_parent	access:public	signature:(T* value)
compact_pointer_parent::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(const compact_pointer_parent& rhs)$/;"	f	class:compact_pointer_parent	access:public	signature:(const compact_pointer_parent& rhs)
compact_pointer_parent::operator T*	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		operator T*() const$/;"	f	class:compact_pointer_parent	access:public	signature:() const
compact_set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <int header_offset, typename T> PUGI__FN_NO_INLINE void compact_set_value(const void* object, T* value)$/;"	f	signature:(const void* object, T* value)
compact_shared_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* compact_shared_parent;$/;"	m	struct:xml_memory_page	file:	access:public
compact_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_string(): _data(0)$/;"	f	class:compact_string	access:public	signature:()
compact_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <int header_offset, int base_offset> class compact_string$/;"	c	file:
compact_string::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		unsigned char _data;$/;"	m	class:compact_string	file:	access:private
compact_string::compact_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_string(): _data(0)$/;"	f	class:compact_string	access:public	signature:()
compact_string::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(char_t* value)$/;"	f	class:compact_string	access:public	signature:(char_t* value)
compact_string::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(const compact_string& rhs)$/;"	f	class:compact_string	access:public	signature:(const compact_string& rhs)
compact_string::operator char_t*	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		operator char_t*() const$/;"	f	class:compact_string	access:public	signature:() const
compact_string_base	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* compact_string_base;$/;"	m	struct:xml_memory_page	file:	access:public
compare_bit	../../libs/librtlnumber/src/rtl_int.cpp	/^	compare_bit(uint8_t set_to){result = set_to;}$/;"	f	class:compare_bit	access:public	signature:(uint8_t set_to)
compare_bit	../../libs/librtlnumber/src/rtl_int.cpp	/^class compare_bit$/;"	c	file:
compare_bit::compare_bit	../../libs/librtlnumber/src/rtl_int.cpp	/^	compare_bit(uint8_t set_to){result = set_to;}$/;"	f	class:compare_bit	access:public	signature:(uint8_t set_to)
compare_bit::is_eq	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_eq(){	return (result&(0x2)); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::is_ge	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_ge(){	return (result&(0x3)); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::is_gt	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_gt(){	return (result&(0x1)); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::is_le	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_le(){	return (result&(0x6)); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::is_lt	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_lt(){	return (result&(0x4)); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::is_ne	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_ne(){	return (!is_eq()); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::is_unk	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_unk(){	return (!result); }$/;"	f	class:compare_bit	access:public	signature:()
compare_bit::result	../../libs/librtlnumber/src/rtl_int.cpp	/^	uint8_t result = 0x0;$/;"	m	class:compare_bit	file:	access:private
compare_eq	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class Comp> static bool compare_eq(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)
compare_expansion_node	pack/pack_types.h	/^class compare_expansion_node {$/;"	c
compare_expansion_node::operator ()	pack/pack_types.h	/^    bool operator()(t_expansion_node& e1, t_expansion_node& e2) \/\/ Returns true if t1 is earlier than t2$/;"	f	class:compare_expansion_node	access:public	signature:(t_expansion_node& e1, t_expansion_node& e2)
compare_molecule_gain	pack/cluster.cpp	/^static int compare_molecule_gain(const void *a, const void *b) {$/;"	f	file:	signature:(const void *a, const void *b)
compare_molecule_gain	pack/cluster.cpp	/^static int compare_molecule_gain(const void *a, const void *b);$/;"	p	file:	signature:(const void *a, const void *b)
compare_pack_pattern	pack/prepack.cpp	/^static int compare_pack_pattern(const t_pack_patterns *pattern_a, const t_pack_patterns *pattern_b) {$/;"	f	file:	signature:(const t_pack_patterns *pattern_a, const t_pack_patterns *pattern_b)
compare_pack_pattern	pack/prepack.cpp	/^static int compare_pack_pattern(const t_pack_patterns *pattern_a, const t_pack_patterns *pattern_b);$/;"	p	file:	signature:(const t_pack_patterns *pattern_a, const t_pack_patterns *pattern_b)
compare_rel	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class Comp> static bool compare_rel(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)
compare_tatum_classic_constraints	timing/timing_util.cpp	/^void compare_tatum_classic_constraints() {$/;"	f	signature:()
compare_tatum_classic_constraints	timing/timing_util.h	/^void compare_tatum_classic_constraints();$/;"	p	signature:()
compile	timing/slre.cpp	/^static void compile(struct slre *r, const char **re) {$/;"	f	file:	signature:(struct slre *r, const char **re)
compile2	timing/slre.cpp	/^static const char *compile2(struct slre *r, const char *re) {$/;"	f	file:	signature:(struct slre *r, const char *re)
component_callibration	power/power.h	/^	PowerSpicedComponent ** component_callibration;$/;"	m	struct:t_power_commonly_used	access:public
component_usage	power/PowerSpicedComponent.h	/^	float (*component_usage)(int num_inputs, float transistor_size);$/;"	m	class:PowerSpicedComponent	access:public
components	power/power_components.h	/^	t_power_usage * components;$/;"	m	struct:t_power_breakdown	access:public
compress	base/netlist.h	/^        IdRemapper compress();$/;"	p	class:Netlist	access:public	signature:()
compress	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::IdRemapper Netlist<BlockId, PortId, PinId, NetId>::compress() {$/;"	f	class:Netlist	signature:()
compress_ids	base/netlist_utils.h	/^vtr::vector_map<Id, Id> compress_ids(const vtr::vector_map<Id, Id>& ids) {$/;"	f	signature:(const vtr::vector_map<Id, Id>& ids)
compute_and_mark_lookahead_pins_used	pack/cluster.cpp	/^static void compute_and_mark_lookahead_pins_used(const AtomBlockId blk_id) {$/;"	f	file:	signature:(const AtomBlockId blk_id)
compute_and_mark_lookahead_pins_used	pack/cluster.cpp	/^static void compute_and_mark_lookahead_pins_used(const AtomBlockId blk_id);$/;"	p	file:	signature:(const AtomBlockId blk_id)
compute_and_mark_lookahead_pins_used_for_pin	pack/cluster.cpp	/^static void compute_and_mark_lookahead_pins_used_for_pin($/;"	p	file:	signature:( const t_pb_graph_pin *pb_graph_pin, const t_pb *primitive_pb, const AtomNetId net_id)
compute_and_mark_lookahead_pins_used_for_pin	pack/cluster.cpp	/^static void compute_and_mark_lookahead_pins_used_for_pin(const t_pb_graph_pin *pb_graph_pin, const t_pb *primitive_pb, const AtomNetId net_id) {$/;"	f	file:	signature:(const t_pb_graph_pin *pb_graph_pin, const t_pb *primitive_pb, const AtomNetId net_id)
compute_delta_delay_model	place/timing_place_lookup.cpp	/^static vtr::Matrix<float> compute_delta_delay_model(const t_placer_opts& placer_opts, const t_router_opts& router_opts, int longest_length) {$/;"	f	file:	signature:(const t_placer_opts& placer_opts, const t_router_opts& router_opts, int longest_length)
compute_delta_delay_model	place/timing_place_lookup.cpp	/^static vtr::Matrix<float> compute_delta_delay_model(const t_placer_opts& placer_opts, const t_router_opts& router_opts, int longest_length);$/;"	p	file:	signature:(const t_placer_opts& placer_opts, const t_router_opts& router_opts, int longest_length)
compute_delta_delays	place/timing_place_lookup.cpp	/^static vtr::Matrix<float> compute_delta_delays(const t_placer_opts& palcer_opts, const t_router_opts& router_opts, size_t longest_length);$/;"	p	file:	signature:(const t_placer_opts& palcer_opts, const t_router_opts& router_opts, size_t longest_length)
compute_delta_delays	place/timing_place_lookup.cpp	/^static vtr::Matrix<float> compute_delta_delays(const t_placer_opts& placer_opts, const t_router_opts& router_opts, size_t longest_length) {$/;"	f	file:	signature:(const t_placer_opts& placer_opts, const t_router_opts& router_opts, size_t longest_length)
compute_override_delay_model	place/timing_place_lookup.cpp	/^static std::unique_ptr<OverrideDelayModel> compute_override_delay_model(const t_router_opts& router_opts, std::unique_ptr<PlaceDelayModel> base_model) {$/;"	f	file:	signature:(const t_router_opts& router_opts, std::unique_ptr<PlaceDelayModel> base_model)
compute_override_delay_model	place/timing_place_lookup.cpp	/^static std::unique_ptr<OverrideDelayModel> compute_override_delay_model(const t_router_opts& router_opts, std::unique_ptr<PlaceDelayModel> base_model);$/;"	p	file:	signature:(const t_router_opts& router_opts, std::unique_ptr<PlaceDelayModel> base_model)
compute_perimeter_switchblocks	route/build_switchblocks.cpp	/^static void compute_perimeter_switchblocks(t_chan_details *chan_details_x, t_chan_details *chan_details_y,$/;"	f	file:	signature:(t_chan_details *chan_details_x, t_chan_details *chan_details_y, vector<t_switchblock_inf> *switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_conns)
compute_perimeter_switchblocks	route/build_switchblocks.cpp	/^static void compute_perimeter_switchblocks(t_chan_details *chan_details_x, t_chan_details *chan_details_y,$/;"	p	file:	signature:(t_chan_details *chan_details_x, t_chan_details *chan_details_y, vector<t_switchblock_inf> *switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_conns)
compute_place_delay_model	place/timing_place_lookup.cpp	/^std::unique_ptr<PlaceDelayModel> compute_place_delay_model($/;"	f	signature:( t_placer_opts placer_opts, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_chan_width_dist chan_width_dist, const t_direct_inf *directs, const int num_directs)
compute_place_delay_model	place/timing_place_lookup.h	/^std::unique_ptr<PlaceDelayModel> compute_place_delay_model($/;"	p	signature:( t_placer_opts placer_opts, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_chan_width_dist chan_width_dist, const t_direct_inf *directs, const int num_directs)
compute_primitive_base_cost	util/vpr_utils.cpp	/^float compute_primitive_base_cost(const t_pb_graph_node *primitive) {$/;"	f	signature:(const t_pb_graph_node *primitive)
compute_primitive_base_cost	util/vpr_utils.h	/^float compute_primitive_base_cost(const t_pb_graph_node *primitive);$/;"	p	signature:(const t_pb_graph_node *primitive)
compute_router_lookahead	route/router_lookahead_map.cpp	/^void compute_router_lookahead(int num_segments){$/;"	f	signature:(int num_segments)
compute_router_lookahead	route/router_lookahead_map.h	/^void compute_router_lookahead(int num_segments);$/;"	p	signature:(int num_segments)
compute_switchblock_row	route/build_switchblocks.cpp	/^static void compute_switchblock_row(int sb_row_size, t_chan_details *chan_details_x, t_chan_details *chan_details_y,$/;"	f	file:	signature:(int sb_row_size, t_chan_details *chan_details_x, t_chan_details *chan_details_y, vector<t_switchblock_inf> *switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_row)
compute_switchblock_row	route/build_switchblocks.cpp	/^static void compute_switchblock_row(int sb_row_size, t_chan_details *chan_details_x, t_chan_details *chan_details_y,$/;"	p	file:	signature:(int sb_row_size, t_chan_details *chan_details_x, t_chan_details *chan_details_y, vector<t_switchblock_inf> *switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_row)
compute_wire_connections	route/build_switchblocks.cpp	/^static void compute_wire_connections(int x_coord, int y_coord,$/;"	f	file:	signature:(int x_coord, int y_coord, enum e_side from_side, enum e_side to_side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, t_switchblock_inf* sb, const DeviceGrid& grid, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_conns, vtr::RandState& rand_state)
compute_wire_connections	route/build_switchblocks.cpp	/^static void compute_wire_connections(int x_coord, int y_coord,$/;"	p	file:	signature:(int x_coord, int y_coord, enum e_side from_side, enum e_side to_side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, t_switchblock_inf *sb, const DeviceGrid& grid, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_conns, vtr::RandState& rand_state)
compute_wireconn_connections	route/build_switchblocks.cpp	/^static void compute_wireconn_connections(const DeviceGrid& grid, e_directionality directionality,$/;"	f	file:	signature:(const DeviceGrid& grid, e_directionality directionality, const t_chan_details& from_chan_details, const t_chan_details& to_chan_details, Switchblock_Lookup sb_conn, int from_x, int from_y, int to_x, int to_y, t_rr_type from_chan_type, t_rr_type to_chan_type, t_wire_type_sizes *wire_type_sizes, t_switchblock_inf *sb, t_wireconn_inf *wireconn_ptr, t_sb_connection_map *sb_conns, vtr::RandState& rand_state)
compute_wireconn_connections	route/build_switchblocks.cpp	/^static void compute_wireconn_connections(const DeviceGrid& grid, e_directionality directionality,$/;"	p	file:	signature:(const DeviceGrid& grid, e_directionality directionality, const t_chan_details& from_chan_details, const t_chan_details& to_chan_details, Switchblock_Lookup sb_conn, int from_x, int from_y, int to_x, int to_y, t_rr_type from_chan_type, t_rr_type to_chan_type, t_wire_type_sizes *wire_type_sizes, t_switchblock_inf *sb, t_wireconn_inf *wireconn_ptr, t_sb_connection_map *sb_conns, vtr::RandState& rand_state)
condition	base/netlist_writer.cpp	/^        std::string condition() const { return condition_; }$/;"	f	class:Arc	access:public	signature:() const
condition_	base/netlist_writer.cpp	/^        std::string condition_;$/;"	m	class:Arc	file:	access:private
configs_used	route/cb_metrics.h	/^	std::map<int, long double> configs_used;$/;"	m	class:Wire_Counting	access:public
configurable	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_arch_switch_inf::configurable() const {$/;"	f	class:t_arch_switch_inf	signature:() const
configurable	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_rr_switch_inf::configurable() const {$/;"	f	class:t_rr_switch_inf	signature:() const
configurable	../../libs/libarchfpga/src/physical_types.h	/^        bool configurable() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
configurable	../../libs/libarchfpga/src/physical_types.h	/^        bool configurable() const;$/;"	p	struct:t_rr_switch_inf	access:public	signature:() const
configurable_edges	route/rr_node.h	/^        edge_idx_range configurable_edges() const { return vtr::make_range(edge_idx_iterator(0), edge_idx_iterator(num_edges() - num_non_configurable_edges())); }$/;"	f	class:t_rr_node	access:public	signature:() const
congested_routing_iteration_threshold_frac	base/read_options.h	/^    argparse::ArgValue<float> congested_routing_iteration_threshold_frac;$/;"	m	struct:t_options	access:public
congested_routing_iteration_threshold_frac	base/vpr_types.h	/^    float congested_routing_iteration_threshold_frac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
congestion	route/router_lookahead_map.cpp	/^	float congestion;$/;"	m	class:Cost_Entry	file:	access:public
congestion_analysis	base/vpr_types.h	/^	bool congestion_analysis;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
congestion_analysis	route/route_profiling.cpp	/^void congestion_analysis() {}$/;"	f	namespace:profiling	signature:()
congestion_analysis	route/route_profiling.h	/^void congestion_analysis();$/;"	p	namespace:profiling	signature:()
congestion_upstream	route/router_lookahead_map.cpp	/^	float congestion_upstream;$/;"	m	class:PQ_Entry	file:	access:public
connected_atom_pins	base/clustered_netlist_utils.cpp	/^ClusteredPinAtomPinsLookup::atom_pin_range ClusteredPinAtomPinsLookup::connected_atom_pins(ClusterPinId clustered_pin) const {$/;"	f	class:ClusteredPinAtomPinsLookup	signature:(ClusterPinId clustered_pin) const
connected_atom_pins	base/clustered_netlist_utils.h	/^        atom_pin_range connected_atom_pins(ClusterPinId clustered_pin) const;$/;"	p	class:ClusteredPinAtomPinsLookup	access:public	signature:(ClusterPinId clustered_pin) const
connection_criticality_tolerance	route/connection_based_routing.h	/^	float connection_criticality_tolerance;$/;"	m	class:Connection_based_routing_resources	access:private
connection_delay_optimality_tolerance	route/connection_based_routing.h	/^	float connection_delay_optimality_tolerance;$/;"	m	class:Connection_based_routing_resources	access:private
connection_driven	base/vpr_types.h	/^	bool connection_driven;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
connection_driven_clustering	base/read_options.h	/^    argparse::ArgValue<bool> connection_driven_clustering;$/;"	m	struct:t_options	access:public
connectiongain	pack/pack_types.h	/^	std::map<AtomBlockId, float> connectiongain; \/* Weighted sum of connections to attraction function *\/$/;"	m	struct:t_pb_stats	access:public
connections	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_connections *connections; \/* linked list of connections of logic blocks in pattern *\/$/;"	m	struct:t_pack_pattern_block	access:public
connections_routed	route/router_stats.h	/^    size_t connections_routed = 0;$/;"	m	struct:RouterStats	access:public
const_gen_inference	base/read_options.h	/^    argparse::ArgValue<e_const_gen_inference> const_gen_inference;$/;"	m	struct:t_options	access:public
const_gen_inference	base/vpr_types.h	/^    e_const_gen_inference const_gen_inference = e_const_gen_inference::COMB;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
const_gen_inference_	base/read_blif.cpp	/^        e_const_gen_inference const_gen_inference_ = e_const_gen_inference::COMB;$/;"	m	struct:BlifAllocCallback	file:	access:private
const_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef It const_iterator;$/;"	t	class:pugi::xml_object_range	access:public
const_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef const xpath_node* const_iterator;$/;"	t	class:pugi::xpath_node_set	access:public
const_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::const_iterator const_iterator;$/;"	t	class:vtr::flat_map	access:public
const_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::const_iterator const_iterator;$/;"	t	class:vtr::linear_map	access:public
const_iterator	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::const_iterator const_iterator;$/;"	t	class:vtr::vector_map	access:public
const_reference	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef const value_type& const_reference;$/;"	t	class:vtr::flat_map	access:public
const_reference	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef const value_type& const_reference;$/;"	t	class:vtr::linear_map	access:public
const_reference	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::const_reference const_reference;$/;"	t	class:vtr::vector_map	access:public
const_reverse_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::const_reverse_iterator const_reverse_iterator;$/;"	t	class:vtr::flat_map	access:public
const_reverse_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::const_reverse_iterator const_reverse_iterator;$/;"	t	class:vtr::linear_map	access:public
const_reverse_iterator	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::const_reverse_iterator const_reverse_iterator;$/;"	t	class:vtr::vector_map	access:public
constant_net_delay	base/vpr_types.h	/^	float constant_net_delay; \/* timing information when place and route not run *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
constant_net_method	base/read_options.h	/^    argparse::ArgValue<e_constant_net_method> constant_net_method;$/;"	m	struct:t_options	access:public
constant_net_method	base/vpr_types.h	/^    e_constant_net_method constant_net_method; \/\/How constant nets should be handled$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
constrain_all_ios	timing/read_sdc2.cpp	/^void constrain_all_ios(const AtomNetlist& netlist,$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& tc, tatum::DomainId input_domain, tatum::DomainId output_domain, tatum::Time input_delay, tatum::Time output_delay)
constrain_all_ios	timing/read_sdc2.cpp	/^void constrain_all_ios(const AtomNetlist& netlist,$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& tc, tatum::DomainId input_domain, tatum::DomainId output_domain, tatum::Time input_delay, tatum::Time output_delay)
constrained_clocks	base/vpr_types.h	/^	t_clock * constrained_clocks; \/* [0..timing_ctx.sdc->num_constrained_clocks - 1] array of clocks with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
constrained_inputs	base/vpr_types.h	/^	t_io * constrained_inputs; \/* [0..num_constrained_inputs - 1] array of inputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
constrained_outputs	base/vpr_types.h	/^	t_io * constrained_outputs; \/* [0..num_constrained_outputs - 1] array of outputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
constraint	base/vpr_types.h	/^	float constraint;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
constraints	base/vpr_context.h	/^    std::shared_ptr<tatum::TimingConstraints> constraints;$/;"	m	struct:TimingContext	access:public
construct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xml_memory_page* construct(void* memory)$/;"	f	struct:xml_memory_page	access:public	signature:(void* memory)
cont	../../libs/libvtrutil/src/vtr_util.cpp	/^static int cont; \/* line continued? (used by strtok)*\/$/;"	m	namespace:vtr	file:
containing_block_index	draw/intra_logic_block.h	/^	ClusterBlockId containing_block_index;$/;"	m	struct:t_selected_sub_block_info	access:private
contains	../../libs/libvtrutil/src/vtr_bimap.h	/^        bool contains(const K key) const { return find(key) != end(); }$/;"	f	class:vtr::bimap	access:public	signature:(const K key) const
contains	../../libs/libvtrutil/src/vtr_bimap.h	/^        bool contains(const V value) const { return find(value) != inverse_end(); }$/;"	f	class:vtr::bimap	access:public	signature:(const V value) const
contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool contains(Point<T> point) const;$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> point) const
contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool contains(Point<T> point) const;$/;"	p	class:vtr::RectUnion	access:public	signature:(Point<T> point) const
contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool Rect<T>::contains(Point<T> point) const {$/;"	f	class:vtr::Rect	signature:(Point<T> point) const
contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool RectUnion<T>::contains(Point<T> point) const {$/;"	f	class:vtr::RectUnion	signature:(Point<T> point) const
contains	../../libs/libvtrutil/src/vtr_vector_map.h	/^        bool contains(const K key) const { return size_t(key) < vec_.size(); }$/;"	f	class:vtr::vector_map	access:public	signature:(const K key) const
contents	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const xpath_lexer_string& contents() const$/;"	f	class:xpath_lexer	access:public	signature:() const
convert_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_buffer(char_t*& out_buffer, size_t& out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)$/;"	f	signature:(char_t*& out_buffer, size_t& out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)
convert_buffer_endian_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_buffer_endian_swap(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)$/;"	f	signature:(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
convert_buffer_generic	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename D> PUGI__FN bool convert_buffer_generic(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, D)$/;"	f	signature:(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, D)
convert_buffer_latin1	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_buffer_latin1(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)$/;"	f	signature:(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
convert_buffer_output	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t convert_buffer_output(char_t* \/* r_char *\/, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)$/;"	f	signature:(char_t* , uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)
convert_buffer_output	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t convert_buffer_output(char_t* r_char, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)$/;"	f	signature:(char_t* r_char, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)
convert_buffer_output_generic	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename D, typename T> PUGI__FN size_t convert_buffer_output_generic(typename T::value_type dest, const char_t* data, size_t length, D, T)$/;"	f	signature:(typename T::value_type dest, const char_t* data, size_t length, D, T)
convert_buffer_output_generic	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename D, typename T> PUGI__FN size_t convert_buffer_output_generic(typename T::value_type dest, const char_t* data, size_t length, D, T, bool opt_swap)$/;"	f	signature:(typename T::value_type dest, const char_t* data, size_t length, D, T, bool opt_swap)
convert_number_to_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_number_to_boolean(double value)$/;"	f	signature:(double value)
convert_number_to_mantissa_exponent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void convert_number_to_mantissa_exponent(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)$/;"	f	signature:(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)
convert_number_to_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_string convert_number_to_string(double value, xpath_allocator* alloc)$/;"	f	signature:(double value, xpath_allocator* alloc)
convert_number_to_string_special	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* convert_number_to_string_special(double value)$/;"	f	signature:(double value)
convert_path_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char* convert_path_heap(const wchar_t* str)$/;"	f	signature:(const wchar_t* str)
convert_sink_nodes_to_net_pins	route/connection_based_routing.h	/^	void convert_sink_nodes_to_net_pins(std::vector<int>& rr_sink_nodes) const;$/;"	p	class:Connection_based_routing_resources	access:public	signature:(std::vector<int>& rr_sink_nodes) const
convert_sink_nodes_to_net_pins	route/route_timing.cpp	/^void Connection_based_routing_resources::convert_sink_nodes_to_net_pins(vector<int>& rr_sink_nodes) const {$/;"	f	class:Connection_based_routing_resources	signature:(vector<int>& rr_sink_nodes) const
convert_string_to_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double convert_string_to_number(const char_t* string)$/;"	f	signature:(const char_t* string)
convert_switch_index	util/vpr_utils.cpp	/^static int convert_switch_index(int *switch_index, int *fanin) {$/;"	f	file:	signature:(int *switch_index, int *fanin)
convert_to_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator convert_to_iterator(const_iterator const_iter) {$/;"	f	class:vtr::flat_map	access:private	signature:(const_iterator const_iter)
convert_to_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator convert_to_iterator(const_iterator const_iter) {$/;"	f	class:vtr::linear_map	access:private	signature:(const_iterator const_iter)
convert_to_win_color	../../libs/libeasygl/src/graphics.cpp	/^COLORREF convert_to_win_color(const t_color& src) {$/;"	f	signature:(const t_color& src)
convert_to_win_color	../../libs/libeasygl/src/graphics.cpp	/^COLORREF convert_to_win_color(const t_color& src);$/;"	p	file:	signature:(const t_color& src)
convert_wchar_endian_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void convert_wchar_endian_swap(wchar_t* result, const wchar_t* data, size_t length)$/;"	f	signature:(wchar_t* result, const wchar_t* data, size_t length)
coords_out_of_bounds	route/build_switchblocks.cpp	/^static bool coords_out_of_bounds(const DeviceGrid& grid, int x_coord, int y_coord,$/;"	f	file:	signature:(const DeviceGrid& grid, int x_coord, int y_coord, e_rr_type chan_type)
coords_out_of_bounds	route/build_switchblocks.cpp	/^static bool coords_out_of_bounds(const DeviceGrid& grid, int x_coord, int y_coord,$/;"	p	file:	signature:(const DeviceGrid& grid, int x_coord, int y_coord, e_rr_type chan_type)
copy_backwards	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I> void copy_backwards(I begin, I end, I target)$/;"	f	signature:(I begin, I end, I target)
copy_off_screen_buffer_to_screen	../../libs/libeasygl/src/graphics.cpp	/^void copy_off_screen_buffer_to_screen() { }$/;"	f	signature:()
copy_off_screen_buffer_to_screen	../../libs/libeasygl/src/graphics.cpp	/^void copy_off_screen_buffer_to_screen() {$/;"	f	signature:()
copy_off_screen_buffer_to_screen	../../libs/libeasygl/src/graphics.h	/^void copy_off_screen_buffer_to_screen();$/;"	p	signature:()
copy_xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool copy_xpath_variable(xpath_variable* lhs, const xpath_variable* rhs)$/;"	f	signature:(xpath_variable* lhs, const xpath_variable* rhs)
cost	base/vpr_types.h	/^	float cost;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
cost	pack/pack_types.h	/^	float cost;$/;"	m	struct:t_expansion_node	access:public
cost	place/place.cpp	/^    float cost;$/;"	m	struct:t_placer_costs	file:	access:public
cost	route/route_common.h	/^	float cost = 0.;$/;"	m	struct:t_heap	access:public
cost	route/router_lookahead_map.cpp	/^	float cost;          \/\/the cost of the path to get to this node$/;"	m	class:PQ_Entry	file:	access:public
cost_index	route/rr_node.cpp	/^short t_rr_node::cost_index() const {$/;"	f	class:t_rr_node	signature:() const
cost_index	route/rr_node.h	/^        short cost_index() const;$/;"	p	class:t_rr_node	access:public	signature:() const
cost_index_	route/rr_node.h	/^        int8_t cost_index_ = -1;$/;"	m	class:t_rr_node	access:private
cost_vector	route/router_lookahead_map.cpp	/^	vector<Cost_Entry> cost_vector;$/;"	m	class:Expansion_Cost_Entry	file:	access:private
count	../../libs/libvtrutil/src/vtr_flat_map.h	/^        size_type count(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
count	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type count(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
count	../../libs/libvtrutil/src/vtr_vector_map.h	/^        size_t count(const K key) const { return contains(key) ? 1 : 0; }$/;"	f	class:vtr::vector_map	access:public	signature:(const K key) const
count	util/hash.h	/^	int count;$/;"	m	struct:t_hash	access:public
count	util/histogram.h	/^    size_t count = 0;$/;"	m	struct:HistogramBucket	access:public
count_attributes	../../libs/libpugiutil/src/pugixml_util.cpp	/^    size_t count_attributes(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt)
count_attributes	../../libs/libpugiutil/src/pugixml_util.hpp	/^    size_t count_attributes(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
count_bidir_routing_transistors	route/rr_graph_area.cpp	/^static void count_bidir_routing_transistors(int num_switch, int wire_to_ipin_switch,$/;"	p	file:	signature:(int num_switch, int wire_to_ipin_switch, float R_minW_nmos, float R_minW_pmos, const float trans_sram_bit)
count_bidir_routing_transistors	route/rr_graph_area.cpp	/^void count_bidir_routing_transistors(int num_switch, int wire_to_ipin_switch,$/;"	f	signature:(int num_switch, int wire_to_ipin_switch, float R_minW_nmos, float R_minW_pmos, const float trans_sram_bit)
count_children	../../libs/libpugiutil/src/pugixml_util.cpp	/^    size_t count_children(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt)
count_children	../../libs/libpugiutil/src/pugixml_util.cpp	/^    size_t count_children(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt)
count_children	../../libs/libpugiutil/src/pugixml_util.hpp	/^    size_t count_children(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt)
count_children	../../libs/libpugiutil/src/pugixml_util.hpp	/^    size_t count_children(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
count_clock_fanouts	timing/timing_util.cpp	/^std::map<tatum::DomainId, size_t> count_clock_fanouts(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& setup_analyzer) {$/;"	f	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& setup_analyzer)
count_clock_fanouts	timing/timing_util.h	/^std::map<tatum::DomainId,size_t> count_clock_fanouts(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& setup_analyzer);$/;"	p	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& setup_analyzer)
count_connections	place/place.cpp	/^static int count_connections() {$/;"	f	file:	signature:()
count_connections	place/place.cpp	/^static int count_connections();$/;"	p	file:	signature:()
count_grid_tiles	base/SetupGrid.cpp	/^size_t count_grid_tiles(const DeviceGrid& grid) {$/;"	f	signature:(const DeviceGrid& grid)
count_grid_tiles	base/SetupGrid.h	/^size_t count_grid_tiles(const DeviceGrid& grid);$/;"	p	signature:(const DeviceGrid& grid)
count_instances	base/device_grid.cpp	/^void DeviceGrid::count_instances() {$/;"	f	class:DeviceGrid	signature:()
count_instances	base/device_grid.h	/^        void count_instances();$/;"	p	class:DeviceGrid	access:private	signature:()
count_molecules	pack/cluster.cpp	/^static int count_molecules(t_pack_molecule* molecule_head) {$/;"	f	file:	signature:(t_pack_molecule* molecule_head)
count_molecules	pack/cluster.cpp	/^static int count_molecules(t_pack_molecule* molecule_head);$/;"	p	file:	signature:(t_pack_molecule* molecule_head)
count_netlist_clocks	base/stats.cpp	/^int count_netlist_clocks() {$/;"	f	signature:()
count_netlist_clocks	base/stats.h	/^int count_netlist_clocks();$/;"	p	signature:()
count_netlist_clocks_as_constrained_clocks	timing/read_sdc.cpp	/^static void count_netlist_clocks_as_constrained_clocks() {$/;"	f	file:	signature:()
count_netlist_clocks_as_constrained_clocks	timing/read_sdc.cpp	/^static void count_netlist_clocks_as_constrained_clocks();$/;"	p	file:	signature:()
count_netlist_ios_as_constrained_ios	timing/read_sdc.cpp	/^static void count_netlist_ios_as_constrained_ios(char * clock_name, float io_delay) {$/;"	f	file:	signature:(char * clock_name, float io_delay)
count_netlist_ios_as_constrained_ios	timing/read_sdc.cpp	/^static void count_netlist_ios_as_constrained_ios(char * clock_name, float io_delay);$/;"	p	file:	signature:(char * clock_name, float io_delay)
count_routing_transistors	route/rr_graph_area.cpp	/^void count_routing_transistors(enum e_directionality directionality,$/;"	f	signature:(enum e_directionality directionality, int num_switch, int wire_to_ipin_switch, t_segment_inf * segment_inf, float R_minW_nmos, float R_minW_pmos)
count_routing_transistors	route/rr_graph_area.h	/^void count_routing_transistors(enum e_directionality directionality,$/;"	p	signature:(enum e_directionality directionality, int num_switch, int wire_to_ipin_switch, t_segment_inf * segment_inf, float R_minW_nmos, float R_minW_pmos)
count_rr_segment_types	route/rr_graph_indexed_data.cpp	/^static std::vector<size_t> count_rr_segment_types() {$/;"	f	file:	signature:()
count_rr_segment_types	route/rr_graph_indexed_data.cpp	/^static std::vector<size_t> count_rr_segment_types();$/;"	p	file:	signature:()
count_switch_configurations	route/cb_metrics.cpp	/^static long double count_switch_configurations(const int level, const int signals_left, const int capacity_left, vector<int> *config,$/;"	f	file:	signature:(const int level, const int signals_left, const int capacity_left, vector<int> *config, map<int, Wire_Counting> *count_map)
count_unidir_routing_transistors	route/rr_graph_area.cpp	/^static void count_unidir_routing_transistors(t_segment_inf * segment_inf,$/;"	p	file:	signature:(t_segment_inf * segment_inf, int wire_to_ipin_switch, float R_minW_nmos, float R_minW_pmos, const float trans_sram_bit)
count_unidir_routing_transistors	route/rr_graph_area.cpp	/^void count_unidir_routing_transistors(t_segment_inf * \/*segment_inf*\/,$/;"	f	signature:(t_segment_inf * , int wire_to_ipin_switch, float R_minW_nmos, float R_minW_pmos, const float trans_sram_bit)
count_valid_refs	base/netlist_utils.h	/^size_t count_valid_refs(R range, const vtr::vector_map<Id, Id>& id_map) {$/;"	f	signature:(R range, const vtr::vector_map<Id, Id>& id_map)
count_wire_type_sizes	route/build_switchblocks.cpp	/^static void count_wire_type_sizes(const t_chan_seg_details *channel, int nodes_per_chan,$/;"	f	file:	signature:(const t_chan_seg_details *channel, int nodes_per_chan, t_wire_type_sizes *wire_type_sizes)
count_wire_type_sizes	route/build_switchblocks.cpp	/^static void count_wire_type_sizes(const t_chan_seg_details *channel, int nodes_per_chan,$/;"	p	file:	signature:(const t_chan_seg_details *channel, int nodes_per_chan, t_wire_type_sizes *wire_type_sizes)
counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf16_counter counter;$/;"	t	struct:wchar_selector	file:	access:public
counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf32_counter counter;$/;"	t	struct:wchar_selector	file:	access:public
covariance	route/routing_predictor.cpp	/^float covariance(std::vector<size_t> x_values, std::vector<float> y_values, float x_avg, float y_avg) {$/;"	f	signature:(std::vector<size_t> x_values, std::vector<float> y_values, float x_avg, float y_avg)
covariance	route/routing_predictor.cpp	/^float covariance(std::vector<size_t> x_values, std::vector<float> y_values, float x_avg, float y_avg);$/;"	p	file:	signature:(std::vector<size_t> x_values, std::vector<float> y_values, float x_avg, float y_avg)
cpd	base/vpr_types.h	/^	float ** cpd;$/;"	m	struct:ScreenUpdatePriority::t_timing_stats	access:public
crbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  crbegin()   const   { return vec_.rbegin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
crbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  crbegin()   const   { return vec_.rbegin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
create	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xml_stream_chunk* create()$/;"	f	struct:xml_stream_chunk	access:public	signature:()
create	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_query_impl* create()$/;"	f	struct:xpath_query_impl	access:public	signature:()
create	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::create()$/;"	f	class:pugi::xml_document	signature:()
create	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void create();$/;"	p	class:pugi::xml_document	access:private	signature:()
create_arg_parser	base/read_options.cpp	/^static argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& args) {$/;"	f	file:	signature:(std::string prog_name, t_options& args)
create_arg_parser	base/read_options.cpp	/^static argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& args);$/;"	p	file:	signature:(std::string prog_name, t_options& args)
create_block	base/atom_netlist.cpp	/^AtomBlockId AtomNetlist::create_block(const std::string name, const t_model* model, const TruthTable truth_table) {$/;"	f	class:AtomNetlist	signature:(const std::string name, const t_model* model, const TruthTable truth_table)
create_block	base/atom_netlist.h	/^        AtomBlockId create_block(const std::string name, const t_model* model, const TruthTable truth_table=TruthTable());$/;"	p	class:AtomNetlist	access:public	signature:(const std::string name, const t_model* model, const TruthTable truth_table=TruthTable())
create_block	base/clustered_netlist.cpp	/^ClusterBlockId ClusteredNetlist::create_block(const char *name, t_pb* pb, t_type_ptr type) {$/;"	f	class:ClusteredNetlist	signature:(const char *name, t_pb* pb, t_type_ptr type)
create_block	base/clustered_netlist.h	/^        ClusterBlockId create_block(const char *name, t_pb* pb, t_type_ptr type);$/;"	p	class:ClusteredNetlist	access:public	signature:(const char *name, t_pb* pb, t_type_ptr type)
create_block	base/netlist.h	/^        BlockId create_block(const std::string name);$/;"	p	class:Netlist	access:protected	signature:(const std::string name)
create_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::create_block(const std::string name) {$/;"	f	class:Netlist	signature:(const std::string name)
create_button	../../libs/libeasygl/src/graphics.cpp	/^void create_button(const char *prev_button_text, const char *button_text,$/;"	f	signature:(const char *prev_button_text, const char *button_text, void (*button_func) (void (*drawscreen) ()))
create_button	../../libs/libeasygl/src/graphics.cpp	/^void create_button(const char* \/*prev_button_text*\/, const char* \/*button_text*\/,$/;"	f	signature:(const char* , const char* , void (* ) (void (*drawscreen) (void)))
create_button	../../libs/libeasygl/src/graphics.h	/^void create_button(const char *prev_button_text, const char *button_text,$/;"	p	signature:(const char *prev_button_text, const char *button_text, void (*button_func) (void (*drawscreen) ()))
create_device_grid	base/SetupGrid.cpp	/^DeviceGrid create_device_grid(std::string layout_name, std::vector<t_grid_def> grid_layouts, size_t width, size_t height) {$/;"	f	signature:(std::string layout_name, std::vector<t_grid_def> grid_layouts, size_t width, size_t height)
create_device_grid	base/SetupGrid.cpp	/^DeviceGrid create_device_grid(std::string layout_name, std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float target_device_utilization) {$/;"	f	signature:(std::string layout_name, std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float target_device_utilization)
create_device_grid	base/SetupGrid.h	/^DeviceGrid create_device_grid(std::string layout_name, std::vector<t_grid_def> grid_layouts, size_t min_width, size_t min_height);$/;"	p	signature:(std::string layout_name, std::vector<t_grid_def> grid_layouts, size_t min_width, size_t min_height)
create_device_grid	base/SetupGrid.h	/^DeviceGrid create_device_grid(std::string layout_name,$/;"	p	signature:(std::string layout_name, std::vector<t_grid_def> grid_layouts, std::map<t_type_ptr,size_t> minimum_instance_counts, float target_device_utilization)
create_hold_slack_histogram	timing/timing_util.cpp	/^std::vector<HistogramBucket> create_hold_slack_histogram(const tatum::HoldTimingAnalyzer& hold_analyzer, size_t num_bins) {$/;"	f	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer, size_t num_bins)
create_hold_slack_histogram	timing/timing_util.h	/^std::vector<HistogramBucket> create_hold_slack_histogram(const tatum::HoldTimingAnalyzer& hold_analyzer, size_t num_bins = 10);$/;"	p	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer, size_t num_bins = 10)
create_net	base/atom_netlist.cpp	/^AtomNetId AtomNetlist::create_net(const std::string name) {$/;"	f	class:AtomNetlist	signature:(const std::string name)
create_net	base/atom_netlist.h	/^        AtomNetId   create_net(const std::string name); \/\/An empty or existing net$/;"	p	class:AtomNetlist	access:public	signature:(const std::string name)
create_net	base/clustered_netlist.cpp	/^ClusterNetId ClusteredNetlist::create_net(const std::string name) {$/;"	f	class:ClusteredNetlist	signature:(const std::string name)
create_net	base/clustered_netlist.h	/^        ClusterNetId    create_net(const std::string name);$/;"	p	class:ClusteredNetlist	access:public	signature:(const std::string name)
create_net	base/netlist.h	/^        NetId   create_net(const std::string name); \/\/An empty or existing net$/;"	p	class:Netlist	access:protected	signature:(const std::string name)
create_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::create_net(const std::string name) {$/;"	f	class:Netlist	signature:(const std::string name)
create_pin	base/atom_netlist.cpp	/^AtomPinId AtomNetlist::create_pin(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type_, bool is_const) {$/;"	f	class:AtomNetlist	signature:(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type_, bool is_const)
create_pin	base/atom_netlist.h	/^        AtomPinId   create_pin(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type, bool is_const=false);$/;"	p	class:AtomNetlist	access:public	signature:(const AtomPortId port_id, BitIndex port_bit, const AtomNetId net_id, const PinType pin_type, bool is_const=false)
create_pin	base/clustered_netlist.cpp	/^ClusterPinId ClusteredNetlist::create_pin(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type_, int pin_index, bool is_const) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type_, int pin_index, bool is_const)
create_pin	base/clustered_netlist.h	/^        ClusterPinId   create_pin(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type, int pin_index, bool is_const=false);$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterPortId port_id, BitIndex port_bit, const ClusterNetId net_id, const PinType pin_type, int pin_index, bool is_const=false)
create_pin	base/netlist.h	/^        PinId   create_pin(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType pin_type, bool is_const=false);$/;"	p	class:Netlist	access:protected	signature:(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType pin_type, bool is_const=false)
create_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::create_pin(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType type, bool is_const) {$/;"	f	class:Netlist	signature:(const PortId port_id, BitIndex port_bit, const NetId net_id, const PinType type, bool is_const)
create_port	base/atom_netlist.cpp	/^AtomPortId AtomNetlist::create_port(const AtomBlockId blk_id, const t_model_ports* model_port) {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId blk_id, const t_model_ports* model_port)
create_port	base/atom_netlist.h	/^        AtomPortId  create_port(const AtomBlockId blk_id, const t_model_ports* model_port);$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId blk_id, const t_model_ports* model_port)
create_port	base/clustered_netlist.cpp	/^ClusterPortId ClusteredNetlist::create_port(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type)
create_port	base/clustered_netlist.h	/^        ClusterPortId create_port(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type);$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterBlockId blk_id, const std::string name, BitIndex width, PortType type)
create_port	base/netlist.h	/^        PortId  create_port(const BlockId blk_id, const std::string name, BitIndex width, PortType type);$/;"	p	class:Netlist	access:protected	signature:(const BlockId blk_id, const std::string name, BitIndex width, PortType type)
create_port	base/netlist.tpp	/^PortId Netlist<BlockId, PortId, PinId, NetId>::create_port(const BlockId blk_id, const std::string name, BitIndex width, PortType type) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string name, BitIndex width, PortType type)
create_rr_graph	route/rr_graph.cpp	/^void create_rr_graph($/;"	f	signature:( const t_graph_type graph_type, const int num_block_types, const t_type_ptr block_types, const DeviceGrid& grid, const t_chan_width nodes_per_chan, const int num_arch_switches, t_det_routing_arch* det_routing_arch, const t_segment_inf * segment_inf, const enum e_base_cost_type base_cost_type, const bool trim_empty_channels, const bool trim_obs_channels, const e_router_lookahead router_lookahead_type, const t_direct_inf *directs, const int num_directs, int *num_rr_switches, int *Warnings)
create_rr_graph	route/rr_graph.h	/^void create_rr_graph($/;"	p	signature:( const t_graph_type graph_type, const int num_block_types, const t_type_ptr block_types, const DeviceGrid& grid, t_chan_width nodes_per_chan, const int num_arch_switches, t_det_routing_arch* det_routing_arch, const t_segment_inf * segment_inf, const enum e_base_cost_type base_cost_type, const bool trim_empty_channels, const bool trim_obs_channels, const e_router_lookahead router_lookahead_type, const t_direct_inf *directs, const int num_directs, int *num_rr_switches, int *Warnings)
create_setup_slack_histogram	timing/timing_util.cpp	/^std::vector<HistogramBucket> create_setup_slack_histogram(const tatum::SetupTimingAnalyzer& setup_analyzer, size_t num_bins) {$/;"	f	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer, size_t num_bins)
create_setup_slack_histogram	timing/timing_util.h	/^std::vector<HistogramBucket> create_setup_slack_histogram(const tatum::SetupTimingAnalyzer& setup_analyzer, size_t num_bins = 10);$/;"	p	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer, size_t num_bins = 10)
create_string	base/netlist.h	/^        StringId create_string(const std::string& str);$/;"	p	class:Netlist	access:protected	signature:(const std::string& str)
create_string	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::StringId Netlist<BlockId, PortId, PinId, NetId>::create_string(const std::string& str) {$/;"	f	class:Netlist	signature:(const std::string& str)
create_timing_constraints	timing/read_sdc.h	/^std::unique_ptr<tatum::TimingConstraints> create_timing_constraints(const AtomNetlist& netlist, const AtomLookup& atom_lookup, t_timing_inf timing_inf);$/;"	p	signature:(const AtomNetlist& netlist, const AtomLookup& atom_lookup, t_timing_inf timing_inf)
create_unconn_net	base/netlist_writer.cpp	/^std::string create_unconn_net(size_t& unconn_count) {$/;"	f	signature:(size_t& unconn_count)
create_unconn_net	base/netlist_writer.cpp	/^std::string create_unconn_net(size_t& unconn_count);$/;"	p	file:	signature:(size_t& unconn_count)
crend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  crend()     const   { return vec_.rend(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
crend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  crend()     const   { return vec_.rend(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
critical_path	route/route_timing.cpp	/^    tatum::TimingPathInfo critical_path;$/;"	m	struct:RoutingMetrics	file:	access:public
critical_path_delay_grew_significantly	route/connection_based_routing.h	/^	bool critical_path_delay_grew_significantly(float new_critical_path_delay) const {$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float new_critical_path_delay) const
critical_path_growth_tolerance	route/connection_based_routing.h	/^	float critical_path_growth_tolerance;$/;"	m	class:Connection_based_routing_resources	access:private
critical_paths	timing/timing_info.h	/^        virtual std::vector<tatum::TimingPathInfo> critical_paths() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
criticality	route/route_timing.cpp	/^    const float* criticality;$/;"	m	struct:Criticality_comp	file:	access:public
criticality	route/route_timing.h	/^    float criticality = 1.;$/;"	m	struct:t_conn_cost_params	access:public
criticality_	timing/concrete_timing_info.h	/^        float criticality_;$/;"	m	class:ConstantTimingInfo	access:private
criticality_exp	base/read_options.h	/^    argparse::ArgValue<float> criticality_exp;$/;"	m	struct:t_options	access:public
criticality_exp	base/vpr_types.h	/^	float criticality_exp;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
cross_count	place/place.cpp	/^static const float cross_count[50] = { \/* [0..49] *\/1.0, 1.0, 1.0, 1.0828, 1.1536, 1.2206, 1.2823, 1.3385, 1.3991, 1.4493, 1.4974,$/;"	v	file:
ct_parse_attr	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_parse_attr = 2,		\/\/ \\0, &, \\r, ', "$/;"	e	enum:chartype_t	file:
ct_parse_attr_ws	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_parse_attr_ws = 4,	\/\/ \\0, &, \\r, ', ", \\n, tab$/;"	e	enum:chartype_t	file:
ct_parse_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_parse_cdata = 16,	\/\/ \\0, ], >, \\r$/;"	e	enum:chartype_t	file:
ct_parse_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_parse_comment = 32,	\/\/ \\0, -, >, \\r$/;"	e	enum:chartype_t	file:
ct_parse_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_parse_pcdata = 1,	\/\/ \\0, &, \\r, <$/;"	e	enum:chartype_t	file:
ct_space	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_space = 8,			\/\/ \\r, \\n, space, tab$/;"	e	enum:chartype_t	file:
ct_start_symbol	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_start_symbol = 128	\/\/ Any symbol > 127, a-z, A-Z, _, :$/;"	e	enum:chartype_t	file:
ct_symbol	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ct_symbol = 64,			\/\/ Any symbol > 127, a-z, A-Z, 0-9, _, :, -, .$/;"	e	enum:chartype_t	file:
ctrl_pressed	../../libs/libeasygl/src/easygl_constants.h	/^    bool ctrl_pressed; \/* indicates whether a Ctrl key was pressed when a mouse button is pressed *\/$/;"	m	struct:__anon16	access:public
ctx	../../libs/libeasygl/src/graphics_state.h	/^    cairo_t *ctx = nullptr;$/;"	m	class:t_x11_state	access:public
ctx_digit	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ctx_digit = 8,			  \/\/ 0-9$/;"	e	enum:chartypex_t	file:
ctx_special_attr	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ctx_special_attr = 2,     \/\/ Any symbol >= 0 and < 32 (except \\t), &, <, >, "$/;"	e	enum:chartypex_t	file:
ctx_special_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ctx_special_pcdata = 1,   \/\/ Any symbol >= 0 and < 32 (except \\t, \\r, \\n), &, <, >$/;"	e	enum:chartypex_t	file:
ctx_start_symbol	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ctx_start_symbol = 4,	  \/\/ Any symbol > 127, a-z, A-Z, _$/;"	e	enum:chartypex_t	file:
ctx_symbol	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		ctx_symbol = 16			  \/\/ Any symbol > 127, a-z, A-Z, 0-9, _, -, .$/;"	e	enum:chartypex_t	file:
cube_to_minterms	base/atom_netlist_utils.cpp	/^std::vector<size_t> cube_to_minterms(std::vector<vtr::LogicValue> cube) {$/;"	f	signature:(std::vector<vtr::LogicValue> cube)
cube_to_minterms	base/atom_netlist_utils.h	/^std::vector<size_t> cube_to_minterms(std::vector<vtr::LogicValue> cube);$/;"	p	signature:(std::vector<vtr::LogicValue> cube)
cube_to_minterms_recurr	base/atom_netlist_utils.cpp	/^void cube_to_minterms_recurr(std::vector<vtr::LogicValue> cube, std::vector<size_t>& minterms) {$/;"	f	signature:(std::vector<vtr::LogicValue> cube, std::vector<size_t>& minterms)
cube_to_minterms_recurr	base/atom_netlist_utils.cpp	/^void cube_to_minterms_recurr(std::vector<vtr::LogicValue> cube, std::vector<size_t>& minterms);$/;"	p	file:	signature:(std::vector<vtr::LogicValue> cube, std::vector<size_t>& minterms)
cur_cap	pack/cluster_router.cpp	/^		size_type cur_cap;$/;"	m	class:reservable_pq	file:	access:private
curr_block	base/read_blif.cpp	/^        AtomBlockId curr_block() const {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:() const
curr_block_	base/read_blif.cpp	/^        AtomBlockId curr_block_;$/;"	m	struct:BlifAllocCallback	file:	access:private
curr_model	base/read_blif.cpp	/^        AtomNetlist& curr_model() {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:()
curr_molecule	base/vpr_types.h	/^	const t_pack_molecule *curr_molecule; \/* current molecule being considered for packing *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
current	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lexeme_t current() const$/;"	f	class:xpath_lexer	access:public	signature:() const
current_draw_mode	../../libs/libeasygl/src/graphics_state.h	/^    e_draw_mode current_draw_mode = DRAW_NORMAL;$/;"	m	struct:t_gl_state	access:public
current_draw_to	../../libs/libeasygl/src/graphics_state.h	/^    t_draw_to current_draw_to = ON_SCREEN;$/;"	m	struct:t_gl_state	access:public
current_gc	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
current_inet	route/connection_based_routing.h	/^	ClusterNetId current_inet;$/;"	m	class:Connection_based_routing_resources	access:private
current_node	pack/pack_types.h	/^	int	current_node;					\/* current t_lb_type_rr_node used by net *\/$/;"	m	struct:t_lb_trace	access:public
current_pos	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* current_pos() const$/;"	f	class:xpath_lexer	access:public	signature:() const
currentcoordinatesystem	../../libs/libeasygl/src/graphics_state.h	/^    t_coordinate_system currentcoordinatesystem = GL_WORLD;$/;"	m	struct:t_gl_state	access:public
currentfontrotation	../../libs/libeasygl/src/graphics_state.h	/^    int currentfontrotation = 0;$/;"	m	struct:t_gl_state	access:public
currentfontsize	../../libs/libeasygl/src/graphics_state.h	/^    int currentfontsize = 12;$/;"	m	struct:t_gl_state	access:public
currentlinecap	../../libs/libeasygl/src/graphics_state.h	/^    int currentlinecap = 0;$/;"	m	struct:t_gl_state	access:public
currentlinestyle	../../libs/libeasygl/src/graphics_state.h	/^    int currentlinestyle = SOLID;$/;"	m	struct:t_gl_state	access:public
currentlinewidth	../../libs/libeasygl/src/graphics_state.h	/^    int currentlinewidth = 0;$/;"	m	struct:t_gl_state	access:public
data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			char data[xpath_memory_page_size];$/;"	m	union:xpath_memory_block::__anon29	file:	access:public
data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T data[xml_memory_page_size \/ sizeof(T)];$/;"	m	struct:xml_stream_chunk	file:	access:public
data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* data;$/;"	m	struct:auto_deleter	file:	access:public
data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* data(xpath_allocator* alloc)$/;"	f	class:xpath_string	access:public	signature:(xpath_allocator* alloc)
data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_text::data() const$/;"	f	class:pugi::xml_text	signature:() const
data	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node data() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
data	../../libs/libarchfpga/src/expr_eval.cpp	/^	} data;$/;"	m	class:Formula_Object	typeref:union:Formula_Object::u_Data	file:	access:public
data	../../libs/libvtrutil/src/vtr_list.h	/^        int data;$/;"	m	struct:vtr::t_linked_int	access:public
data	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T* data() {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:()
data	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const T* data() const {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:() const
data	timing/slre.cpp	/^  unsigned char data[256];$/;"	m	struct:slre	file:	access:public
data	util/token.h	/^	char *data;$/;"	m	struct:t_token	access:public
data_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        std::unique_ptr<T[]> data_ = nullptr;$/;"	m	class:vtr::NdMatrixBase	access:protected
data_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        std::unique_ptr<T[]> data_ = nullptr;$/;"	m	class:vtr::NdOffsetMatrixBase	access:protected
data_char	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			char_t data_char[bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
data_length_digits_	../../libs/libvtrutil/src/picosha2.h	/^	word_t data_length_digits_[4]; \/\/as 64bit integer (16bit x 4 integer)$/;"	m	class:picosha2::hash256_one_by_one	access:private
data_size	timing/slre.cpp	/^  int data_size;$/;"	m	struct:slre	file:	access:public
data_u16	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			uint16_t data_u16[2 * bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
data_u32	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			uint32_t data_u32[bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
data_u8	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			uint8_t data_u8[4 * bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
data_vptr	../../libs/libvtrutil/src/vtr_list.h	/^        void *data_vptr;$/;"	m	struct:vtr::t_linked_vptr	access:public
dc	../../libs/libarchfpga/src/physical_types.h	/^	float dc;$/;"	m	struct:t_chan	access:public
dealloc_mux_graph	power/power.cpp	/^static void dealloc_mux_graph(t_mux_node * node) {$/;"	f	file:	signature:(t_mux_node * node)
dealloc_mux_graph	power/power.cpp	/^static void dealloc_mux_graph(t_mux_node * node);$/;"	p	file:	signature:(t_mux_node * node)
dealloc_mux_graph_rec	power/power.cpp	/^static void dealloc_mux_graph_rec(t_mux_node * node) {$/;"	f	file:	signature:(t_mux_node * node)
dealloc_mux_graph_rec	power/power.cpp	/^static void dealloc_mux_graph_rec(t_mux_node * node);$/;"	p	file:	signature:(t_mux_node * node)
deallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static deallocation_function deallocate;$/;"	m	struct:xml_memory_management_function_storage	file:	access:public
deallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> deallocation_function xml_memory_management_function_storage<T>::deallocate = default_deallocate;$/;"	m	class:xml_memory_management_function_storage	file:
deallocate_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void deallocate_memory(void* ptr, size_t size, xml_memory_page* page)$/;"	f	struct:xml_allocator	access:public	signature:(void* ptr, size_t size, xml_memory_page* page)
deallocate_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void deallocate_page(xml_memory_page* page)$/;"	f	struct:xml_allocator	access:public	signature:(xml_memory_page* page)
deallocate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void deallocate_string(char_t* string)$/;"	f	struct:xml_allocator	access:public	signature:(char_t* string)
deallocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef void (*deallocation_function)(void* ptr);$/;"	t	namespace:pugi
decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf16_decoder<opt_false> decoder;$/;"	t	struct:wchar_selector	file:	access:public
decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf32_decoder<opt_false> decoder;$/;"	t	struct:wchar_selector	file:	access:public
default_allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void* default_allocate(size_t size)$/;"	f	signature:(size_t size)
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseBaseCost	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseCircuitFormat	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseClockModeling	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseClusterSeed	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseConstGenInference	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseConstantNetMethod	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseIncrRerouteDelayRipup	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseOnOff	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParsePlaceAlgorithm	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParsePlaceDelayModel	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseReducer	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouteBBUpdate	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRoutePredictor	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouteType	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouterAlgorithm	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseRouterLookahead	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseTimingReportDetail	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:ParseUnrelatedClustering	access:public	signature:()
default_choices	base/read_options.cpp	/^    std::vector<std::string> default_choices() {$/;"	f	struct:RouteBudgetsAlgorithm	access:public	signature:()
default_deallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void default_deallocate(void* ptr)$/;"	f	signature:(void* ptr)
default_message	draw/draw_types.h	/^	char default_message[vtr::bufsize];$/;"	m	struct:t_draw_state	access:public
default_triangle_LOD_screen_area_test	draw/draw.cpp	/^static inline bool default_triangle_LOD_screen_area_test() {$/;"	f	file:	signature:()
default_triangle_LOD_screen_area_test	draw/draw.cpp	/^static inline bool default_triangle_LOD_screen_area_test();$/;"	p	file:	signature:()
defaults_	base/vpr_types.h	/^    t_ext_pin_util defaults_;$/;"	m	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:private
delay	base/netlist_writer.cpp	/^        double delay() const { return delay_; }$/;"	f	class:Arc	access:public	signature:() const
delay	base/vpr_types.h	/^	float delay; \/* Delay through the I\/O in this constraint *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
delay	place/place_delay_model.cpp	/^float DeltaDelayModel::delay(int from_x, int from_y, int \/*from_pin*\/, int to_x, int to_y, int \/*to_pin*\/) const {$/;"	f	class:DeltaDelayModel	signature:(int from_x, int from_y, int , int to_x, int to_y, int ) const
delay	place/place_delay_model.cpp	/^float OverrideDelayModel::delay(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const {$/;"	f	class:OverrideDelayModel	signature:(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const
delay	place/place_delay_model.h	/^        virtual float delay(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const = 0;$/;"	p	class:PlaceDelayModel	access:public	signature:(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const
delay	route/router_lookahead_map.cpp	/^	float delay;$/;"	m	class:Cost_Entry	file:	access:public
delay	route/router_lookahead_map.cpp	/^	float delay;$/;"	m	class:PQ_Entry	file:	access:public
delay_	base/netlist_writer.cpp	/^        double delay_;$/;"	m	class:Arc	file:	access:private
delay_budget	route/route_timing.h	/^    const t_conn_delay_budget* delay_budget = nullptr;$/;"	m	struct:t_conn_cost_params	access:public
delay_calc_	base/netlist_writer.cpp	/^        std::shared_ptr<const AnalysisDelayCalculator> delay_calc_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
delay_calc_	timing/VprTimingGraphResolver.h	/^        const AnalysisDelayCalculator& delay_calc_;$/;"	m	class:VprTimingGraphResolver	access:private
delay_calc_	timing/concrete_timing_info.h	/^        std::shared_ptr<DelayCalc> delay_calc_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
delay_calc_	timing/concrete_timing_info.h	/^        std::shared_ptr<DelayCalc> delay_calc_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
delay_cost	place/place.cpp	/^    float delay_cost;$/;"	m	struct:t_placer_costs	file:	access:public
delay_lower_bound	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_lower_bound; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
delay_max	../../libs/libarchfpga/src/physical_types.h	/^	float delay_max;$/;"	m	struct:t_pb_graph_edge	access:public
delay_max_budget	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_max_budget; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
delay_min	../../libs/libarchfpga/src/physical_types.h	/^	float delay_min;$/;"	m	struct:t_pb_graph_edge	access:public
delay_min_budget	route/route_budgets.h	/^    vtr::vector<ClusterNetId, float *> delay_min_budget; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
delay_model_reducer	base/vpr_types.h	/^    e_reducer delay_model_reducer;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
delay_model_type	base/vpr_types.h	/^    PlaceDelayModelType delay_model_type;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
delay_offset	base/vpr_types.h	/^    float delay_offset;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
delay_overrides_	place/place_delay_model.h	/^        vtr::flat_map2<t_override,float> delay_overrides_;$/;"	m	class:OverrideDelayModel	access:private
delay_ramp_delta_threshold	base/vpr_types.h	/^    int delay_ramp_delta_threshold;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
delay_ramp_slope	base/vpr_types.h	/^    float delay_ramp_slope;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
delay_reduce	place/timing_place_lookup.cpp	/^float delay_reduce(std::vector<float>& delays, e_reducer reducer) {$/;"	f	signature:(std::vector<float>& delays, e_reducer reducer)
delay_reduce	place/timing_place_lookup.cpp	/^float delay_reduce(std::vector<float>& delays, e_reducer reducer);$/;"	p	file:	signature:(std::vector<float>& delays, e_reducer reducer)
delay_target	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_target; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
delay_upper_bound	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_upper_bound; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
delayless_switch	base/vpr_types.h	/^	short delayless_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
delays_	place/place_delay_model.h	/^        vtr::Matrix<float> delays_;$/;"	m	class:DeltaDelayModel	access:private
delete_in_vptr_list	../../libs/libvtrutil/src/vtr_list.cpp	/^t_linked_vptr *delete_in_vptr_list(t_linked_vptr *head) {$/;"	f	namespace:vtr	signature:(t_linked_vptr *head)
delete_in_vptr_list	../../libs/libvtrutil/src/vtr_list.h	/^    t_linked_vptr *delete_in_vptr_list(t_linked_vptr *head);$/;"	p	namespace:vtr	signature:(t_linked_vptr *head)
delete_xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void delete_xpath_variable(xpath_value_type type, xpath_variable* var)$/;"	f	signature:(xpath_value_type type, xpath_variable* var)
delete_xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> PUGI__FN void delete_xpath_variable(T* var)$/;"	f	signature:(T* var)
deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		D deleter;$/;"	m	struct:auto_deleter	file:	access:public
delta_max_rss_mib	../../libs/libvtrutil/src/vtr_time.cpp	/^float Timer::delta_max_rss_mib() const {$/;"	f	class:vtr::Timer	signature:() const
delta_max_rss_mib	../../libs/libvtrutil/src/vtr_time.h	/^            float delta_max_rss_mib() const;$/;"	p	class:vtr::Timer	access:public	signature:() const
delta_x	place/place_delay_model.h	/^            int delta_x;$/;"	m	struct:OverrideDelayModel::t_override	access:public
delta_y	place/place_delay_model.h	/^            int delta_y;$/;"	m	struct:OverrideDelayModel::t_override	access:public
deltas	place/timing_place_lookup.cpp	/^    std::vector<vtr::Point<int>> deltas;$/;"	m	struct:t_profile_loc	file:	access:public
dens	../../libs/libarchfpga/src/physical_types.h	/^	float dens; \/* Switching density of net assigned to this clock *\/$/;"	m	struct:t_clock_network	access:public
density	base/vpr_types.h	/^	float density;$/;"	m	struct:ScreenUpdatePriority::t_net_power	access:public
depth	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int xml_tree_walker::depth() const$/;"	f	class:pugi::xml_tree_walker	signature:() const
depth	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int depth() const;$/;"	p	class:pugi::xml_tree_walker	access:protected	signature:() const
depth	../../libs/libarchfpga/src/physical_types.h	/^	int depth = 0; \/* depth of pb_type *\/$/;"	m	struct:t_pb_type	access:public
depth	../../libs/libvtrutil/src/vtr_time.cpp	/^int ScopedActionTimer::depth() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
depth	../../libs/libvtrutil/src/vtr_time.h	/^            int depth() const;$/;"	p	class:vtr::ScopedActionTimer	access:protected	signature:() const
depth_	../../libs/libvtrutil/src/vtr_time.h	/^            int depth_;$/;"	m	class:vtr::ScopedActionTimer	access:private
describe_congested_rr_nodes	pack/cluster_router.cpp	/^static std::string describe_congested_rr_nodes(const std::vector<int>& congested_rr_nodes,$/;"	f	file:	signature:(const std::vector<int>& congested_rr_nodes, const t_lb_router_data* router_data)
describe_congested_rr_nodes	pack/cluster_router.cpp	/^static std::string describe_congested_rr_nodes(const std::vector<int>& congested_rr_nodes,$/;"	p	file:	signature:(const std::vector<int>& congested_rr_nodes, const t_lb_router_data* router_data)
describe_lb_type_rr_node	pack/cluster_router.cpp	/^static std::string describe_lb_type_rr_node(int inode,$/;"	f	file:	signature:(int inode, const t_lb_router_data* router_data)
describe_lb_type_rr_node	pack/cluster_router.cpp	/^static std::string describe_lb_type_rr_node(int inode,$/;"	p	file:	signature:(int inode, const t_lb_router_data* router_data)
describe_pb_graph_pin	pack/cluster_router.cpp	/^static std::string describe_pb_graph_pin(const t_pb_graph_pin* pb_graph_pin) {$/;"	f	file:	signature:(const t_pb_graph_pin* pb_graph_pin)
describe_pb_graph_pin	pack/cluster_router.cpp	/^static std::string describe_pb_graph_pin(const t_pb_graph_pin* pb_graph_pin);$/;"	p	file:	signature:(const t_pb_graph_pin* pb_graph_pin)
describe_rr_node	route/rr_graph.cpp	/^std::string describe_rr_node(int inode) {$/;"	f	signature:(int inode)
describe_rr_node	route/rr_graph.h	/^std::string describe_rr_node(int inode);$/;"	p	signature:(int inode)
describe_unrouteable_connection	route/route_timing.cpp	/^static std::string describe_unrouteable_connection(const int source_node, const int sink_node) {$/;"	f	file:	signature:(const int source_node, const int sink_node)
describe_unrouteable_connection	route/route_timing.cpp	/^static std::string describe_unrouteable_connection(const int source_node, const int sink_node);$/;"	p	file:	signature:(const int source_node, const int sink_node)
description	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char* xml_parse_result::description() const$/;"	f	class:pugi::xml_parse_result	signature:() const
description	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char* xpath_parse_result::description() const$/;"	f	class:pugi::xpath_parse_result	signature:() const
description	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char* description() const;$/;"	p	struct:pugi::xml_parse_result	access:public	signature:() const
description	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char* description() const;$/;"	p	struct:pugi::xpath_parse_result	access:public	signature:() const
descriptor2font_rotated	../../libs/libeasygl/src/fontcache.h	/^    font_lookup descriptor2font_rotated;$/;"	m	class:FontCache	access:private
descriptor2font_zeros	../../libs/libeasygl/src/fontcache.h	/^    font_lookup descriptor2font_zeros;$/;"	m	class:FontCache	access:private
deselect_all	draw/draw.cpp	/^static void deselect_all() {$/;"	f	file:	signature:()
deselect_all	draw/draw.cpp	/^static void deselect_all();$/;"	p	file:	signature:()
destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void destroy(xml_stream_chunk* chunk)$/;"	f	struct:xml_stream_chunk	access:public	signature:(xml_stream_chunk* chunk)
destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void destroy(xpath_query_impl* impl)$/;"	f	struct:xpath_query_impl	access:public	signature:(xpath_query_impl* impl)
destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::destroy()$/;"	f	class:pugi::xml_document	signature:()
destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void destroy();$/;"	p	class:pugi::xml_document	access:private	signature:()
destroy_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void destroy_attribute(xml_attribute_struct* a, xml_allocator& alloc)$/;"	f	signature:(xml_attribute_struct* a, xml_allocator& alloc)
destroy_button	../../libs/libeasygl/src/graphics.cpp	/^destroy_button(const char *button_text) {$/;"	f	signature:(const char *button_text)
destroy_button	../../libs/libeasygl/src/graphics.cpp	/^void destroy_button(const char* \/*button_text*\/) { }$/;"	f	signature:(const char* )
destroy_button	../../libs/libeasygl/src/graphics.h	/^void destroy_button(const char *button_text);$/;"	p	signature:(const char *button_text)
destroy_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void destroy_node(xml_node_struct* n, xml_allocator& alloc)$/;"	f	signature:(xml_node_struct* n, xml_allocator& alloc)
detail	../../libs/libvtrutil/src/picosha2.h	/^namespace detail$/;"	n	namespace:picosha2
detail_level	timing/VprTimingGraphResolver.cpp	/^e_timing_report_detail VprTimingGraphResolver::detail_level() const {$/;"	f	class:VprTimingGraphResolver	signature:() const
detail_level	timing/VprTimingGraphResolver.h	/^        e_timing_report_detail detail_level() const;$/;"	p	class:VprTimingGraphResolver	access:private	signature:() const
detail_level_	timing/VprTimingGraphResolver.h	/^        e_timing_report_detail detail_level_ = e_timing_report_detail::NETLIST;$/;"	m	class:VprTimingGraphResolver	access:private
detect_and_fix_timing_graph_combinational_loops	timing/path_delay2.cpp	/^void detect_and_fix_timing_graph_combinational_loops() {$/;"	f	signature:()
detect_and_fix_timing_graph_combinational_loops	timing/path_delay2.h	/^void detect_and_fix_timing_graph_combinational_loops();$/;"	p	signature:()
detect_timing_graph_combinational_loops	timing/path_delay2.cpp	/^std::vector<std::vector<int> > detect_timing_graph_combinational_loops() {$/;"	f	signature:()
detect_timing_graph_combinational_loops	timing/path_delay2.cpp	/^std::vector<std::vector<int> > detect_timing_graph_combinational_loops();$/;"	p	file:	signature:()
determine_lut_permutation	base/netlist_writer.cpp	/^        std::vector<int> determine_lut_permutation(size_t num_inputs, const t_pb* atom_pb) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(size_t num_inputs, const t_pb* atom_pb)
determine_main_netlist_index	base/read_blif.cpp	/^        size_t determine_main_netlist_index() {$/;"	f	struct:BlifAllocCallback	access:public	signature:()
device	base/vpr_context.h	/^        const DeviceContext& device() const { return device_; }$/;"	f	class:VprContext	access:public	signature:() const
device_	base/vpr_context.h	/^        DeviceContext device_;$/;"	m	class:VprContext	access:private
device_layout	base/read_options.h	/^    argparse::ArgValue<std::string> device_layout;$/;"	m	struct:t_options	access:public
device_layout	base/vpr_types.h	/^    std::string device_layout;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
device_layout	base/vpr_types.h	/^    std::string device_layout;$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
difference_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_attribute_iterator	access:public
difference_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_named_node_iterator	access:public
difference_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_node_iterator	access:public
difference_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::difference_type difference_type;$/;"	t	class:vtr::flat_map	access:public
difference_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::difference_type difference_type;$/;"	t	class:vtr::linear_map	access:public
dim_ranges_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const DimRange* dim_ranges_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
dim_ranges_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        std::array<DimRange,N> dim_ranges_;$/;"	m	class:vtr::NdOffsetMatrixBase	access:protected
dim_size	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t dim_size(size_t i) const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(size_t i) const
dim_size	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t dim_size(size_t i) const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(size_t i) const
dim_sizes_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const size_t* dim_sizes_;$/;"	m	class:vtr::NdMatrixProxy	access:private
dim_sizes_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        std::array<size_t,N> dim_sizes_;$/;"	m	class:vtr::NdMatrixBase	access:protected
dim_stride_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const size_t dim_stride_;$/;"	m	class:vtr::NdMatrixProxy	access:private
dim_stride_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const size_t dim_stride_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
dir	../../libs/libarchfpga/src/logic_types.h	/^	enum PORTS dir = ERR_PORT; \/* port direction *\/$/;"	m	struct:t_model_ports	typeref:enum:t_model_ports::PORTS	access:public
dir_side_	route/rr_node.h	/^        } dir_side_;$/;"	m	class:t_rr_node	typeref:union:t_rr_node::__anon8	access:private
direction	base/vpr_types.h	/^	enum e_direction direction = NO_DIRECTION;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	typeref:enum:ScreenUpdatePriority::t_seg_details::e_direction	access:public
direction	base/vpr_types.h	/^        e_direction direction() const { return seg_detail_->direction; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
direction	route/rr_node.cpp	/^e_direction t_rr_node::direction() const {$/;"	f	class:t_rr_node	signature:() const
direction	route/rr_node.h	/^            e_direction direction; \/\/Valid only for CHANX\/CHANY$/;"	m	union:t_rr_node::__anon8	access:public
direction	route/rr_node.h	/^        e_direction direction() const;$/;"	p	class:t_rr_node	access:public	signature:() const
direction_string	route/rr_node.cpp	/^const char* t_rr_node::direction_string() const{$/;"	f	class:t_rr_node	signature:() const
direction_string	route/rr_node.h	/^        const char *direction_string() const;$/;"	p	class:t_rr_node	access:public	signature:() const
directionality	../../libs/libarchfpga/src/physical_types.cpp	/^e_directionality t_arch_switch_inf::directionality() const {$/;"	f	class:t_arch_switch_inf	signature:() const
directionality	../../libs/libarchfpga/src/physical_types.h	/^	e_directionality directionality;	\/* the directionality of this switchblock (unidir\/bidir) *\/$/;"	m	struct:t_switchblock_inf	access:public
directionality	../../libs/libarchfpga/src/physical_types.h	/^	enum e_directionality directionality;$/;"	m	struct:t_segment_inf	typeref:enum:t_segment_inf::e_directionality	access:public
directionality	../../libs/libarchfpga/src/physical_types.h	/^        e_directionality directionality() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
directionality	base/vpr_types.h	/^	enum e_directionality directionality; \/* UDSD by AY *\/$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	typeref:enum:ScreenUpdatePriority::t_det_routing_arch::e_directionality	access:public
dirname	../../libs/libvtrutil/src/vtr_path.cpp	/^std::string dirname(const std::string& path) {$/;"	f	namespace:vtr	signature:(const std::string& path)
dirname	../../libs/libvtrutil/src/vtr_path.h	/^    std::string dirname(const std::string& path);$/;"	p	namespace:vtr	signature:(const std::string& path)
dirty_	base/netlist.h	/^        bool dirty_ = false;        \/\/Indicates the netlist has invalid entries from remove_*() functions$/;"	m	class:Netlist	access:private
disable_event_loop	../../libs/libeasygl/src/graphics_state.h	/^    bool disable_event_loop = false;$/;"	m	struct:t_gl_state	access:public
disabled_domain_pairs_	timing/read_sdc2.cpp	/^        std::set<std::pair<tatum::DomainId,tatum::DomainId>> disabled_domain_pairs_;$/;"	m	class:SdcParseCallback2	file:	access:private
discover_all_forced_connections	pack/cluster_feasibility_filter.cpp	/^static void discover_all_forced_connections(t_pb_graph_node *pb_graph_node) {$/;"	f	file:	signature:(t_pb_graph_node *pb_graph_node)
discover_all_forced_connections	pack/cluster_feasibility_filter.cpp	/^static void discover_all_forced_connections(t_pb_graph_node *pb_graph_node);$/;"	p	file:	signature:(t_pb_graph_node *pb_graph_node)
discover_pattern_names_in_pb_graph_node	pack/prepack.cpp	/^static void discover_pattern_names_in_pb_graph_node($/;"	f	file:	signature:( t_pb_graph_node *pb_graph_node, t_hash **nhash, int *ncount)
discover_pattern_names_in_pb_graph_node	pack/prepack.cpp	/^static void discover_pattern_names_in_pb_graph_node($/;"	p	file:	signature:( t_pb_graph_node *pb_graph_node, t_hash **nhash, int *ncount)
disp_type	../../libs/libeasygl/src/graphics_state.h	/^    t_display_type disp_type = SCREEN;$/;"	m	struct:t_gl_state	access:public
display	../../libs/libeasygl/src/graphics_state.h	/^    Display *display = nullptr;$/;"	m	class:t_x11_state	access:public
display_height	../../libs/libeasygl/src/graphics.cpp	/^    int display_width, display_height;$/;"	m	struct:__anon20	file:	access:public
display_width	../../libs/libeasygl/src/graphics.cpp	/^    int display_width, display_height;$/;"	m	struct:__anon20	file:	access:public
distr	route/rr_graph.cpp	/^    int *distr;$/;"	m	struct:t_mux_size_distribution	file:	access:public
doAnalysis	base/vpr_types.h	/^    e_stage_action doAnalysis;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
doPacking	base/vpr_types.h	/^	e_stage_action doPacking;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
doPlacement	base/vpr_types.h	/^	e_stage_action doPlacement;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
doRouting	base/vpr_types.h	/^	e_stage_action doRouting;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
do_analysis	base/read_options.h	/^    argparse::ArgValue<bool> do_analysis;$/;"	m	struct:t_options	access:public
do_clustering	pack/cluster.cpp	/^std::map<t_type_ptr,size_t> do_clustering(const t_packer_opts& packer_opts, const t_arch *arch, t_pack_molecule *molecule_head,$/;"	f	signature:(const t_packer_opts& packer_opts, const t_arch *arch, t_pack_molecule *molecule_head, int num_models, const std::unordered_set<AtomNetId>& is_clock, std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode, bool allow_unrelated_clustering, std::vector<t_lb_type_rr_node> *lb_type_rr_graphs, const t_ext_pin_util_targets& ext_pin_util_targets , vtr::vector<AtomBlockId, int>& partitions , t_timing_inf timing_inf )
do_clustering	pack/cluster.h	/^std::map<t_type_ptr,size_t> do_clustering(const t_packer_opts& packer_opts, const t_arch *arch, t_pack_molecule *molecule_head,$/;"	p	signature:(const t_packer_opts& packer_opts, const t_arch *arch, t_pack_molecule *molecule_head, int num_models, const std::unordered_set<AtomNetId>& is_clock, std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode, bool allow_unrelated_clustering, std::vector<t_lb_type_rr_node> *lb_type_rr_graphs, const t_ext_pin_util_targets& ext_pin_util_targets , vtr::vector<AtomBlockId, int>& partitions , t_timing_inf timing_inf )
do_font_loading	../../libs/libeasygl/src/fontcache.cpp	/^font_ptr FontCache::do_font_loading($/;"	f	class:FontCache	signature:( int pointsize, int degrees )
do_font_loading	../../libs/libeasygl/src/fontcache.h	/^    static font_ptr do_font_loading(int pointsize, int degrees);$/;"	p	class:FontCache	access:private	signature:(int pointsize, int degrees)
do_packing	base/read_options.h	/^    argparse::ArgValue<bool> do_packing;$/;"	m	struct:t_options	access:public
do_path_counting	timing/path_delay.cpp	/^static void do_path_counting(float criticality_denom) {$/;"	f	file:	signature:(float criticality_denom)
do_path_counting	timing/path_delay.cpp	/^static void do_path_counting(float criticality_denom);$/;"	p	file:	signature:(float criticality_denom)
do_placement	base/read_options.h	/^    argparse::ArgValue<bool> do_placement;$/;"	m	struct:t_options	access:public
do_power	base/read_options.h	/^    argparse::ArgValue<bool> do_power;$/;"	m	struct:t_options	access:public
do_power	base/vpr_types.h	/^	bool do_power; \/* Perform power estimation? *\/$/;"	m	struct:ScreenUpdatePriority::t_power_opts	access:public
do_routing	base/read_options.h	/^    argparse::ArgValue<bool> do_routing;$/;"	m	struct:t_options	access:public
do_timing_analysis	timing/path_delay.cpp	/^void do_timing_analysis(t_slack * slacks, const t_timing_inf &timing_inf, bool is_prepacked, bool is_final_analysis) {$/;"	f	signature:(t_slack * slacks, const t_timing_inf &timing_inf, bool is_prepacked, bool is_final_analysis)
do_timing_analysis	timing/path_delay.h	/^void do_timing_analysis(t_slack * slacks, const t_timing_inf &timing_inf, bool is_prepacked, bool is_final_analysis);$/;"	p	signature:(t_slack * slacks, const t_timing_inf &timing_inf, bool is_prepacked, bool is_final_analysis)
do_timing_analysis_for_constraint	timing/path_delay.cpp	/^static float do_timing_analysis_for_constraint(int source_clock_domain, int sink_clock_domain,$/;"	f	file:	signature:(int source_clock_domain, int sink_clock_domain, bool is_prepacked, bool is_final_analysis, long * max_critical_input_paths_ptr, long * max_critical_output_paths_ptr, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping, const t_timing_inf &timing_inf)
do_timing_analysis_for_constraint	timing/path_delay.cpp	/^static float do_timing_analysis_for_constraint(int source_clock_domain, int sink_clock_domain,$/;"	p	file:	signature:(int source_clock_domain, int sink_clock_domain, bool is_prepacked, bool is_final_analysis, long * max_critical_input_paths_ptr, long * max_critical_output_paths_ptr, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping, const t_timing_inf &timing_inf)
document_buffer_order	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const void* document_buffer_order(const xpath_node& xnode)$/;"	f	signature:(const xpath_node& xnode)
document_element	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_document::document_element() const$/;"	f	class:pugi::xml_document	signature:() const
document_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node document_element() const;$/;"	p	class:pugi::xml_document	access:public	signature:() const
document_order_comparator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct document_order_comparator$/;"	s	file:
document_order_comparator::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const$/;"	f	struct:document_order_comparator	access:public	signature:(const xpath_node& lhs, const xpath_node& rhs) const
domain_constraint	base/vpr_types.h	/^    vtr::Matrix<float> domain_constraint; \/* [0..num_constrained_clocks - 1 (source)][0..num_constrained_clocks - 1 (destination)] *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
done_callibration	power/PowerSpicedComponent.h	/^	bool done_callibration;$/;"	m	class:PowerCallibInputs	access:public
done_callibration	power/PowerSpicedComponent.h	/^	bool done_callibration;$/;"	m	class:PowerSpicedComponent	access:public
draw	../../libs/libeasygl/src/graphics.cpp	/^    XftDraw* draw;$/;"	m	struct:__anon18	file:	access:public
draw_area	../../libs/libeasygl/src/graphics_state.h	/^    Drawable* draw_area = nullptr;$/;"	m	class:t_x11_state	access:public
draw_area_draw	../../libs/libeasygl/src/graphics_state.h	/^            *draw_area_draw = nullptr;$/;"	m	class:t_x11_state	access:public
draw_atoms_fanin_fanout_flylines	draw/intra_logic_block.cpp	/^void draw_atoms_fanin_fanout_flylines(const std::vector<AtomBlockId>& atoms) {$/;"	f	signature:(const std::vector<AtomBlockId>& atoms)
draw_atoms_fanin_fanout_flylines	draw/intra_logic_block.cpp	/^void draw_atoms_fanin_fanout_flylines(const std::vector<AtomBlockId>& atoms);$/;"	p	file:	signature:(const std::vector<AtomBlockId>& atoms)
draw_block_pin_util	draw/draw.cpp	/^static void draw_block_pin_util() {$/;"	f	file:	signature:()
draw_block_pin_util	draw/draw.cpp	/^static void draw_block_pin_util();$/;"	p	file:	signature:()
draw_buffer	../../libs/libeasygl/src/graphics_state.h	/^    Pixmap draw_buffer;$/;"	m	class:t_x11_state	access:public
draw_buffer_draw	../../libs/libeasygl/src/graphics_state.h	/^    XftDraw *draw_buffer_draw = nullptr,$/;"	m	class:t_x11_state	access:public
draw_chanx_to_chanx_edge	draw/draw.cpp	/^static void draw_chanx_to_chanx_edge(int from_node, int to_node,$/;"	f	file:	signature:(int from_node, int to_node, int to_track, short switch_type)
draw_chanx_to_chanx_edge	draw/draw.cpp	/^static void draw_chanx_to_chanx_edge(int from_node, int to_node,$/;"	p	file:	signature:(int from_node, int to_node, int to_track, short switch_type)
draw_chanx_to_chany_edge	draw/draw.cpp	/^static void draw_chanx_to_chany_edge(int chanx_node, int chanx_track, int chany_node,$/;"	p	file:	signature:(int chanx_node, int chanx_track, int chany_node, int chany_track, enum e_edge_dir edge_dir, short switch_type)
draw_chanx_to_chany_edge	draw/draw.cpp	/^static void draw_chanx_to_chany_edge(int chanx_node, int chanx_track,$/;"	f	file:	signature:(int chanx_node, int chanx_track, int chany_node, int chany_track, enum e_edge_dir edge_dir, short switch_type)
draw_chany_to_chany_edge	draw/draw.cpp	/^static void draw_chany_to_chany_edge(int from_node, int to_node,$/;"	f	file:	signature:(int from_node, int to_node, int to_track, short switch_type)
draw_chany_to_chany_edge	draw/draw.cpp	/^static void draw_chany_to_chany_edge(int from_node, int to_node,$/;"	p	file:	signature:(int from_node, int to_node, int to_track, short switch_type)
draw_check_rr_node_hit	draw/draw.cpp	/^static int draw_check_rr_node_hit (float click_x, float click_y) {$/;"	f	file:	signature:(float click_x, float click_y)
draw_check_rr_node_hit	draw/draw.cpp	/^static int draw_check_rr_node_hit (float click_x, float click_y);$/;"	p	file:	signature:(float click_x, float click_y)
draw_color_map_legend	draw/draw.cpp	/^static void draw_color_map_legend(const vtr::ColorMap& cmap) {$/;"	f	file:	signature:(const vtr::ColorMap& cmap)
draw_color_map_legend	draw/draw.cpp	/^static void draw_color_map_legend(const vtr::ColorMap& cmap);$/;"	p	file:	signature:(const vtr::ColorMap& cmap)
draw_congestion	draw/draw.cpp	/^static void draw_congestion() {$/;"	f	file:	signature:()
draw_congestion	draw/draw.cpp	/^static void draw_congestion();$/;"	p	file:	signature:()
draw_coords	draw/draw_global.cpp	/^static t_draw_coords draw_coords;$/;"	v	file:
draw_crit_path	draw/draw.cpp	/^static void draw_crit_path() {$/;"	f	file:	signature:()
draw_crit_path	draw/draw.cpp	/^static void draw_crit_path();$/;"	p	file:	signature:()
draw_expand_non_configurable_rr_nodes	draw/draw.cpp	/^static std::set<int> draw_expand_non_configurable_rr_nodes(int from_node) {$/;"	f	file:	signature:(int from_node)
draw_expand_non_configurable_rr_nodes	draw/draw.cpp	/^static std::set<int> draw_expand_non_configurable_rr_nodes(int hit_node);$/;"	p	file:	signature:(int hit_node)
draw_expand_non_configurable_rr_nodes_recurr	draw/draw.cpp	/^static void draw_expand_non_configurable_rr_nodes_recurr(int from_node, std::set<int>& expanded_nodes) {$/;"	f	file:	signature:(int from_node, std::set<int>& expanded_nodes)
draw_expand_non_configurable_rr_nodes_recurr	draw/draw.cpp	/^static void draw_expand_non_configurable_rr_nodes_recurr(int from_node, std::set<int>& expanded_nodes);$/;"	p	file:	signature:(int from_node, std::set<int>& expanded_nodes)
draw_flyline_timing_edge	draw/draw.cpp	/^static void draw_flyline_timing_edge(t_point start, t_point end, float incr_delay) {$/;"	f	file:	signature:(t_point start, t_point end, float incr_delay)
draw_flyline_timing_edge	draw/draw.cpp	/^static void draw_flyline_timing_edge(t_point start, t_point end, float incr_delay);$/;"	p	file:	signature:(t_point start, t_point end, float incr_delay)
draw_get_rr_chan_bbox	draw/draw.cpp	/^static t_bound_box draw_get_rr_chan_bbox (int inode) {$/;"	f	file:	signature:(int inode)
draw_get_rr_chan_bbox	draw/draw.cpp	/^static t_bound_box draw_get_rr_chan_bbox(int inode);$/;"	p	file:	signature:(int inode)
draw_get_rr_pin_coords	draw/draw.cpp	/^void draw_get_rr_pin_coords(const t_rr_node* node, float *xcen, float *ycen) {$/;"	f	signature:(const t_rr_node* node, float *xcen, float *ycen)
draw_get_rr_pin_coords	draw/draw.cpp	/^void draw_get_rr_pin_coords(int inode, float *xcen, float *ycen) {$/;"	f	signature:(int inode, float *xcen, float *ycen)
draw_get_rr_pin_coords	draw/draw.h	/^void draw_get_rr_pin_coords(const t_rr_node* node, float *xcen, float *ycen);$/;"	p	signature:(const t_rr_node* node, float *xcen, float *ycen)
draw_get_rr_pin_coords	draw/draw.h	/^void draw_get_rr_pin_coords(int inode, float *xcen, float *ycen);$/;"	p	signature:(int inode, float *xcen, float *ycen)
draw_highlight_blocks_color	draw/draw.cpp	/^static void draw_highlight_blocks_color(t_type_ptr type, ClusterBlockId blk_id) {$/;"	f	file:	signature:(t_type_ptr type, ClusterBlockId blk_id)
draw_highlight_blocks_color	draw/draw.cpp	/^static void draw_highlight_blocks_color(t_type_ptr type, ClusterBlockId blk_id);$/;"	p	file:	signature:(t_type_ptr type, ClusterBlockId blk_id)
draw_highlight_fan_in_fan_out	draw/draw.cpp	/^static void draw_highlight_fan_in_fan_out(const std::set<int>& nodes) {$/;"	f	file:	signature:(const std::set<int>& nodes)
draw_highlight_fan_in_fan_out	draw/draw.cpp	/^static void draw_highlight_fan_in_fan_out(const std::set<int>& nodes);$/;"	p	file:	signature:(const std::set<int>& nodes)
draw_if_net_highlighted	draw/draw.cpp	/^static bool draw_if_net_highlighted (ClusterNetId inet) {$/;"	f	file:	signature:(ClusterNetId inet)
draw_if_net_highlighted	draw/draw.cpp	/^static bool draw_if_net_highlighted (ClusterNetId inet);$/;"	p	file:	signature:(ClusterNetId inet)
draw_internal_alloc_blk	draw/intra_logic_block.cpp	/^void draw_internal_alloc_blk() {$/;"	f	signature:()
draw_internal_alloc_blk	draw/intra_logic_block.h	/^void draw_internal_alloc_blk();$/;"	p	signature:()
draw_internal_calc_coords	draw/intra_logic_block.cpp	/^draw_internal_calc_coords(int type_descrip_index, t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(int type_descrip_index, t_pb_graph_node *pb_graph_node, int num_pb_types, int type_index, int num_pb, int pb_index, float parent_width, float parent_height, float *blk_width, float *blk_height)
draw_internal_calc_coords	draw/intra_logic_block.cpp	/^static void draw_internal_calc_coords(int type_descrip_index, t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(int type_descrip_index, t_pb_graph_node *pb_graph_node, int num_pb_types, int type_index, int num_pb, int pb_index, float parent_width, float parent_height, float *blk_width, float *blk_height)
draw_internal_draw_subblk	draw/intra_logic_block.cpp	/^void draw_internal_draw_subblk() {$/;"	f	signature:()
draw_internal_draw_subblk	draw/intra_logic_block.h	/^void draw_internal_draw_subblk();$/;"	p	signature:()
draw_internal_find_max_lvl	draw/intra_logic_block.cpp	/^static int draw_internal_find_max_lvl(t_pb_type pb_type) {$/;"	f	file:	signature:(t_pb_type pb_type)
draw_internal_find_max_lvl	draw/intra_logic_block.cpp	/^static int draw_internal_find_max_lvl(t_pb_type pb_type);$/;"	p	file:	signature:(t_pb_type pb_type)
draw_internal_init_blk	draw/intra_logic_block.cpp	/^void draw_internal_init_blk() {$/;"	f	signature:()
draw_internal_init_blk	draw/intra_logic_block.h	/^void draw_internal_init_blk();$/;"	p	signature:()
draw_internal_load_coords	draw/intra_logic_block.cpp	/^static void draw_internal_load_coords(int type_descrip_index, t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(int type_descrip_index, t_pb_graph_node *pb_graph_node, float parent_width, float parent_height)
draw_internal_load_coords	draw/intra_logic_block.cpp	/^static void draw_internal_load_coords(int type_descrip_index, t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(int type_descrip_index, t_pb_graph_node *pb_graph_node, float parent_width, float parent_height)
draw_internal_pb	draw/intra_logic_block.cpp	/^static void draw_internal_pb(const ClusterBlockId clb_index, t_pb* pb, const t_bound_box& parent_bbox, const t_type_ptr type) {$/;"	f	file:	signature:(const ClusterBlockId clb_index, t_pb* pb, const t_bound_box& parent_bbox, const t_type_ptr type)
draw_internal_pb	draw/intra_logic_block.cpp	/^static void draw_internal_pb(const ClusterBlockId clb_index, t_pb* pb, const t_bound_box& parent_bbox, const t_type_ptr type);$/;"	p	file:	signature:(const ClusterBlockId clb_index, t_pb* pb, const t_bound_box& parent_bbox, const t_type_ptr type)
draw_logical_connections	draw/intra_logic_block.cpp	/^void draw_logical_connections() {$/;"	f	signature:()
draw_logical_connections	draw/intra_logic_block.h	/^void draw_logical_connections();$/;"	p	signature:()
draw_message	../../libs/libeasygl/src/graphics.cpp	/^draw_message() {$/;"	f	signature:()
draw_message	../../libs/libeasygl/src/graphics.cpp	/^void draw_message(void) { }$/;"	f	signature:(void)
draw_message	../../libs/libeasygl/src/graphics.h	/^void draw_message();$/;"	p	signature:()
draw_mux	draw/draw.cpp	/^static inline t_bound_box draw_mux(t_point origin, e_side orientation, float height) {$/;"	f	file:	signature:(t_point origin, e_side orientation, float height)
draw_mux	draw/draw.cpp	/^static inline t_bound_box draw_mux(t_point origin, e_side orientation, float height);$/;"	p	file:	signature:(t_point origin, e_side orientation, float height)
draw_mux	draw/draw.cpp	/^static inline t_bound_box draw_mux(t_point origin, e_side orientation, float height, float width, float height_scale);$/;"	p	file:	signature:(t_point origin, e_side orientation, float height, float width, float height_scale)
draw_mux	draw/draw.cpp	/^static inline t_bound_box draw_mux(t_point origin, e_side orientation, float height, float width, float scale) {$/;"	f	file:	signature:(t_point origin, e_side orientation, float height, float width, float scale)
draw_mux_with_size	draw/draw.cpp	/^static inline void draw_mux_with_size(t_point origin, e_side orientation, float height, int size) {$/;"	f	file:	signature:(t_point origin, e_side orientation, float height, int size)
draw_mux_with_size	draw/draw.cpp	/^static inline void draw_mux_with_size(t_point origin, e_side orientation, float height, int size);$/;"	p	file:	signature:(t_point origin, e_side orientation, float height, int size)
draw_one_logical_connection	draw/intra_logic_block.cpp	/^void draw_one_logical_connection(const AtomPinId src_pin, const AtomPinId sink_pin) {$/;"	f	signature:(const AtomPinId src_pin, const AtomPinId sink_pin)
draw_one_logical_connection	draw/intra_logic_block.cpp	/^void draw_one_logical_connection(const AtomPinId src_pin, const AtomPinId sink_pin);$/;"	p	file:	signature:(const AtomPinId src_pin, const AtomPinId sink_pin)
draw_partial_route	draw/draw.cpp	/^void draw_partial_route(const std::vector<int>& rr_nodes_to_draw) {$/;"	f	signature:(const std::vector<int>& rr_nodes_to_draw)
draw_partial_route	draw/draw.cpp	/^void draw_partial_route(const std::vector<int>& rr_nodes_to_draw);$/;"	p	file:	signature:(const std::vector<int>& rr_nodes_to_draw)
draw_pin_to_chan_edge	draw/draw.cpp	/^static void draw_pin_to_chan_edge(int pin_node, int chan_node) {$/;"	f	file:	signature:(int pin_node, int chan_node)
draw_pin_to_chan_edge	draw/draw.cpp	/^static void draw_pin_to_chan_edge(int pin_node, int chan_node);$/;"	p	file:	signature:(int pin_node, int chan_node)
draw_pin_to_pin	draw/draw.cpp	/^static void draw_pin_to_pin(int opin, int ipin);$/;"	p	file:	signature:(int opin, int ipin)
draw_pin_to_pin	draw/draw.cpp	/^static void draw_pin_to_pin(int opin_node, int ipin_node) {$/;"	f	file:	signature:(int opin_node, int ipin_node)
draw_reset_blk_color	draw/draw.cpp	/^static void draw_reset_blk_color(ClusterBlockId blk_id) {$/;"	f	file:	signature:(ClusterBlockId blk_id)
draw_reset_blk_color	draw/draw.cpp	/^static void draw_reset_blk_color(ClusterBlockId blk_id);$/;"	p	file:	signature:(ClusterBlockId blk_id)
draw_reset_blk_colors	draw/draw.cpp	/^static void draw_reset_blk_colors() {$/;"	f	file:	signature:()
draw_reset_blk_colors	draw/draw.cpp	/^static void draw_reset_blk_colors();$/;"	p	file:	signature:()
draw_route_type	draw/draw_types.h	/^	e_route_type draw_route_type = GLOBAL;$/;"	m	struct:t_draw_state	access:public
draw_routed_net	draw/draw.cpp	/^static void draw_routed_net(ClusterNetId net);$/;"	p	file:	signature:(ClusterNetId net)
draw_routed_net	draw/draw.cpp	/^static void draw_routed_net(ClusterNetId net_id) {$/;"	f	file:	signature:(ClusterNetId net_id)
draw_routed_timing_edge	draw/draw.cpp	/^static void draw_routed_timing_edge(tatum::NodeId start_tnode, tatum::NodeId end_tnode, float incr_delay, t_color color) {$/;"	f	file:	signature:(tatum::NodeId start_tnode, tatum::NodeId end_tnode, float incr_delay, t_color color)
draw_routed_timing_edge	draw/draw.cpp	/^static void draw_routed_timing_edge(tatum::NodeId start_tnode, tatum::NodeId end_tnode, float incr_delay, t_color color);$/;"	p	file:	signature:(tatum::NodeId start_tnode, tatum::NodeId end_tnode, float incr_delay, t_color color)
draw_routed_timing_edge_connection	draw/draw.cpp	/^static void draw_routed_timing_edge_connection(tatum::NodeId src_tnode, tatum::NodeId sink_tnode, t_color color) {$/;"	f	file:	signature:(tatum::NodeId src_tnode, tatum::NodeId sink_tnode, t_color color)
draw_routed_timing_edge_connection	draw/draw.cpp	/^static void draw_routed_timing_edge_connection(tatum::NodeId src_tnode, tatum::NodeId sink_tnode, t_color color);$/;"	p	file:	signature:(tatum::NodeId src_tnode, tatum::NodeId sink_tnode, t_color color)
draw_router_rr_costs	draw/draw.cpp	/^static void draw_router_rr_costs() {$/;"	f	file:	signature:()
draw_router_rr_costs	draw/draw.cpp	/^static void draw_router_rr_costs();$/;"	p	file:	signature:()
draw_routing_bb	draw/draw.cpp	/^static void draw_routing_bb() {$/;"	f	file:	signature:()
draw_routing_bb	draw/draw.cpp	/^static void draw_routing_bb();$/;"	p	file:	signature:()
draw_routing_costs	draw/draw.cpp	/^static void draw_routing_costs() {$/;"	f	file:	signature:()
draw_routing_costs	draw/draw.cpp	/^static void draw_routing_costs();$/;"	p	file:	signature:()
draw_routing_util	draw/draw.cpp	/^static void draw_routing_util() {$/;"	f	file:	signature:()
draw_routing_util	draw/draw.cpp	/^static void draw_routing_util();$/;"	p	file:	signature:()
draw_rr	draw/draw.cpp	/^static void draw_rr();$/;"	p	file:	signature:()
draw_rr	draw/draw.cpp	/^void draw_rr() {$/;"	f	signature:()
draw_rr_chan	draw/draw.cpp	/^static void draw_rr_chan(int inode, const t_color color) {$/;"	f	file:	signature:(int inode, const t_color color)
draw_rr_chan	draw/draw.cpp	/^static void draw_rr_chan(int inode, const t_color color);$/;"	p	file:	signature:(int inode, const t_color color)
draw_rr_costs	draw/draw.cpp	/^static void draw_rr_costs(const std::vector<float>& rr_costs, bool lowest_cost_first) {$/;"	f	file:	signature:(const std::vector<float>& rr_costs, bool lowest_cost_first)
draw_rr_costs	draw/draw.cpp	/^static void draw_rr_costs(const std::vector<float>& rr_costs, bool lowest_cost_first=true);$/;"	p	file:	signature:(const std::vector<float>& rr_costs, bool lowest_cost_first=true)
draw_rr_edges	draw/draw.cpp	/^static void draw_rr_edges(int from_node);$/;"	p	file:	signature:(int from_node)
draw_rr_edges	draw/draw.cpp	/^static void draw_rr_edges(int inode) {$/;"	f	file:	signature:(int inode)
draw_rr_node	draw/draw_types.h	/^	t_draw_rr_node *draw_rr_node = nullptr;$/;"	m	struct:t_draw_state	access:public
draw_rr_pin	draw/draw.cpp	/^static void draw_rr_pin(int inode, const t_color& color) {$/;"	f	file:	signature:(int inode, const t_color& color)
draw_rr_pin	draw/draw.cpp	/^static void draw_rr_pin(int inode, const t_color& color);$/;"	p	file:	signature:(int inode, const t_color& color)
draw_rr_src_sink	draw/draw.cpp	/^static void draw_rr_src_sink(int inode, t_color color) {$/;"	f	file:	signature:(int inode, t_color color)
draw_rr_src_sink	draw/draw.cpp	/^static void draw_rr_src_sink(int inode, t_color color);$/;"	p	file:	signature:(int inode, t_color color)
draw_rr_switch	draw/draw.cpp	/^static void draw_rr_switch(float from_x, float from_y, float to_x, float to_y, bool buffered, bool configurable) {$/;"	f	file:	signature:(float from_x, float from_y, float to_x, float to_y, bool buffered, bool configurable)
draw_rr_switch	draw/draw.cpp	/^static void draw_rr_switch(float from_x, float from_y, float to_x, float to_y,$/;"	p	file:	signature:(float from_x, float from_y, float to_x, float to_y, bool buffered, bool switch_configurable)
draw_rr_toggle	draw/draw_types.h	/^	e_draw_rr_toggle draw_rr_toggle = DRAW_NO_RR;$/;"	m	struct:t_draw_state	access:public
draw_selected_pb_flylines	draw/intra_logic_block.cpp	/^void draw_selected_pb_flylines() {$/;"	f	signature:()
draw_selected_pb_flylines	draw/intra_logic_block.cpp	/^void draw_selected_pb_flylines();$/;"	p	file:	signature:()
draw_state	draw/draw_global.cpp	/^static t_draw_state draw_state;$/;"	v	file:
draw_surface	../../libs/libeasygl/src/Surface.h	/^        friend void draw_surface(const Surface& surface, float x, float y);$/;"	p	class:Surface	access:friend	signature:(const Surface& surface, float x, float y)
draw_surface	../../libs/libeasygl/src/graphics.cpp	/^void draw_surface(const Surface& surface, float x, float y) {$/;"	f	signature:(const Surface& surface, float x, float y)
draw_surface	../../libs/libeasygl/src/graphics.cpp	/^void draw_surface(const Surface& surface, t_point upper_left) {$/;"	f	signature:(const Surface& surface, t_point upper_left)
draw_surface	../../libs/libeasygl/src/graphics.h	/^void draw_surface(const Surface& surface, float x, float y);$/;"	p	signature:(const Surface& surface, float x, float y)
draw_surface	../../libs/libeasygl/src/graphics.h	/^void draw_surface(const Surface& surface, t_point upper_left);$/;"	p	signature:(const Surface& surface, t_point upper_left)
draw_triangle_along_line	draw/draw.cpp	/^void draw_triangle_along_line(float xend, float yend, float x1, float x2, float y1, float y2, float arrow_size) {$/;"	f	signature:(float xend, float yend, float x1, float x2, float y1, float y2, float arrow_size)
draw_triangle_along_line	draw/draw.cpp	/^void draw_triangle_along_line(t_point loc, t_point start, t_point end, float arrow_size) {$/;"	f	signature:(t_point loc, t_point start, t_point end, float arrow_size)
draw_triangle_along_line	draw/draw.cpp	/^void draw_triangle_along_line(t_point start, t_point end, float relative_position, float arrow_size) {$/;"	f	signature:(t_point start, t_point end, float relative_position, float arrow_size)
draw_triangle_along_line	draw/draw.h	/^void draw_triangle_along_line(float xend, float yend, float x1 ,float x2, float y1, float y2, float arrow_size=DEFAULT_ARROW_SIZE);$/;"	p	signature:(float xend, float yend, float x1 ,float x2, float y1, float y2, float arrow_size=DEFAULT_ARROW_SIZE)
draw_triangle_along_line	draw/draw.h	/^void draw_triangle_along_line(t_point loc, t_point start, t_point end, float arrow_size=DEFAULT_ARROW_SIZE);$/;"	p	signature:(t_point loc, t_point start, t_point end, float arrow_size=DEFAULT_ARROW_SIZE)
draw_triangle_along_line	draw/draw.h	/^void draw_triangle_along_line(t_point start, t_point end, float relative_position=1., float arrow_size=DEFAULT_ARROW_SIZE);$/;"	p	signature:(t_point start, t_point end, float relative_position=1., float arrow_size=DEFAULT_ARROW_SIZE)
draw_x	draw/draw.cpp	/^static void draw_x(float x, float y, float size) {$/;"	f	file:	signature:(float x, float y, float size)
draw_x	draw/draw.cpp	/^static void draw_x(float x, float y, float size);$/;"	p	file:	signature:(float x, float y, float size)
drawarc	../../libs/libeasygl/src/graphics.cpp	/^drawarc(float xc, float yc, float rad, float startang,$/;"	f	signature:(float xc, float yc, float rad, float startang, float angextent)
drawarc	../../libs/libeasygl/src/graphics.cpp	/^void drawarc(float \/*xcen*\/, float \/*ycen*\/, float \/*rad*\/, float \/*startang*\/,$/;"	f	signature:(float , float , float , float , float )
drawarc	../../libs/libeasygl/src/graphics.h	/^void drawarc(float xcen, float ycen, float rad, float startang,$/;"	p	signature:(float xcen, float ycen, float rad, float startang, float angextent)
drawellipticarc	../../libs/libeasygl/src/graphics.cpp	/^drawellipticarc(float xc, float yc, float radx, float rady, float startang, float angextent) {$/;"	f	signature:(float xc, float yc, float radx, float rady, float startang, float angextent)
drawellipticarc	../../libs/libeasygl/src/graphics.cpp	/^void drawellipticarc($/;"	f	signature:( const t_point& , float , float , float , float )
drawellipticarc	../../libs/libeasygl/src/graphics.cpp	/^void drawellipticarc($/;"	f	signature:( const t_point& center, float radx, float rady, float startang, float angextent)
drawellipticarc	../../libs/libeasygl/src/graphics.cpp	/^void drawellipticarc(float \/*xc*\/, float \/*yc*\/, float \/*radx*\/, float \/*rady*\/,$/;"	f	signature:(float , float , float , float , float , float )
drawellipticarc	../../libs/libeasygl/src/graphics.h	/^void drawellipticarc($/;"	p	signature:( const t_point& center, float radx, float rady, float startang, float angextent)
drawellipticarc	../../libs/libeasygl/src/graphics.h	/^void drawellipticarc($/;"	p	signature:( float xc, float yc, float radx, float rady, float startang, float angextent)
drawline	../../libs/libeasygl/src/graphics.cpp	/^drawline(float x1, float y1, float x2, float y2) {$/;"	f	signature:(float x1, float y1, float x2, float y2)
drawline	../../libs/libeasygl/src/graphics.cpp	/^void drawline(const t_point& \/*p1*\/, const t_point& \/*p2*\/) { }$/;"	f	signature:(const t_point& , const t_point& )
drawline	../../libs/libeasygl/src/graphics.cpp	/^void drawline(const t_point& p1, const t_point& p2) {$/;"	f	signature:(const t_point& p1, const t_point& p2)
drawline	../../libs/libeasygl/src/graphics.cpp	/^void drawline(float \/*x1*\/, float \/*y1*\/, float \/*x2*\/, float \/*y2*\/) { }$/;"	f	signature:(float , float , float , float )
drawline	../../libs/libeasygl/src/graphics.h	/^void drawline(const t_point& p1, const t_point& p2);$/;"	p	signature:(const t_point& p1, const t_point& p2)
drawline	../../libs/libeasygl/src/graphics.h	/^void drawline(float x1, float y1, float x2, float y2);$/;"	p	signature:(float x1, float y1, float x2, float y2)
drawnets	draw/draw.cpp	/^static void drawnets() {$/;"	f	file:	signature:()
drawnets	draw/draw.cpp	/^static void drawnets();$/;"	p	file:	signature:()
drawplace	draw/draw.cpp	/^static void drawplace() {$/;"	f	file:	signature:()
drawplace	draw/draw.cpp	/^static void drawplace();$/;"	p	file:	signature:()
drawrect	../../libs/libeasygl/src/graphics.cpp	/^drawrect(float x1, float y1, float x2, float y2) {$/;"	f	signature:(float x1, float y1, float x2, float y2)
drawrect	../../libs/libeasygl/src/graphics.cpp	/^void drawrect(const t_bound_box& \/*rect*\/) { }$/;"	f	signature:(const t_bound_box& )
drawrect	../../libs/libeasygl/src/graphics.cpp	/^void drawrect(const t_bound_box& rect) {$/;"	f	signature:(const t_bound_box& rect)
drawrect	../../libs/libeasygl/src/graphics.cpp	/^void drawrect(const t_point& \/*bottomleft*\/, const t_point& \/*upperright*\/) { }$/;"	f	signature:(const t_point& , const t_point& )
drawrect	../../libs/libeasygl/src/graphics.cpp	/^void drawrect(const t_point& bottomleft, const t_point& upperright) {$/;"	f	signature:(const t_point& bottomleft, const t_point& upperright)
drawrect	../../libs/libeasygl/src/graphics.cpp	/^void drawrect(float \/*x1*\/, float \/*y1*\/, float \/*x2*\/, float \/*y2*\/) { }$/;"	f	signature:(float , float , float , float )
drawrect	../../libs/libeasygl/src/graphics.h	/^void drawrect(const t_bound_box& rect);$/;"	p	signature:(const t_bound_box& rect)
drawrect	../../libs/libeasygl/src/graphics.h	/^void drawrect(const t_point& bottomleft, const t_point& upperright);$/;"	p	signature:(const t_point& bottomleft, const t_point& upperright)
drawrect	../../libs/libeasygl/src/graphics.h	/^void drawrect(float x1, float y1, float x2, float y2);$/;"	p	signature:(float x1, float y1, float x2, float y2)
drawroute	draw/draw.cpp	/^static void drawroute(enum e_draw_net_type draw_net_type) {$/;"	f	file:	signature:(enum e_draw_net_type draw_net_type)
drawroute	draw/draw.cpp	/^static void drawroute(enum e_draw_net_type draw_net_type);$/;"	p	file:	signature:(enum e_draw_net_type draw_net_type)
drawscreen	draw/draw.cpp	/^static void drawscreen() {$/;"	f	file:	signature:()
drawscreen	draw/draw.cpp	/^static void drawscreen();$/;"	p	file:	signature:()
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext($/;"	f	signature:( const t_point& text_center, const std::string& text, const t_bound_box& bounds, float tolerance)
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(const t_point& \/*text_center*\/, const std::string& \/*text*\/, const t_bound_box& \/*bounds*\/) { }$/;"	f	signature:(const t_point& , const std::string& , const t_bound_box& )
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(const t_point& \/*text_center*\/, const std::string& \/*text*\/, const t_bound_box& \/*bounds*\/, float \/*tolerance*\/) { }$/;"	f	signature:(const t_point& , const std::string& , const t_bound_box& , float )
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(const t_point& \/*text_center*\/, const std::string& \/*text*\/, float \/*boundx*\/, float \/*boundy*\/) { }$/;"	f	signature:(const t_point& , const std::string& , float , float )
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(const t_point& text_center, const std::string& text, const t_bound_box& bounds) {$/;"	f	signature:(const t_point& text_center, const std::string& text, const t_bound_box& bounds)
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(const t_point& text_center, const std::string& text, float boundx, float boundy) {$/;"	f	signature:(const t_point& text_center, const std::string& text, float boundx, float boundy)
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(float \/*xc*\/, float \/*yc*\/, const std::string& \/*text*\/, float \/*boundx*\/, float \/*boundy*\/) { }$/;"	f	signature:(float , float , const std::string& , float , float )
drawtext	../../libs/libeasygl/src/graphics.cpp	/^void drawtext(float xc, float yc, const std::string& str_text, float boundx, float boundy) {$/;"	f	signature:(float xc, float yc, const std::string& str_text, float boundx, float boundy)
drawtext	../../libs/libeasygl/src/graphics.h	/^void drawtext(const t_point& text_center, const std::string& text, const t_bound_box& bounds);$/;"	p	signature:(const t_point& text_center, const std::string& text, const t_bound_box& bounds)
drawtext	../../libs/libeasygl/src/graphics.h	/^void drawtext(const t_point& text_center, const std::string& text, const t_bound_box& bounds, float tolerance);$/;"	p	signature:(const t_point& text_center, const std::string& text, const t_bound_box& bounds, float tolerance)
drawtext	../../libs/libeasygl/src/graphics.h	/^void drawtext(const t_point& text_center, const std::string& text, float boundx=FLT_MAX, float boundy=FLT_MAX);$/;"	p	signature:(const t_point& text_center, const std::string& text, float boundx=FLT_MAX, float boundy=FLT_MAX)
drawtext	../../libs/libeasygl/src/graphics.h	/^void drawtext(float xc, float yc, const std::string& text, float boundx=FLT_MAX, float boundy=FLT_MAX);$/;"	p	signature:(float xc, float yc, const std::string& text, float boundx=FLT_MAX, float boundy=FLT_MAX)
drawtext_in	../../libs/libeasygl/src/graphics.cpp	/^void drawtext_in(const t_bound_box& \/*bbox*\/, const std::string& \/*text*\/) { }$/;"	f	signature:(const t_bound_box& , const std::string& )
drawtext_in	../../libs/libeasygl/src/graphics.cpp	/^void drawtext_in(const t_bound_box& \/*bbox*\/, const std::string& \/*text*\/, float \/*tolerance*\/) { }$/;"	f	signature:(const t_bound_box& , const std::string& , float )
drawtext_in	../../libs/libeasygl/src/graphics.cpp	/^void drawtext_in(const t_bound_box& bbox, const std::string& text) {$/;"	f	signature:(const t_bound_box& bbox, const std::string& text)
drawtext_in	../../libs/libeasygl/src/graphics.cpp	/^void drawtext_in(const t_bound_box& bbox, const std::string& text, float tolerance) {$/;"	f	signature:(const t_bound_box& bbox, const std::string& text, float tolerance)
drawtext_in	../../libs/libeasygl/src/graphics.h	/^void drawtext_in(const t_bound_box& bbox, const std::string& text);$/;"	p	signature:(const t_bound_box& bbox, const std::string& text)
drawtext_in	../../libs/libeasygl/src/graphics.h	/^void drawtext_in(const t_bound_box& bbox, const std::string& text, float tolerance);$/;"	p	signature:(const t_bound_box& bbox, const std::string& text, float tolerance)
drawtextleftaligned	../../libs/libeasygl/src/graphics.h	/^void drawtextleftaligned(float xc, float yc, const std::string& text, float boundx = FLT_MAX, float boundy = FLT_MAX);	\/\/ <Addition\/Mod: Charles>$/;"	p	signature:(float xc, float yc, const std::string& text, float boundx = FLT_MAX, float boundy = FLT_MAX)
drawtextrightaligned	../../libs/libeasygl/src/graphics.h	/^void drawtextrightaligned(float xc, float yc, const std::string& text, float boundx = FLT_MAX, float boundy = FLT_MAX);	\/\/ <Addition\/Mod: Charles>$/;"	p	signature:(float xc, float yc, const std::string& text, float boundx = FLT_MAX, float boundy = FLT_MAX)
driven_by_moved_block	place/place.cpp	/^static bool driven_by_moved_block(const ClusterNetId net) {$/;"	f	file:	signature:(const ClusterNetId net)
driven_by_moved_block	place/place.cpp	/^static bool driven_by_moved_block(const ClusterNetId net);$/;"	p	file:	signature:(const ClusterNetId net)
driver_clb_max_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> driver_clb_max_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
driver_clb_min_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> driver_clb_min_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
driver_pb_pin_id	base/vpr_types.h	/^	int driver_pb_pin_id = OPEN; \/* The pb_pin id of the pb_pin that drives this pin *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
driver_pin	../../libs/libarchfpga/src/physical_types.h	/^	int driver_pin;$/;"	m	struct:t_pb_graph_edge	access:public
driver_set	../../libs/libarchfpga/src/physical_types.h	/^	int driver_set;$/;"	m	struct:t_pb_graph_edge	access:public
driver_switch_type	power/power.h	/^	short driver_switch_type; \/* Switch type that drives this resource *\/$/;"	m	struct:t_rr_node_power	access:public
dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConcreteHoldTimingInfo	access:private
dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConcreteSetupHoldTimingInfo	access:private
dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConcreteSetupTimingInfo	access:private
dsec	timing/concrete_timing_info.h	/^        typedef std::chrono::duration<double> dsec;$/;"	t	class:ConstantTimingInfo	access:private
dummy_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const xpath_node_set dummy_node_set;$/;"	v	file:
dump_chan_details	route/rr_graph2.cpp	/^void dump_chan_details($/;"	f	signature:( const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int max_chan_width, const DeviceGrid& grid, const char *fname)
dump_chan_details	route/rr_graph2.h	/^void dump_chan_details($/;"	p	signature:( const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int max_chan_width, const DeviceGrid& grid, const char *fname)
dump_echo	place/place_delay_model.cpp	/^void DeltaDelayModel::dump_echo(std::string filepath) const {$/;"	f	class:DeltaDelayModel	signature:(std::string filepath) const
dump_echo	place/place_delay_model.cpp	/^void OverrideDelayModel::dump_echo(std::string filepath) const {$/;"	f	class:OverrideDelayModel	signature:(std::string filepath) const
dump_echo	place/place_delay_model.h	/^        virtual void dump_echo(std::string filename) const = 0;$/;"	p	class:PlaceDelayModel	access:public	signature:(std::string filename) const
dump_rr_graph	route/rr_graph.cpp	/^void dump_rr_graph(const char *file_name) {$/;"	f	signature:(const char *file_name)
dump_rr_graph	route/rr_graph.h	/^void dump_rr_graph(const char *file_name);$/;"	p	signature:(const char *file_name)
dump_sblock_pattern	route/rr_graph2.cpp	/^void dump_sblock_pattern($/;"	f	signature:( const t_sblock_pattern& sblock_pattern, int max_chan_width, const DeviceGrid& grid, const char *fname)
dump_sblock_pattern	route/rr_graph2.h	/^void dump_sblock_pattern($/;"	p	signature:( const t_sblock_pattern& sblock_pattern, int max_chan_width, const DeviceGrid& grid, const char *fname)
dump_seg_details	route/rr_graph2.cpp	/^void dump_seg_details($/;"	f	signature:( const t_chan_seg_details * seg_details, int max_chan_width, const char *fname)
dump_seg_details	route/rr_graph2.cpp	/^void dump_seg_details($/;"	f	signature:( const t_chan_seg_details* seg_details, int max_chan_width, FILE* fp)
dump_seg_details	route/rr_graph2.cpp	/^void dump_seg_details($/;"	p	file:	signature:( t_seg_details * seg_details, int max_chan_width, const char *fname)
dump_seg_details	route/rr_graph2.h	/^void dump_seg_details($/;"	p	signature:( const t_chan_seg_details *seg_details, int max_chan_width, FILE *fp)
dump_seg_details	route/rr_graph2.h	/^void dump_seg_details($/;"	p	signature:( const t_chan_seg_details *seg_details, int max_chan_width, const char *fname)
duplicate_comparator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct duplicate_comparator$/;"	s	file:
duplicate_comparator::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const$/;"	f	struct:duplicate_comparator	access:public	signature:(const xpath_node& lhs, const xpath_node& rhs) const
duplicate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* duplicate_string(const char_t* string, size_t length, xpath_allocator* alloc)$/;"	f	class:xpath_string	file:	access:private	signature:(const char_t* string, size_t length, xpath_allocator* alloc)
dynamic	../../libs/libarchfpga/src/physical_types.h	/^	float dynamic;$/;"	m	struct:t_power_usage	access:public
dynamic_update_bounding_boxes	route/route_timing.cpp	/^static size_t dynamic_update_bounding_boxes(int high_fanout_threshold) {$/;"	f	file:	signature:(int high_fanout_threshold)
dynamic_update_bounding_boxes	route/route_timing.cpp	/^static size_t dynamic_update_bounding_boxes(int high_fanout_threshold);$/;"	p	file:	signature:(int high_fanout_threshold)
e_Fc_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_Fc_type {$/;"	g
e_base_cost_type	base/vpr_types.h	/^enum e_base_cost_type {$/;"	g	class:ScreenUpdatePriority	access:private
e_block_pack_status	base/vpr_types.h	/^enum e_block_pack_status {$/;"	g	class:ScreenUpdatePriority	access:private
e_circuit_format	base/read_circuit.h	/^enum class e_circuit_format {$/;"	c
e_circuit_format::AUTO	base/read_circuit.h	/^    AUTO, \/\/Infer from file extension$/;"	m	class:e_circuit_format	access:private
e_circuit_format::BLIF	base/read_circuit.h	/^    BLIF, \/\/Strict structural BLIF$/;"	m	class:e_circuit_format	access:private
e_clock_modeling	base/clock_modeling.h	/^enum e_clock_modeling {$/;"	g
e_cluster_seed	base/vpr_types.h	/^enum class e_cluster_seed {$/;"	c	class:ScreenUpdatePriority	access:private
e_commit_remove	pack/cluster_router.cpp	/^enum e_commit_remove {RT_COMMIT, RT_REMOVE};$/;"	g	file:
e_const_gen_inference	base/vpr_types.h	/^enum class e_const_gen_inference {$/;"	c	class:ScreenUpdatePriority	access:private
e_constant_net_method	base/constant_nets.h	/^enum e_constant_net_method {$/;"	g
e_cost_indices	base/vpr_types.h	/^enum e_cost_indices {$/;"	g	class:ScreenUpdatePriority	access:private
e_cost_methods	place/place.cpp	/^enum e_cost_methods {$/;"	g	file:
e_detailed_routing_stages	pack/cluster.cpp	/^enum e_detailed_routing_stages {$/;"	g	file:
e_directionality	../../libs/libarchfpga/src/physical_types.h	/^enum e_directionality {$/;"	g
e_draw_block_pin_util	draw/draw_types.h	/^enum e_draw_block_pin_util {$/;"	g
e_draw_congestion	draw/draw_types.h	/^enum e_draw_congestion {$/;"	g
e_draw_crit_path	draw/draw_types.h	/^enum e_draw_crit_path {$/;"	g
e_draw_mode	../../libs/libeasygl/src/easygl_constants.h	/^enum e_draw_mode {$/;"	g
e_draw_net_type	draw/draw_types.h	/^enum e_draw_net_type {$/;"	g
e_draw_nets	draw/draw_types.h	/^enum e_draw_nets {$/;"	g
e_draw_router_rr_cost	draw/draw_types.h	/^enum e_draw_router_rr_cost {$/;"	g
e_draw_routing_costs	draw/draw_types.h	/^enum e_draw_routing_costs {$/;"	g
e_draw_routing_util	draw/draw_types.h	/^enum e_draw_routing_util {$/;"	g
e_draw_rr_toggle	draw/draw_types.h	/^enum e_draw_rr_toggle {$/;"	g
e_echo_files	base/echo_files.h	/^enum e_echo_files {$/;"	g
e_edge_dir	draw/draw_types.h	/^enum e_edge_dir {$/;"	g
e_fc_type	../../libs/libarchfpga/src/physical_types.h	/^enum class e_fc_type {$/;"	c
e_fc_type::IN	../../libs/libarchfpga/src/physical_types.h	/^    IN, \/\/The fc specification for an input pin$/;"	m	class:e_fc_type	access:private
e_fc_value_type	../../libs/libarchfpga/src/physical_types.h	/^enum class e_fc_value_type {$/;"	c
e_fc_value_type::FRACTIONAL	../../libs/libarchfpga/src/physical_types.h	/^    FRACTIONAL,   \/\/Fractional Fc specification (i.e. fraction of routing channel tracks)$/;"	m	class:e_fc_value_type	access:private
e_feasibility	pack/cluster.cpp	/^enum e_feasibility {$/;"	g	file:
e_formula_obj	../../libs/libarchfpga/src/expr_eval.cpp	/^typedef enum e_formula_obj{$/;"	g	file:
e_gain_type	pack/cluster.cpp	/^enum e_gain_type {$/;"	g	file:
e_gain_update	pack/cluster.cpp	/^enum e_gain_update {$/;"	g	file:
e_graph_type	route/rr_graph.h	/^enum e_graph_type {$/;"	g
e_incr_reroute_delay_ripup	base/vpr_types.h	/^enum class e_incr_reroute_delay_ripup {$/;"	c	class:ScreenUpdatePriority	access:private
e_interconnect	../../libs/libarchfpga/src/physical_types.h	/^enum e_interconnect {$/;"	g
e_lb_rr_type	pack/pack_types.h	/^enum e_lb_rr_type {$/;"	g
e_metric	route/cb_metrics.h	/^enum e_metric{$/;"	g
e_net_relation_to_clustered_block	pack/cluster.cpp	/^enum e_net_relation_to_clustered_block {$/;"	g	file:
e_operator	../../libs/libarchfpga/src/expr_eval.cpp	/^typedef enum e_operator{$/;"	g	file:
e_output_files	base/echo_files.h	/^enum e_output_files {$/;"	g
e_pack_pattern_molecule_type	base/vpr_types.h	/^enum e_pack_pattern_molecule_type {$/;"	g	class:ScreenUpdatePriority	access:private
e_packer_algorithm	base/vpr_types.h	/^enum e_packer_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
e_pad_loc_type	base/vpr_types.h	/^enum e_pad_loc_type {$/;"	g	class:ScreenUpdatePriority	access:private
e_pb_graph_pin_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_pb_graph_pin_type {$/;"	g
e_pb_type_class	../../libs/libarchfpga/src/physical_types.h	/^enum e_pb_type_class {$/;"	g
e_pin_location_distr	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_location_distr {$/;"	g
e_pin_to_pin_annotation_format	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_to_pin_annotation_format {$/;"	g
e_pin_to_pin_annotation_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_to_pin_annotation_type {$/;"	g
e_pin_to_pin_capacitance_annotations	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_to_pin_capacitance_annotations {$/;"	g
e_pin_to_pin_delay_annotations	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_to_pin_delay_annotations {$/;"	g
e_pin_to_pin_pack_pattern_annotations	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_to_pin_pack_pattern_annotations {$/;"	g
e_pin_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_pin_type {$/;"	g
e_place_algorithm	base/vpr_types.h	/^enum e_place_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
e_power_breakdown_entry_type	power/power.cpp	/^} e_power_breakdown_entry_type;$/;"	t	typeref:enum:__anon5	file:
e_power_buffer_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_power_buffer_type {$/;"	g
e_power_callib_component	power/power_callibrate.h	/^} e_power_callib_component;$/;"	t	typeref:enum:__anon3
e_power_component_type	power/power_components.h	/^} e_power_component_type;$/;"	t	typeref:enum:__anon4
e_power_estimation_method	../../libs/libarchfpga/src/physical_types.h	/^typedef enum e_power_estimation_method_ e_power_estimation_method;$/;"	t	typeref:enum:e_power_estimation_method_
e_power_estimation_method_	../../libs/libarchfpga/src/physical_types.h	/^enum e_power_estimation_method_ {$/;"	g
e_power_log_type	power/power.h	/^} e_power_log_type;$/;"	t	typeref:enum:__anon2
e_power_ret_code	power/power.h	/^} e_power_ret_code;$/;"	t	typeref:enum:__anon1
e_power_wire_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_power_wire_type {$/;"	g
e_reducer	base/vpr_types.h	/^enum class e_reducer {$/;"	c	class:ScreenUpdatePriority	access:private
e_removal_policy	pack/cluster.cpp	/^enum e_removal_policy {$/;"	g	file:
e_representative_entry_method	route/router_lookahead_map.cpp	/^enum e_representative_entry_method{$/;"	g	file:
e_route_bb_update	base/vpr_types.h	/^enum class e_route_bb_update {$/;"	c	class:ScreenUpdatePriority	access:private
e_route_type	base/vpr_types.h	/^enum e_route_type {$/;"	g	class:ScreenUpdatePriority	access:private
e_router_algorithm	base/vpr_types.h	/^enum e_router_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
e_router_lookahead	base/vpr_types.h	/^enum class e_router_lookahead {$/;"	c	class:ScreenUpdatePriority	access:private
e_routing_budgets_algorithm	base/vpr_types.h	/^enum e_routing_budgets_algorithm {$/;"	g	class:ScreenUpdatePriority	access:private
e_routing_failure_predictor	base/vpr_types.h	/^enum e_routing_failure_predictor {$/;"	g	class:ScreenUpdatePriority	access:private
e_sb_location	../../libs/libarchfpga/src/physical_types.h	/^enum e_sb_location{$/;"	g
e_sb_type	../../libs/libarchfpga/src/physical_types.h	/^enum class e_sb_type {$/;"	c
e_sb_type::HORIZONTAL	../../libs/libarchfpga/src/physical_types.h	/^    HORIZONTAL,    \/\/Horizontal straight-through connections$/;"	m	class:e_sb_type	access:private
e_sb_type::NONE	../../libs/libarchfpga/src/physical_types.h	/^    NONE,          \/\/No SB at this location$/;"	m	class:e_sb_type	access:private
e_sb_type::STRAIGHT	../../libs/libarchfpga/src/physical_types.h	/^    STRAIGHT,      \/\/Straight-through connections (i.e. vertical + horizontal)$/;"	m	class:e_sb_type	access:private
e_sb_type::TURNS	../../libs/libarchfpga/src/physical_types.h	/^    TURNS,         \/\/Turning connections only$/;"	m	class:e_sb_type	access:private
e_sb_type::VERTICAL	../../libs/libarchfpga/src/physical_types.h	/^    VERTICAL,      \/\/Vertical straight-through connections$/;"	m	class:e_sb_type	access:private
e_seg_details_type	route/rr_graph2.h	/^enum e_seg_details_type {$/;"	g
e_stage_action	base/vpr_types.h	/^enum e_stage_action {$/;"	g	class:ScreenUpdatePriority	access:private
e_stat	../../libs/libarchfpga/src/physical_types.h	/^enum e_stat {$/;"	g
e_swap_result	place/place.cpp	/^enum e_swap_result {$/;"	g	file:
e_switch_block_type	../../libs/libarchfpga/src/physical_types.h	/^enum e_switch_block_type {$/;"	g
e_timing_report_detail	base/vpr_types.h	/^enum class e_timing_report_detail {$/;"	c	class:ScreenUpdatePriority	access:private
e_tnode_type	base/vpr_types.h	/^enum e_tnode_type {$/;"	g	class:ScreenUpdatePriority	access:private
e_token_type	util/token.h	/^enum e_token_type {$/;"	g
e_trans_area_eq	route/rr_graph_area.cpp	/^enum e_trans_area_eq {	AREA_ORIGINAL,$/;"	g	file:
e_tx_type	power/power.h	/^enum e_tx_type {$/;"	g
e_unrelated_clustering	base/vpr_types.h	/^enum class e_unrelated_clustering {$/;"	c	class:ScreenUpdatePriority	access:private
e_vpr_error	util/vpr_error.h	/^enum e_vpr_error {$/;"	g
early_exit_heuristic	route/route_timing.cpp	/^static bool early_exit_heuristic(const WirelengthInfo& wirelength_info) {$/;"	f	file:	signature:(const WirelengthInfo& wirelength_info)
early_exit_heuristic	route/route_timing.cpp	/^static bool early_exit_heuristic(const WirelengthInfo& wirelength_info);$/;"	p	file:	signature:(const WirelengthInfo& wirelength_info)
early_reconvergence_exit_heuristic	route/route_timing.cpp	/^static bool early_reconvergence_exit_heuristic(const t_router_opts& router_opts, $/;"	p	file:	signature:(const t_router_opts& router_opts, int itry_since_last_convergence, std::shared_ptr<const SetupHoldTimingInfo> timing_info, const RoutingMetrics& best_routing_metrics)
early_reconvergence_exit_heuristic	route/route_timing.cpp	/^static bool early_reconvergence_exit_heuristic(const t_router_opts& router_opts,$/;"	f	file:	signature:(const t_router_opts& router_opts, int itry_since_last_convergence, std::shared_ptr<const SetupHoldTimingInfo> timing_info, const RoutingMetrics& best_routing_metrics)
echoFileEnabled	base/echo_files.cpp	/^static bool *echoFileEnabled = nullptr;$/;"	v	file:
echoFileNames	base/echo_files.cpp	/^static char **echoFileNames = nullptr;$/;"	v	file:
echo_lb_type_rr_graphs	pack/lb_type_rr_graph.cpp	/^void echo_lb_type_rr_graphs(char *filename, std::vector<t_lb_type_rr_node> *lb_type_rr_graphs) {$/;"	f	signature:(char *filename, std::vector<t_lb_type_rr_node> *lb_type_rr_graphs)
echo_lb_type_rr_graphs	pack/lb_type_rr_graph.h	/^void echo_lb_type_rr_graphs(char *filename, std::vector<t_lb_type_rr_node> *lb_type_rr_graphs);$/;"	p	signature:(char *filename, std::vector<t_lb_type_rr_node> *lb_type_rr_graphs)
echo_pb_graph	pack/pb_type_graph.cpp	/^void echo_pb_graph(char * filename) {$/;"	f	signature:(char * filename)
echo_pb_graph	pack/pb_type_graph.h	/^void echo_pb_graph(char * filename);$/;"	p	signature:(char * filename)
echo_pb_pins	pack/pb_type_graph.cpp	/^static void echo_pb_pins(t_pb_graph_pin **pb_graph_pins, const int num_ports,$/;"	f	file:	signature:(t_pb_graph_pin **pb_graph_pins, const int num_ports, const int level, FILE * fp)
echo_pb_pins	pack/pb_type_graph.cpp	/^static void echo_pb_pins(t_pb_graph_pin **pb_graph_pins, const int num_ports,$/;"	p	file:	signature:(t_pb_graph_pin **pb_graph_pins, const int num_ports, const int level, FILE * fp)
echo_pb_rec	pack/pb_type_graph.cpp	/^static void echo_pb_rec(const t_pb_graph_node *pb, const int level,$/;"	p	file:	signature:(const t_pb_graph_node *pb, const int level, FILE * fp)
echo_pb_rec	pack/pb_type_graph.cpp	/^static void echo_pb_rec(const t_pb_graph_node *pb_graph_node, const int level,$/;"	f	file:	signature:(const t_pb_graph_node *pb_graph_node, const int level, FILE *fp)
edge_delay_breakdown	timing/VprTimingGraphResolver.cpp	/^tatum::EdgeDelayBreakdown VprTimingGraphResolver::edge_delay_breakdown(tatum::EdgeId edge, tatum::DelayType tatum_delay_type) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::EdgeId edge, tatum::DelayType tatum_delay_type) const
edge_idx_iterator	route/rr_node.h	/^            edge_idx_iterator(value_type init): value_(init) {}$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:(value_type init)
edge_idx_iterator	route/rr_node.h	/^        class edge_idx_iterator : public std::iterator<std::bidirectional_iterator_tag, short> {$/;"	c	class:t_rr_node	inherits:std::iterator	access:public
edge_idx_range	route/rr_node.h	/^        typedef vtr::Range<edge_idx_iterator> edge_idx_range;$/;"	t	class:t_rr_node	access:public
edge_is_configurable	route/rr_node.cpp	/^bool t_rr_node::edge_is_configurable(short iedge) const {$/;"	f	class:t_rr_node	signature:(short iedge) const
edge_is_configurable	route/rr_node.h	/^        bool edge_is_configurable(short iedge) const;$/;"	p	class:t_rr_node	access:public	signature:(short iedge) const
edge_max_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> edge_max_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
edge_min_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> edge_min_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
edge_sets	route/check_route.cpp	/^    std::set<std::set<t_node_edge>> edge_sets;$/;"	m	struct:t_non_configurable_rr_sets	file:	access:public
edge_sink_node	route/rr_node.h	/^        int edge_sink_node(short iedge) const { VTR_ASSERT_SAFE(iedge < num_edges()); return edges_[iedge].sink_node; }$/;"	f	class:t_rr_node	access:public	signature:(short iedge) const
edge_switch	route/rr_node.h	/^        short edge_switch(short iedge) const { VTR_ASSERT_SAFE(iedge < num_edges()); return edges_[iedge].switch_id; }$/;"	f	class:t_rr_node	access:public	signature:(short iedge) const
edges	route/rr_node.h	/^        edge_idx_range edges() const { return vtr::make_range(edge_idx_iterator(0), edge_idx_iterator(num_edges())); }$/;"	f	class:t_rr_node	access:public	signature:() const
edges_	route/rr_node.h	/^        std::unique_ptr<t_rr_edge[]> edges_ = nullptr;$/;"	m	class:t_rr_node	access:private
edges_capacity_	route/rr_node.h	/^        uint16_t edges_capacity_ = 0;$/;"	m	class:t_rr_node	access:private
edges_head	pack/pb_type_graph.cpp	/^static vtr::t_linked_vptr *edges_head;$/;"	v	file:
elapsed_sec	../../libs/libvtrutil/src/vtr_time.cpp	/^float Timer::elapsed_sec() const {$/;"	f	class:vtr::Timer	signature:() const
elapsed_sec	../../libs/libvtrutil/src/vtr_time.h	/^            float elapsed_sec() const;$/;"	p	class:vtr::Timer	access:public	signature:() const
emit	timing/slre.cpp	/^static void emit(struct slre *r, int code) {$/;"	f	file:	signature:(struct slre *r, int code)
emplace	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator emplace(const key_type& key, Args&&... args) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key, Args&&... args)
emplace	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<iterator,bool> emplace(const key_type& key, Args&&... args) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key, Args&&... args)
emplace_back	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void emplace_back(Args&&... args) { vec_.emplace_back(std::forward<Args>(args)...); }$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
emplace_hint	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator emplace_hint(const_iterator position, Args&&... args) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator position, Args&&... args)
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool empty() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool empty() const$/;"	f	class:xpath_string	access:public	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::empty() const$/;"	f	class:pugi::xml_attribute	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::empty() const$/;"	f	class:pugi::xml_node	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::empty() const$/;"	f	class:pugi::xml_text	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node_set::empty() const$/;"	f	class:pugi::xpath_node_set	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
empty	../../libs/libvtrutil/src/vtr_bimap.h	/^        bool empty() const { return (size() == 0); }$/;"	f	class:vtr::bimap	access:public	signature:() const
empty	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool empty() const { return vec_.empty(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
empty	../../libs/libvtrutil/src/vtr_linear_map.h	/^        bool empty() const { return vec_.empty(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
empty	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        bool empty() const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:() const
empty	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        bool empty() const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:() const
empty	../../libs/libvtrutil/src/vtr_range.h	/^        bool empty() { return begin_ == end_; }$/;"	f	class:vtr::Range	access:public	signature:()
empty	../../libs/libvtrutil/src/vtr_vector_map.h	/^        bool empty() const { return vec_.empty(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
empty_heap	route/route_common.cpp	/^void empty_heap() {$/;"	f	signature:()
empty_heap	route/route_common.h	/^void empty_heap();$/;"	p	signature:()
enable_clustering_pin_feasibility_filter	base/read_options.h	/^    argparse::ArgValue<bool> enable_clustering_pin_feasibility_filter;$/;"	m	struct:t_options	access:public
enable_or_disable_button	../../libs/libeasygl/src/graphics.cpp	/^void enable_or_disable_button(int \/*ibutton*\/, bool \/*enabled*\/) { }$/;"	f	signature:(int , bool )
enable_or_disable_button	../../libs/libeasygl/src/graphics.cpp	/^void enable_or_disable_button(int ibutton, bool enabled) {$/;"	f	signature:(int ibutton, bool enabled)
enable_or_disable_button	../../libs/libeasygl/src/graphics.h	/^void enable_or_disable_button(int ibutton, bool enabled);$/;"	p	signature:(int ibutton, bool enabled)
enable_pin_feasibility_filter	base/vpr_types.h	/^    bool enable_pin_feasibility_filter;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
enable_router_debug	route/route_timing.cpp	/^static void enable_router_debug(const t_router_opts& router_opts, ClusterNetId net, int sink_rr) {$/;"	f	file:	signature:(const t_router_opts& router_opts, ClusterNetId net, int sink_rr)
enable_router_debug	route/route_timing.cpp	/^static void enable_router_debug(const t_router_opts& router_opts, ClusterNetId net, int sink_rr);$/;"	p	file:	signature:(const t_router_opts& router_opts, ClusterNetId net, int sink_rr)
enable_timing_computations	base/vpr_types.h	/^	bool enable_timing_computations;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
enabled	../../libs/libeasygl/src/graphics.cpp	/^    bool enabled;$/;"	m	struct:__anon18	file:	access:public
encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_encoding encoding;$/;"	m	class:xml_buffered_writer	file:	access:public
encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_encoding encoding;$/;"	m	struct:pugi::xml_parse_result	access:public
encoding_auto	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_auto,		\/\/ Auto-detect input encoding using BOM or < \/ <? detection; use UTF8 if BOM is not found$/;"	e	enum:pugi::xml_encoding
encoding_latin1	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_latin1$/;"	e	enum:pugi::xml_encoding
encoding_utf16	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf16,		\/\/ UTF16 with native endianness$/;"	e	enum:pugi::xml_encoding
encoding_utf16_be	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf16_be,	\/\/ Big-endian UTF16$/;"	e	enum:pugi::xml_encoding
encoding_utf16_le	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf16_le,	\/\/ Little-endian UTF16$/;"	e	enum:pugi::xml_encoding
encoding_utf32	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf32,		\/\/ UTF32 with native endianness$/;"	e	enum:pugi::xml_encoding
encoding_utf32_be	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf32_be,	\/\/ Big-endian UTF32$/;"	e	enum:pugi::xml_encoding
encoding_utf32_le	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf32_le,	\/\/ Little-endian UTF32$/;"	e	enum:pugi::xml_encoding
encoding_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf8,		\/\/ UTF8 encoding$/;"	e	enum:pugi::xml_encoding
encoding_wchar	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_wchar,		\/\/ The same encoding wchar_t has (either UTF16 or UTF32)$/;"	e	enum:pugi::xml_encoding
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* end;$/;"	m	struct:gap	file:	access:public
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* end;$/;"	m	struct:xpath_lexer_string	file:	access:public
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* end() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)$/;"	v
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_tree_walker::end(xml_node&)$/;"	f	class:pugi::xml_tree_walker	signature:(xml_node&)
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::iterator xml_node::end() const$/;"	f	class:pugi::xml_node	signature:() const
end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::const_iterator xpath_node_set::end() const$/;"	f	class:pugi::xpath_node_set	signature:() const
end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It end() const { return _end; }$/;"	f	class:pugi::xml_object_range	access:public	signature:() const
end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const_iterator end() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		iterator end() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual bool end(xml_node& node);$/;"	p	class:pugi::xml_tree_walker	access:public	signature:(xml_node& node)
end	../../libs/libvtrutil/src/vtr_bimap.h	/^        iterator end() const { return map_.end(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
end	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          end()       const   { return vec_.end(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
end	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator                end()               { return vec_.end(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
end	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          end()       const   { return vec_.end(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
end	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator                end()               { return vec_.end(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
end	../../libs/libvtrutil/src/vtr_range.h	/^        T end() { return end_; }$/;"	f	class:vtr::Range	access:public	signature:()
end	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_iterator end() const { return vec_.end(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
end	../../libs/libvtrutil/src/vtr_vector_map.h	/^        iterator end() { return vec_.end(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
end	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::const_reverse_iterator end() const { return values_.crend(); }$/;"	f	class:LogicVec	access:public	signature:() const
end	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue>::reverse_iterator end() { return values_.rend(); }$/;"	f	class:LogicVec	access:public	signature:()
end_	../../libs/libvtrutil/src/vtr_range.h	/^        T end_;$/;"	m	class:vtr::Range	access:private
end_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string end_expr;    \/\/Ending position (inclusive)$/;"	m	struct:t_grid_loc_spec	access:public
end_index	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t end_index(size_t i) const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(size_t i) const
end_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t end_index() const { return end_index_; }$/;"	f	class:vtr::DimRange	access:public	signature:() const
end_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t end_index(size_t i) const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(size_t i) const
end_index_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t end_index_ = 0;$/;"	m	class:vtr::DimRange	access:private
ended_	base/read_blif.cpp	/^        bool ended_ = true; \/\/Initially no active .model$/;"	m	struct:BlifAllocCallback	file:	access:private
endian_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline uint16_t endian_swap(uint16_t value)$/;"	f	signature:(uint16_t value)
endian_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline uint32_t endian_swap(uint32_t value)$/;"	f	signature:(uint32_t value)
energy_per_toggle	../../libs/libarchfpga/src/physical_types.h	/^	float energy_per_toggle;$/;"	m	struct:t_port_power	access:public
enqueue_cost	pack/pack_types.h	/^	float enqueue_cost;		\/* cost of node pused on exploration priority queue *\/$/;"	m	struct:t_explored_node_tb	access:public
enqueue_id	pack/pack_types.h	/^	int enqueue_id;			\/* ID used ot determine if this node has been pushed on exploration priority queue *\/$/;"	m	struct:t_explored_node_tb	access:public
entries	power/PowerSpicedComponent.h	/^	std::vector<PowerCallibInputs*> entries;$/;"	m	class:PowerSpicedComponent	access:public
entries	power/PowerSpicedComponent.h	/^	std::vector<PowerCallibSize*> entries;$/;"	m	class:PowerCallibInputs	access:public
epsilon	route/route_tree_timing.cpp	/^constexpr float epsilon = 1e-15;$/;"	v
equal_approx	route/route_tree_timing.cpp	/^static bool equal_approx(float a, float b) {$/;"	f	file:	signature:(float a, float b)
equal_range	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::pair<const_iterator,const_iterator> equal_range(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
equal_range	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
equal_range	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<const_iterator,const_iterator> equal_range(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
equal_range	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
equal_to	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct equal_to$/;"	s	file:
equal_to::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:equal_to	access:public	signature:(const T& lhs, const T& rhs) const
equivalence	../../libs/libarchfpga/src/physical_types.h	/^    PortEquivalence equivalence;$/;"	m	struct:t_class	access:public
equivalent	../../libs/libarchfpga/src/physical_types.h	/^	PortEquivalence equivalent;$/;"	m	struct:t_port	access:public
erase	../../libs/libvtrutil/src/vtr_bimap.h	/^        void erase(const K key) {$/;"	f	class:vtr::bimap	access:public	signature:(const K key)
erase	../../libs/libvtrutil/src/vtr_bimap.h	/^        void erase(const V val) {$/;"	f	class:vtr::bimap	access:public	signature:(const V val)
erase	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void erase(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
erase	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void erase(const_iterator first, const_iterator last) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator first, const_iterator last)
erase	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void erase(const_iterator position) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator position)
erase	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void erase(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
erase	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void erase(const_iterator first, const_iterator last) {$/;"	f	class:vtr::linear_map	access:public	signature:(const_iterator first, const_iterator last)
erase	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void erase(const_iterator position) {$/;"	f	class:vtr::linear_map	access:public	signature:(const_iterator position)
error	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char* error;$/;"	m	struct:pugi::xpath_parse_result	access:public
error_handler	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		jmp_buf error_handler;$/;"	m	struct:xpath_stack_data	file:	access:public
error_handler	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		jmp_buf* error_handler;$/;"	m	class:xpath_allocator	file:	access:public
error_no_match	timing/slre.cpp	/^static const char *error_no_match = "No match";$/;"	v	file:
error_offset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* error_offset;$/;"	m	struct:xml_parser	file:	access:public
error_status	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_parse_status error_status;$/;"	m	struct:xml_parser	file:	access:public
error_string	timing/slre.cpp	/^  const char *error_string;   \/\/ Error string$/;"	m	struct:slre	file:	access:public
escape_sdf_identifier	base/netlist_writer.cpp	/^std::string escape_sdf_identifier(const std::string id);$/;"	p	file:	signature:(const std::string id)
escape_sdf_identifier	base/netlist_writer.cpp	/^std::string escape_sdf_identifier(const std::string identifier) {$/;"	f	signature:(const std::string identifier)
escape_verilog_identifier	base/netlist_writer.cpp	/^std::string escape_verilog_identifier(const std::string id);$/;"	p	file:	signature:(const std::string id)
escape_verilog_identifier	base/netlist_writer.cpp	/^std::string escape_verilog_identifier(const std::string identifier) {$/;"	f	signature:(const std::string identifier)
estimate_overuse_slope	route/routing_predictor.cpp	/^float RoutingPredictor::estimate_overuse_slope() {$/;"	f	class:RoutingPredictor	signature:()
estimate_overuse_slope	route/routing_predictor.h	/^    float estimate_overuse_slope();$/;"	p	class:RoutingPredictor	access:public	signature:()
estimate_success_iteration	route/routing_predictor.cpp	/^float RoutingPredictor::estimate_success_iteration() {$/;"	f	class:RoutingPredictor	signature:()
estimate_success_iteration	route/routing_predictor.h	/^    float estimate_success_iteration();$/;"	p	class:RoutingPredictor	access:public	signature:()
estimation_method	../../libs/libarchfpga/src/physical_types.h	/^	e_power_estimation_method estimation_method;$/;"	m	struct:t_pb_type_power	access:public
eval_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool eval_boolean(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
eval_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set_raw eval_node_set(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval)
eval_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		double eval_number(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
eval_once	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static bool eval_once(xpath_node_set::type_t type, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set::type_t type, nodeset_eval_t eval)
eval_op	../../libs/librtlnumber/src/rtl_int.cpp	/^static compare_bit eval_op(VNumber a,int64_t b)$/;"	f	file:	signature:(VNumber a,int64_t b)
eval_op	../../libs/librtlnumber/src/rtl_int.cpp	/^static compare_bit eval_op(VNumber& a_in, VNumber& b_in)$/;"	f	file:	signature:(VNumber& a_in, VNumber& b_in)
eval_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string eval_string(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
eval_string_concat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string eval_string_concat(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
evaluate_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_query::evaluate_boolean(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
evaluate_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool evaluate_boolean(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
evaluate_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xpath_query::evaluate_node(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
evaluate_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node evaluate_node(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
evaluate_node_cost	route/route_breadth_first.cpp	/^static float evaluate_node_cost(const float prev_path_cost, const float bend_cost,$/;"	f	file:	signature:(const float prev_path_cost, const float bend_cost, const int from_node, const int to_node)
evaluate_node_cost	route/route_breadth_first.cpp	/^static float evaluate_node_cost(const float prev_path_cost, const float bend_cost,$/;"	p	file:	signature:(const float prev_path_cost, const float bend_cost, const int from_node, const int to_node)
evaluate_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set xpath_query::evaluate_node_set(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
evaluate_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set evaluate_node_set(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
evaluate_node_set_prepare	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN impl::xpath_ast_node* evaluate_node_set_prepare(xpath_query_impl* impl)$/;"	f	signature:(xpath_query_impl* impl)
evaluate_num_conns_formula	route/build_switchblocks.cpp	/^static int evaluate_num_conns_formula(std::string num_conns_formula, int from_wire_count, int to_wire_count) {$/;"	f	file:	signature:(std::string num_conns_formula, int from_wire_count, int to_wire_count)
evaluate_num_conns_formula	route/build_switchblocks.cpp	/^static int evaluate_num_conns_formula(std::string num_conns_formula, int from_wire_count, int to_wire_count);$/;"	p	file:	signature:(std::string num_conns_formula, int from_wire_count, int to_wire_count)
evaluate_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xpath_query::evaluate_number(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
evaluate_number	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double evaluate_number(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xpath_query::evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(char_t* buffer, size_t capacity, const xpath_node& n) const
evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN string_t xpath_query::evaluate_string(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(char_t* buffer, size_t capacity, const xpath_node& n) const
evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		string_t evaluate_string(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
evaluate_string_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_string evaluate_string_impl(xpath_query_impl* impl, const xpath_node& n, xpath_stack_data& sd)$/;"	f	signature:(xpath_query_impl* impl, const xpath_node& n, xpath_stack_data& sd)
evaluate_timing_driven_node_costs	route/route_timing.cpp	/^static t_timing_driven_node_costs evaluate_timing_driven_node_costs(const t_timing_driven_node_costs old_costs,$/;"	f	file:	signature:(const t_timing_driven_node_costs old_costs, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, const int from_node, const int to_node, const int iconn, const int target_node)
evaluate_timing_driven_node_costs	route/route_timing.cpp	/^static t_timing_driven_node_costs evaluate_timing_driven_node_costs(const t_timing_driven_node_costs old_costs,$/;"	p	file:	signature:(const t_timing_driven_node_costs old_costs, const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, const int from_node, const int to_node, const int iconn, const int target_node)
event_loop	../../libs/libeasygl/src/graphics.cpp	/^event_loop(void (*act_on_mousebutton)(float x, float y, t_event_buttonPressed button_info),$/;"	f	signature:(void (*act_on_mousebutton)(float x, float y, t_event_buttonPressed button_info), void (*act_on_mousemove)(float x, float y), void (*act_on_keypress)(char key_pressed, int keysym), void (*drawscreen) ())
event_loop	../../libs/libeasygl/src/graphics.cpp	/^void event_loop(void (* \/*act_on_mousebutton*\/) (float x, float y, t_event_buttonPressed button_info),$/;"	f	signature:(void (* ) (float x, float y, t_event_buttonPressed button_info), void (* ) (float x, float y), void (* ) (char key_pressed, int keysym), void (* ) (void))
event_loop	../../libs/libeasygl/src/graphics.h	/^void event_loop(void (*act_on_mousebutton) (float x, float y, t_event_buttonPressed button_info),$/;"	p	signature:(void (*act_on_mousebutton) (float x, float y, t_event_buttonPressed button_info), void (*act_on_mousemove) (float x, float y), void (*act_on_keypress) (char key_pressed, int keysym), void (*drawscreen) ())
exact	timing/slre.cpp	/^static void exact(struct slre *r, const char **re) {$/;"	f	file:	signature:(struct slre *r, const char **re)
exact_one_char	timing/slre.cpp	/^static void exact_one_char(struct slre *r, int ch) {$/;"	f	file:	signature:(struct slre *r, int ch)
exists_free_primitive_for_atom_block	pack/cluster_placement.cpp	/^bool exists_free_primitive_for_atom_block($/;"	f	signature:( t_cluster_placement_stats *cluster_placement_stats, const AtomBlockId blk_id)
exists_free_primitive_for_atom_block	pack/cluster_placement.h	/^bool exists_free_primitive_for_atom_block($/;"	p	signature:( t_cluster_placement_stats *cluster_placement_stats, const AtomBlockId blk_id)
exit_before_pack	base/read_options.h	/^    argparse::ArgValue<bool> exit_before_pack;$/;"	m	struct:t_options	access:public
exit_before_pack	base/vpr_types.h	/^    bool exit_before_pack; \/\/Exits early before starting packing (useful for collecting statistics without running\/loading any stages)$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
exit_crit	place/place.cpp	/^static int exit_crit(float t, float cost,$/;"	f	file:	signature:(float t, float cost, t_annealing_sched annealing_sched)
exit_crit	place/place.cpp	/^static int exit_crit(float t, float cost,$/;"	p	file:	signature:(float t, float cost, t_annealing_sched annealing_sched)
exit_t	base/vpr_types.h	/^	float exit_t;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
expand_dijkstra_neighbours	route/router_lookahead_map.cpp	/^static void expand_dijkstra_neighbours(PQ_Entry parent_entry, vector<float> &node_visited_costs, vector<bool> &node_expanded, priority_queue<PQ_Entry> &pq);$/;"	p	file:	signature:(PQ_Entry parent_entry, vector<float> &node_visited_costs, vector<bool> &node_expanded, priority_queue<PQ_Entry> &pq)
expand_dijkstra_neighbours	route/router_lookahead_map.cpp	/^static void expand_dijkstra_neighbours(PQ_Entry parent_entry, vector<float> &node_visited_costs, vector<bool> &node_expanded, priority_queue<PQ_Entry> &pq){$/;"	f	file:	signature:(PQ_Entry parent_entry, vector<float> &node_visited_costs, vector<bool> &node_expanded, priority_queue<PQ_Entry> &pq)
expand_forced_pack_molecule_placement	pack/cluster_placement.cpp	/^static bool expand_forced_pack_molecule_placement($/;"	f	file:	signature:( const t_pack_molecule *molecule, const t_pack_pattern_block *pack_pattern_block, t_pb_graph_node **primitives_list, float *cost)
expand_forced_pack_molecule_placement	pack/cluster_placement.cpp	/^static bool expand_forced_pack_molecule_placement($/;"	p	file:	signature:( const t_pack_molecule *molecule, const t_pack_pattern_block *pack_pattern_block, t_pb_graph_node **primitives_list, float *cost)
expand_heap_if_full	route/route_common.cpp	/^	void expand_heap_if_full() {$/;"	f	namespace:heap_	signature:()
expand_heap_if_full	route/route_common.cpp	/^	void expand_heap_if_full();$/;"	p	namespace:heap_	file:	signature:()
expand_node	pack/cluster_router.cpp	/^static void expand_node(t_lb_router_data *router_data, t_expansion_node exp_node,$/;"	f	file:	signature:(t_lb_router_data *router_data, t_expansion_node exp_node, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int net_fanout)
expand_node	pack/cluster_router.cpp	/^static void expand_node(t_lb_router_data *router_data, t_expansion_node exp_node,$/;"	p	file:	signature:(t_lb_router_data *router_data, t_expansion_node exp_node, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int net_fanout)
expand_non_configurable	route/check_route.cpp	/^static void expand_non_configurable(int inode, std::set<t_node_edge>& edge_set) {$/;"	f	file:	signature:(int inode, std::set<t_node_edge>& edge_set)
expand_non_configurable	route/check_route.cpp	/^static void expand_non_configurable(int inode, std::set<t_node_edge>& edge_set);$/;"	p	file:	signature:(int inode, std::set<t_node_edge>& edge_set)
expand_pack_molecule_pin_edge	pack/cluster_placement.cpp	/^static t_pb_graph_pin *expand_pack_molecule_pin_edge(const int pattern_id,$/;"	f	file:	signature:(const int pattern_id, const t_pb_graph_pin *cur_pin, const bool forward)
expand_pack_molecule_pin_edge	pack/cluster_placement.cpp	/^static t_pb_graph_pin *expand_pack_molecule_pin_edge(const int pattern_id,$/;"	p	file:	signature:(const int pattern_id, const t_pb_graph_pin *cur_pin, const bool forward)
expand_pb_graph_node_and_load_output_to_input_connections	pack/cluster_feasibility_filter.cpp	/^static void expand_pb_graph_node_and_load_output_to_input_connections($/;"	f	file:	signature:( t_pb_graph_pin *current_pb_graph_pin, t_pb_graph_pin *reference_pin, const int depth)
expand_pb_graph_node_and_load_output_to_input_connections	pack/cluster_feasibility_filter.cpp	/^static void expand_pb_graph_node_and_load_output_to_input_connections($/;"	p	file:	signature:( t_pb_graph_pin *current_pb_graph_pin, t_pb_graph_pin *reference_pin, const int depth)
expand_pb_graph_node_and_load_pin_class_by_depth	pack/cluster_feasibility_filter.cpp	/^static void expand_pb_graph_node_and_load_pin_class_by_depth($/;"	f	file:	signature:( t_pb_graph_pin *current_pb_graph_pin, const t_pb_graph_pin *reference_pb_graph_pin, const int depth, int *input_count, int *output_count)
expand_pb_graph_node_and_load_pin_class_by_depth	pack/cluster_feasibility_filter.cpp	/^static void expand_pb_graph_node_and_load_pin_class_by_depth($/;"	p	file:	signature:( t_pb_graph_pin *current_pb_graph_pin, const t_pb_graph_pin *reference_pb_graph_pin, const int depth, int *input_count, int *output_count)
expand_rt	pack/cluster_router.cpp	/^static void expand_rt(t_lb_router_data *router_data, int inet, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int irt_net);$/;"	p	file:	signature:(t_lb_router_data *router_data, int inet, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int irt_net)
expand_rt	pack/cluster_router.cpp	/^static void expand_rt(t_lb_router_data *router_data, int inet,$/;"	f	file:	signature:(t_lb_router_data *router_data, int inet, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int irt_net)
expand_rt_rec	pack/cluster_router.cpp	/^static void expand_rt_rec(t_lb_trace *rt, int prev_index, t_explored_node_tb *explored_node_tb,$/;"	f	file:	signature:(t_lb_trace *rt, int prev_index, t_explored_node_tb *explored_node_tb, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int irt_net, int explore_id_index)
expand_rt_rec	pack/cluster_router.cpp	/^static void expand_rt_rec(t_lb_trace *rt, int prev_index, t_explored_node_tb *explored_node_tb,$/;"	p	file:	signature:(t_lb_trace *rt, int prev_index, t_explored_node_tb *explored_node_tb, reservable_pq<t_expansion_node, vector <t_expansion_node>, compare_expansion_node> &pq, int irt_net, int explore_id_index)
expand_truth_table	base/atom_netlist_utils.cpp	/^AtomNetlist::TruthTable expand_truth_table(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs) {$/;"	f	signature:(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs)
expand_truth_table	base/atom_netlist_utils.h	/^AtomNetlist::TruthTable expand_truth_table(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs);$/;"	p	signature:(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs)
expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, size_t expected_count, const loc_data& loc_data)
expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::string child_name, size_t expected_count, const loc_data& loc_data)
expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, size_t expected_count, const loc_data& loc_data)
expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::string child_name, size_t expected_count, const loc_data& loc_data)
expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, const loc_data& loc_data)
expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, std::string explanation, const loc_data& loc_data)
expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, const loc_data& loc_data)
expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, std::string explanation, const loc_data& loc_data)
expect_only_children	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_only_children(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> child_names, const loc_data& loc_data)
expect_only_children	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_only_children(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> child_names, const loc_data& loc_data)
expectation_available	route/cb_metrics.h	/^	float expectation_available = 0.;$/;"	m	class:Wire_Counting	access:public
explore_id_index	pack/pack_types.h	/^	int explore_id_index; \/* used in conjunction with node_traceback to determine whether or not a location has been explored.  By using a unique identifier every route, I don't have to clear the previous route exploration *\/$/;"	m	struct:t_lb_router_data	access:public
explore_transitive_fanout	pack/pack_types.h	/^	bool explore_transitive_fanout; \/* If no marked candidate molecules and no high fanout nets to determine next candidate molecule then explore molecules on transitive fanout *\/$/;"	m	struct:t_pb_stats	access:public
explored_id	pack/pack_types.h	/^	int explored_id;		\/* ID used to determine if this node has been explored *\/$/;"	m	struct:t_explored_node_tb	access:public
explored_node_tb	pack/pack_types.h	/^	t_explored_node_tb *explored_node_tb; \/* [0..lb_type_graph->size()-1] Stores mode exploration and traceback info for nodes *\/$/;"	m	struct:t_lb_router_data	access:public
extra_buffers	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_extra_buffer* extra_buffers;$/;"	m	struct:xml_document_struct	file:	access:public
f_MTA_area	power/power_sizing.cpp	/^static double f_MTA_area;$/;"	v	file:
f_blk_pin_from_port_pin	util/vpr_utils.cpp	/^static int *** f_blk_pin_from_port_pin = nullptr;$/;"	v	file:
f_buffer_strength_last_searched	power/power_cmos_tech.cpp	/^static t_power_buffer_strength_inf * f_buffer_strength_last_searched;$/;"	v	file:
f_buffer_strength_last_searched	tags	/^f_buffer_strength_last_searched	power\/power_cmos_tech.cpp	\/^static t_power_buffer_strength_inf * f_buffer_strength_last_searched;$\/;"	v	file:$/;"	v	file:
f_cost_map	route/router_lookahead_map.cpp	/^t_cost_map f_cost_map;$/;"	v
f_direct_type_from_blk_pin	place/place_macro.cpp	/^static int ** f_direct_type_from_blk_pin = nullptr;$/;"	v	file:
f_idirect_from_blk_pin	place/place_macro.cpp	/^static int ** f_idirect_from_blk_pin = nullptr;$/;"	v	file:
f_imacro_from_iblk	place/place_macro.cpp	/^static vtr::vector_map<ClusterBlockId, int> f_imacro_from_iblk;$/;"	v	file:
f_mux_volt_last_searched	power/power_cmos_tech.cpp	/^static t_power_mux_volt_inf * f_mux_volt_last_searched;$/;"	v	file:
f_net_to_driver_tnode	timing/path_delay.cpp	/^static int * f_net_to_driver_tnode;$/;"	v	file:
f_num_timing_net_pins	timing/path_delay.cpp	/^static vector<size_t> f_num_timing_net_pins;$/;"	v	file:
f_port_from_blk_pin	util/vpr_utils.cpp	/^static int ** f_port_from_blk_pin = nullptr;$/;"	v	file:
f_port_pin_from_blk_pin	util/vpr_utils.cpp	/^static int ** f_port_pin_from_blk_pin = nullptr;$/;"	v	file:
f_power_searching_nmos_leakage_info	power/power_cmos_tech.cpp	/^static t_power_nmos_leakage_inf * f_power_searching_nmos_leakage_info;$/;"	v	file:
f_power_searching_nmos_leakage_info	tags	/^f_power_searching_nmos_leakage_info	power\/power_cmos_tech.cpp	\/^static t_power_nmos_leakage_inf * f_power_searching_nmos_leakage_info;$\/;"	v	file:$/;"	v	file:
f_router_debug	route/route_timing.cpp	/^bool f_router_debug = false;$/;"	v
f_timer_depth	../../libs/libvtrutil/src/vtr_time.cpp	/^int f_timer_depth = 0;$/;"	m	namespace:vtr	file:
f_timing_place_crit_ch	place/timing_place.cpp	/^static vtr::t_chunk f_timing_place_crit_ch;$/;"	v	file:
f_timing_stats	timing/path_delay.cpp	/^static t_timing_stats * f_timing_stats = nullptr; \/* Critical path delay and worst-case slack per constraint. *\/$/;"	v	file:
f_transistor_last_searched	power/power_cmos_tech.cpp	/^static t_transistor_inf * f_transistor_last_searched;$/;"	v	file:
factor	power/PowerSpicedComponent.h	/^	float factor;$/;"	m	class:PowerCallibSize	access:public
factorial	route/cb_metrics.cpp	/^static long double factorial(const int num){$/;"	f	file:	signature:(const int num)
falling_edge	timing/read_sdc.cpp	/^	float falling_edge;$/;"	m	struct:t_sdc_clock	file:	access:public
fan_in	route/rr_node.cpp	/^short t_rr_node::fan_in() const {$/;"	f	class:t_rr_node	signature:() const
fan_in	route/rr_node.h	/^        short fan_in() const;$/;"	p	class:t_rr_node	access:public	signature:() const
fan_in_	route/rr_node.h	/^        uint16_t fan_in_ = 0;$/;"	m	class:t_rr_node	access:private
fanout	base/vpr_types.h	/^	int fanout;$/;"	m	struct:ScreenUpdatePriority::t_clock	access:public
fanout_analysis	base/vpr_types.h	/^	bool fanout_analysis;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
fc	base/place_and_route.h	/^	int fc; \/* at this fc *\/$/;"	m	struct:t_fmap_cell	access:public
fc_constraints	base/vpr_types.h	/^	t_override_constraint * fc_constraints; \/*  [0..num_fc_constraints - 1] *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
fc_specs	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_fc_specification> fc_specs;$/;"	m	struct:t_type_descriptor	access:public
fc_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_type fc_type;              \/\/What type of Fc$/;"	m	struct:t_fc_specification	access:public
fc_value	../../libs/libarchfpga/src/physical_types.h	/^    float fc_value;                 \/\/The Fc value$/;"	m	struct:t_fc_specification	access:public
fc_value	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    float fc_value;$/;"	m	struct:t_fc_override	file:	access:public
fc_value_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_value_type fc_value_type;  \/\/How to interpret the Fc value$/;"	m	struct:t_fc_specification	access:public
fc_value_type	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    e_fc_value_type fc_value_type;$/;"	m	struct:t_fc_override	file:	access:public
fclose	../../libs/libvtrutil/src/vtr_util.cpp	/^int fclose(FILE* f) {$/;"	f	namespace:vtr	signature:(FILE* f)
fclose	../../libs/libvtrutil/src/vtr_util.h	/^    int fclose(FILE* f);$/;"	p	namespace:vtr	signature:(FILE* f)
fcn	../../libs/libeasygl/src/graphics.cpp	/^    void(*fcn) (void(*drawscreen) ());$/;"	m	struct:__anon18	file:	access:public
feasible_blocks	pack/pack_types.h	/^	t_pack_molecule **feasible_blocks;$/;"	m	struct:t_pb_stats	access:public
feasible_routing	route/route_common.cpp	/^bool feasible_routing() {$/;"	f	signature:()
feasible_routing	route/route_export.h	/^bool feasible_routing();$/;"	p	signature:()
ff_constraints	base/vpr_types.h	/^	t_override_constraint * ff_constraints; \/*  [0..num_ff_constraints - 1] array of such constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
fgets	../../libs/libvtrutil/src/vtr_util.cpp	/^char* fgets(char *buf, int max_size, FILE * fp) {$/;"	f	namespace:vtr	signature:(char *buf, int max_size, FILE * fp)
fgets	../../libs/libvtrutil/src/vtr_util.h	/^    char* fgets(char *buf, int max_size, FILE * fp);$/;"	p	namespace:vtr	signature:(char *buf, int max_size, FILE * fp)
file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void* file;$/;"	m	class:pugi::xml_writer_file	access:private
file_exists	../../libs/libvtrutil/src/vtr_util.cpp	/^bool file_exists(const char* filename) {$/;"	f	namespace:vtr	signature:(const char* filename)
file_exists	../../libs/libvtrutil/src/vtr_util.h	/^    bool file_exists(const char * filename);$/;"	p	namespace:vtr	signature:(const char * filename)
file_line_number	../../libs/libvtrutil/src/vtr_util.cpp	/^static int file_line_number = 0; \/* file in line number being parsed (used by fgets) *\/$/;"	m	namespace:vtr	file:
file_line_number	base/vpr_types.h	/^	int file_line_number; \/* line in the SDC file I\/O was constrained on - used for error reporting *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
file_line_number	base/vpr_types.h	/^	int file_line_number; \/* line in the SDC file clock was constrained on - used for error reporting *\/$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
filename	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            const std::string& filename() const { return filename_; }$/;"	f	class:pugiutil::loc_data	access:public	signature:() const
filename	../../libs/libpugiutil/src/pugixml_util.hpp	/^            std::string filename() const { return filename_; }$/;"	f	class:pugiutil::XmlError	access:public	signature:() const
filename	../../libs/libvtrutil/src/vtr_error.h	/^        std::string filename() const { return filename_; }$/;"	f	class:vtr::VtrError	access:public	signature:() const
filename_	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::string filename_;$/;"	m	class:pugiutil::loc_data	access:private
filename_	../../libs/libpugiutil/src/pugixml_util.hpp	/^            std::string filename_;$/;"	m	class:pugiutil::XmlError	access:private
filename_	../../libs/libvtrutil/src/vtr_error.h	/^        std::string filename_;$/;"	m	class:vtr::VtrError	access:private
filename_	base/read_blif.cpp	/^        std::string filename_ = "";$/;"	m	struct:BlifAllocCallback	file:	access:private
filename_c_str	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            const char* filename_c_str() const { return filename_.c_str(); }$/;"	f	class:pugiutil::loc_data	access:public	signature:() const
filename_c_str	../../libs/libpugiutil/src/pugixml_util.hpp	/^            const char* filename_c_str() const { return filename_.c_str(); }$/;"	f	class:pugiutil::XmlError	access:public	signature:() const
filename_c_str	../../libs/libvtrutil/src/vtr_error.h	/^        const char* filename_c_str() const { return filename_.c_str(); }$/;"	f	class:vtr::VtrError	access:public	signature:() const
fill	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void fill(T value) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(T value)
fill	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void fill(T value) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(T value)
fill_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        char fill_;$/;"	m	class:vtr::OsFormatGuard	access:private
fill_in_missing_lookahead_entries	route/router_lookahead_map.cpp	/^static void fill_in_missing_lookahead_entries(int segment_index, e_rr_type chan_type);$/;"	p	file:	signature:(int segment_index, e_rr_type chan_type)
fill_in_missing_lookahead_entries	route/router_lookahead_map.cpp	/^static void fill_in_missing_lookahead_entries(int segment_index, e_rr_type chan_type){$/;"	f	file:	signature:(int segment_index, e_rr_type chan_type)
fillarc	../../libs/libeasygl/src/graphics.cpp	/^void fillarc(const t_point& \/*center*\/, float \/*rad*\/, float \/*startang*\/, float \/*angextent*\/) { }$/;"	f	signature:(const t_point& , float , float , float )
fillarc	../../libs/libeasygl/src/graphics.cpp	/^void fillarc(const t_point& center, float rad, float startang, float angextent) {$/;"	f	signature:(const t_point& center, float rad, float startang, float angextent)
fillarc	../../libs/libeasygl/src/graphics.cpp	/^void fillarc(float \/*xcen*\/, float \/*ycen*\/, float \/*rad*\/, float \/*startang*\/,$/;"	f	signature:(float , float , float , float , float )
fillarc	../../libs/libeasygl/src/graphics.cpp	/^void fillarc(float xc, float yc, float rad, float startang, float angextent) {$/;"	f	signature:(float xc, float yc, float rad, float startang, float angextent)
fillarc	../../libs/libeasygl/src/graphics.h	/^void fillarc(const t_point& center, float rad, float startang, float angextent);$/;"	p	signature:(const t_point& center, float rad, float startang, float angextent)
fillarc	../../libs/libeasygl/src/graphics.h	/^void fillarc(float xcen, float ycen, float rad, float startang,$/;"	p	signature:(float xcen, float ycen, float rad, float startang, float angextent)
fillellipticarc	../../libs/libeasygl/src/graphics.cpp	/^fillellipticarc(float xc, float yc, float radx, float rady, float startang,$/;"	f	signature:(float xc, float yc, float radx, float rady, float startang, float angextent)
fillellipticarc	../../libs/libeasygl/src/graphics.cpp	/^void fillellipticarc($/;"	f	signature:( const t_point& , float , float , float , float )
fillellipticarc	../../libs/libeasygl/src/graphics.cpp	/^void fillellipticarc($/;"	f	signature:( const t_point& center, float radx, float rady, float startang, float angextent)
fillellipticarc	../../libs/libeasygl/src/graphics.cpp	/^void fillellipticarc(float \/*xc*\/, float \/*yc*\/, float \/*radx*\/, float \/*rady*\/,$/;"	f	signature:(float , float , float , float , float , float )
fillellipticarc	../../libs/libeasygl/src/graphics.h	/^void fillellipticarc(const t_point& center, float radx, float rady, float startang, float angextent);$/;"	p	signature:(const t_point& center, float radx, float rady, float startang, float angextent)
fillellipticarc	../../libs/libeasygl/src/graphics.h	/^void fillellipticarc(float xc, float yc, float radx, float rady, float startang, float angextent);$/;"	p	signature:(float xc, float yc, float radx, float rady, float startang, float angextent)
fillpoly	../../libs/libeasygl/src/graphics.cpp	/^fillpoly(t_point *points, int npoints) {$/;"	f	signature:(t_point *points, int npoints)
fillpoly	../../libs/libeasygl/src/graphics.cpp	/^void fillpoly(t_point* \/*points*\/, int \/*npoints*\/) { }$/;"	f	signature:(t_point* , int )
fillpoly	../../libs/libeasygl/src/graphics.h	/^void fillpoly(t_point *points, int npoints);$/;"	p	signature:(t_point *points, int npoints)
fillrect	../../libs/libeasygl/src/graphics.cpp	/^fillrect(float x1, float y1, float x2, float y2) {$/;"	f	signature:(float x1, float y1, float x2, float y2)
fillrect	../../libs/libeasygl/src/graphics.cpp	/^void fillrect(const t_bound_box& \/*rect*\/) { }$/;"	f	signature:(const t_bound_box& )
fillrect	../../libs/libeasygl/src/graphics.cpp	/^void fillrect(const t_bound_box& rect) {$/;"	f	signature:(const t_bound_box& rect)
fillrect	../../libs/libeasygl/src/graphics.cpp	/^void fillrect(const t_point& \/*bottomleft*\/, const t_point& \/*upperright*\/) { }$/;"	f	signature:(const t_point& , const t_point& )
fillrect	../../libs/libeasygl/src/graphics.cpp	/^void fillrect(const t_point& bottomleft, const t_point& upperright) {$/;"	f	signature:(const t_point& bottomleft, const t_point& upperright)
fillrect	../../libs/libeasygl/src/graphics.cpp	/^void fillrect(float \/*x1*\/, float \/*y1*\/, float \/*x2*\/, float \/*y2*\/) { }$/;"	f	signature:(float , float , float , float )
fillrect	../../libs/libeasygl/src/graphics.h	/^void fillrect(const t_bound_box& rect);$/;"	p	signature:(const t_bound_box& rect)
fillrect	../../libs/libeasygl/src/graphics.h	/^void fillrect(const t_point& bottomleft, const t_point& upperright);$/;"	p	signature:(const t_point& bottomleft, const t_point& upperright)
fillrect	../../libs/libeasygl/src/graphics.h	/^void fillrect(float x1, float y1, float x2, float y2);$/;"	p	signature:(float x1, float y1, float x2, float y2)
find	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void** find(const void* key)$/;"	f	class:compact_hash_table	access:public	signature:(const void* key)
find	../../libs/libvtrutil/src/vtr_bimap.h	/^        inverse_iterator find(const V value) const {$/;"	f	class:vtr::bimap	access:public	signature:(const V value) const
find	../../libs/libvtrutil/src/vtr_bimap.h	/^        iterator find(const K key) const {$/;"	f	class:vtr::bimap	access:public	signature:(const K key) const
find	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator find(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
find	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator find(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
find	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator find(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
find	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator find(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
find	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_iterator find(const K key) const {$/;"	f	class:vtr::vector_map	access:public	signature:(const K key) const
find	../../libs/libvtrutil/src/vtr_vector_map.h	/^        iterator find(const K key) {$/;"	f	class:vtr::vector_map	access:public	signature:(const K key)
findPortByName	../../libs/libarchfpga/src/arch_util.cpp	/^t_port * findPortByName(const char * name, t_pb_type * pb_type,$/;"	f	signature:(const char * name, t_pb_type * pb_type, int * high_index, int * low_index)
findPortByName	../../libs/libarchfpga/src/arch_util.h	/^t_port * findPortByName(const char * name, t_pb_type * pb_type,$/;"	p	signature:(const char * name, t_pb_type * pb_type, int * high_index, int * low_index)
find_affected_blocks	place/place.cpp	/^static int find_affected_blocks(ClusterBlockId b_from, int x_to, int y_to, int z_to) {$/;"	f	file:	signature:(ClusterBlockId b_from, int x_to, int y_to, int z_to)
find_affected_blocks	place/place.cpp	/^static int find_affected_blocks(ClusterBlockId b_from, int x_to, int y_to, int z_to);$/;"	p	file:	signature:(ClusterBlockId b_from, int x_to, int y_to, int z_to)
find_affected_nets_and_update_costs	place/place.cpp	/^static int find_affected_nets_and_update_costs(e_place_algorithm place_algorithm, const PlaceDelayModel& delay_model, float& bb_delta_c, float& timing_delta_c, float& delay_delta_c) {$/;"	f	file:	signature:(e_place_algorithm place_algorithm, const PlaceDelayModel& delay_model, float& bb_delta_c, float& timing_delta_c, float& delay_delta_c)
find_affected_nets_and_update_costs	place/place.cpp	/^static int find_affected_nets_and_update_costs(e_place_algorithm place_algorithm, const PlaceDelayModel& delay_model, float& bb_delta_c, float& timing_delta_c, float& delay_delta_c);$/;"	p	file:	signature:(e_place_algorithm place_algorithm, const PlaceDelayModel& delay_model, float& bb_delta_c, float& timing_delta_c, float& delay_delta_c)
find_all_the_macro	place/place_macro.cpp	/^static void find_all_the_macro (int * num_of_macro, std::vector<ClusterBlockId> &pl_macro_member_blk_num_of_this_blk,$/;"	f	file:	signature:(int * num_of_macro, std::vector<ClusterBlockId> &pl_macro_member_blk_num_of_this_blk, std::vector<int> &pl_macro_idirect, std::vector<int> &pl_macro_num_members, std::vector<std::vector<ClusterBlockId>> &pl_macro_member_blk_num)
find_all_the_macro	place/place_macro.cpp	/^static void find_all_the_macro (int * num_of_macro, std::vector<ClusterBlockId> &pl_macro_member_blk_num_of_this_blk,$/;"	p	file:	signature:(int * num_of_macro, std::vector<ClusterBlockId> &pl_macro_member_blk_num_of_this_blk, std::vector<int> &pl_macro_idirect, std::vector<int> &pl_macro_num_members, std::vector<std::vector<ClusterBlockId>> &pl_macro_member_blk_num)
find_associated_clock_pin	timing/PreClusterDelayCalculator.h	/^    const t_pb_graph_pin* find_associated_clock_pin(const AtomPinId io_pin) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const AtomPinId io_pin) const
find_associated_clock_pin	timing/timing_graph_builder.h	/^        const t_pb_graph_pin* find_associated_clock_pin(const AtomPinId pin);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomPinId pin)
find_atom_input_logical_net	base/netlist_writer.cpp	/^        AtomNetId find_atom_input_logical_net(const t_pb* atom, int atom_input_idx) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom, int atom_input_idx)
find_atom_pin	util/vpr_utils.cpp	/^AtomPinId find_atom_pin(ClusterBlockId blk_id, const t_pb_graph_pin* pb_gpin) {$/;"	f	signature:(ClusterBlockId blk_id, const t_pb_graph_pin* pb_gpin)
find_atom_pin	util/vpr_utils.h	/^AtomPinId find_atom_pin(ClusterBlockId blk_id, const t_pb_graph_pin* pb_gpin);$/;"	p	signature:(ClusterBlockId blk_id, const t_pb_graph_pin* pb_gpin)
find_atom_pin_for_pb_route_id	util/vpr_utils.cpp	/^static AtomPinId find_atom_pin_for_pb_route_id(ClusterBlockId clb, int pb_route_id, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	file:	signature:(ClusterBlockId clb, int pb_route_id, const IntraLbPbPinLookup& pb_gpin_lookup)
find_atom_pin_for_pb_route_id	util/vpr_utils.cpp	/^static AtomPinId find_atom_pin_for_pb_route_id(ClusterBlockId clb, int pb_route_id, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	file:	signature:(ClusterBlockId clb, int pb_route_id, const IntraLbPbPinLookup& pb_gpin_lookup)
find_atom_port	base/atom_netlist.cpp	/^AtomPortId AtomNetlist::find_atom_port(const AtomBlockId blk_id, const t_model_ports* model_port) const {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId blk_id, const t_model_ports* model_port) const
find_atom_port	base/atom_netlist.h	/^        AtomPortId  find_atom_port(const AtomBlockId blk_id, const t_model_ports* model_port) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomBlockId blk_id, const t_model_ports* model_port) const
find_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		template <typename Predicate> xml_attribute find_attribute(Predicate pred) const$/;"	f	class:pugi::xml_node	access:public	signature:(Predicate pred) const
find_average_rr_node_index	route/rr_graph2.cpp	/^int find_average_rr_node_index($/;"	f	signature:( int device_width, int device_height, t_rr_type rr_type, int ptc, const t_rr_node_indices& L_rr_node_indices)
find_average_rr_node_index	route/rr_graph2.h	/^int find_average_rr_node_index($/;"	p	signature:( int device_width, int device_height, t_rr_type rr_type, int ptc, const t_rr_node_indices&L_rr_node_indices)
find_block	base/netlist.h	/^        BlockId     find_block(const StringId name_id) const;$/;"	p	class:Netlist	access:protected	signature:(const StringId name_id) const
find_block	base/netlist.h	/^        BlockId find_block(const std::string& name) const;$/;"	p	class:Netlist	access:public	signature:(const std::string& name) const
find_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::find_block(const std::string& name) const {$/;"	f	class:Netlist	signature:(const std::string& name) const
find_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::find_block(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const {$/;"	f	class:Netlist	signature:(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const
find_block_type_by_name	util/vpr_utils.cpp	/^t_type_descriptor* find_block_type_by_name(std::string name, t_type_descriptor* types, int num_types) {$/;"	f	signature:(std::string name, t_type_descriptor* types, int num_types)
find_block_type_by_name	util/vpr_utils.h	/^t_type_descriptor* find_block_type_by_name(std::string name, t_type_descriptor* types, int num_types);$/;"	p	signature:(std::string name, t_type_descriptor* types, int num_types)
find_cc_constraint	timing/read_sdc.cpp	/^static int find_cc_constraint(char * source_clock_domain, char * sink_clock_domain);$/;"	p	file:	signature:(char * source_clock_domain, char * sink_clock_domain)
find_cc_constraint	timing/read_sdc.cpp	/^static int find_cc_constraint(char * source_clock_name, char * sink_clock_name) {$/;"	f	file:	signature:(char * source_clock_name, char * sink_clock_name)
find_cf_constraint	timing/path_delay.cpp	/^static int find_cf_constraint(const char * source_clock_name, const char * sink_ff_name) {$/;"	f	file:	signature:(const char * source_clock_name, const char * sink_ff_name)
find_cf_constraint	timing/path_delay.cpp	/^static int find_cf_constraint(const char * source_clock_name, const char * sink_ff_name);$/;"	p	file:	signature:(const char * source_clock_name, const char * sink_ff_name)
find_char	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* find_char(const char_t* s, char_t c)$/;"	f	signature:(const char_t* s, char_t c)
find_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		template <typename Predicate> xml_node find_child(Predicate pred) const$/;"	f	class:pugi::xml_node	access:public	signature:(Predicate pred) const
find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const$/;"	f	class:pugi::xml_node	signature:(const char_t* attr_name, const char_t* attr_value) const
find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const
find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* attr_name, const char_t* attr_value) const
find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node find_child_by_attribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const char_t* attr_name, const char_t* attr_value) const
find_clb_pb_pin	util/vpr_utils.cpp	/^int find_clb_pb_pin(ClusterBlockId clb, int clb_pin) {$/;"	f	signature:(ClusterBlockId clb, int clb_pin)
find_clb_pb_pin	util/vpr_utils.h	/^int find_clb_pb_pin(ClusterBlockId clb, int clb_pin);$/;"	p	signature:(ClusterBlockId clb, int clb_pin)
find_clb_pin_connected_atom_pins	util/vpr_utils.cpp	/^std::vector<AtomPinId> find_clb_pin_connected_atom_pins(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	signature:(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup)
find_clb_pin_connected_atom_pins	util/vpr_utils.h	/^std::vector<AtomPinId> find_clb_pin_connected_atom_pins(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	signature:(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup)
find_clb_pin_driver_atom_pin	util/vpr_utils.cpp	/^AtomPinId find_clb_pin_driver_atom_pin(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	signature:(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup)
find_clb_pin_driver_atom_pin	util/vpr_utils.h	/^AtomPinId find_clb_pin_driver_atom_pin(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	signature:(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup)
find_clb_pin_sink_atom_pins	util/vpr_utils.cpp	/^std::vector<AtomPinId> find_clb_pin_sink_atom_pins(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	signature:(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup)
find_clb_pin_sink_atom_pins	util/vpr_utils.h	/^std::vector<AtomPinId> find_clb_pin_sink_atom_pins(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	signature:(ClusterBlockId clb, int clb_pin, const IntraLbPbPinLookup& pb_gpin_lookup)
find_clock	timing/path_delay.cpp	/^static int find_clock(const char * net_name) {$/;"	f	file:	signature:(const char * net_name)
find_clock	timing/path_delay.cpp	/^static int find_clock(const char * net_name);$/;"	p	file:	signature:(const char * net_name)
find_clock_pin	pack/pb_type_graph_annotations.cpp	/^static t_pb_graph_pin* find_clock_pin(t_pb_graph_node* gnode, const char* clock, int line_num) {$/;"	f	file:	signature:(t_pb_graph_node* gnode, const char* clock, int line_num)
find_clock_pin	pack/pb_type_graph_annotations.cpp	/^static t_pb_graph_pin* find_clock_pin(t_pb_graph_node* gnode, const char* clock, int line_num);$/;"	p	file:	signature:(t_pb_graph_node* gnode, const char* clock, int line_num)
find_combinational_annotation	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^const t_pin_to_pin_annotation* find_combinational_annotation(const t_pb_type* pb_type, std::string in_port, std::string out_port) {$/;"	f	signature:(const t_pb_type* pb_type, std::string in_port, std::string out_port)
find_combinational_annotation	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^const t_pin_to_pin_annotation* find_combinational_annotation(const t_pb_type* pb_type, std::string in_port, std::string out_port);$/;"	p	file:	signature:(const t_pb_type* pb_type, std::string in_port, std::string out_port)
find_combinationally_connected_input_ports	base/atom_netlist_utils.cpp	/^std::vector<AtomPortId> find_combinationally_connected_input_ports(const AtomNetlist& netlist, AtomPortId output_port) {$/;"	f	signature:(const AtomNetlist& netlist, AtomPortId output_port)
find_combinationally_connected_input_ports	base/atom_netlist_utils.cpp	/^std::vector<AtomPortId> find_combinationally_connected_input_ports(const AtomNetlist& netlist, AtomPortId output_port);$/;"	p	file:	signature:(const AtomNetlist& netlist, AtomPortId output_port)
find_congested_rr_nodes	pack/cluster_router.cpp	/^static std::vector<int> find_congested_rr_nodes(const std::vector<t_lb_type_rr_node>& lb_type_graph,$/;"	f	file:	signature:(const std::vector<t_lb_type_rr_node>& lb_type_graph, const t_lb_rr_node_stats* lb_rr_node_stats)
find_congested_rr_nodes	pack/cluster_router.cpp	/^static std::vector<int> find_congested_rr_nodes(const std::vector<t_lb_type_rr_node>& lb_type_graph,$/;"	p	file:	signature:(const std::vector<t_lb_type_rr_node>& lb_type_graph, const t_lb_rr_node_stats* lb_rr_node_stats)
find_connected_internal_clb_sink_pins	util/vpr_utils.cpp	/^static std::vector<int> find_connected_internal_clb_sink_pins(ClusterBlockId clb, int pb_pin) {$/;"	f	file:	signature:(ClusterBlockId clb, int pb_pin)
find_connected_internal_clb_sink_pins	util/vpr_utils.cpp	/^static std::vector<int> find_connected_internal_clb_sink_pins(ClusterBlockId clb, int pb_pin);$/;"	p	file:	signature:(ClusterBlockId clb, int pb_pin)
find_connected_internal_clb_sink_pins_recurr	util/vpr_utils.cpp	/^static void find_connected_internal_clb_sink_pins_recurr(ClusterBlockId clb, int pb_pin, std::vector<int>& connected_sink_pb_pins) {$/;"	f	file:	signature:(ClusterBlockId clb, int pb_pin, std::vector<int>& connected_sink_pb_pins)
find_connected_internal_clb_sink_pins_recurr	util/vpr_utils.cpp	/^static void find_connected_internal_clb_sink_pins_recurr(ClusterBlockId clb, int pb_pin, std::vector<int>& connected_sink_pb_pins);$/;"	p	file:	signature:(ClusterBlockId clb, int pb_pin, std::vector<int>& connected_sink_pb_pins)
find_constrained_clock	timing/read_sdc.cpp	/^static int find_constrained_clock(char * ptr) {$/;"	f	file:	signature:(char * ptr)
find_constrained_clock	timing/read_sdc.cpp	/^static int find_constrained_clock(char * ptr);$/;"	p	file:	signature:(char * ptr)
find_create_rr_rc_data	route/rr_node.cpp	/^short find_create_rr_rc_data(const float R, const float C) {$/;"	f	signature:(const float R, const float C)
find_create_rr_rc_data	route/rr_node.h	/^short find_create_rr_rc_data(const float R, const float C);$/;"	p	signature:(const float R, const float C)
find_direct_connect_sample_locations	place/timing_place_lookup.cpp	/^static bool find_direct_connect_sample_locations(const t_direct_inf* direct,$/;"	f	file:	signature:(const t_direct_inf* direct, t_type_ptr from_type, int from_pin, int from_pin_class, t_type_ptr to_type, int to_pin, int to_pin_class, int* src_rr, int* sink_rr)
find_direct_connect_sample_locations	place/timing_place_lookup.cpp	/^static bool find_direct_connect_sample_locations(const t_direct_inf* direct,$/;"	p	file:	signature:(const t_direct_inf* direct, t_type_ptr from_type, int from_pin, int from_pin_class, t_type_ptr to_type, int to_pin, int to_pin_class, int* src_rr, int* sink_rr)
find_edge	draw/draw.cpp	/^static int find_edge(int prev_inode, int inode) {$/;"	f	file:	signature:(int prev_inode, int inode)
find_edge	draw/draw.cpp	/^static int find_edge(int prev_inode, int inode);$/;"	p	file:	signature:(int prev_inode, int inode)
find_expansion_edge_of_pattern	pack/prepack.cpp	/^static t_pb_graph_edge * find_expansion_edge_of_pattern(const int pattern_index,$/;"	f	file:	signature:(const int pattern_index, const t_pb_graph_node *pb_graph_node)
find_expansion_edge_of_pattern	pack/prepack.cpp	/^static t_pb_graph_edge * find_expansion_edge_of_pattern(const int pattern_index,$/;"	p	file:	signature:(const int pattern_index, const t_pb_graph_node *pb_graph_node)
find_ff_clock_tnode	timing/path_delay.cpp	/^static t_tnode * find_ff_clock_tnode(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id) {$/;"	f	file:	signature:(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id)
find_ff_clock_tnode	timing/path_delay.cpp	/^static t_tnode * find_ff_clock_tnode(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id);$/;"	p	file:	signature:(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id)
find_first_set	../../libs/libeasygl/src/graphics.cpp	/^static unsigned long find_first_set(unsigned long mask) {$/;"	f	file:	signature:(unsigned long mask)
find_first_set	../../libs/libeasygl/src/graphics.cpp	/^static unsigned long find_first_set(unsigned long mask);$/;"	p	file:	signature:(unsigned long mask)
find_hold_total_negative_slack	timing/timing_util.cpp	/^float find_hold_total_negative_slack(const tatum::HoldTimingAnalyzer& hold_analyzer) {$/;"	f	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer)
find_hold_total_negative_slack	timing/timing_util.h	/^float find_hold_total_negative_slack(const tatum::HoldTimingAnalyzer& hold_analyzer);$/;"	p	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer)
find_hold_worst_negative_slack	timing/timing_util.cpp	/^float find_hold_worst_negative_slack(const tatum::HoldTimingAnalyzer& hold_analyzer) {$/;"	f	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer)
find_hold_worst_negative_slack	timing/timing_util.h	/^float find_hold_worst_negative_slack(const tatum::HoldTimingAnalyzer& hold_analyzer);$/;"	p	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer)
find_hold_worst_slack	timing/timing_util.cpp	/^float find_hold_worst_slack(const tatum::HoldTimingAnalyzer& hold_analyzer, const tatum::DomainId launch, const tatum::DomainId capture) {$/;"	f	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer, const tatum::DomainId launch, const tatum::DomainId capture)
find_hold_worst_slack	timing/timing_util.h	/^float find_hold_worst_slack(const tatum::HoldTimingAnalyzer& hold_analyzer, const tatum::DomainId launch, const tatum::DomainId capture);$/;"	p	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer, const tatum::DomainId launch, const tatum::DomainId capture)
find_incoming_rr_nodes	pack/cluster_router.cpp	/^static std::vector<int> find_incoming_rr_nodes(int dst_node, const t_lb_router_data* router_data) {$/;"	f	file:	signature:(int dst_node, const t_lb_router_data* router_data)
find_incoming_rr_nodes	pack/cluster_router.cpp	/^static std::vector<int> find_incoming_rr_nodes(int dst_node, const t_lb_router_data* router_data);$/;"	p	file:	signature:(int dst_node, const t_lb_router_data* router_data)
find_input	timing/path_delay.cpp	/^static int find_input(const char * net_name) {$/;"	f	file:	signature:(const char * net_name)
find_input	timing/path_delay.cpp	/^static int find_input(const char * net_name);$/;"	p	file:	signature:(const char * net_name)
find_ipin_cblock_switch_index	base/SetupVPR.cpp	/^static int find_ipin_cblock_switch_index(const t_arch& Arch) {$/;"	f	file:	signature:(const t_arch& Arch)
find_ipin_cblock_switch_index	base/SetupVPR.cpp	/^static int find_ipin_cblock_switch_index(const t_arch& Arch);$/;"	p	file:	signature:(const t_arch& Arch)
find_label_of_track	route/rr_graph2.cpp	/^static int find_label_of_track($/;"	f	file:	signature:( int *wire_mux_on_track, int num_wire_muxes, int from_track)
find_label_of_track	route/rr_graph2.cpp	/^static int find_label_of_track($/;"	p	file:	signature:( int *wire_mux_on_track, int num_wire_muxes, int from_track)
find_least_slack	timing/path_delay.cpp	/^static float find_least_slack(bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping) {$/;"	f	file:	signature:(bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
find_least_slack	timing/path_delay.cpp	/^static float find_least_slack(bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping);$/;"	p	file:	signature:(bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
find_least_slack_critical_path_delay	timing/timing_util.cpp	/^tatum::TimingPathInfo find_least_slack_critical_path_delay(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer) {$/;"	f	signature:(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer)
find_least_slack_critical_path_delay	timing/timing_util.h	/^tatum::TimingPathInfo find_least_slack_critical_path_delay(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer);$/;"	p	signature:(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer)
find_longest_critical_path_delay	timing/timing_util.cpp	/^tatum::TimingPathInfo find_longest_critical_path_delay(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer) {$/;"	f	signature:(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer)
find_longest_critical_path_delay	timing/timing_util.h	/^tatum::TimingPathInfo find_longest_critical_path_delay(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer);$/;"	p	signature:(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer)
find_memory_sibling	util/vpr_utils.cpp	/^AtomBlockId find_memory_sibling(const t_pb* pb) {$/;"	f	signature:(const t_pb* pb)
find_memory_sibling	util/vpr_utils.h	/^AtomBlockId find_memory_sibling(const t_pb* pb);$/;"	p	signature:(const t_pb* pb)
find_model	base/read_blif.cpp	/^        const t_model* find_model(std::string name) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(std::string name)
find_model	util/vpr_utils.cpp	/^const t_model* find_model(const t_model* models, const std::string& name, bool required) {$/;"	f	signature:(const t_model* models, const std::string& name, bool required)
find_model	util/vpr_utils.h	/^const t_model* find_model(const t_model* models, const std::string& name, bool required=true);$/;"	p	signature:(const t_model* models, const std::string& name, bool required=true)
find_model_port	base/read_blif.cpp	/^        const t_model_ports* find_model_port(const t_model* blk_model, std::string port_name) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(const t_model* blk_model, std::string port_name)
find_model_port	util/vpr_utils.cpp	/^const t_model_ports* find_model_port(const t_model* model, const std::string& name, bool required) {$/;"	f	signature:(const t_model* model, const std::string& name, bool required)
find_model_port	util/vpr_utils.h	/^const t_model_ports* find_model_port(const t_model* model, const std::string& name, bool required=true);$/;"	p	signature:(const t_model* model, const std::string& name, bool required=true)
find_most_common_block_type	util/vpr_utils.cpp	/^t_type_ptr find_most_common_block_type(const DeviceGrid& grid) {$/;"	f	signature:(const DeviceGrid& grid)
find_most_common_block_type	util/vpr_utils.h	/^t_type_ptr find_most_common_block_type(const DeviceGrid& grid);$/;"	p	signature:(const DeviceGrid& grid)
find_neightboring_average	place/timing_place_lookup.cpp	/^static float find_neightboring_average(vtr::Matrix<float> &matrix, int x, int y) {$/;"	f	file:	signature:(vtr::Matrix<float> &matrix, int x, int y)
find_neightboring_average	place/timing_place_lookup.cpp	/^static float find_neightboring_average(vtr::Matrix<float> &matrix, int x, int y);$/;"	p	file:	signature:(vtr::Matrix<float> &matrix, int x, int y)
find_net	base/netlist.h	/^        NetId       find_net(const StringId name_id) const;$/;"	p	class:Netlist	access:protected	signature:(const StringId name_id) const
find_net	base/netlist.h	/^        NetId   find_net(const std::string& name) const;$/;"	p	class:Netlist	access:public	signature:(const std::string& name) const
find_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::find_net(const std::string& name) const {$/;"	f	class:Netlist	signature:(const std::string& name) const
find_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::find_net(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const {$/;"	f	class:Netlist	signature:(const typename Netlist<BlockId, PortId, PinId, NetId>::StringId name_id) const
find_netlist_logical_clock_drivers	base/atom_netlist_utils.cpp	/^std::set<AtomPinId> find_netlist_logical_clock_drivers(const AtomNetlist& netlist) {$/;"	f	signature:(const AtomNetlist& netlist)
find_netlist_logical_clock_drivers	base/atom_netlist_utils.h	/^std::set<AtomPinId> find_netlist_logical_clock_drivers(const AtomNetlist& netlist);$/;"	p	signature:(const AtomNetlist& netlist)
find_netlist_physical_clock_nets	base/atom_netlist_utils.cpp	/^std::set<AtomNetId> find_netlist_physical_clock_nets(const AtomNetlist& netlist) {$/;"	f	signature:(const AtomNetlist& netlist)
find_netlist_physical_clock_nets	base/atom_netlist_utils.h	/^std::set<AtomNetId> find_netlist_physical_clock_nets(const AtomNetlist& netlist);$/;"	p	signature:(const AtomNetlist& netlist)
find_netlist_primary_ios	timing/read_sdc2.cpp	/^std::map<std::string,AtomPinId> find_netlist_primary_ios(const AtomNetlist& netlist) {$/;"	f	signature:(const AtomNetlist& netlist)
find_netlist_primary_ios	timing/read_sdc2.cpp	/^std::map<std::string,AtomPinId> find_netlist_primary_ios(const AtomNetlist& netlist);$/;"	p	file:	signature:(const AtomNetlist& netlist)
find_new_root_atom_for_chain	pack/prepack.cpp	/^static AtomBlockId find_new_root_atom_for_chain(const AtomBlockId blk_id, const t_pack_patterns *list_of_pack_pattern,$/;"	f	file:	signature:(const AtomBlockId blk_id, const t_pack_patterns *list_of_pack_pattern, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules)
find_new_root_atom_for_chain	pack/prepack.cpp	/^static AtomBlockId find_new_root_atom_for_chain(const AtomBlockId blk_id, const t_pack_patterns *list_of_pack_pattern,$/;"	p	file:	signature:(const AtomBlockId blk_id, const t_pack_patterns *list_of_pack_pattern, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules)
find_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		template <typename Predicate> xml_node find_node(Predicate pred) const$/;"	f	class:pugi::xml_node	access:public	signature:(Predicate pred) const
find_node_in_rt	pack/cluster_router.cpp	/^static t_lb_trace *find_node_in_rt(t_lb_trace *rt, int rt_index) {$/;"	f	file:	signature:(t_lb_trace *rt, int rt_index)
find_node_in_rt	pack/cluster_router.cpp	/^static t_lb_trace *find_node_in_rt(t_lb_trace *rt, int rt_index);$/;"	p	file:	signature:(t_lb_trace *rt, int rt_index)
find_node_setup_slack	timing/timing_util.cpp	/^float find_node_setup_slack(const tatum::SetupTimingAnalyzer& setup_analyzer, tatum::NodeId node, tatum::DomainId launch_domain, tatum::DomainId capture_domain) {$/;"	f	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer, tatum::NodeId node, tatum::DomainId launch_domain, tatum::DomainId capture_domain)
find_node_setup_slack	timing/timing_util.h	/^float find_node_setup_slack(const tatum::SetupTimingAnalyzer& setup_analyzer, tatum::NodeId node, tatum::DomainId launch_domain, tatum::DomainId capture_domain);$/;"	p	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer, tatum::NodeId node, tatum::DomainId launch_domain, tatum::DomainId capture_domain)
find_num_inputs	base/netlist_writer.cpp	/^        int find_num_inputs(const t_pb* pb) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* pb)
find_origin_node_for_hold_slack	timing/timing_util.cpp	/^tatum::NodeId find_origin_node_for_hold_slack(const tatum::TimingTags::tag_range arrival_tags,$/;"	f	signature:(const tatum::TimingTags::tag_range arrival_tags, const tatum::TimingTags::tag_range required_tags, float slack)
find_origin_node_for_hold_slack	timing/timing_util.h	/^tatum::NodeId find_origin_node_for_hold_slack(const tatum::TimingTags::tag_range arrival_tags,$/;"	p	signature:(const tatum::TimingTags::tag_range arrival_tags, const tatum::TimingTags::tag_range required_tags, float slack)
find_output	timing/path_delay.cpp	/^static int find_output(const char * net_name) {$/;"	f	file:	signature:(const char * net_name)
find_output	timing/path_delay.cpp	/^static int find_output(const char * net_name);$/;"	p	file:	signature:(const char * net_name)
find_pb	base/vpr_types.h	/^    const t_pb* find_pb(const t_pb_graph_node* gnode) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const t_pb_graph_node* gnode) const
find_pb_for_model	base/vpr_types.h	/^    const t_pb* find_pb_for_model(const std::string& blif_model) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const std::string& blif_model) const
find_pb_graph_edge	timing/clb_delay_calc.h	/^        const t_pb_graph_edge* find_pb_graph_edge(ClusterBlockId clb, int pb_route_idx) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(ClusterBlockId clb, int pb_route_idx) const
find_pb_graph_edge	timing/clb_delay_calc.h	/^        const t_pb_graph_edge* find_pb_graph_edge(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const
find_pb_graph_edge	timing/clb_delay_calc.inl	/^inline const t_pb_graph_edge* ClbDelayCalc::find_pb_graph_edge(ClusterBlockId clb, int pb_route_idx) const {$/;"	f	class:ClbDelayCalc	signature:(ClusterBlockId clb, int pb_route_idx) const
find_pb_graph_edge	timing/clb_delay_calc.inl	/^inline const t_pb_graph_edge* ClbDelayCalc::find_pb_graph_edge(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const {$/;"	f	class:ClbDelayCalc	signature:(const t_pb_graph_pin* driver, const t_pb_graph_pin* sink) const
find_pb_graph_pin	timing/PreClusterDelayCalculator.h	/^    const t_pb_graph_pin* find_pb_graph_pin(const AtomPinId pin) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const AtomPinId pin) const
find_pb_graph_pin	timing/atom_delay_calc.h	/^        const t_pb_graph_pin* find_pb_graph_pin(const AtomPinId atom_pin) const;$/;"	p	class:AtomDelayCalc	access:private	signature:(const AtomPinId atom_pin) const
find_pb_graph_pin	timing/atom_delay_calc.inl	/^inline const t_pb_graph_pin* AtomDelayCalc::find_pb_graph_pin(const AtomPinId atom_pin) const {$/;"	f	class:AtomDelayCalc	signature:(const AtomPinId atom_pin) const
find_pb_graph_pin	timing/timing_graph_builder.h	/^        const t_pb_graph_pin* find_pb_graph_pin(const AtomPinId pin);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomPinId pin)
find_pb_graph_pin	util/vpr_utils.cpp	/^const t_pb_graph_pin* find_pb_graph_pin(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const AtomPinId pin_id) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const AtomPinId pin_id)
find_pb_graph_pin	util/vpr_utils.cpp	/^const t_pb_graph_pin* find_pb_graph_pin(const t_pb_graph_node* pb_gnode, std::string port_name, int index) {$/;"	f	signature:(const t_pb_graph_node* pb_gnode, std::string port_name, int index)
find_pb_graph_pin	util/vpr_utils.h	/^const t_pb_graph_pin* find_pb_graph_pin(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const AtomPinId pin_id);$/;"	p	signature:(const AtomNetlist& netlist, const AtomLookup& netlist_lookup, const AtomPinId pin_id)
find_pb_graph_pin	util/vpr_utils.h	/^const t_pb_graph_pin* find_pb_graph_pin(const t_pb_graph_node* pb_gnode, std::string port_name, int index);$/;"	p	signature:(const t_pb_graph_node* pb_gnode, std::string port_name, int index)
find_pb_graph_port	util/vpr_utils.cpp	/^const t_port* find_pb_graph_port(const t_pb_graph_node* pb_gnode, std::string port_name) {$/;"	f	signature:(const t_pb_graph_node* pb_gnode, std::string port_name)
find_pb_graph_port	util/vpr_utils.h	/^const t_port* find_pb_graph_port(const t_pb_graph_node* pb_gnode, std::string port_name);$/;"	p	signature:(const t_pb_graph_node* pb_gnode, std::string port_name)
find_pb_pin_clb_pin	util/vpr_utils.cpp	/^int find_pb_pin_clb_pin(ClusterBlockId clb, int pb_pin) {$/;"	f	signature:(ClusterBlockId clb, int pb_pin)
find_pb_pin_clb_pin	util/vpr_utils.h	/^int find_pb_pin_clb_pin(ClusterBlockId clb, int pb_pin);$/;"	p	signature:(ClusterBlockId clb, int pb_pin)
find_pb_route_clb_input_net_pin	util/vpr_utils.cpp	/^std::tuple<ClusterNetId, int, int> find_pb_route_clb_input_net_pin(ClusterBlockId clb, int sink_pb_pin_id) {$/;"	f	signature:(ClusterBlockId clb, int sink_pb_pin_id)
find_pb_route_clb_input_net_pin	util/vpr_utils.h	/^std::tuple<ClusterNetId,int,int> find_pb_route_clb_input_net_pin(ClusterBlockId clb, int sink_pb_route_id);$/;"	p	signature:(ClusterBlockId clb, int sink_pb_route_id)
find_pin	base/netlist.h	/^        PinId   find_pin(const PortId port_id, BitIndex port_bit) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id, BitIndex port_bit) const
find_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::find_pin(const PortId port_id, BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(const PortId port_id, BitIndex port_bit) const
find_pin	util/vpr_utils.cpp	/^int find_pin(t_type_ptr type, std::string port_name, int pin_index_in_port) {$/;"	f	signature:(t_type_ptr type, std::string port_name, int pin_index_in_port)
find_pin	util/vpr_utils.h	/^int find_pin(t_type_ptr type, std::string port_name, int pin_index_in_port);$/;"	p	signature:(t_type_ptr type, std::string port_name, int pin_index_in_port)
find_pin_class	util/vpr_utils.cpp	/^int find_pin_class(t_type_ptr type, std::string port_name, int pin_index_in_port, e_pin_type pin_type) {$/;"	f	signature:(t_type_ptr type, std::string port_name, int pin_index_in_port, e_pin_type pin_type)
find_pin_class	util/vpr_utils.h	/^int find_pin_class(t_type_ptr type, std::string port_name, int pin_index_in_port, e_pin_type pin_type);$/;"	p	signature:(t_type_ptr type, std::string port_name, int pin_index_in_port, e_pin_type pin_type)
find_pin_index_at_model_scope	draw/intra_logic_block.cpp	/^void find_pin_index_at_model_scope($/;"	f	signature:( const AtomPinId pin_id, const AtomBlockId blk_id, int* pin_index, int* total_pins)
find_pin_index_at_model_scope	draw/intra_logic_block.h	/^void find_pin_index_at_model_scope(const AtomPinId the_pin, const AtomBlockId lblk,$/;"	p	signature:(const AtomPinId the_pin, const AtomBlockId lblk, int* pin_index, int* total_pins)
find_port	base/netlist.h	/^        PortId  find_port(const BlockId blk_id, const std::string& name) const;$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string& name) const
find_port	base/netlist.tpp	/^PortId Netlist<BlockId, PortId, PinId, NetId>::find_port(const BlockId blk_id, const std::string& name) const {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string& name) const
find_port_size	base/netlist_writer.cpp	/^        size_t find_port_size(std::string port_name) {$/;"	f	class:BlackBoxInst	access:public	signature:(std::string port_name)
find_scc_edge_to_break	timing/timing_graph_builder.cpp	/^tatum::EdgeId TimingGraphBuilder::find_scc_edge_to_break(std::vector<tatum::NodeId> scc) {$/;"	f	class:TimingGraphBuilder	signature:(std::vector<tatum::NodeId> scc)
find_scc_edge_to_break	timing/timing_graph_builder.h	/^        tatum::EdgeId find_scc_edge_to_break(std::vector<tatum::NodeId> scc);$/;"	p	class:TimingGraphBuilder	access:private	signature:(std::vector<tatum::NodeId> scc)
find_segment	../../libs/libarchfpga/src/arch_util.cpp	/^t_segment_inf* find_segment(const t_arch* arch, std::string name) {$/;"	f	signature:(const t_arch* arch, std::string name)
find_segment	../../libs/libarchfpga/src/arch_util.h	/^t_segment_inf* find_segment(const t_arch* arch, std::string name);$/;"	p	signature:(const t_arch* arch, std::string name)
find_sequential_annotation	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^const t_pin_to_pin_annotation* find_sequential_annotation(const t_pb_type* pb_type, const t_model_ports* port, enum e_pin_to_pin_delay_annotations annot_type) {$/;"	f	signature:(const t_pb_type* pb_type, const t_model_ports* port, enum e_pin_to_pin_delay_annotations annot_type)
find_sequential_annotation	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^const t_pin_to_pin_annotation* find_sequential_annotation(const t_pb_type* pb_type, const t_model_ports* port, enum e_pin_to_pin_delay_annotations annot_type);$/;"	p	file:	signature:(const t_pb_type* pb_type, const t_model_ports* port, enum e_pin_to_pin_delay_annotations annot_type)
find_setup_total_negative_slack	timing/timing_util.cpp	/^float find_setup_total_negative_slack(const tatum::SetupTimingAnalyzer& setup_analyzer) {$/;"	f	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer)
find_setup_total_negative_slack	timing/timing_util.h	/^float find_setup_total_negative_slack(const tatum::SetupTimingAnalyzer& setup_analyzer);$/;"	p	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer)
find_setup_worst_negative_slack	timing/timing_util.cpp	/^float find_setup_worst_negative_slack(const tatum::SetupTimingAnalyzer& setup_analyzer) {$/;"	f	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer)
find_setup_worst_negative_slack	timing/timing_util.h	/^float find_setup_worst_negative_slack(const tatum::SetupTimingAnalyzer& setup_analyzer);$/;"	p	signature:(const tatum::SetupTimingAnalyzer& setup_analyzer)
find_string	base/netlist.h	/^        StringId    find_string(const std::string& str) const;$/;"	p	class:Netlist	access:protected	signature:(const std::string& str) const
find_string	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::StringId Netlist<BlockId, PortId, PinId, NetId>::find_string(const std::string& str) const {$/;"	f	class:Netlist	signature:(const std::string& str) const
find_substring	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* find_substring(const char_t* s, const char_t* p)$/;"	f	signature:(const char_t* s, const char_t* p)
find_switch_by_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^int find_switch_by_name(const t_arch& arch, std::string switch_name) {$/;"	f	signature:(const t_arch& arch, std::string switch_name)
find_switch_by_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^int find_switch_by_name(const t_arch& arch, std::string switch_name);$/;"	p	file:	signature:(const t_arch& arch, std::string switch_name)
find_tnode	base/netlist_writer.cpp	/^        tatum::NodeId find_tnode(const t_pb* atom, int cluster_pin_idx) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom, int cluster_pin_idx)
find_tnode_atom_block	util/vpr_utils.cpp	/^AtomBlockId find_tnode_atom_block(int inode) {$/;"	f	signature:(int inode)
find_tnode_atom_block	util/vpr_utils.h	/^AtomBlockId find_tnode_atom_block(int inode);$/;"	p	signature:(int inode)
find_tnode_net_name	timing/path_delay.cpp	/^static const char * find_tnode_net_name(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping) {$/;"	f	file:	signature:(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
find_tnode_net_name	timing/path_delay.cpp	/^static const char * find_tnode_net_name(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping);$/;"	p	file:	signature:(int inode, bool is_prepacked, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
find_to	place/place.cpp	/^static bool find_to(t_type_ptr type, float rlim,$/;"	f	file:	signature:(t_type_ptr type, float rlim, int x_from, int y_from, int *px_to, int *py_to, int *pz_to)
find_to	place/place.cpp	/^static bool find_to(t_type_ptr type, float rlim,$/;"	p	file:	signature:(t_type_ptr type, float rlim, int x_from, int y_from, int *px_to, int *py_to, int *pz_to)
find_to_location	place/place.cpp	/^static void find_to_location(t_type_ptr type, float rlim,$/;"	f	file:	signature:(t_type_ptr type, float rlim, int x_from, int y_from, int *px_to, int *py_to, int *pz_to)
find_to_location	place/place.cpp	/^static void find_to_location(t_type_ptr type, float rlim,$/;"	p	file:	signature:(t_type_ptr type, float rlim, int x_from, int y_from, int *px_to, int *py_to, int *pz_to)
find_top_cb	base/netlist_writer.cpp	/^        const t_pb* find_top_cb(const t_pb* curr) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* curr)
find_top_pb_route	base/netlist_writer.cpp	/^        const t_pb_routes& find_top_pb_route(const t_pb* curr) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* curr)
find_total_negative_slack_within_clb_blocks	timing/timing_util.cpp	/^float find_total_negative_slack_within_clb_blocks(const tatum::HoldTimingAnalyzer& hold_analyzer) {$/;"	f	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer)
find_total_negative_slack_within_clb_blocks	timing/timing_util.h	/^float find_total_negative_slack_within_clb_blocks(const tatum::HoldTimingAnalyzer& hold_analyzer);$/;"	p	signature:(const tatum::HoldTimingAnalyzer& hold_analyzer)
find_tracks_unconnected_to_pin	route/cb_metrics.cpp	/^static void find_tracks_unconnected_to_pin( const set<int> *pin_tracks, const vector< set<int> > *track_to_pins, vector<int> *result );$/;"	p	file:	signature:( const set<int> *pin_tracks, const vector< set<int> > *track_to_pins, vector<int> *result )
find_tracks_unconnected_to_pin	route/cb_metrics.cpp	/^static void find_tracks_unconnected_to_pin( const set<int> *pin_tracks, const vector< set<int> > *track_to_pins, vector<int> *result ){$/;"	f	file:	signature:( const set<int> *pin_tracks, const vector< set<int> > *track_to_pins, vector<int> *result )
find_tracks_with_more_switches_than	route/cb_metrics.cpp	/^static void find_tracks_with_more_switches_than( const set<int> *pin_tracks, const t_vec_vec_set *track_to_pins, const int side,$/;"	f	file:	signature:( const set<int> *pin_tracks, const t_vec_vec_set *track_to_pins, const int side, const bool both_sides, const int criteria, vector<int> *result )
find_tracks_with_more_switches_than	route/cb_metrics.cpp	/^static void find_tracks_with_more_switches_than( const set<int> *pin_tracks, const t_vec_vec_set *track_to_pins, const int side,$/;"	p	file:	signature:( const set<int> *pin_tracks, const t_vec_vec_set *track_to_pins, const int side, const bool both_sides, const int criteria, vector<int> *result )
find_x_for_y_value	route/routing_predictor.cpp	/^    float find_x_for_y_value(float y_value) const {$/;"	f	class:LinearModel	access:public	signature:(float y_value) const
find_y_for_x_value	route/routing_predictor.cpp	/^    float find_y_for_x_value(float x_value) const {$/;"	f	class:LinearModel	access:public	signature:(float x_value) const
finish	../../libs/libvtrutil/src/picosha2.h	/^	void finish(){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:()
finish	base/netlist_walker.h	/^        void finish() { finish_impl(); }$/;"	f	class:NetlistVisitor	access:public	signature:()
finish_impl	base/netlist_walker.cpp	/^void NetlistVisitor::finish_impl() {$/;"	f	class:NetlistVisitor	signature:()
finish_impl	base/netlist_walker.h	/^        virtual void finish_impl();$/;"	p	class:NetlistVisitor	access:protected	signature:()
first	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node first() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
first	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xpath_node_set::first() const$/;"	f	class:pugi::xpath_node_set	signature:() const
first	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node first() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
first_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_attribute_struct, 11, 0> first_attribute;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
first_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::first_attribute() const$/;"	f	class:pugi::xml_node	signature:() const
first_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute first_attribute() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
first_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_node_struct, 8, 0> first_child;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
first_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::first_child() const$/;"	f	class:pugi::xml_node	signature:() const
first_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node first_child() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
first_element_by_path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::first_element_by_path(const char_t* path_, char_t delimiter) const$/;"	f	class:pugi::xml_node	signature:(const char_t* path_, char_t delimiter) const
first_element_by_path	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node first_element_by_path(const char_t* path, char_t delimiter = '\/') const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* path, char_t delimiter = Ã) const
first_iter_pres_fac	base/read_options.h	/^    argparse::ArgValue<float> first_iter_pres_fac;$/;"	m	struct:t_options	access:public
first_iter_pres_fac	base/vpr_types.h	/^	float first_iter_pres_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
first_iteration_timing_report_file	base/vpr_types.h	/^    std::string first_iteration_timing_report_file;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
fit_model	route/routing_predictor.cpp	/^LinearModel fit_model(std::vector<size_t> iterations, std::vector<size_t> overuse, float history_factor) {$/;"	f	signature:(std::vector<size_t> iterations, std::vector<size_t> overuse, float history_factor)
fit_model	route/routing_predictor.cpp	/^LinearModel fit_model(std::vector<size_t> iterations, std::vector<size_t> overuse, float history_factor);$/;"	p	file:	signature:(std::vector<size_t> iterations, std::vector<size_t> overuse, float history_factor)
fix_comb_loops	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::fix_comb_loops() {$/;"	f	class:TimingGraphBuilder	signature:()
fix_comb_loops	timing/timing_graph_builder.h	/^        void fix_comb_loops();$/;"	p	class:TimingGraphBuilder	access:private	signature:()
fix_duplicate_equivalent_pins	pack/cluster_router.cpp	/^static void fix_duplicate_equivalent_pins(t_lb_router_data *router_data) {$/;"	f	file:	signature:(t_lb_router_data *router_data)
fix_duplicate_equivalent_pins	pack/cluster_router.cpp	/^static void fix_duplicate_equivalent_pins(t_lb_router_data *router_data);$/;"	p	file:	signature:(t_lb_router_data *router_data)
fix_empty_coordinates	place/timing_place_lookup.cpp	/^static void fix_empty_coordinates(vtr::Matrix<float>& delta_delays) {$/;"	f	file:	signature:(vtr::Matrix<float>& delta_delays)
fix_empty_coordinates	place/timing_place_lookup.cpp	/^static void fix_empty_coordinates(vtr::Matrix<float>& delta_delays);$/;"	p	file:	signature:(vtr::Matrix<float>& delta_delays)
fix_uninitialized_coordinates	place/timing_place_lookup.cpp	/^static void fix_uninitialized_coordinates(vtr::Matrix<float>& delta_delays) {$/;"	f	file:	signature:(vtr::Matrix<float>& delta_delays)
fix_uninitialized_coordinates	place/timing_place_lookup.cpp	/^static void fix_uninitialized_coordinates(vtr::Matrix<float>& delta_delays);$/;"	p	file:	signature:(vtr::Matrix<float>& delta_delays)
fixed_Tdel	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_arch_switch_inf::fixed_Tdel() const {$/;"	f	class:t_arch_switch_inf	signature:() const
fixed_Tdel	../../libs/libarchfpga/src/physical_types.h	/^        bool fixed_Tdel() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
fixed_channel_width	base/vpr_types.h	/^	int fixed_channel_width;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
fixed_terminals	pack/pack_types.h	/^    std::vector<bool> fixed_terminals;  \/* Marks a terminal as having a fixed target (i.e. a pin not a sink) *\/$/;"	m	struct:t_intra_lb_net	access:public
fixup_branch	timing/slre.cpp	/^static void fixup_branch(struct slre *r, int fixup) {$/;"	f	file:	signature:(struct slre *r, int fixup)
flags_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::ios::fmtflags flags_;$/;"	m	class:vtr::OsFormatGuard	access:private
flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map() = default;$/;"	p	class:vtr::flat_map	access:public	signature:()
flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(InputIterator first, InputIterator last) {$/;"	f	class:vtr::flat_map	access:public	signature:(InputIterator first, InputIterator last)
flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(const flat_map&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(const flat_map&)
flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(flat_map&&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(flat_map&&)
flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(std::vector<value_type> values) {$/;"	f	class:vtr::flat_map	access:public	signature:(std::vector<value_type> values)
flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^class flat_map {$/;"	c	namespace:vtr
flat_map2	../../libs/libvtrutil/src/vtr_flat_map.h	/^class flat_map2 : public flat_map<K,T,Compare> {$/;"	c	namespace:vtr	inherits:flat_map
flush	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* flush(char_t* s)$/;"	f	struct:gap	access:public	signature:(char_t* s)
flush	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t flush()$/;"	f	class:xml_buffered_writer	access:public	signature:()
flush	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void flush(const char_t* data, size_t size)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data, size_t size)
flush_intermediate_queues	pack/cluster_placement.cpp	/^static void flush_intermediate_queues($/;"	f	file:	signature:( t_cluster_placement_stats *cluster_placement_stats)
flush_intermediate_queues	pack/cluster_placement.cpp	/^static void flush_intermediate_queues($/;"	p	file:	signature:( t_cluster_placement_stats *cluster_placement_stats)
flushinput	../../libs/libeasygl/src/graphics.cpp	/^flushinput() {$/;"	f	signature:()
flushinput	../../libs/libeasygl/src/graphics.cpp	/^void flushinput(void) { }$/;"	f	signature:(void)
flushinput	../../libs/libeasygl/src/graphics.h	/^void flushinput();$/;"	p	signature:()
fname_	timing/read_sdc.cpp	/^        std::string fname_;$/;"	m	class:SdcCallback	file:	access:private
fname_	timing/read_sdc2.cpp	/^        std::string fname_;$/;"	m	class:SdcParseCallback2	file:	access:private
font_descriptor	../../libs/libeasygl/src/fontcache.h	/^    typedef std::pair<size_t, int> font_descriptor;$/;"	t	class:FontCache	access:private
font_info	../../libs/libeasygl/src/graphics_state.h	/^    FontCache font_info;$/;"	m	struct:t_gl_state	access:public
font_lookup	../../libs/libeasygl/src/fontcache.h	/^    typedef std::unordered_map<font_descriptor, font_ptr, fontdesc_hasher> font_lookup;$/;"	t	class:FontCache	access:private
font_ptr	../../libs/libeasygl/src/fontcache.h	/^typedef LOGFONT* font_ptr;$/;"	t
font_queue	../../libs/libeasygl/src/fontcache.h	/^    typedef std::deque<font_descriptor> font_queue;$/;"	t	class:FontCache	access:private
fontdesc_hasher	../../libs/libeasygl/src/fontcache.h	/^    struct fontdesc_hasher {$/;"	s	class:FontCache	access:private
fopen	../../libs/libvtrutil/src/vtr_util.cpp	/^FILE* fopen(const char *fname, const char *flag) {$/;"	f	namespace:vtr	signature:(const char *fname, const char *flag)
fopen	../../libs/libvtrutil/src/vtr_util.h	/^    FILE* fopen(const char *fname, const char *flag);$/;"	p	namespace:vtr	signature:(const char *fname, const char *flag)
for_each	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual bool for_each(xml_node& node) = 0;$/;"	p	class:pugi::xml_tree_walker	access:public	signature:(xml_node& node)
force_pause_	base/vpr_context.h	/^        volatile sig_atomic_t force_pause_ = false;$/;"	m	class:VprContext	access:private
force_setcolor	../../libs/libeasygl/src/graphics.cpp	/^static void force_setcolor(const t_color& new_color) {$/;"	f	file:	signature:(const t_color& new_color)
force_setcolor	../../libs/libeasygl/src/graphics.cpp	/^static void force_setcolor(const t_color& new_color);$/;"	p	file:	signature:(const t_color& new_color)
force_setcolor	../../libs/libeasygl/src/graphics.cpp	/^static void force_setcolor(int cindex) {$/;"	f	file:	signature:(int cindex)
force_setcolor	../../libs/libeasygl/src/graphics.cpp	/^static void force_setcolor(int cindex);$/;"	p	file:	signature:(int cindex)
force_setlinestyle	../../libs/libeasygl/src/graphics.cpp	/^static void force_setlinestyle(int linestyle, int capstyle = 1);	\/\/ <Modification> as #define CapButt 1 in X.h$/;"	p	file:	signature:(int linestyle, int capstyle = 1)
force_setlinestyle	../../libs/libeasygl/src/graphics.cpp	/^static void force_setlinestyle(int linestyle, int capstyle) {$/;"	f	file:	signature:(int linestyle, int capstyle)
force_setlinewidth	../../libs/libeasygl/src/graphics.cpp	/^static void force_setlinewidth(int linewidth) {$/;"	f	file:	signature:(int linewidth)
force_setlinewidth	../../libs/libeasygl/src/graphics.cpp	/^static void force_setlinewidth(int linewidth);$/;"	p	file:	signature:(int linewidth)
force_settextattrs	../../libs/libeasygl/src/graphics.cpp	/^static void force_settextattrs(int pointsize, int degrees) {$/;"	f	file:	signature:(int pointsize, int degrees)
force_settextattrs	../../libs/libeasygl/src/graphics.cpp	/^static void force_settextattrs(int pointsize, int degrees);$/;"	p	file:	signature:(int pointsize, int degrees)
forced_pause	base/vpr_context.h	/^        bool forced_pause() const { return force_pause_; }$/;"	f	class:VprContext	access:public	signature:() const
forcible_reroute_connection_flag	route/connection_based_routing.h	/^	vtr::vector<ClusterNetId, std::unordered_map<int,bool>> forcible_reroute_connection_flag;$/;"	m	class:Connection_based_routing_resources	access:private
forcibly_reroute_connections	route/connection_based_routing.h	/^	bool forcibly_reroute_connections(float max_criticality,$/;"	p	class:Connection_based_routing_resources	access:public	signature:(float max_criticality, std::shared_ptr<const SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
forcibly_reroute_connections	route/route_timing.cpp	/^bool Connection_based_routing_resources::forcibly_reroute_connections(float max_criticality,$/;"	f	class:Connection_based_routing_resources	signature:(float max_criticality, std::shared_ptr<const SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, vtr::vector<ClusterNetId, float *> &net_delay)
foreground_color	../../libs/libeasygl/src/graphics_state.h	/^    t_color foreground_color = BLACK;$/;"	m	struct:t_gl_state	access:public
format	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_to_pin_annotation_format format;$/;"	m	struct:t_pin_to_pin_annotation	typeref:enum:t_pin_to_pin_annotation::e_pin_to_pin_annotation_format	access:public
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
format_coordinates	base/read_route.cpp	/^static void format_coordinates(int &x, int &y, string coord, ClusterNetId net, const char* filename, const int lineno) {$/;"	f	file:	signature:(int &x, int &y, string coord, ClusterNetId net, const char* filename, const int lineno)
format_coordinates	base/read_route.cpp	/^static void format_coordinates(int &x, int &y, string coord, ClusterNetId net, const char* filename, const int lineno);$/;"	p	file:	signature:(int &x, int &y, string coord, ClusterNetId net, const char* filename, const int lineno)
format_default	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_default = format_indent;$/;"	m	namespace:pugi
format_histogram	util/histogram.cpp	/^std::vector<std::string> format_histogram(std::vector<HistogramBucket> histogram, size_t width) {$/;"	f	signature:(std::vector<HistogramBucket> histogram, size_t width)
format_histogram	util/histogram.h	/^std::vector<std::string> format_histogram(std::vector<HistogramBucket> histogram, size_t width=80);$/;"	p	signature:(std::vector<HistogramBucket> histogram, size_t width=80)
format_indent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_indent = 0x01;$/;"	m	namespace:pugi
format_indent_attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_indent_attributes = 0x40;$/;"	m	namespace:pugi
format_name	base/read_route.cpp	/^static string format_name(string name) {$/;"	f	file:	signature:(string name)
format_name	base/read_route.cpp	/^static string format_name(string name);$/;"	p	file:	signature:(string name)
format_no_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_no_declaration = 0x08;$/;"	m	namespace:pugi
format_no_escapes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_no_escapes = 0x10;$/;"	m	namespace:pugi
format_pin_info	base/read_route.cpp	/^static void format_pin_info(string &pb_name, string & port_name, int & pb_pin_num, string input) {$/;"	f	file:	signature:(string &pb_name, string & port_name, int & pb_pin_num, string input)
format_pin_info	base/read_route.cpp	/^static void format_pin_info(string &pb_name, string & port_name, int & pb_pin_num, string input);$/;"	p	file:	signature:(string &pb_name, string & port_name, int & pb_pin_num, string input)
format_raw	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_raw = 0x04;$/;"	m	namespace:pugi
format_save_file_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_save_file_text = 0x20;$/;"	m	namespace:pugi
format_tatum_error	base/vpr_tatum_error.cpp	/^std::string format_tatum_error(const tatum::Error& error) {$/;"	f	signature:(const tatum::Error& error)
format_tatum_error	base/vpr_tatum_error.h	/^std::string format_tatum_error(const tatum::Error& error);$/;"	p	signature:(const tatum::Error& error)
format_write_bom	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_write_bom = 0x02;$/;"	m	namespace:pugi
formula_to_rpn	../../libs/libarchfpga/src/expr_eval.cpp	/^static void formula_to_rpn( const char* formula, const t_formula_data &mydata,$/;"	f	file:	signature:( const char* formula, const t_formula_data &mydata, vector<Formula_Object> &rpn_output )
formula_to_rpn	../../libs/libarchfpga/src/expr_eval.cpp	/^static void formula_to_rpn( const char* formula, const t_formula_data &mydata,$/;"	p	file:	signature:( const char* formula, const t_formula_data &mydata, vector<Formula_Object> &rpn_output )
forward_expand_pack_pattern_from_edge	pack/prepack.cpp	/^static void forward_expand_pack_pattern_from_edge($/;"	f	file:	signature:( const t_pb_graph_edge* expansion_edge, t_pack_patterns *list_of_packing_patterns, const int curr_pattern_index, int *L_num_blocks, bool make_root_of_chain)
forward_expand_pack_pattern_from_edge	pack/prepack.cpp	/^static void forward_expand_pack_pattern_from_edge($/;"	p	file:	signature:( const t_pb_graph_edge *expansion_edge, t_pack_patterns *list_of_packing_patterns, const int curr_pattern_index, int *L_num_blocks, const bool make_root_of_chain)
forward_infer_pattern	pack/prepack.cpp	/^static void forward_infer_pattern(t_pb_graph_pin *pb_graph_pin) {$/;"	f	file:	signature:(t_pb_graph_pin *pb_graph_pin)
forward_infer_pattern	pack/prepack.cpp	/^static void forward_infer_pattern(t_pb_graph_pin *pb_graph_pin);$/;"	p	file:	signature:(t_pb_graph_pin *pb_graph_pin)
forward_weight	base/vpr_types.h	/^	float forward_weight, backward_weight; \/* Weightings of the importance of paths$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
fptr	base/vpr_types.h	/^	float *fptr;$/;"	m	struct:ScreenUpdatePriority::t_linked_f_pointer	access:public
frac_cb	../../libs/libarchfpga/src/physical_types.h	/^	float frac_cb;$/;"	m	struct:t_segment_inf	access:public
frac_sb	../../libs/libarchfpga/src/physical_types.h	/^	float frac_sb;$/;"	m	struct:t_segment_inf	access:public
frand	../../libs/libvtrutil/src/vtr_random.cpp	/^float frand() {$/;"	f	namespace:vtr	signature:()
frand	../../libs/libvtrutil/src/vtr_random.h	/^    float frand();$/;"	p	namespace:vtr	signature:()
free	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* free(void *some){$/;"	f	namespace:vtr	signature:(void *some)
free	../../libs/libvtrutil/src/vtr_memory.h	/^    void* free(void *some);$/;"	p	namespace:vtr	signature:(void *some)
freeTokens	util/token.cpp	/^void freeTokens(t_token *tokens, const int num_tokens) {$/;"	f	signature:(t_token *tokens, const int num_tokens)
freeTokens	util/token.h	/^void freeTokens(t_token *tokens, const int num_tokens);$/;"	p	signature:(t_token *tokens, const int num_tokens)
free_all_lb_type_rr_graph	pack/lb_type_rr_graph.cpp	/^void free_all_lb_type_rr_graph(std::vector<t_lb_type_rr_node> *lb_type_rr_graphs) {$/;"	f	signature:(std::vector<t_lb_type_rr_node> *lb_type_rr_graphs)
free_all_lb_type_rr_graph	pack/lb_type_rr_graph.h	/^void free_all_lb_type_rr_graph(std::vector<t_lb_type_rr_node> *lb_type_rr_graphs);$/;"	p	signature:(std::vector<t_lb_type_rr_node> *lb_type_rr_graphs)
free_all_pb_graph_nodes	../../libs/libarchfpga/src/arch_util.cpp	/^static void free_all_pb_graph_nodes(t_type_descriptor* type_descriptors, int num_type_descriptors) {$/;"	f	file:	signature:(t_type_descriptor* type_descriptors, int num_type_descriptors)
free_all_pb_graph_nodes	../../libs/libarchfpga/src/arch_util.cpp	/^static void free_all_pb_graph_nodes(t_type_descriptor* type_descriptors, int num_type_descriptors);$/;"	p	file:	signature:(t_type_descriptor* type_descriptors, int num_type_descriptors)
free_arch	../../libs/libarchfpga/src/arch_util.cpp	/^void free_arch(t_arch* arch) {$/;"	f	signature:(t_arch* arch)
free_arch	../../libs/libarchfpga/src/arch_util.h	/^void free_arch(t_arch* arch);$/;"	p	signature:(t_arch* arch)
free_blk_pin_from_port_pin	util/vpr_utils.cpp	/^void free_blk_pin_from_port_pin() {$/;"	f	signature:()
free_blk_pin_from_port_pin	util/vpr_utils.h	/^void free_blk_pin_from_port_pin();$/;"	p	signature:()
free_budgets	route/route_budgets.cpp	/^void route_budgets::free_budgets() {$/;"	f	class:route_budgets	signature:()
free_budgets	route/route_budgets.h	/^    void free_budgets();$/;"	p	class:route_budgets	access:private	signature:()
free_chan_details	route/rr_graph2.cpp	/^void free_chan_details($/;"	f	signature:( t_chan_details& chan_details_x, t_chan_details& chan_details_y)
free_chan_details	route/rr_graph2.h	/^void free_chan_details($/;"	p	signature:( t_chan_details& chan_details_x, t_chan_details& chan_details_y)
free_chunk_memory	../../libs/libvtrutil/src/vtr_memory.cpp	/^void free_chunk_memory(t_chunk *chunk_info) {$/;"	f	namespace:vtr	signature:(t_chunk *chunk_info)
free_chunk_memory	../../libs/libvtrutil/src/vtr_memory.h	/^    void free_chunk_memory(t_chunk *chunk_info);$/;"	p	namespace:vtr	signature:(t_chunk *chunk_info)
free_chunk_memory_trace	route/route_common.cpp	/^void free_chunk_memory_trace() {$/;"	f	signature:()
free_chunk_memory_trace	route/route_common.h	/^void free_chunk_memory_trace();$/;"	p	signature:()
free_circuit	base/vpr_api.cpp	/^static void free_circuit();$/;"	p	file:	signature:()
free_circuit	base/vpr_api.cpp	/^void free_circuit() {$/;"	f	signature:()
free_clock_constraint	timing/read_sdc.cpp	/^static void free_clock_constraint(t_clock *& clock_array, int num_clocks) {$/;"	f	file:	signature:(t_clock *& clock_array, int num_clocks)
free_clock_constraint	timing/read_sdc.cpp	/^static void free_clock_constraint(t_clock *& clock_array, int num_clocks);$/;"	p	file:	signature:(t_clock *& clock_array, int num_clocks)
free_cluster_placement_stats	pack/cluster_placement.cpp	/^void free_cluster_placement_stats($/;"	f	signature:( t_cluster_placement_stats *cluster_placement_stats_list)
free_cluster_placement_stats	pack/cluster_placement.h	/^void free_cluster_placement_stats($/;"	p	signature:( t_cluster_placement_stats *cluster_placement_stats)
free_complex_block_types	base/vpr_api.cpp	/^static void free_complex_block_types() {$/;"	f	file:	signature:()
free_complex_block_types	base/vpr_api.cpp	/^static void free_complex_block_types();$/;"	p	file:	signature:()
free_cost_map	route/router_lookahead_map.cpp	/^static void free_cost_map();$/;"	p	file:	signature:()
free_cost_map	route/router_lookahead_map.cpp	/^static void free_cost_map(){$/;"	f	file:	signature:()
free_crit	place/timing_place.cpp	/^static void free_crit(vtr::t_chunk *chunk_list_ptr);$/;"	p	file:	signature:(vtr::t_chunk *chunk_list_ptr)
free_crit	place/timing_place.cpp	/^static void free_crit(vtr::t_chunk *chunk_list_ptr){$/;"	f	file:	signature:(vtr::t_chunk *chunk_list_ptr)
free_device	base/vpr_api.cpp	/^static void free_device(const t_det_routing_arch& routing_arch);$/;"	p	file:	signature:(const t_det_routing_arch& routing_arch)
free_device	base/vpr_api.cpp	/^void free_device(const t_det_routing_arch& routing_arch) {$/;"	f	signature:(const t_det_routing_arch& routing_arch)
free_draw_structs	draw/draw.cpp	/^void free_draw_structs() {$/;"	f	signature:()
free_draw_structs	draw/draw.h	/^void free_draw_structs();$/;"	p	signature:()
free_echo_file_info	base/echo_files.cpp	/^void free_echo_file_info() {$/;"	f	signature:()
free_echo_file_info	base/echo_files.h	/^void free_echo_file_info();$/;"	p	signature:()
free_fast_cost_update	place/place.cpp	/^static void free_fast_cost_update() {$/;"	f	file:	signature:()
free_fast_cost_update	place/place.cpp	/^static void free_fast_cost_update();$/;"	p	file:	signature:()
free_hash_table	util/hash.cpp	/^void free_hash_table(t_hash **hash_table) {$/;"	f	signature:(t_hash **hash_table)
free_hash_table	util/hash.h	/^void free_hash_table(t_hash **hash_table);$/;"	p	signature:(t_hash **hash_table)
free_heap_data	route/route_common.cpp	/^void free_heap_data(t_heap *hptr) {$/;"	f	signature:(t_heap *hptr)
free_heap_data	route/route_common.h	/^void free_heap_data(t_heap *hptr);$/;"	p	signature:(t_heap *hptr)
free_int_list	../../libs/libvtrutil/src/vtr_list.cpp	/^void free_int_list(t_linked_int ** int_list_head_ptr) {$/;"	f	namespace:vtr	signature:(t_linked_int ** int_list_head_ptr)
free_int_list	../../libs/libvtrutil/src/vtr_list.h	/^    void free_int_list(t_linked_int ** int_list_head_ptr);$/;"	p	namespace:vtr	signature:(t_linked_int ** int_list_head_ptr)
free_intra_lb_nets	pack/cluster_router.cpp	/^void free_intra_lb_nets(vector <t_intra_lb_net> *intra_lb_nets) {$/;"	f	signature:(vector <t_intra_lb_net> *intra_lb_nets)
free_intra_lb_nets	pack/cluster_router.h	/^void free_intra_lb_nets(vector <t_intra_lb_net> *intra_lb_nets);$/;"	p	signature:(vector <t_intra_lb_net> *intra_lb_nets)
free_io_constraint	timing/read_sdc.cpp	/^static void free_io_constraint(t_io *& io_array, int num_ios) {$/;"	f	file:	signature:(t_io *& io_array, int num_ios)
free_io_constraint	timing/read_sdc.cpp	/^static void free_io_constraint(t_io *& io_array, int num_ios);$/;"	p	file:	signature:(t_io *& io_array, int num_ios)
free_ivec_vector	../../libs/libvtrutil/src/vtr_matrix.cpp	/^void free_ivec_vector(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax) {$/;"	f	namespace:vtr	signature:(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax)
free_ivec_vector	../../libs/libvtrutil/src/vtr_matrix.h	/^    void free_ivec_vector(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax);$/;"	p	namespace:vtr	signature:(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax)
free_lb_net_rt	pack/cluster_router.cpp	/^static void free_lb_net_rt(t_lb_trace *lb_trace) {$/;"	f	file:	signature:(t_lb_trace *lb_trace)
free_lb_net_rt	pack/cluster_router.cpp	/^static void free_lb_net_rt(t_lb_trace *lb_trace);$/;"	p	file:	signature:(t_lb_trace *lb_trace)
free_lb_trace	pack/cluster_router.cpp	/^static void free_lb_trace(t_lb_trace *lb_trace) {$/;"	f	file:	signature:(t_lb_trace *lb_trace)
free_lb_trace	pack/cluster_router.cpp	/^static void free_lb_trace(t_lb_trace *lb_trace);$/;"	p	file:	signature:(t_lb_trace *lb_trace)
free_legal_placements	place/place.cpp	/^static void free_legal_placements() {$/;"	f	file:	signature:()
free_legal_placements	place/place.cpp	/^static void free_legal_placements();$/;"	p	file:	signature:()
free_linked_rc_edge	timing/net_delay.cpp	/^static void free_linked_rc_edge(t_linked_rc_edge * rc_edge,$/;"	f	file:	signature:(t_linked_rc_edge * rc_edge, t_linked_rc_edge ** rc_edge_free_list_ptr)
free_linked_rc_edge	timing/net_delay.cpp	/^static void free_linked_rc_edge(t_linked_rc_edge * rc_edge,$/;"	p	file:	signature:(t_linked_rc_edge * rc_edge, t_linked_rc_edge ** rc_edge_free_list_ptr)
free_linked_rt_edge	route/route_tree_timing.cpp	/^static void free_linked_rt_edge(t_linked_rt_edge * rt_edge) {$/;"	f	file:	signature:(t_linked_rt_edge * rt_edge)
free_linked_rt_edge	route/route_tree_timing.cpp	/^static void free_linked_rt_edge(t_linked_rt_edge * rt_edge);$/;"	p	file:	signature:(t_linked_rt_edge * rt_edge)
free_list_of_pack_patterns	pack/prepack.cpp	/^void free_list_of_pack_patterns(t_pack_patterns *list_of_pack_patterns, const int num_packing_patterns) {$/;"	f	signature:(t_pack_patterns *list_of_pack_patterns, const int num_packing_patterns)
free_list_of_pack_patterns	pack/prepack.h	/^void free_list_of_pack_patterns(t_pack_patterns *list_of_pack_patterns, const int num_packing_patterns);$/;"	p	signature:(t_pack_patterns *list_of_pack_patterns, const int num_packing_patterns)
free_lookups_and_criticalities	place/timing_place.cpp	/^void free_lookups_and_criticalities() {$/;"	f	signature:()
free_lookups_and_criticalities	place/timing_place.h	/^void free_lookups_and_criticalities();$/;"	p	signature:()
free_net_delay	timing/net_delay.cpp	/^void free_net_delay(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	f	signature:(vtr::vector<ClusterNetId, float *> &net_delay, vtr::t_chunk *chunk_list_ptr)
free_net_delay	timing/net_delay.h	/^void free_net_delay(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	p	signature:(vtr::vector<ClusterNetId, float *> &net_delay, vtr::t_chunk *chunk_list_ptr)
free_output_file_names	base/echo_files.cpp	/^void free_output_file_names() {$/;"	f	signature:()
free_output_file_names	base/echo_files.h	/^void free_output_file_names();$/;"	p	signature:()
free_override_constraint	timing/read_sdc.cpp	/^void free_override_constraint(t_override_constraint *& constraint_array, int num_constraints) {$/;"	f	signature:(t_override_constraint *& constraint_array, int num_constraints)
free_override_constraint	timing/read_sdc.h	/^void free_override_constraint(t_override_constraint *& constraint_array, int num_constraints);$/;"	p	signature:(t_override_constraint *& constraint_array, int num_constraints)
free_pack_pattern	pack/prepack.cpp	/^static void free_pack_pattern(t_pack_pattern_block *pattern_block, t_pack_pattern_block **pattern_block_list) {$/;"	f	file:	signature:(t_pack_pattern_block *pattern_block, t_pack_pattern_block **pattern_block_list)
free_pack_pattern	pack/prepack.cpp	/^static void free_pack_pattern(t_pack_pattern_block *pattern_block, t_pack_pattern_block **pattern_block_list);$/;"	p	file:	signature:(t_pack_pattern_block *pattern_block, t_pack_pattern_block **pattern_block_list)
free_pb	util/vpr_utils.cpp	/^void free_pb(t_pb *pb) {$/;"	f	signature:(t_pb *pb)
free_pb	util/vpr_utils.h	/^void free_pb(t_pb *pb);$/;"	p	signature:(t_pb *pb)
free_pb_graph	../../libs/libarchfpga/src/arch_util.cpp	/^static void free_pb_graph(t_pb_graph_node *pb_graph_node) {$/;"	f	file:	signature:(t_pb_graph_node *pb_graph_node)
free_pb_graph	../../libs/libarchfpga/src/arch_util.cpp	/^static void free_pb_graph(t_pb_graph_node *pb_graph_node);$/;"	p	file:	signature:(t_pb_graph_node *pb_graph_node)
free_pb_graph_edges	pack/pb_type_graph.cpp	/^void free_pb_graph_edges() {$/;"	f	signature:()
free_pb_graph_edges	pack/pb_type_graph.h	/^void free_pb_graph_edges();$/;"	p	signature:()
free_pb_graph_pin_lookup_from_index	util/vpr_utils.cpp	/^void free_pb_graph_pin_lookup_from_index(t_pb_graph_pin** pb_graph_pin_lookup_from_type) {$/;"	f	signature:(t_pb_graph_pin** pb_graph_pin_lookup_from_type)
free_pb_graph_pin_lookup_from_index	util/vpr_utils.h	/^void free_pb_graph_pin_lookup_from_index(t_pb_graph_pin** pb_graph_pin_lookup_from_type);$/;"	p	signature:(t_pb_graph_pin** pb_graph_pin_lookup_from_type)
free_pb_route	pack/cluster_router.cpp	/^void free_pb_route(t_pb_route *pb_route) {$/;"	f	signature:(t_pb_route *pb_route)
free_pb_route	pack/cluster_router.h	/^void free_pb_route(t_pb_route *free_pb_route);$/;"	p	signature:(t_pb_route *free_pb_route)
free_pb_stats	util/vpr_utils.cpp	/^void free_pb_stats(t_pb *pb) {$/;"	f	signature:(t_pb *pb)
free_pb_stats	util/vpr_utils.h	/^void free_pb_stats(t_pb *pb);$/;"	p	signature:(t_pb *pb)
free_pb_stats_recursive	pack/cluster.cpp	/^static void free_pb_stats_recursive(t_pb *pb) {$/;"	f	file:	signature:(t_pb *pb)
free_pb_stats_recursive	pack/cluster.cpp	/^static void free_pb_stats_recursive(t_pb *pb);$/;"	p	file:	signature:(t_pb *pb)
free_pb_type	../../libs/libarchfpga/src/arch_util.cpp	/^static void free_pb_type(t_pb_type *pb_type) {$/;"	f	file:	signature:(t_pb_type *pb_type)
free_pb_type	../../libs/libarchfpga/src/arch_util.cpp	/^static void free_pb_type(t_pb_type *pb_type);$/;"	p	file:	signature:(t_pb_type *pb_type)
free_pin_id_to_pb_mapping	util/vpr_utils.cpp	/^void free_pin_id_to_pb_mapping(vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping) {$/;"	f	signature:(vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
free_pin_id_to_pb_mapping	util/vpr_utils.h	/^void free_pin_id_to_pb_mapping(vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping);$/;"	p	signature:(vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
free_placement_macros_structs	place/place_macro.cpp	/^void free_placement_macros_structs() {$/;"	f	signature:()
free_placement_macros_structs	place/place_macro.h	/^void free_placement_macros_structs();$/;"	p	signature:()
free_placement_structs	place/place.cpp	/^static void free_placement_structs(t_placer_opts placer_opts) {$/;"	f	file:	signature:(t_placer_opts placer_opts)
free_placement_structs	place/place.cpp	/^static void free_placement_structs(t_placer_opts placer_opts);$/;"	p	file:	signature:(t_placer_opts placer_opts)
free_port_pin_from_blk_pin	util/vpr_utils.cpp	/^void free_port_pin_from_blk_pin() {$/;"	f	signature:()
free_port_pin_from_blk_pin	util/vpr_utils.h	/^void free_port_pin_from_blk_pin();$/;"	p	signature:()
free_rc_edge_free_list	timing/net_delay.cpp	/^static void free_rc_edge_free_list(t_linked_rc_edge * rc_edge_free_list) {$/;"	f	file:	signature:(t_linked_rc_edge * rc_edge_free_list)
free_rc_edge_free_list	timing/net_delay.cpp	/^static void free_rc_edge_free_list(t_linked_rc_edge * rc_edge_free_list);$/;"	p	file:	signature:(t_linked_rc_edge * rc_edge_free_list)
free_rc_node	timing/net_delay.cpp	/^static void free_rc_node(t_rc_node * rc_node,$/;"	f	file:	signature:(t_rc_node * rc_node, t_rc_node ** rc_node_free_list_ptr)
free_rc_node	timing/net_delay.cpp	/^static void free_rc_node(t_rc_node * rc_node,$/;"	p	file:	signature:(t_rc_node * rc_node, t_rc_node ** rc_node_free_list_ptr)
free_rc_node_free_list	timing/net_delay.cpp	/^static void free_rc_node_free_list(t_rc_node * rc_node_free_list) {$/;"	f	file:	signature:(t_rc_node * rc_node_free_list)
free_rc_node_free_list	timing/net_delay.cpp	/^static void free_rc_node_free_list(t_rc_node * rc_node_free_list);$/;"	p	file:	signature:(t_rc_node * rc_node_free_list)
free_rc_tree	timing/net_delay.cpp	/^static void free_rc_tree(t_rc_node * rc_root,$/;"	f	file:	signature:(t_rc_node * rc_root, t_rc_node ** rc_node_free_list_ptr, t_linked_rc_edge ** rc_edge_free_list_ptr)
free_rc_tree	timing/net_delay.cpp	/^static void free_rc_tree(t_rc_node * rc_root,$/;"	p	file:	signature:(t_rc_node * rc_root, t_rc_node ** rc_node_free_list_ptr, t_linked_rc_edge ** rc_edge_free_list_ptr)
free_route_structs	route/route_common.cpp	/^void free_route_structs() {$/;"	f	signature:()
free_route_structs	route/route_export.h	/^void free_route_structs();$/;"	p	signature:()
free_route_tree	route/route_tree_timing.cpp	/^void free_route_tree(t_rt_node * rt_node) {$/;"	f	signature:(t_rt_node * rt_node)
free_route_tree	route/route_tree_timing.h	/^void free_route_tree(t_rt_node * rt_node);$/;"	p	signature:(t_rt_node * rt_node)
free_route_tree_timing_structs	route/route_tree_timing.cpp	/^void free_route_tree_timing_structs() {$/;"	f	signature:()
free_route_tree_timing_structs	route/route_tree_timing.h	/^void free_route_tree_timing_structs();$/;"	p	signature:()
free_router_data	pack/cluster_router.cpp	/^void free_router_data(t_lb_router_data *router_data) {$/;"	f	signature:(t_lb_router_data *router_data)
free_router_data	pack/cluster_router.h	/^void free_router_data(t_lb_router_data *router_data);$/;"	p	signature:(t_lb_router_data *router_data)
free_routing_structs	route/router_delay_profiling.cpp	/^void free_routing_structs() {$/;"	f	signature:()
free_routing_structs	route/router_delay_profiling.h	/^void free_routing_structs();$/;"	p	signature:()
free_rr_graph	route/rr_graph.cpp	/^void free_rr_graph() {$/;"	f	signature:()
free_rr_graph	route/rr_graph.h	/^void free_rr_graph();$/;"	p	signature:()
free_rt_node	route/route_tree_timing.cpp	/^static void free_rt_node(t_rt_node * rt_node) {$/;"	f	file:	signature:(t_rt_node * rt_node)
free_rt_node	route/route_tree_timing.cpp	/^static void free_rt_node(t_rt_node * rt_node);$/;"	p	file:	signature:(t_rt_node * rt_node)
free_saved_routing	route/route_common.cpp	/^void free_saved_routing(vtr::vector<ClusterNetId, t_trace *> &best_routing) {$/;"	f	signature:(vtr::vector<ClusterNetId, t_trace *> &best_routing)
free_saved_routing	route/route_export.h	/^void free_saved_routing(vtr::vector<ClusterNetId, t_trace *> &best_routing);$/;"	p	signature:(vtr::vector<ClusterNetId, t_trace *> &best_routing)
free_sdc_related_structs	timing/read_sdc.cpp	/^void free_sdc_related_structs() {$/;"	f	signature:()
free_sdc_related_structs	timing/read_sdc.h	/^void free_sdc_related_structs();$/;"	p	signature:()
free_switchblock_permutations	route/build_switchblocks.cpp	/^void free_switchblock_permutations(t_sb_connection_map *sb_conns){$/;"	f	signature:(t_sb_connection_map *sb_conns)
free_switchblock_permutations	route/build_switchblocks.h	/^void free_switchblock_permutations(t_sb_connection_map *sb_conns);$/;"	p	signature:(t_sb_connection_map *sb_conns)
free_timing_driven_route_structs	route/route_timing.cpp	/^void free_timing_driven_route_structs(float *pin_criticality, int *sink_order,$/;"	f	signature:(float *pin_criticality, int *sink_order, t_rt_node ** rt_node_of_sink)
free_timing_driven_route_structs	route/route_timing.h	/^void free_timing_driven_route_structs(float *pin_criticality, int *sink_order,$/;"	p	signature:(float *pin_criticality, int *sink_order, t_rt_node ** rt_node_of_sink)
free_timing_graph	timing/path_delay.cpp	/^void free_timing_graph(t_slack * slacks) {$/;"	f	signature:(t_slack * slacks)
free_timing_graph	timing/path_delay.h	/^void free_timing_graph(t_slack * slacks);$/;"	p	signature:(t_slack * slacks)
free_timing_stats	timing/path_delay.cpp	/^void free_timing_stats() {$/;"	f	signature:()
free_timing_stats	timing/path_delay.h	/^void free_timing_stats();$/;"	p	signature:()
free_tnode_lookup_from_pin_id	timing/path_delay.cpp	/^void free_tnode_lookup_from_pin_id(vtr::vector<ClusterBlockId, std::vector<int>> &tnode_lookup) {$/;"	f	signature:(vtr::vector<ClusterBlockId, std::vector<int>> &tnode_lookup)
free_tnode_lookup_from_pin_id	timing/path_delay.h	/^void free_tnode_lookup_from_pin_id(vtr::vector<ClusterBlockId, std::vector<int>> &tnode_lookup);$/;"	p	signature:(vtr::vector<ClusterBlockId, std::vector<int>> &tnode_lookup)
free_trace_data	route/route_common.cpp	/^void free_trace_data(t_trace *tptr) {$/;"	f	signature:(t_trace *tptr)
free_trace_data	route/route_common.h	/^void free_trace_data(t_trace* trace);$/;"	p	signature:(t_trace* trace)
free_trace_structs	route/route_common.cpp	/^void free_trace_structs() {$/;"	f	signature:()
free_trace_structs	route/route_common.h	/^void free_trace_structs();$/;"	p	signature:()
free_traceback	route/route_common.cpp	/^void free_traceback(ClusterNetId net_id) {$/;"	f	signature:(ClusterNetId net_id)
free_traceback	route/route_common.cpp	/^void free_traceback(t_trace* tptr) {$/;"	f	signature:(t_trace* tptr)
free_traceback	route/route_common.h	/^void free_traceback(ClusterNetId net_id);$/;"	p	signature:(ClusterNetId net_id)
free_traceback	route/route_common.h	/^void free_traceback(t_trace* tptr);$/;"	p	signature:(t_trace* tptr)
free_try_swap_arrays	place/place.cpp	/^static void free_try_swap_arrays() {$/;"	f	file:	signature:()
free_try_swap_arrays	place/place.cpp	/^static void free_try_swap_arrays();$/;"	p	file:	signature:()
free_type_descriptors	../../libs/libarchfpga/src/arch_util.cpp	/^void free_type_descriptors(t_type_descriptor* type_descriptors, int num_type_descriptors) {$/;"	f	signature:(t_type_descriptor* type_descriptors, int num_type_descriptors)
free_type_descriptors	../../libs/libarchfpga/src/arch_util.h	/^void free_type_descriptors(t_type_descriptor* type_descriptors, int num_type_descriptors);$/;"	p	signature:(t_type_descriptor* type_descriptors, int num_type_descriptors)
free_type_track_to_pin_map	route/rr_graph.cpp	/^static void free_type_track_to_pin_map($/;"	p	file:	signature:( t_track_to_pin_lookup& track_to_pin_map, t_type_ptr types, int max_chan_width)
free_type_track_to_pin_map	route/rr_graph.cpp	/^static void free_type_track_to_pin_map(t_track_to_pin_lookup& track_to_pin_map,$/;"	f	file:	signature:(t_track_to_pin_lookup& track_to_pin_map, t_type_ptr types, int max_chan_width)
freed_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t freed_size;$/;"	m	struct:xml_memory_page	file:	access:public
frequency	../../libs/libarchfpga/src/physical_types.h	/^	int frequency;$/;"	m	struct:t_segment_inf	access:public
from_block	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_block *from_block;$/;"	m	struct:t_pack_pattern_connections	access:public
from_class	place/place_delay_model.h	/^            int from_class;$/;"	m	struct:OverrideDelayModel::t_override	access:public
from_clb_pin_end_index	route/rr_graph.cpp	/^    int from_clb_pin_end_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
from_clb_pin_start_index	route/rr_graph.cpp	/^    int from_clb_pin_start_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
from_clb_type	route/rr_graph.cpp	/^    t_type_descriptor *from_clb_type;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
from_const	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_string from_const(const char_t* str)$/;"	f	class:xpath_string	access:public	signature:(const char_t* str)
from_edge	route/route_common.h	/^    short from_edge = NO_PREVIOUS; \/\/The edge used to connect from 'from_node' to 'to_node'$/;"	m	struct:t_heap_prev	access:public
from_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_string from_heap(const char_t* begin, const char_t* end, xpath_allocator* alloc)$/;"	f	class:xpath_string	access:public	signature:(const char_t* begin, const char_t* end, xpath_allocator* alloc)
from_heap_preallocated	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_string from_heap_preallocated(const char_t* begin, const char_t* end)$/;"	f	class:xpath_string	access:public	signature:(const char_t* begin, const char_t* end)
from_node	route/check_route.cpp	/^    int from_node;$/;"	m	struct:t_node_edge	file:	access:public
from_node	route/route_common.h	/^    int from_node = NO_PREVIOUS; \/\/The previous node used to connect to 'to_node'$/;"	m	struct:t_heap_prev	access:public
from_node	route/rr_graph2.h	/^    int from_node = OPEN;$/;"	m	struct:t_rr_edge_info	access:public
from_pin	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_pin *from_pin;$/;"	m	struct:t_pack_pattern_connections	access:public
from_pin	../../libs/libarchfpga/src/physical_types.h	/^	char *from_pin;$/;"	m	struct:t_direct_inf	access:public
from_side	../../libs/libarchfpga/src/physical_types.h	/^	enum e_side from_side = TOP;$/;"	m	class:SB_Side_Connection	typeref:enum:SB_Side_Connection::e_side	access:public
from_side	../../libs/libarchfpga/src/physical_types.h	/^    e_side from_side;$/;"	m	struct:t_direct_inf	access:public
from_side	route/build_switchblocks.h	/^	e_side from_side;	\/* source side of switchblock connection *\/$/;"	m	class:Switchblock_Lookup	access:public
from_str	base/read_options.cpp	/^    ConvertedValue<PlaceDelayModelType> from_str(std::string str) {$/;"	f	struct:ParsePlaceDelayModel	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<bool> from_str(std::string str) {$/;"	f	struct:ParseOnOff	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_base_cost_type> from_str(std::string str) {$/;"	f	struct:ParseBaseCost	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_circuit_format> from_str(std::string str) {$/;"	f	struct:ParseCircuitFormat	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_clock_modeling> from_str(std::string str) {$/;"	f	struct:ParseClockModeling	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_cluster_seed> from_str(std::string str) {$/;"	f	struct:ParseClusterSeed	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_const_gen_inference> from_str(std::string str) {$/;"	f	struct:ParseConstGenInference	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_constant_net_method> from_str(std::string str) {$/;"	f	struct:ParseConstantNetMethod	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_incr_reroute_delay_ripup> from_str(std::string str) {$/;"	f	struct:ParseIncrRerouteDelayRipup	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_place_algorithm> from_str(std::string str) {$/;"	f	struct:ParsePlaceAlgorithm	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_reducer> from_str(std::string str) {$/;"	f	struct:ParseReducer	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_route_bb_update> from_str(std::string str) {$/;"	f	struct:ParseRouteBBUpdate	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_route_type> from_str(std::string str) {$/;"	f	struct:ParseRouteType	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_router_algorithm> from_str(std::string str) {$/;"	f	struct:ParseRouterAlgorithm	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_router_lookahead> from_str(std::string str) {$/;"	f	struct:ParseRouterLookahead	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_routing_budgets_algorithm> from_str(std::string str) {$/;"	f	struct:RouteBudgetsAlgorithm	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_routing_failure_predictor> from_str(std::string str) {$/;"	f	struct:ParseRoutePredictor	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_timing_report_detail> from_str(std::string str) {$/;"	f	struct:ParseTimingReportDetail	access:public	signature:(std::string str)
from_str	base/read_options.cpp	/^    ConvertedValue<e_unrelated_clustering> from_str(std::string str) {$/;"	f	struct:ParseUnrelatedClustering	access:public	signature:(std::string str)
from_switchpoint_order	../../libs/libarchfpga/src/physical_types.h	/^    SwitchPointOrder from_switchpoint_order = SwitchPointOrder::FIXED; \/\/The desired from_switchpoint_set ordering$/;"	m	struct:t_wireconn_inf	access:public
from_switchpoint_set	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_wire_switchpoints> from_switchpoint_set; \/\/The set of segment\/wirepoints representing the 'from' set (union of all t_wire_switchpoints in vector)$/;"	m	struct:t_wireconn_inf	access:public
from_type	place/place_delay_model.h	/^            int from_type;$/;"	m	struct:OverrideDelayModel::t_override	access:public
from_wire	route/build_switchblocks.h	/^	short from_wire;$/;"	m	struct:t_switchblock_edge	access:public
fs	base/place_and_route.h	/^	int fs; \/* at this fs *\/$/;"	m	struct:t_fmap_cell	access:public
full_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t full_size; \/\/ 0 if string occupies whole page$/;"	m	struct:xml_memory_string_header	file:	access:public
full_stats	base/read_options.h	/^    argparse::ArgValue<bool> full_stats;$/;"	m	struct:t_options	access:public
full_stats	base/vpr_types.h	/^	bool full_stats;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
g	../../libs/libvtrutil/src/vtr_color_map.h	/^    T g;$/;"	m	struct:vtr::Color	access:public
g_vpr_ctx	base/globals.cpp	/^VprContext g_vpr_ctx;$/;"	v
gain	pack/pack_types.h	/^	std::map<AtomBlockId, float> gain; \/* Attraction (inverse of cost) function *\/$/;"	m	struct:t_pb_stats	access:public
gap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		gap(): end(0), size(0)$/;"	f	struct:gap	access:public	signature:()
gap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct gap$/;"	s	file:
gap::end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* end;$/;"	m	struct:gap	file:	access:public
gap::flush	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* flush(char_t* s)$/;"	f	struct:gap	access:public	signature:(char_t* s)
gap::gap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		gap(): end(0), size(0)$/;"	f	struct:gap	access:public	signature:()
gap::push	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void push(char_t*& s, size_t count)$/;"	f	struct:gap	access:public	signature:(char_t*& s, size_t count)
gap::size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t size;$/;"	m	struct:gap	file:	access:public
gc_menus	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
gc_normal	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
gc_xor	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
gcd	../../libs/libvtrutil/src/vtr_math.h	/^    static T gcd(T x, T y){$/;"	f	namespace:vtr	signature:(T x, T y)
gen_nan	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double gen_nan()$/;"	f	signature:()
gen_netlist_as_blif	base/vpr_types.h	/^	bool gen_netlist_as_blif; \/* option to print out post-pack\/pre-place netlist as blif *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
gen_post_synthesis_netlist	base/vpr_types.h	/^    bool gen_post_synthesis_netlist;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
generate_hold_timing_stats	analysis/timing_reports.cpp	/^void generate_hold_timing_stats(const HoldTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& analysis_opts) {$/;"	f	signature:(const HoldTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& analysis_opts)
generate_hold_timing_stats	analysis/timing_reports.h	/^void generate_hold_timing_stats(const HoldTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& report_detail);$/;"	p	signature:(const HoldTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& report_detail)
generate_post_place_timing_reports	place/place.cpp	/^static void generate_post_place_timing_reports(const t_placer_opts& placer_opts,$/;"	f	file:	signature:(const t_placer_opts& placer_opts, const t_analysis_opts& analysis_opts, const SetupTimingInfo& timing_info, const PlacementDelayCalculator& delay_calc)
generate_post_place_timing_reports	place/place.cpp	/^static void generate_post_place_timing_reports(const t_placer_opts& placer_opts,$/;"	p	file:	signature:(const t_placer_opts& placer_opts, const t_analysis_opts& analysis_opts, const SetupTimingInfo& timing_info, const PlacementDelayCalculator& delay_calc)
generate_route_timing_reports	route/route_timing.cpp	/^static void generate_route_timing_reports(const t_router_opts& router_opts,$/;"	f	file:	signature:(const t_router_opts& router_opts, const t_analysis_opts& analysis_opts, const SetupTimingInfo& timing_info, const RoutingDelayCalculator& delay_calc)
generate_route_timing_reports	route/route_timing.cpp	/^static void generate_route_timing_reports(const t_router_opts& router_opts,$/;"	p	file:	signature:(const t_router_opts& router_opts, const t_analysis_opts& analysis_opts, const SetupTimingInfo& timing_info, const RoutingDelayCalculator& delay_calc)
generate_setup_timing_stats	analysis/timing_reports.cpp	/^void generate_setup_timing_stats(const SetupTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& analysis_opts) {$/;"	f	signature:(const SetupTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& analysis_opts)
generate_setup_timing_stats	analysis/timing_reports.h	/^void generate_setup_timing_stats(const SetupTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& report_detail);$/;"	p	signature:(const SetupTimingInfo& timing_info, const AnalysisDelayCalculator& delay_calc, const t_analysis_opts& report_detail)
generic_compute_matrix	place/timing_place_lookup.cpp	/^static void generic_compute_matrix(vtr::Matrix<std::vector<float>>& matrix, $/;"	p	file:	signature:(vtr::Matrix<std::vector<float>>& matrix, int source_x, int source_y, int start_x, int start_y, int end_x, int end_y, t_router_opts router_opts)
generic_compute_matrix	place/timing_place_lookup.cpp	/^static void generic_compute_matrix(vtr::Matrix<std::vector<float>>& matrix,$/;"	f	file:	signature:(vtr::Matrix<std::vector<float>>& matrix, int source_x, int source_y, int start_x, int start_y, int end_x, int end_y, t_router_opts router_opts)
geomean	../../libs/libvtrutil/src/vtr_math.h	/^    double geomean(Container c) {$/;"	f	namespace:vtr	signature:(Container c)
geomean	../../libs/libvtrutil/src/vtr_math.h	/^    double geomean(InputIterator first, InputIterator last, double init=1.) {$/;"	f	namespace:vtr	signature:(InputIterator first, InputIterator last, double init=1.)
get	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_text::get() const$/;"	f	class:pugi::xml_text	signature:() const
get	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_variable* xpath_variable_set::get(const char_t* name) const$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name) const
get	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* xpath_variable_set::get(const char_t* name)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name)
get	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* get() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
get	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_variable* get(const char_t* name) const;$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name) const
get	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* get(const char_t* name);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name)
getEchoEnabled	base/echo_files.cpp	/^bool getEchoEnabled() {$/;"	f	signature:()
getEchoEnabled	base/echo_files.h	/^bool getEchoEnabled();$/;"	p	signature:()
getEchoFileName	base/echo_files.cpp	/^char *getEchoFileName(enum e_echo_files echo_option) {$/;"	f	signature:(enum e_echo_files echo_option)
getEchoFileName	base/echo_files.h	/^char *getEchoFileName(enum e_echo_files echo_option);$/;"	p	signature:(enum e_echo_files echo_option)
getInstance	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state *t_win32_state::getInstance()$/;"	f	class:t_win32_state	signature:()
getInstance	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state *t_x11_state::getInstance()$/;"	f	class:t_x11_state	signature:()
getInstance	../../libs/libeasygl/src/graphics_state.h	/^    static t_win32_state *getInstance();$/;"	p	class:t_win32_state	access:public	signature:()
getInstance	../../libs/libeasygl/src/graphics_state.h	/^    static t_x11_state *getInstance();$/;"	p	class:t_x11_state	access:public	signature:()
getOutputFileName	base/echo_files.cpp	/^char *getOutputFileName(enum e_output_files ename) {$/;"	f	signature:(enum e_output_files ename)
getOutputFileName	base/echo_files.h	/^char *getOutputFileName(enum e_output_files ename);$/;"	p	signature:(enum e_output_files ename)
getSurface	../../libs/libeasygl/src/SurfaceImpl.cpp	/^cairo_surface_t* SurfaceImpl::getSurface() const {$/;"	f	class:SurfaceImpl	signature:() const
getSurface	../../libs/libeasygl/src/SurfaceImpl.h	/^        cairo_surface_t* getSurface() const;$/;"	p	class:SurfaceImpl	access:public	signature:() const
get_absolute_clb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_absolute_clb_bbox(const ClusterBlockId clb_index, const t_type_ptr type) {$/;"	f	class:t_draw_coords	signature:(const ClusterBlockId clb_index, const t_type_ptr type)
get_absolute_clb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_absolute_clb_bbox(int grid_x, int grid_y, int sub_block_index) {$/;"	f	class:t_draw_coords	signature:(int grid_x, int grid_y, int sub_block_index)
get_absolute_clb_bbox	draw/draw_types.h	/^	t_bound_box get_absolute_clb_bbox(const ClusterBlockId clb_index, const t_type_ptr type);$/;"	p	struct:t_draw_coords	access:public	signature:(const ClusterBlockId clb_index, const t_type_ptr type)
get_absolute_clb_bbox	draw/draw_types.h	/^	t_bound_box get_absolute_clb_bbox(int grid_x, int grid_y, int sub_block_index);$/;"	p	struct:t_draw_coords	access:public	signature:(int grid_x, int grid_y, int sub_block_index)
get_absolute_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_absolute_pb_bbox(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode) {$/;"	f	class:t_draw_coords	signature:(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode)
get_absolute_pb_bbox	draw/draw_types.h	/^	t_bound_box get_absolute_pb_bbox(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode);$/;"	p	struct:t_draw_coords	access:public	signature:(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode)
get_all_clocks	timing/read_sdc2.cpp	/^        std::set<tatum::DomainId> get_all_clocks() {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:()
get_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename Object> inline xml_allocator& get_allocator(const Object* object)$/;"	f	signature:(const Object* object)
get_arch_file_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^const char* get_arch_file_name() {$/;"	f	signature:()
get_arch_file_name	../../libs/libarchfpga/src/read_xml_arch_file.h	/^const char* get_arch_file_name();$/;"	p	signature:()
get_arch_switch_info	pack/pack.cpp	/^float get_arch_switch_info(short switch_index, int switch_fanin, float &Tdel_switch, float &R_switch, float &Cout_switch){$/;"	f	signature:(short switch_index, int switch_fanin, float &Tdel_switch, float &R_switch, float &Cout_switch)
get_arch_switch_info	pack/pack.h	/^float get_arch_switch_info(short switch_index, int switch_fanin, float &Tdel_switch, float &R_switch, float &Cout_switch);$/;"	p	signature:(short switch_index, int switch_fanin, float &Tdel_switch, float &R_switch, float &Cout_switch)
get_array_size_of_molecule	pack/cluster_placement.cpp	/^int get_array_size_of_molecule(const t_pack_molecule *molecule) {$/;"	f	signature:(const t_pack_molecule *molecule)
get_array_size_of_molecule	pack/cluster_placement.h	/^int get_array_size_of_molecule(const t_pack_molecule *molecule);$/;"	p	signature:(const t_pack_molecule *molecule)
get_attribute	../../libs/libpugiutil/src/pugixml_util.cpp	/^    pugi::xml_attribute get_attribute(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& attr_name, const loc_data& loc_data, const ReqOpt req_opt)
get_attribute	../../libs/libpugiutil/src/pugixml_util.hpp	/^    pugi::xml_attribute get_attribute(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& attr_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
get_average_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_average_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
get_average_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_average_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
get_bb_from_scratch	place/place.cpp	/^static void get_bb_from_scratch(ClusterNetId net_id, t_bb *coords,$/;"	f	file:	signature:(ClusterNetId net_id, t_bb *coords, t_bb *num_on_edges)
get_bb_from_scratch	place/place.cpp	/^static void get_bb_from_scratch(ClusterNetId net_id, t_bb *coords,$/;"	p	file:	signature:(ClusterNetId net_id, t_bb *coords, t_bb *num_on_edges)
get_best_class	place/timing_place_lookup.cpp	/^static int get_best_class(enum e_pin_type pintype, t_type_ptr type) {$/;"	f	file:	signature:(enum e_pin_type pintype, t_type_ptr type)
get_best_class	place/timing_place_lookup.cpp	/^static int get_best_class(enum e_pin_type pintype, t_type_ptr type);$/;"	p	file:	signature:(enum e_pin_type pintype, t_type_ptr type)
get_bidir_opin_connections	route/rr_graph2.cpp	/^int get_bidir_opin_connections($/;"	f	signature:( const int i, const int j, const int ipin, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_pin_to_track_lookup& opin_to_track_map, const t_rr_node_indices& L_rr_node_indices, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y)
get_bidir_opin_connections	route/rr_graph2.h	/^int get_bidir_opin_connections($/;"	p	signature:( const int i, const int j, const int ipin, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_pin_to_track_lookup& opin_to_track_map, const t_rr_node_indices& L_rr_node_indices, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y)
get_bidir_track_to_chan_seg	route/rr_graph2.cpp	/^static int get_bidir_track_to_chan_seg($/;"	f	file:	signature:( const std::vector<int> conn_tracks, const t_rr_node_indices& L_rr_node_indices, const int to_chan, const int to_seg, const int to_sb, const t_rr_type to_type, const t_chan_seg_details * seg_details, const bool from_is_sblock, const int from_switch, const int switch_override, const enum e_directionality directionality, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create)
get_bidir_track_to_chan_seg	route/rr_graph2.cpp	/^static int get_bidir_track_to_chan_seg($/;"	p	file:	signature:( const std::vector<int> conn_tracks, const t_rr_node_indices& L_rr_node_indices, const int to_chan, const int to_seg, const int to_sb, const t_rr_type to_type, const t_chan_seg_details * seg_details, const bool from_is_sblock, const int from_switch, const int switch_override, const enum e_directionality directionality, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create)
get_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bit_value_t get_bit(size_t address)$/;"	f	class:BitSpace::BitFields	access:public	signature:(size_t address)
get_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bit_value_t get_bit(size_t address)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t address)
get_bit_from_lsb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::bit_value_t get_bit_from_lsb(size_t index)$/;"	f	class:VNumber	access:public	signature:(size_t index)
get_bit_from_msb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::bit_value_t get_bit_from_msb(size_t index)$/;"	f	class:VNumber	access:public	signature:(size_t index)
get_bit_location	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t get_bit_location(size_t address)$/;"	f	class:BitSpace::BitFields	access:private	signature:(size_t address)
get_bitfield	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        BitFields<veri_internal_bits_t> *get_bitfield(size_t index)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t index)
get_blk_pin_from_port_pin	util/vpr_utils.cpp	/^void get_blk_pin_from_port_pin(int blk_type_index, int port,int port_pin,$/;"	f	signature:(int blk_type_index, int port,int port_pin, int * blk_pin)
get_blk_pin_from_port_pin	util/vpr_utils.h	/^void get_blk_pin_from_port_pin(int blk_type_index, int port,int port_pin,$/;"	p	signature:(int blk_type_index, int port,int port_pin, int * blk_pin)
get_block_type_color	draw/draw.cpp	/^t_color get_block_type_color(t_type_ptr type) {$/;"	f	signature:(t_type_ptr type)
get_block_type_color	draw/draw.cpp	/^t_color get_block_type_color(t_type_ptr type);$/;"	p	file:	signature:(t_type_ptr type)
get_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::get_boolean() const$/;"	f	class:pugi::xpath_variable	signature:() const
get_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool get_boolean() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
get_buffer_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_encoding get_buffer_encoding(xml_encoding encoding, const void* contents, size_t size)$/;"	f	signature:(xml_encoding encoding, const void* contents, size_t size)
get_cached_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_cached_delay(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_cached_delay(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_cached_hold_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_cached_hold_time(tatum::EdgeId edge) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge) const
get_cached_hold_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_cached_hold_time(tatum::EdgeId edge) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge) const
get_cached_pins	timing/PostClusterDelayCalculator.h	/^    std::pair<ClusterPinId,ClusterPinId> get_cached_pins(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_cached_pins	timing/PostClusterDelayCalculator.tpp	/^inline std::pair<ClusterPinId,ClusterPinId> PostClusterDelayCalculator::get_cached_pins(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_cached_setup_time	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_cached_setup_time(tatum::EdgeId edge) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge) const
get_cached_setup_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_cached_setup_time(tatum::EdgeId edge) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge) const
get_cblock_trans	route/rr_graph_area.cpp	/^static float get_cblock_trans(int *num_inputs_to_cblock, int wire_to_ipin_switch,$/;"	f	file:	signature:(int *num_inputs_to_cblock, int wire_to_ipin_switch, int max_inputs_to_cblock, float trans_sram_bit)
get_cblock_trans	route/rr_graph_area.cpp	/^static float get_cblock_trans(int *num_inputs_to_cblock, int wire_to_ipin_switch,$/;"	p	file:	signature:(int *num_inputs_to_cblock, int wire_to_ipin_switch, int max_inputs_to_cblock, float trans_sram_bit)
get_center	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_bound_box::get_center() const {$/;"	f	class:t_bound_box	signature:() const
get_center	../../libs/libeasygl/src/graphics_types.h	/^    t_point get_center() const;$/;"	p	class:t_bound_box	access:public	signature:() const
get_channel_occupancy_stats	base/stats.cpp	/^static void get_channel_occupancy_stats() {$/;"	f	file:	signature:()
get_channel_occupancy_stats	base/stats.cpp	/^static void get_channel_occupancy_stats();$/;"	p	file:	signature:()
get_class_range_for_block	util/vpr_utils.cpp	/^void get_class_range_for_block(const ClusterBlockId blk_id,$/;"	f	signature:(const ClusterBlockId blk_id, int *class_low, int *class_high)
get_class_range_for_block	util/vpr_utils.h	/^void get_class_range_for_block(const ClusterBlockId blk_id, int *class_low,$/;"	p	signature:(const ClusterBlockId blk_id, int *class_low, int *class_high)
get_clock_pins_indices	../../libs/libarchfpga/src/physical_types.cpp	/^std::vector<int> t_type_descriptor::get_clock_pins_indices () {$/;"	f	class:t_type_descriptor	signature:()
get_clock_pins_indices	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> get_clock_pins_indices();$/;"	p	struct:t_type_descriptor	access:public	signature:()
get_clocks	timing/read_sdc2.cpp	/^        std::set<tatum::DomainId> get_clocks(const sdcparse::StringGroup& clock_group) {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(const sdcparse::StringGroup& clock_group)
get_cluster_of_block	pack/cluster.h	/^int get_cluster_of_block(int blkidx);$/;"	p	signature:(int blkidx)
get_conn_block_metrics	route/cb_metrics.cpp	/^void get_conn_block_metrics(const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf,$/;"	f	signature:(const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf, const e_pin_type pin_type, const int *Fc_array, const t_chan_width *chan_width_inf, Conn_Block_Metrics *cb_metrics)
get_conn_block_metrics	route/cb_metrics.h	/^void get_conn_block_metrics(const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf,$/;"	p	signature:(const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf, const e_pin_type pin_type, const int *Fc_array, const t_chan_width *chan_width_inf, Conn_Block_Metrics *cb_metrics)
get_containing_block	draw/intra_logic_block.cpp	/^ClusterBlockId t_selected_sub_block_info::get_containing_block() const { return containing_block_index; }$/;"	f	class:t_selected_sub_block_info	signature:() const
get_containing_block	draw/intra_logic_block.h	/^	ClusterBlockId get_containing_block() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
get_cost_of_pb_edge	pack/lb_type_rr_graph.cpp	/^static float get_cost_of_pb_edge(t_pb_graph_edge *edge);$/;"	p	file:	signature:(t_pb_graph_edge *edge)
get_cost_of_pb_edge	pack/lb_type_rr_graph.cpp	/^static float get_cost_of_pb_edge(t_pb_graph_edge* \/*edge*\/) {$/;"	f	file:	signature:(t_pb_graph_edge* )
get_crit_short_path	route/route_budgets.cpp	/^float route_budgets::get_crit_short_path(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
get_crit_short_path	route/route_budgets.h	/^    float get_crit_short_path(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
get_critical_path_delay	timing/path_delay.cpp	/^float get_critical_path_delay() {$/;"	f	signature:()
get_critical_path_delay	timing/path_delay.h	/^float get_critical_path_delay();$/;"	p	signature:()
get_current_inet	route/connection_based_routing.h	/^	ClusterNetId get_current_inet() const {return current_inet;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:() const
get_delay_normalization_fac	route/rr_graph_indexed_data.cpp	/^static float get_delay_normalization_fac(int nodes_per_chan,$/;"	f	file:	signature:(int nodes_per_chan, const t_rr_node_indices& L_rr_node_indices)
get_delay_normalization_fac	route/rr_graph_indexed_data.cpp	/^static float get_delay_normalization_fac(int nodes_per_chan,$/;"	p	file:	signature:(int nodes_per_chan, const t_rr_node_indices& L_rr_node_indices)
get_delay_ps	base/netlist_writer.cpp	/^        double get_delay_ps(tatum::NodeId source_tnode, tatum::NodeId sink_tnode) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(tatum::NodeId source_tnode, tatum::NodeId sink_tnode)
get_delay_ps	base/netlist_writer.cpp	/^double get_delay_ps(double delay_sec) {$/;"	f	signature:(double delay_sec)
get_delay_ps	base/netlist_writer.cpp	/^double get_delay_ps(double delay_sec);$/;"	p	file:	signature:(double delay_sec)
get_delay_target	route/route_budgets.cpp	/^float route_budgets::get_delay_target(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
get_delay_target	route/route_budgets.h	/^    float get_delay_target(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
get_document	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename Object> inline xml_document_struct& get_document(const Object* object)$/;"	f	signature:(const Object* object)
get_draw_coords_vars	draw/draw_global.cpp	/^t_draw_coords *get_draw_coords_vars() {$/;"	f	signature:()
get_draw_coords_vars	draw/draw_global.h	/^t_draw_coords *get_draw_coords_vars();$/;"	p	signature:()
get_draw_state_vars	draw/draw_global.cpp	/^t_draw_state *get_draw_state_vars() {$/;"	f	signature:()
get_draw_state_vars	draw/draw_global.h	/^t_draw_state *get_draw_state_vars();$/;"	p	signature:()
get_driver_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_driver_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_edge_from_nets	route/route_budgets.h	/^    tatum::EdgeId get_edge_from_nets(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, int ipin)
get_entry	power/PowerSpicedComponent.cpp	/^PowerCallibInputs * PowerSpicedComponent::get_entry(int num_inputs) {$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs)
get_entry	power/PowerSpicedComponent.h	/^	PowerCallibInputs* get_entry(int num_inputs);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs)
get_entry_bound	power/PowerSpicedComponent.cpp	/^PowerCallibInputs * PowerSpicedComponent::get_entry_bound(bool lower,$/;"	f	class:PowerSpicedComponent	signature:(bool lower, int num_inputs)
get_entry_bound	power/PowerSpicedComponent.cpp	/^PowerCallibSize * PowerCallibInputs::get_entry_bound(bool lower,$/;"	f	class:PowerCallibInputs	signature:(bool lower, float transistor_size)
get_entry_bound	power/PowerSpicedComponent.h	/^	PowerCallibInputs * get_entry_bound(bool lower, int num_inputs);$/;"	p	class:PowerSpicedComponent	access:public	signature:(bool lower, int num_inputs)
get_entry_bound	power/PowerSpicedComponent.h	/^	PowerCallibSize * get_entry_bound(bool lower, float transistor_size);$/;"	p	class:PowerCallibInputs	access:public	signature:(bool lower, float transistor_size)
get_escape_char	timing/slre.cpp	/^static int get_escape_char(const char **re) {$/;"	f	file:	signature:(const char **re)
get_expected_cost	route/router_lookahead.cpp	/^float ClassicLookahead::get_expected_cost(int current_node, int target_node, const t_conn_cost_params& params, float R_upstream) const {$/;"	f	class:ClassicLookahead	signature:(int current_node, int target_node, const t_conn_cost_params& params, float R_upstream) const
get_expected_cost	route/router_lookahead.cpp	/^float MapLookahead::get_expected_cost(int current_node, int target_node, const t_conn_cost_params& params, float \/*R_upstream*\/) const {$/;"	f	class:MapLookahead	signature:(int current_node, int target_node, const t_conn_cost_params& params, float ) const
get_expected_cost	route/router_lookahead.cpp	/^float NoOpLookahead::get_expected_cost(int \/*current_node*\/, int \/*target_node*\/, const t_conn_cost_params& \/*params*\/, float \/*R_upstream*\/) const {$/;"	f	class:NoOpLookahead	signature:(int , int , const t_conn_cost_params& , float ) const
get_expected_cost	route/router_lookahead.h	/^        virtual float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const = 0;$/;"	p	class:RouterLookahead	access:public	signature:(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const
get_expected_lowest_cost_primitive_for_atom_block	pack/prepack.cpp	/^static t_pb_graph_node* get_expected_lowest_cost_primitive_for_atom_block(const AtomBlockId blk_id) {$/;"	f	file:	signature:(const AtomBlockId blk_id)
get_expected_lowest_cost_primitive_for_atom_block	pack/prepack.cpp	/^static t_pb_graph_node* get_expected_lowest_cost_primitive_for_atom_block(const AtomBlockId blk_id);$/;"	p	file:	signature:(const AtomBlockId blk_id)
get_expected_lowest_cost_primitive_for_atom_block_in_pb_graph_node	pack/prepack.cpp	/^static t_pb_graph_node *get_expected_lowest_cost_primitive_for_atom_block_in_pb_graph_node(const AtomBlockId blk_id, t_pb_graph_node *curr_pb_graph_node, float *cost) {$/;"	f	file:	signature:(const AtomBlockId blk_id, t_pb_graph_node *curr_pb_graph_node, float *cost)
get_expected_lowest_cost_primitive_for_atom_block_in_pb_graph_node	pack/prepack.cpp	/^static t_pb_graph_node* get_expected_lowest_cost_primitive_for_atom_block_in_pb_graph_node(const AtomBlockId blk_id, t_pb_graph_node *curr_pb_graph_node, float *cost);$/;"	p	file:	signature:(const AtomBlockId blk_id, t_pb_graph_node *curr_pb_graph_node, float *cost)
get_expected_segs_to_target	route/router_lookahead.cpp	/^static int get_expected_segs_to_target(int inode, int target_node, int *num_segs_ortho_dir_ptr);$/;"	p	file:	signature:(int inode, int target_node, int *num_segs_ortho_dir_ptr)
get_expected_segs_to_target	route/router_lookahead.cpp	/^static int get_expected_segs_to_target(int inode, int target_node,$/;"	f	file:	signature:(int inode, int target_node, int *num_segs_ortho_dir_ptr)
get_file_line_number_of_last_opened_file	../../libs/libvtrutil/src/vtr_util.cpp	/^int get_file_line_number_of_last_opened_file() {$/;"	f	namespace:vtr	signature:()
get_file_line_number_of_last_opened_file	../../libs/libvtrutil/src/vtr_util.h	/^    int get_file_line_number_of_last_opened_file();$/;"	p	namespace:vtr	signature:()
get_file_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_status get_file_size(FILE* file, size_t& out_result)$/;"	f	signature:(FILE* file, size_t& out_result)
get_first_child	../../libs/libpugiutil/src/pugixml_util.cpp	/^    pugi::xml_node get_first_child(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt)
get_first_child	../../libs/libpugiutil/src/pugixml_util.hpp	/^    pugi::xml_node get_first_child(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
get_fobj_precedence	../../libs/libarchfpga/src/expr_eval.cpp	/^static int get_fobj_precedence( const Formula_Object &fobj );$/;"	p	file:	signature:( const Formula_Object &fobj )
get_fobj_precedence	../../libs/libarchfpga/src/expr_eval.cpp	/^static int get_fobj_precedence( const Formula_Object &fobj ){$/;"	f	file:	signature:( const Formula_Object &fobj )
get_font_info	../../libs/libeasygl/src/fontcache.cpp	/^font_ptr FontCache::get_font_info($/;"	f	class:FontCache	signature:( size_t pointsize, int degrees, queue_type& orderqueue, map_type& descr2font_map, size_t max_size)
get_font_info	../../libs/libeasygl/src/fontcache.cpp	/^font_ptr FontCache::get_font_info(size_t pointsize, int degrees) {$/;"	f	class:FontCache	signature:(size_t pointsize, int degrees)
get_font_info	../../libs/libeasygl/src/fontcache.h	/^    font_ptr get_font_info(size_t pointsize, int degrees);$/;"	p	class:FontCache	access:public	signature:(size_t pointsize, int degrees)
get_font_info	../../libs/libeasygl/src/fontcache.h	/^    static font_ptr get_font_info($/;"	p	class:FontCache	access:private	signature:( size_t pointsize, int degrees, queue_type& orderqueue, map_type& descr2font_map, size_t max_size)
get_formula_object	../../libs/libarchfpga/src/expr_eval.cpp	/^static void get_formula_object( const char *ch, int &ichar, const t_formula_data &mydata,$/;"	f	file:	signature:( const char *ch, int &ichar, const t_formula_data &mydata, Formula_Object *fobj )
get_formula_object	../../libs/libarchfpga/src/expr_eval.cpp	/^static void get_formula_object( const char *ch, int &ichar, const t_formula_data &mydata,$/;"	p	file:	signature:( const char *ch, int &ichar, const t_formula_data &mydata, Formula_Object *fobj )
get_free_molecule_with_most_ext_inputs_for_cluster	pack/cluster.cpp	/^static t_pack_molecule *get_free_molecule_with_most_ext_inputs_for_cluster($/;"	f	file:	signature:( t_pb *cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr)
get_free_molecule_with_most_ext_inputs_for_cluster	pack/cluster.cpp	/^static t_pack_molecule* get_free_molecule_with_most_ext_inputs_for_cluster($/;"	p	file:	signature:( t_pb *cur_pb, t_cluster_placement_stats *cluster_placement_stats_ptr)
get_geomean_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_geomean_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
get_geomean_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_geomean_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
get_hamming_proximity	route/cb_metrics.cpp	/^static float get_hamming_proximity(const int Fc, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics);$/;"	p	file:	signature:(const int Fc, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics)
get_hamming_proximity	route/cb_metrics.cpp	/^static float get_hamming_proximity(const int Fc, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics){$/;"	f	file:	signature:(const int Fc, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics)
get_hash_bytes	../../libs/libvtrutil/src/picosha2.h	/^	void get_hash_bytes(OutIter first, OutIter last)const{$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:(OutIter first, OutIter last) const
get_hash_entry	util/hash.cpp	/^get_hash_entry(t_hash **hash_table, const char *name) {$/;"	f	signature:(t_hash **hash_table, const char *name)
get_hash_entry	util/hash.h	/^t_hash *get_hash_entry(t_hash **hash_table, const char *name);$/;"	p	signature:(t_hash **hash_table, const char *name)
get_hash_hex_string	../../libs/libvtrutil/src/picosha2.h	/^inline std::string get_hash_hex_string(const hash256_one_by_one& hasher){$/;"	f	namespace:picosha2	signature:(const hash256_one_by_one& hasher)
get_hash_hex_string	../../libs/libvtrutil/src/picosha2.h	/^inline void get_hash_hex_string(const hash256_one_by_one& hasher, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const hash256_one_by_one& hasher, std::string& hex_str)
get_hash_stats	util/hash.cpp	/^void get_hash_stats(t_hash **hash_table, char *hash_table_name){$/;"	f	signature:(t_hash **hash_table, char *hash_table_name)
get_hash_stats	util/hash.h	/^void get_hash_stats(t_hash **hash_table, char *hash_table_name);$/;"	p	signature:(t_hash **hash_table, char *hash_table_name)
get_heap_head	route/route_common.cpp	/^get_heap_head() {$/;"	f	signature:()
get_height	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_height() const {$/;"	f	class:t_bound_box	signature:() const
get_height	../../libs/libeasygl/src/graphics_types.h	/^    float get_height() const;$/;"	p	class:t_bound_box	access:public	signature:() const
get_highest_gain_molecule	pack/cluster.cpp	/^static t_pack_molecule *get_highest_gain_molecule($/;"	f	file:	signature:( t_pb *cur_pb, const std::multimap<AtomBlockId,t_pack_molecule*> &atom_molecules, const enum e_gain_type gain_mode, t_cluster_placement_stats *cluster_placement_stats_ptr, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets, const ClusterBlockId cluster_index)
get_highest_gain_molecule	pack/cluster.cpp	/^static t_pack_molecule* get_highest_gain_molecule($/;"	p	file:	signature:( t_pb *cur_pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const enum e_gain_type gain_mode, t_cluster_placement_stats *cluster_placement_stats_ptr, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets, const ClusterBlockId cluster_index)
get_highest_gain_seed_molecule	pack/cluster.cpp	/^static t_pack_molecule* get_highest_gain_seed_molecule(int* seedindex, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const std::vector<AtomBlockId> seed_atoms) {$/;"	f	file:	signature:(int* seedindex, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const std::vector<AtomBlockId> seed_atoms)
get_highest_gain_seed_molecule	pack/cluster.cpp	/^static t_pack_molecule* get_highest_gain_seed_molecule(int* seedindex, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const std::vector<AtomBlockId> seed_atoms);$/;"	p	file:	signature:(int* seedindex, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const std::vector<AtomBlockId> seed_atoms)
get_imacro_from_iblk	place/place_macro.cpp	/^void get_imacro_from_iblk(int *imacro, ClusterBlockId iblk, t_pl_macro *macros, int num_macros) {$/;"	f	signature:(int *imacro, ClusterBlockId iblk, t_pl_macro *macros, int num_macros)
get_imacro_from_iblk	place/place_macro.h	/^void get_imacro_from_iblk(int * imacro, ClusterBlockId iblk, t_pl_macro * macros, int num_macros);$/;"	p	signature:(int * imacro, ClusterBlockId iblk, t_pl_macro * macros, int num_macros)
get_intercluster_switch_fanin_estimates	base/vpr_api.cpp	/^static void get_intercluster_switch_fanin_estimates(const t_vpr_setup& vpr_setup, const t_arch& arch, const int wire_segment_length,$/;"	f	file:	signature:(const t_vpr_setup& vpr_setup, const t_arch& arch, const int wire_segment_length, int *opin_switch_fanin, int *wire_switch_fanin, int *ipin_switch_fanin)
get_intercluster_switch_fanin_estimates	base/vpr_api.cpp	/^static void get_intercluster_switch_fanin_estimates(const t_vpr_setup& vpr_setup, const t_arch& arch, const int wire_segment_length,$/;"	p	file:	signature:(const t_vpr_setup& vpr_setup, const t_arch& arch, const int wire_segment_length, int *opin_switch_fanin, int *wire_switch_fanin, int *ipin_switch_fanin)
get_keypress_input	../../libs/libeasygl/src/graphics_state.h	/^    bool get_keypress_input = false;$/;"	m	struct:t_gl_state	access:public
get_latin1_7bit_prefix_length	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)$/;"	f	signature:(const uint8_t* data, size_t size)
get_lb_type_rr_graph_ext_sink_index	pack/lb_type_rr_graph.cpp	/^int get_lb_type_rr_graph_ext_sink_index(t_type_ptr lb_type) {$/;"	f	signature:(t_type_ptr lb_type)
get_lb_type_rr_graph_ext_sink_index	pack/lb_type_rr_graph.h	/^int get_lb_type_rr_graph_ext_sink_index(t_type_ptr lb_type);$/;"	p	signature:(t_type_ptr lb_type)
get_lb_type_rr_graph_ext_source_index	pack/lb_type_rr_graph.cpp	/^int get_lb_type_rr_graph_ext_source_index(t_type_ptr lb_type) {$/;"	f	signature:(t_type_ptr lb_type)
get_lb_type_rr_graph_ext_source_index	pack/lb_type_rr_graph.h	/^int get_lb_type_rr_graph_ext_source_index(t_type_ptr lb_type);$/;"	p	signature:(t_type_ptr lb_type)
get_lemieux_cost_func	route/cb_metrics.cpp	/^static float get_lemieux_cost_func(const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics);$/;"	p	file:	signature:(const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics)
get_lemieux_cost_func	route/cb_metrics.cpp	/^static float get_lemieux_cost_func(const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics){$/;"	f	file:	signature:(const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics)
get_longest_segment_length	place/timing_place_lookup.cpp	/^static int get_longest_segment_length($/;"	f	file:	signature:( t_det_routing_arch det_routing_arch, t_segment_inf * segment_inf)
get_longest_segment_length	place/timing_place_lookup.cpp	/^static int get_longest_segment_length($/;"	p	file:	signature:( t_det_routing_arch det_routing_arch, t_segment_inf * segment_inf)
get_lookahead_map_cost	route/router_lookahead_map.cpp	/^float get_lookahead_map_cost(int from_node_ind, int to_node_ind, float criticality_fac){$/;"	f	signature:(int from_node_ind, int to_node_ind, float criticality_fac)
get_lookahead_map_cost	route/router_lookahead_map.h	/^float get_lookahead_map_cost(int from_node_ind, int to_node_ind, float criticality_fac);$/;"	p	signature:(int from_node_ind, int to_node_ind, float criticality_fac)
get_max_Fc	route/cb_metrics.cpp	/^int get_max_Fc(const int *Fc_array, const t_type_ptr block_type, const e_pin_type pin_type){$/;"	f	signature:(const int *Fc_array, const t_type_ptr block_type, const e_pin_type pin_type)
get_max_Fc	route/cb_metrics.cpp	/^static int get_max_Fc(const int *Fc_array, const t_type_ptr block_type, const e_pin_type pin_type);$/;"	p	file:	signature:(const int *Fc_array, const t_type_ptr block_type, const e_pin_type pin_type)
get_max_delay_budget	route/route_budgets.cpp	/^float route_budgets::get_max_delay_budget(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
get_max_delay_budget	route/route_budgets.h	/^    float get_max_delay_budget(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
get_max_depth_of_pb_graph_node	pack/cluster_feasibility_filter.cpp	/^static int get_max_depth_of_pb_graph_node(const t_pb_graph_node *pb_graph_node) {$/;"	f	file:	signature:(const t_pb_graph_node *pb_graph_node)
get_max_depth_of_pb_graph_node	pack/cluster_feasibility_filter.cpp	/^static int get_max_depth_of_pb_graph_node(const t_pb_graph_node *pb_graph_node);$/;"	p	file:	signature:(const t_pb_graph_node *pb_graph_node)
get_max_depth_of_pb_type	util/vpr_utils.cpp	/^int get_max_depth_of_pb_type(t_pb_type *pb_type) {$/;"	f	signature:(t_pb_type *pb_type)
get_max_depth_of_pb_type	util/vpr_utils.h	/^int get_max_depth_of_pb_type(t_pb_type *pb_type);$/;"	p	signature:(t_pb_type *pb_type)
get_max_lcm	route/build_switchblocks.cpp	/^static int get_max_lcm( vector<t_switchblock_inf> *switchblocks, t_wire_type_sizes *wire_type_sizes){$/;"	f	file:	signature:( vector<t_switchblock_inf> *switchblocks, t_wire_type_sizes *wire_type_sizes)
get_max_lcm	route/build_switchblocks.cpp	/^static int get_max_lcm(vector<t_switchblock_inf> *switchblocks, t_wire_type_sizes *wire_type_sizes);$/;"	p	file:	signature:(vector<t_switchblock_inf> *switchblocks, t_wire_type_sizes *wire_type_sizes)
get_max_nets_in_pb_type	util/vpr_utils.cpp	/^int get_max_nets_in_pb_type(const t_pb_type *pb_type) {$/;"	f	signature:(const t_pb_type *pb_type)
get_max_nets_in_pb_type	util/vpr_utils.h	/^int get_max_nets_in_pb_type(const t_pb_type *pb_type);$/;"	p	signature:(const t_pb_type *pb_type)
get_max_pins_per_net	route/route_timing.cpp	/^int get_max_pins_per_net() {$/;"	f	signature:()
get_max_pins_per_net	route/route_timing.h	/^int get_max_pins_per_net();$/;"	p	signature:()
get_max_primitives_in_pb_type	util/vpr_utils.cpp	/^int get_max_primitives_in_pb_type(t_pb_type *pb_type) {$/;"	f	signature:(t_pb_type *pb_type)
get_max_primitives_in_pb_type	util/vpr_utils.h	/^int get_max_primitives_in_pb_type(t_pb_type *pb_type);$/;"	p	signature:(t_pb_type *pb_type)
get_max_rss	../../libs/libvtrutil/src/vtr_rusage.cpp	/^size_t get_max_rss() {$/;"	f	namespace:vtr	signature:()
get_max_rss	../../libs/libvtrutil/src/vtr_rusage.h	/^    size_t get_max_rss();$/;"	p	namespace:vtr	signature:()
get_median_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_median_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
get_median_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_median_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
get_memory_allocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN allocation_function PUGIXML_FUNCTION get_memory_allocation_function()$/;"	f	namespace:pugi	signature:()
get_memory_allocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	allocation_function PUGIXML_FUNCTION get_memory_allocation_function();$/;"	p	namespace:pugi	signature:()
get_memory_deallocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function()$/;"	f	namespace:pugi	signature:()
get_memory_deallocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function();$/;"	p	namespace:pugi	signature:()
get_min_delay_budget	route/route_budgets.cpp	/^float route_budgets::get_min_delay_budget(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
get_min_delay_budget	route/route_budgets.h	/^    float get_min_delay_budget(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
get_mode	base/vpr_types.h	/^	t_mode* get_mode() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
get_molecule_by_num_ext_inputs	pack/cluster.cpp	/^static t_pack_molecule *get_molecule_by_num_ext_inputs($/;"	f	file:	signature:( const int ext_inps, const enum e_removal_policy remove_flag, t_cluster_placement_stats *cluster_placement_stats_ptr)
get_molecule_by_num_ext_inputs	pack/cluster.cpp	/^static t_pack_molecule *get_molecule_by_num_ext_inputs($/;"	p	file:	signature:( const int ext_inps, const enum e_removal_policy remove_flag, t_cluster_placement_stats *cluster_placement_stats_ptr)
get_molecule_for_cluster	pack/cluster.cpp	/^static t_pack_molecule *get_molecule_for_cluster($/;"	f	file:	signature:( t_pb *cur_pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const bool allow_unrelated_clustering, int *num_unrelated_clustering_attempts, t_cluster_placement_stats *cluster_placement_stats_ptr, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets, ClusterBlockId cluster_index, int verbosity)
get_molecule_for_cluster	pack/cluster.cpp	/^static t_pack_molecule* get_molecule_for_cluster($/;"	p	file:	signature:( t_pb *cur_pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const bool allow_unrelated_clustering, int *num_unrelated_clustering_attempts, t_cluster_placement_stats *cluster_placement_stats_ptr, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets, ClusterBlockId cluster_index, int verbosity)
get_molecule_gain	pack/cluster.cpp	/^static float get_molecule_gain(t_pack_molecule *molecule, map<AtomBlockId, float> &blk_gain) {$/;"	f	file:	signature:(t_pack_molecule *molecule, map<AtomBlockId, float> &blk_gain)
get_molecule_gain	pack/cluster.cpp	/^static float get_molecule_gain(t_pack_molecule *molecule, map<AtomBlockId, float> &blk_gain);$/;"	p	file:	signature:(t_pack_molecule *molecule, map<AtomBlockId, float> &blk_gain)
get_mouse_move_input	../../libs/libeasygl/src/graphics_state.h	/^    bool get_mouse_move_input = false;$/;"	m	struct:t_gl_state	access:public
get_mutable_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool get_mutable_buffer(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)$/;"	f	signature:(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
get_nearby_cost_entry	route/router_lookahead_map.cpp	/^static Cost_Entry get_nearby_cost_entry(int x, int y, int segment_index, int chan_index);$/;"	p	file:	signature:(int x, int y, int segment_index, int chan_index)
get_nearby_cost_entry	route/router_lookahead_map.cpp	/^static Cost_Entry get_nearby_cost_entry(int x, int y, int segment_index, int chan_index){$/;"	f	file:	signature:(int x, int y, int segment_index, int chan_index)
get_net_cost	place/place.cpp	/^static float get_net_cost(ClusterNetId net_id, t_bb *bb_ptr);$/;"	p	file:	signature:(ClusterNetId net_id, t_bb *bb_ptr)
get_net_cost	place/place.cpp	/^static float get_net_cost(ClusterNetId net_id, t_bb *bbptr) {$/;"	f	file:	signature:(ClusterNetId net_id, t_bb *bbptr)
get_net_wirelength_estimate	place/place.cpp	/^static double get_net_wirelength_estimate(ClusterNetId net_id, t_bb *bbptr) {$/;"	f	file:	signature:(ClusterNetId net_id, t_bb *bbptr)
get_net_wirelength_estimate	place/place.cpp	/^static double get_net_wirelength_estimate(ClusterNetId net_id, t_bb *bbptr);$/;"	p	file:	signature:(ClusterNetId net_id, t_bb *bbptr)
get_next_hash	util/hash.cpp	/^get_next_hash(t_hash **hash_table, t_hash_iterator *hash_iterator) {$/;"	f	signature:(t_hash **hash_table, t_hash_iterator *hash_iterator)
get_next_hash	util/hash.h	/^t_hash *get_next_hash(t_hash **hash_table,$/;"	p	signature:(t_hash **hash_table, t_hash_iterator *hash_iterator)
get_next_primitive_list	pack/cluster_placement.cpp	/^bool get_next_primitive_list($/;"	f	signature:( t_cluster_placement_stats *cluster_placement_stats, const t_pack_molecule *molecule, t_pb_graph_node **primitives_list)
get_next_primitive_list	pack/cluster_placement.h	/^bool get_next_primitive_list($/;"	p	signature:( t_cluster_placement_stats *cluster_placement_stats, const t_pack_molecule *molecule, t_pb_graph_node **primitives_list)
get_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_node_set& xpath_variable::get_node_set() const$/;"	f	class:pugi::xpath_variable	signature:() const
get_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_node_set& get_node_set() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
get_non_updateable_bb	place/place.cpp	/^static void get_non_updateable_bb(ClusterNetId net_id, t_bb *bb_coord_new) {$/;"	f	file:	signature:(ClusterNetId net_id, t_bb *bb_coord_new)
get_non_updateable_bb	place/place.cpp	/^static void get_non_updateable_bb(ClusterNetId net_id, t_bb *bb_coord_new);$/;"	p	file:	signature:(ClusterNetId net_id, t_bb *bb_coord_new)
get_num_bends_and_length	base/stats.cpp	/^void get_num_bends_and_length(ClusterNetId inet, int *bends_ptr, int *len_ptr,$/;"	f	signature:(ClusterNetId inet, int *bends_ptr, int *len_ptr, int *segments_ptr)
get_num_bends_and_length	base/stats.h	/^void get_num_bends_and_length(ClusterNetId inet, int *bends, int *length, int *segments);$/;"	p	signature:(ClusterNetId inet, int *bends, int *length, int *segments)
get_num_child_types	base/vpr_types.h	/^	int get_num_child_types() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
get_num_children_of_type	base/vpr_types.h	/^	int get_num_children_of_type(int type_index) const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(int type_index) const
get_num_modes_of_lb_type_rr_node	pack/lb_type_rr_graph.cpp	/^int get_num_modes_of_lb_type_rr_node(const t_lb_type_rr_node &lb_type_rr_node) {$/;"	f	signature:(const t_lb_type_rr_node &lb_type_rr_node)
get_num_modes_of_lb_type_rr_node	pack/lb_type_rr_graph.h	/^int get_num_modes_of_lb_type_rr_node(const t_lb_type_rr_node &lb_type_rr_node);$/;"	p	signature:(const t_lb_type_rr_node &lb_type_rr_node)
get_num_wire_types	route/cb_metrics.cpp	/^int get_num_wire_types(const int num_segments, const t_segment_inf *segment_inf){$/;"	f	signature:(const int num_segments, const t_segment_inf *segment_inf)
get_num_wire_types	route/cb_metrics.h	/^int get_num_wire_types(const int num_segments, const t_segment_inf *segment_inf);$/;"	p	signature:(const int num_segments, const t_segment_inf *segment_inf)
get_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xpath_variable::get_number() const$/;"	f	class:pugi::xpath_variable	signature:() const
get_number	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double get_number() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
get_opin_direct_connecions	route/rr_graph.cpp	/^static int get_opin_direct_connecions($/;"	p	file:	signature:( int x, int y, e_side side, int opin, int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_rr_node_indices& L_rr_node_indices, const std::vector<t_rr_node>& rr_nodes, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs)
get_opin_direct_connecions	route/rr_graph.cpp	/^static int get_opin_direct_connecions(int x, int y, e_side side, int opin,$/;"	f	file:	signature:(int x, int y, e_side side, int opin, int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_rr_node_indices& L_rr_node_indices, const std::vector<t_rr_node>& rr_nodes, const t_direct_inf *directs, const int num_directs, const t_clb_to_clb_directs *clb_to_clb_directs)
get_padding_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    BitSpace::bit_value_t get_padding_bit()$/;"	f	class:VNumber	access:public	signature:()
get_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* get_page() const$/;"	f	class:compact_header	access:public	signature:() const
get_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_pb_bbox(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode) {$/;"	f	class:t_draw_coords	signature:(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode)
get_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_pb_bbox(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode) {$/;"	f	class:t_draw_coords	signature:(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode)
get_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_pb_type_info::get_pb_bbox(const t_pb_graph_node& pb_graph_node) {$/;"	f	class:t_draw_pb_type_info	signature:(const t_pb_graph_node& pb_graph_node)
get_pb_bbox	draw/draw_types.h	/^	t_bound_box get_pb_bbox(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_coords	access:public	signature:(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode)
get_pb_bbox	draw/draw_types.h	/^	t_bound_box get_pb_bbox(const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_pb_type_info	access:public	signature:(const t_pb_graph_node& pb_gnode)
get_pb_bbox	draw/draw_types.h	/^	t_bound_box get_pb_bbox(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_coords	access:public	signature:(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode)
get_pb_bbox_ref	draw/draw_types.cpp	/^t_bound_box& t_draw_pb_type_info::get_pb_bbox_ref(const t_pb_graph_node& pb_graph_node) {$/;"	f	class:t_draw_pb_type_info	signature:(const t_pb_graph_node& pb_graph_node)
get_pb_bbox_ref	draw/draw_types.h	/^	t_bound_box& get_pb_bbox_ref(const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_pb_type_info	access:public	signature:(const t_pb_graph_node& pb_gnode)
get_pb_graph_node_pin_from_block_pin	util/vpr_utils.cpp	/^t_pb_graph_pin* get_pb_graph_node_pin_from_block_pin(ClusterBlockId iblock, int ipin) {$/;"	f	signature:(ClusterBlockId iblock, int ipin)
get_pb_graph_node_pin_from_block_pin	util/vpr_utils.h	/^t_pb_graph_pin* get_pb_graph_node_pin_from_block_pin(ClusterBlockId iblock, int ipin);$/;"	p	signature:(ClusterBlockId iblock, int ipin)
get_pb_graph_node_pin_from_model_port_pin	util/vpr_utils.cpp	/^t_pb_graph_pin* get_pb_graph_node_pin_from_model_port_pin(const t_model_ports *model_port, const int model_pin, const t_pb_graph_node *pb_graph_node) {$/;"	f	signature:(const t_model_ports *model_port, const int model_pin, const t_pb_graph_node *pb_graph_node)
get_pb_graph_node_pin_from_model_port_pin	util/vpr_utils.h	/^t_pb_graph_pin* get_pb_graph_node_pin_from_model_port_pin(const t_model_ports *model_port, const int model_pin, const t_pb_graph_node *pb_graph_node);$/;"	p	signature:(const t_model_ports *model_port, const int model_pin, const t_pb_graph_node *pb_graph_node)
get_pb_graph_pin_from_name	pack/pb_type_graph.cpp	/^static t_pb_graph_pin * get_pb_graph_pin_from_name(const char * port_name,$/;"	f	file:	signature:(const char * port_name, const t_pb_graph_node * pb, const int pin)
get_pb_graph_pin_from_name	pack/pb_type_graph.cpp	/^static t_pb_graph_pin * get_pb_graph_pin_from_name(const char * port_name,$/;"	p	file:	signature:(const char * port_name, const t_pb_graph_node * pb, const int pin)
get_pin_diversity	route/cb_metrics.cpp	/^static float get_pin_diversity(const int Fc, const int num_pin_type_pins, const Conn_Block_Metrics *cb_metrics);$/;"	p	file:	signature:(const int Fc, const int num_pin_type_pins, const Conn_Block_Metrics *cb_metrics)
get_pin_diversity	route/cb_metrics.cpp	/^static float get_pin_diversity(const int Fc, const int num_pin_type_pins, const Conn_Block_Metrics *cb_metrics){$/;"	f	file:	signature:(const int Fc, const int num_pin_type_pins, const Conn_Block_Metrics *cb_metrics)
get_pin_locations	route/cb_metrics.cpp	/^static void get_pin_locations(const t_type_ptr block_type, const e_pin_type pin_type, const int num_pin_type_pins, int *****tracks_connected_to_pin, t_2d_int_vec *pin_locations){$/;"	f	file:	signature:(const t_type_ptr block_type, const e_pin_type pin_type, const int num_pin_type_pins, int *****tracks_connected_to_pin, t_2d_int_vec *pin_locations)
get_pin_locations	route/cb_metrics.cpp	/^static void get_pin_locations(const t_type_ptr block_type, const e_pin_type pin_type, const int num_pin_type_pins, int *****tracks_connected_to_pin,$/;"	p	file:	signature:(const t_type_ptr block_type, const e_pin_type pin_type, const int num_pin_type_pins, int *****tracks_connected_to_pin, t_2d_int_vec *pin_locations)
get_pin_range_for_block	util/vpr_utils.cpp	/^void get_pin_range_for_block(const ClusterBlockId blk_id,$/;"	f	signature:(const ClusterBlockId blk_id, int *pin_low, int *pin_high)
get_pin_range_for_block	util/vpr_utils.h	/^void get_pin_range_for_block(const ClusterBlockId blk_id,$/;"	p	signature:(const ClusterBlockId blk_id, int *pin_low, int *pin_high)
get_pin_util	base/vpr_types.cpp	/^t_ext_pin_util t_ext_pin_util_targets::get_pin_util(std::string block_type_name) const {$/;"	f	class:t_ext_pin_util_targets	signature:(std::string block_type_name) const
get_pin_util	base/vpr_types.h	/^    t_ext_pin_util get_pin_util(std::string block_type_name) const;$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(std::string block_type_name) const
get_pins	timing/read_sdc2.cpp	/^        std::set<AtomPinId> get_pins(const sdcparse::StringGroup& pin_group) {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(const sdcparse::StringGroup& pin_group)
get_port_pin_from_blk_pin	util/vpr_utils.cpp	/^void get_port_pin_from_blk_pin(int blk_type_index, int blk_pin, int * port,$/;"	f	signature:(int blk_type_index, int blk_pin, int * port, int * port_pin)
get_port_pin_from_blk_pin	util/vpr_utils.h	/^void get_port_pin_from_blk_pin(int blk_type_index, int blk_pin, int * port,$/;"	p	signature:(int blk_type_index, int blk_pin, int * port, int * port_pin)
get_ports	timing/read_sdc2.cpp	/^        std::set<AtomPinId> get_ports(const sdcparse::StringGroup& port_group) {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(const sdcparse::StringGroup& port_group)
get_random_state	../../libs/libvtrutil/src/vtr_random.cpp	/^RandState get_random_state() {$/;"	f	namespace:vtr	signature:()
get_random_state	../../libs/libvtrutil/src/vtr_random.h	/^    RandState get_random_state();$/;"	p	namespace:vtr	signature:()
get_reached_rt_sinks	route/connection_based_routing.h	/^	std::vector<t_rt_node*>& get_reached_rt_sinks() {return reached_rt_sinks;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:()
get_remaining_targets	route/connection_based_routing.h	/^	std::vector<int>& get_remaining_targets() {return remaining_targets;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:()
get_report_structure	../../libs/libeasygl/src/graphics.cpp	/^void get_report_structure(t_report *report) {$/;"	f	signature:(t_report *report)
get_report_structure	../../libs/libeasygl/src/graphics.cpp	/^void get_report_structure(t_report*) { }$/;"	f	signature:(t_report*)
get_report_structure	../../libs/libeasygl/src/graphics.h	/^void get_report_structure(t_report*);$/;"	p	signature:(t_report*)
get_representative_cost_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_representative_cost_entry(e_representative_entry_method method){$/;"	f	class:Expansion_Cost_Entry	access:public	signature:(e_representative_entry_method method)
get_router_rr_cost	draw/draw.cpp	/^static float get_router_rr_cost(const t_rr_node_route_inf node_inf, e_draw_router_rr_cost draw_router_rr_cost) {$/;"	f	file:	signature:(const t_rr_node_route_inf node_inf, e_draw_router_rr_cost draw_router_rr_cost)
get_router_rr_cost	draw/draw.cpp	/^static float get_router_rr_cost(const t_rr_node_route_inf node_inf, e_draw_router_rr_cost draw_router_rr_cost);$/;"	p	file:	signature:(const t_rr_node_route_inf node_inf, e_draw_router_rr_cost draw_router_rr_cost)
get_routing_calc	route/route_budgets.h	/^    std::shared_ptr<RoutingDelayCalculator> get_routing_calc(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
get_rr_cong_cost	route/route_common.cpp	/^float get_rr_cong_cost(int inode) {$/;"	f	signature:(int inode)
get_rr_cong_cost	route/route_common.h	/^float get_rr_cong_cost(int inode);$/;"	p	signature:(int inode)
get_rr_node_index	route/rr_graph2.cpp	/^int get_rr_node_index(const t_rr_node_indices& L_rr_node_indices,$/;"	f	signature:(const t_rr_node_indices& L_rr_node_indices, int x, int y, t_rr_type rr_type, int ptc, e_side side)
get_rr_node_index	route/rr_graph2.h	/^int get_rr_node_index($/;"	p	signature:( int x, int y, t_rr_type rr_type, int ptc, const t_rr_node_indices& L_rr_node_indices)
get_rr_node_index	route/rr_graph2.h	/^int get_rr_node_index(const t_rr_node_indices& L_rr_node_indices,$/;"	p	signature:(const t_rr_node_indices& L_rr_node_indices, int x, int y, t_rr_type rr_type, int ptc, e_side side=NUM_SIDES)
get_rr_node_indices	route/rr_graph2.cpp	/^std::vector<int> get_rr_node_indices(const t_rr_node_indices& L_rr_node_indices,$/;"	f	signature:(const t_rr_node_indices& L_rr_node_indices, int x, int y, t_rr_type rr_type, int ptc)
get_rr_node_indices	route/rr_graph2.h	/^std::vector<int> get_rr_node_indices(const t_rr_node_indices& L_rr_node_indices,$/;"	p	signature:(const t_rr_node_indices& L_rr_node_indices, int x, int y, t_rr_type rr_type, int ptc)
get_sb_formula_raw_result	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^int get_sb_formula_raw_result( const char* formula, const t_formula_data &mydata ){$/;"	f	signature:( const char* formula, const t_formula_data &mydata )
get_sb_formula_raw_result	../../libs/libarchfpga/src/parse_switchblocks.h	/^int get_sb_formula_raw_result( const char* formula, const t_formula_data &mydata );$/;"	p	signature:( const char* formula, const t_formula_data &mydata )
get_sdc_file_name	timing/read_sdc.cpp	/^const char * get_sdc_file_name(){$/;"	f	signature:()
get_sdc_file_name	timing/read_sdc.h	/^const char * get_sdc_file_name(); \/* Accessor function for getting SDC file name *\/$/;"	p	signature:()
get_seg_end	route/rr_graph2.cpp	/^int get_seg_end(const t_chan_seg_details * seg_details, const int itrack, const int istart,$/;"	f	signature:(const t_chan_seg_details * seg_details, const int itrack, const int istart, const int chan_num, const int seg_max)
get_seg_end	route/rr_graph2.h	/^int get_seg_end(const t_chan_seg_details *seg_details,$/;"	p	signature:(const t_chan_seg_details *seg_details, const int itrack, const int istart, const int chan_num, const int seg_max)
get_seg_start	route/rr_graph2.cpp	/^int get_seg_start($/;"	f	signature:( const t_chan_seg_details * seg_details, const int itrack, const int chan_num, const int seg_num)
get_seg_start	route/rr_graph2.h	/^int get_seg_start($/;"	p	signature:( const t_chan_seg_details *seg_details, const int itrack, const int chan_num, const int seg_num)
get_seg_track_counts	route/rr_graph2.cpp	/^int *get_seg_track_counts($/;"	f	signature:( const int num_sets, const int num_seg_types, const t_segment_inf * segment_inf, const bool use_full_seg_groups)
get_seg_track_counts	route/rr_graph2.h	/^int *get_seg_track_counts($/;"	p	signature:( const int num_sets, const int num_seg_types, const t_segment_inf * segment_inf, const bool use_full_seg_groups)
get_segment_usage_stats	route/segment_stats.cpp	/^void get_segment_usage_stats(int num_segment, t_segment_inf * segment_inf) {$/;"	f	signature:(int num_segment, t_segment_inf * segment_inf)
get_segment_usage_stats	route/segment_stats.h	/^void get_segment_usage_stats(int num_segment, t_segment_inf * segment_inf);$/;"	p	signature:(int num_segment, t_segment_inf * segment_inf)
get_selected_pb	draw/intra_logic_block.cpp	/^t_pb* t_selected_sub_block_info::get_selected_pb() const { return selected_pb; }$/;"	f	class:t_selected_sub_block_info	signature:() const
get_selected_pb	draw/intra_logic_block.h	/^	t_pb* get_selected_pb() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
get_selected_pb_gnode	draw/intra_logic_block.cpp	/^t_pb_graph_node* t_selected_sub_block_info::get_selected_pb_gnode() const { return selected_pb_gnode; }$/;"	f	class:t_selected_sub_block_info	signature:() const
get_selected_pb_gnode	draw/intra_logic_block.h	/^	t_pb_graph_node* get_selected_pb_gnode() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
get_selected_sub_block_info	draw/intra_logic_block.cpp	/^t_selected_sub_block_info& get_selected_sub_block_info() {$/;"	f	signature:()
get_selected_sub_block_info	draw/intra_logic_block.h	/^t_selected_sub_block_info& get_selected_sub_block_info();$/;"	p	signature:()
get_serial_num	route/route_common.cpp	/^void get_serial_num() {$/;"	f	signature:()
get_serial_num	route/route_export.h	/^void get_serial_num();$/;"	p	signature:()
get_simple_switch_block_track	route/rr_graph_sbox.cpp	/^int get_simple_switch_block_track(const enum e_side from_side,$/;"	f	signature:(const enum e_side from_side, const enum e_side to_side, const int from_track, const enum e_switch_block_type switch_block_type, const int nodes_per_chan)
get_simple_switch_block_track	route/rr_graph_sbox.h	/^int get_simple_switch_block_track(enum e_side from_side, enum e_side to_side,$/;"	p	signature:(enum e_side from_side, enum e_side to_side, int from_track, enum e_switch_block_type switch_block_type, int nodes_per_chan)
get_single_child	../../libs/libpugiutil/src/pugixml_util.cpp	/^    pugi::xml_node get_single_child(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt)
get_single_child	../../libs/libpugiutil/src/pugixml_util.hpp	/^    pugi::xml_node get_single_child(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
get_sink_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    tatum::Time get_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_sink_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::get_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type) const
get_slope	route/routing_predictor.cpp	/^    float get_slope() {$/;"	f	class:LinearModel	access:public	signature:()
get_slope	route/routing_predictor.cpp	/^float RoutingPredictor::get_slope() {$/;"	f	class:RoutingPredictor	signature:()
get_slope	route/routing_predictor.h	/^    float get_slope();$/;"	p	class:RoutingPredictor	access:public	signature:()
get_smallest_entry	route/router_lookahead_map.cpp	/^	Cost_Entry get_smallest_entry();$/;"	p	class:Expansion_Cost_Entry	file:	access:private	signature:()
get_smallest_entry	route/router_lookahead_map.cpp	/^Cost_Entry Expansion_Cost_Entry::get_smallest_entry(){$/;"	f	class:Expansion_Cost_Entry	signature:()
get_stable_critical_path_delay	route/connection_based_routing.h	/^	float get_stable_critical_path_delay() const {return last_stable_critical_path_delay;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:() const
get_start_node_ind	route/router_lookahead_map.cpp	/^static int get_start_node_ind(int start_x, int start_y, int target_x, int target_y, t_rr_type rr_type, int seg_index, int track_offset);$/;"	p	file:	signature:(int start_x, int start_y, int target_x, int target_y, t_rr_type rr_type, int seg_index, int track_offset)
get_start_node_ind	route/router_lookahead_map.cpp	/^static int get_start_node_ind(int start_x, int start_y, int target_x, int target_y, t_rr_type rr_type, int seg_index, int track_offset){$/;"	f	file:	signature:(int start_x, int start_y, int target_x, int target_y, t_rr_type rr_type, int seg_index, int track_offset)
get_std_dev	place/place.cpp	/^static double get_std_dev(int n, double sum_x_squared, double av_x) {$/;"	f	file:	signature:(int n, double sum_x_squared, double av_x)
get_std_dev	place/place.cpp	/^static double get_std_dev(int n, double sum_x_squared, double av_x);$/;"	p	file:	signature:(int n, double sum_x_squared, double av_x)
get_strconv_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN strconv_attribute_t get_strconv_attribute(unsigned int optmask)$/;"	f	signature:(unsigned int optmask)
get_strconv_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN strconv_pcdata_t get_strconv_pcdata(unsigned int optmask)$/;"	f	signature:(unsigned int optmask)
get_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xpath_variable::get_string() const$/;"	f	class:pugi::xpath_variable	signature:() const
get_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* get_string() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
get_switch_box_tracks	route/rr_graph_sbox.h	/^std::vector<int> get_switch_box_tracks(const int from_i,$/;"	p	signature:(const int from_i, const int from_j, const int from_track, const t_rr_type from_type, const int to_i, const int to_j, const t_rr_type to_type, const std::vector<int> ***switch_block_conn)
get_switch_type	route/rr_graph2.cpp	/^static void get_switch_type($/;"	f	file:	signature:( bool is_from_sblock, bool is_to_sblock, short from_node_switch, short to_node_switch, const int switch_override, short switch_types[2])
get_switch_type	route/rr_graph2.cpp	/^static void get_switch_type($/;"	p	file:	signature:( bool is_from_sb, bool is_to_sb, short from_node_switch, short to_node_switch, const int switch_override, short switch_types[2])
get_switchpoint_of_wire	route/build_switchblocks.cpp	/^static int get_switchpoint_of_wire(const DeviceGrid& grid, e_rr_type chan_type,$/;"	f	file:	signature:(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details, int seg_coord, e_side sb_side)
get_switchpoint_of_wire	route/build_switchblocks.cpp	/^static int get_switchpoint_of_wire(const DeviceGrid& grid, e_rr_type chan_type,$/;"	p	file:	signature:(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details, int seg_coord, e_side sb_side)
get_switchpoint_wires	route/build_switchblocks.cpp	/^static std::vector<t_wire_switchpoint> get_switchpoint_wires(const DeviceGrid& grid, const t_chan_seg_details* chan_details,$/;"	f	file:	signature:(const DeviceGrid& grid, const t_chan_seg_details* chan_details, t_rr_type chan_type, int x, int y, e_side side, const vector<t_wire_switchpoints>& wire_switchpoints_vec, t_wire_type_sizes *wire_type_sizes, bool is_dest, SwitchPointOrder switchpoint_order, vtr::RandState& rand_state)
get_switchpoint_wires	route/build_switchblocks.cpp	/^static std::vector<t_wire_switchpoint> get_switchpoint_wires(const DeviceGrid& grid, const t_chan_seg_details* chan_details,$/;"	p	file:	signature:(const DeviceGrid& grid, const t_chan_seg_details* chan_details, t_rr_type chan_type, int x, int y, e_side side, const vector<t_wire_switchpoints>& wire_switchpoints_vec, t_wire_type_sizes *wire_type_sizes, bool is_dest, SwitchPointOrder order, vtr::RandState& rand_state)
get_tile_height	draw/draw_types.cpp	/^float t_draw_coords::get_tile_height() {$/;"	f	class:t_draw_coords	signature:()
get_tile_height	draw/draw_types.h	/^	float get_tile_height();$/;"	p	struct:t_draw_coords	access:public	signature:()
get_tile_width	draw/draw_types.cpp	/^float t_draw_coords::get_tile_width() {$/;"	f	class:t_draw_coords	signature:()
get_tile_width	draw/draw_types.h	/^	float get_tile_width();$/;"	p	struct:t_draw_coords	access:public	signature:()
get_timing_place_crit	place/timing_place.cpp	/^float get_timing_place_crit(ClusterNetId net_id, int ipin) {$/;"	f	signature:(ClusterNetId net_id, int ipin)
get_timing_place_crit	place/timing_place.h	/^float get_timing_place_crit(ClusterNetId net_id, int ipin);$/;"	p	signature:(ClusterNetId net_id, int ipin)
get_total_path_delay	route/route_budgets.cpp	/^float route_budgets::get_total_path_delay(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer,$/;"	f	class:route_budgets	signature:(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer, analysis_type analysis_type, tatum::NodeId timing_node)
get_total_path_delay	route/route_budgets.h	/^    float get_total_path_delay(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer,$/;"	p	class:route_budgets	access:private	signature:(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer, analysis_type analysis_type, tatum::NodeId timing_node)
get_track_num	draw/draw.cpp	/^static int get_track_num(int inode, const vtr::OffsetMatrix<int>& chanx_track, const vtr::OffsetMatrix<int>& chany_track) {$/;"	f	file:	signature:(int inode, const vtr::OffsetMatrix<int>& chanx_track, const vtr::OffsetMatrix<int>& chany_track)
get_track_num	draw/draw.cpp	/^static int get_track_num(int inode, const vtr::OffsetMatrix<int>& chanx_track, const vtr::OffsetMatrix<int>& chany_track);$/;"	p	file:	signature:(int inode, const vtr::OffsetMatrix<int>& chanx_track, const vtr::OffsetMatrix<int>& chany_track)
get_track_to_chan_seg	route/rr_graph2.cpp	/^static int get_track_to_chan_seg($/;"	f	file:	signature:( const int from_wire, const int to_chan, const int to_seg, const t_rr_type to_chan_type, const e_side from_side, const e_side to_side, const int switch_override, const t_rr_node_indices& L_rr_node_indices, t_sb_connection_map *sb_conn_map, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create)
get_track_to_chan_seg	route/rr_graph2.cpp	/^static int get_track_to_chan_seg($/;"	p	file:	signature:( const int from_track, const int to_chan, const int to_seg, const t_rr_type to_chan_type, const e_side from_side, const e_side to_side, const int swtich_override, const t_rr_node_indices&L_rr_node_indices, t_sb_connection_map *sb_conn_map, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create)
get_track_to_pins	route/rr_graph2.cpp	/^int get_track_to_pins($/;"	f	signature:( int seg, int chan, int track, int tracks_per_chan, int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_rr_node_indices& L_rr_node_indices, const t_track_to_pin_lookup& track_to_pin_lookup, const t_chan_seg_details * seg_details, enum e_rr_type chan_type, int chan_length, int wire_to_ipin_switch, enum e_directionality directionality)
get_track_to_pins	route/rr_graph2.h	/^int get_track_to_pins($/;"	p	signature:( int seg, int chan, int track, int tracks_per_chan, int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_rr_node_indices& L_rr_node_indices, const t_track_to_pin_lookup& track_to_pin_lookup, const t_chan_seg_details *seg_details, enum e_rr_type chan_type, int chan_length, int wire_to_ipin_switch, enum e_directionality directionality)
get_track_to_tracks	route/rr_graph2.cpp	/^int get_track_to_tracks($/;"	f	signature:( const int from_chan, const int from_seg, const int from_track, const t_rr_type from_type, const int to_seg, const t_rr_type to_type, const int chan_len, const int max_chan_width, const DeviceGrid& grid, const int Fs_per_side, t_sblock_pattern& sblock_pattern, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_chan_seg_details * from_seg_details, const t_chan_seg_details * to_seg_details, const t_chan_details& to_chan_details, const enum e_directionality directionality, const t_rr_node_indices& L_rr_node_indices, const vtr::NdMatrix<std::vector<int>, 3>& switch_block_conn, t_sb_connection_map *sb_conn_map)
get_track_to_tracks	route/rr_graph2.h	/^int get_track_to_tracks($/;"	p	signature:( const int from_chan, const int from_seg, const int from_track, const t_rr_type from_type, const int to_seg, const t_rr_type to_type, const int chan_len, const int max_chan_width, const DeviceGrid& grid, const int Fs_per_side, t_sblock_pattern& sblock_pattern, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, const t_chan_seg_details *from_seg_details, const t_chan_seg_details *to_seg_details, const t_chan_details& to_chan_details, const enum e_directionality directionality, const t_rr_node_indices& L_rr_node_indices, const vtr::NdMatrix<std::vector<int>,3>& switch_block_conn, t_sb_connection_map *sb_conn_map)
get_unidir_opin_connections	route/rr_graph2.cpp	/^int get_unidir_opin_connections($/;"	f	signature:( const int chan, const int seg, int Fc, const int seg_type_index, const t_rr_type chan_type, const t_chan_seg_details *seg_details, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, vtr::NdMatrix<int,3>& Fc_ofs, const int max_len, const int max_chan_width, const t_rr_node_indices& L_rr_node_indices, bool *Fc_clipped)
get_unidir_opin_connections	route/rr_graph2.h	/^int get_unidir_opin_connections($/;"	p	signature:( const int chan, const int seg, int Fc, const int seg_type_index, const t_rr_type chan_type, const t_chan_seg_details *seg_details, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create, vtr::NdMatrix<int,3>& Fc_ofs, const int max_len, const int max_chan_width, const t_rr_node_indices& L_rr_node_indices, bool *Fc_clipped)
get_unidir_track_to_chan_seg	route/rr_graph2.cpp	/^static int get_unidir_track_to_chan_seg($/;"	f	file:	signature:( const int from_track, const int to_chan, const int to_seg, const int to_sb, const t_rr_type to_type, const int max_chan_width, const DeviceGrid& grid, const enum e_side from_side, const enum e_side to_side, const int Fs_per_side, t_sblock_pattern& sblock_pattern, const int switch_override, const t_rr_node_indices& L_rr_node_indices, const t_chan_seg_details * seg_details, bool * Fs_clipped, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create)
get_unidir_track_to_chan_seg	route/rr_graph2.cpp	/^static int get_unidir_track_to_chan_seg($/;"	p	file:	signature:( const int from_track, const int to_chan, const int to_seg, const int to_sb, const t_rr_type to_type, const int max_chan_width, const DeviceGrid& grid, const enum e_side from_side, const enum e_side to_side, const int Fs_per_side, t_sblock_pattern& sblock_pattern, const int switch_override, const t_rr_node_indices& L_rr_node_indices, const t_chan_seg_details * seg_details, bool * Fs_clipped, const int from_rr_node, t_rr_edge_info_set& rr_edges_to_create)
get_unique_pb_graph_node_id	util/vpr_utils.cpp	/^int get_unique_pb_graph_node_id(const t_pb_graph_node *pb_graph_node) {$/;"	f	signature:(const t_pb_graph_node *pb_graph_node)
get_unique_pb_graph_node_id	util/vpr_utils.h	/^int get_unique_pb_graph_node_id(const t_pb_graph_node *pb_graph_node);$/;"	p	signature:(const t_pb_graph_node *pb_graph_node)
get_valid_length	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t get_valid_length(const char_t* data, size_t length)$/;"	f	signature:(const char_t* data, size_t length)
get_value	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    int64_t get_value()$/;"	f	class:VNumber	access:public	signature:()
get_value_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool get_value_bool(const char_t* value)$/;"	f	signature:(const char_t* value)
get_value_double	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double get_value_double(const char_t* value)$/;"	f	signature:(const char_t* value)
get_value_float	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN float get_value_float(const char_t* value)$/;"	f	signature:(const char_t* value)
get_value_int	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int get_value_int(const char_t* value)$/;"	f	signature:(const char_t* value)
get_value_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN long long get_value_llong(const char_t* value)$/;"	f	signature:(const char_t* value)
get_value_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned int get_value_uint(const char_t* value)$/;"	f	signature:(const char_t* value)
get_value_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned long long get_value_ullong(const char_t* value)$/;"	f	signature:(const char_t* value)
get_var_value	../../libs/libarchfpga/src/expr_eval.h	/^        int get_var_value(std::string var) const {$/;"	f	class:t_formula_data	access:public	signature:(std::string var) const
get_visible_screen	../../libs/libeasygl/src/graphics.cpp	/^t_bound_box get_visible_screen() {$/;"	f	signature:()
get_visible_screen	../../libs/libeasygl/src/graphics.h	/^t_bound_box get_visible_screen();$/;"	p	signature:()
get_visible_world	../../libs/libeasygl/src/graphics.cpp	/^t_bound_box get_visible_world() {$/;"	f	signature:()
get_visible_world	../../libs/libeasygl/src/graphics.h	/^t_bound_box get_visible_world();$/;"	p	signature:()
get_wchar_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_encoding get_wchar_encoding()$/;"	f	signature:()
get_width	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_width() const {$/;"	f	class:t_bound_box	signature:() const
get_width	../../libs/libeasygl/src/graphics_types.h	/^    float get_width() const;$/;"	p	class:t_bound_box	access:public	signature:() const
get_wire_homogeneity	route/cb_metrics.cpp	/^static float get_wire_homogeneity(const int Fc, const int nodes_per_chan, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics){$/;"	f	file:	signature:(const int Fc, const int nodes_per_chan, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics)
get_wire_homogeneity	route/cb_metrics.cpp	/^static float get_wire_homogeneity(const int Fc, const int nodes_per_chan,$/;"	p	file:	signature:(const int Fc, const int nodes_per_chan, const int num_pin_type_pins, const int exponent, const bool both_sides, const Conn_Block_Metrics *cb_metrics)
get_wire_segment_length	route/build_switchblocks.cpp	/^int get_wire_segment_length(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details);$/;"	p	file:	signature:(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details)
get_wire_segment_length	route/build_switchblocks.cpp	/^int get_wire_segment_length(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details){$/;"	f	signature:(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details)
get_wire_subsegment_num	route/build_switchblocks.cpp	/^static int get_wire_subsegment_num(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details, int seg_coord){$/;"	f	file:	signature:(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details, int seg_coord)
get_wire_subsegment_num	route/build_switchblocks.cpp	/^static int get_wire_subsegment_num(const DeviceGrid& grid, e_rr_type chan_type,$/;"	p	file:	signature:(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details &wire_details, int seg_coord)
get_write_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_encoding get_write_encoding(xml_encoding encoding)$/;"	f	signature:(xml_encoding encoding)
get_write_native_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_encoding get_write_native_encoding()$/;"	f	signature:()
get_xbar_matrix	route/cb_metrics.cpp	/^static void get_xbar_matrix(const int *****conn_block, const t_type_ptr block_type, e_pin_type pin_type, const int side, const bool both_sides,$/;"	f	file:	signature:(const int *****conn_block, const t_type_ptr block_type, e_pin_type pin_type, const int side, const bool both_sides, const int nodes_per_chan, const int Fc, t_xbar_matrix *xbar_matrix)
get_xcenter	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_xcenter() const {$/;"	f	class:t_bound_box	signature:() const
get_xcenter	../../libs/libeasygl/src/graphics_types.h	/^    float get_xcenter() const;$/;"	p	class:t_bound_box	access:public	signature:() const
get_xy_deltas	route/router_lookahead_map.cpp	/^static void get_xy_deltas(int from_node_ind, int to_node_ind, int *delta_x, int *delta_y);$/;"	p	file:	signature:(int from_node_ind, int to_node_ind, int *delta_x, int *delta_y)
get_xy_deltas	route/router_lookahead_map.cpp	/^static void get_xy_deltas(int from_node_ind, int to_node_ind, int *delta_x, int *delta_y){$/;"	f	file:	signature:(int from_node_ind, int to_node_ind, int *delta_x, int *delta_y)
get_ycenter	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_ycenter() const {$/;"	f	class:t_bound_box	signature:() const
get_ycenter	../../libs/libeasygl/src/graphics_types.h	/^    float get_ycenter() const;$/;"	p	class:t_bound_box	access:public	signature:() const
get_zoom_factor	../../libs/libeasygl/src/graphics.cpp	/^float get_zoom_factor() { return 1.; }$/;"	f	signature:()
get_zoom_factor	../../libs/libeasygl/src/graphics.cpp	/^float get_zoom_factor() {$/;"	f	signature:()
get_zoom_factor	../../libs/libeasygl/src/graphics.h	/^float get_zoom_factor();$/;"	p	signature:()
getcolor	../../libs/libeasygl/src/graphics.cpp	/^t_color getcolor() {$/;"	f	signature:()
getcolor	../../libs/libeasygl/src/graphics.cpp	/^t_color getcolor(void) {$/;"	f	signature:(void)
getcolor	../../libs/libeasygl/src/graphics.h	/^t_color getcolor();$/;"	p	signature:()
getcwd	../../libs/libvtrutil/src/vtr_path.cpp	/^std::string getcwd() {$/;"	f	namespace:vtr	signature:()
getcwd	../../libs/libvtrutil/src/vtr_path.h	/^    std::string getcwd();$/;"	p	namespace:vtr	signature:()
getfontsize	../../libs/libeasygl/src/graphics.cpp	/^int getfontsize() {$/;"	f	signature:()
getfontsize	../../libs/libeasygl/src/graphics.h	/^int getfontsize();$/;"	p	signature:()
gettextrotation	../../libs/libeasygl/src/graphics.cpp	/^int gettextrotation() {$/;"	f	signature:()
gettextrotation	../../libs/libeasygl/src/graphics.h	/^int gettextrotation();$/;"	p	signature:()
gettextwidth	../../libs/libeasygl/src/graphics.h	/^float gettextwidth(const std::string& text);	\/\/ In the coodirnate system current drawing at \/\/ <Addition\/Mod: Charles>$/;"	p	signature:(const std::string& text)
gl_state	../../libs/libeasygl/src/graphics.cpp	/^static t_gl_state gl_state;$/;"	v	file:
glob_pattern_to_regex	timing/read_sdc2.cpp	/^std::regex glob_pattern_to_regex(const std::string& glob_pattern) {$/;"	f	signature:(const std::string& glob_pattern)
glob_pattern_to_regex	timing/read_sdc2.cpp	/^std::regex glob_pattern_to_regex(const std::string& glob_pattern);$/;"	p	file:	signature:(const std::string& glob_pattern)
global_clocks	base/vpr_types.h	/^	bool global_clocks;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
global_route_switch	base/vpr_types.h	/^	short global_route_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
gnode_clb_pair	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::gnode_clb_pair::gnode_clb_pair(const t_pb_graph_node* pb_gnode_, const ClusterBlockId clb_index_) :$/;"	f	class:t_selected_sub_block_info::gnode_clb_pair	signature:(const t_pb_graph_node* pb_gnode_, const ClusterBlockId clb_index_)
gnode_clb_pair	draw/intra_logic_block.h	/^		gnode_clb_pair() = default;$/;"	p	struct:t_selected_sub_block_info::gnode_clb_pair	access:public	signature:()
gnode_clb_pair	draw/intra_logic_block.h	/^		gnode_clb_pair(const t_pb_graph_node* pb_gnode, const ClusterBlockId clb_index);$/;"	p	struct:t_selected_sub_block_info::gnode_clb_pair	access:public	signature:(const t_pb_graph_node* pb_gnode, const ClusterBlockId clb_index)
gnode_clb_pair	draw/intra_logic_block.h	/^	struct gnode_clb_pair {$/;"	s	struct:t_selected_sub_block_info	access:public
got_commands	timing/read_sdc.cpp	/^        bool got_commands() { return got_commands_; }$/;"	f	class:SdcCallback	access:public	signature:()
got_commands_	timing/read_sdc.cpp	/^        bool got_commands_ = false;$/;"	m	class:SdcCallback	file:	access:private
goto_next_char	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool goto_next_char( int *str_ind, const string &pw_formula, char ch);$/;"	p	file:	signature:( int *str_ind, const string &pw_formula, char ch)
goto_next_char	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool goto_next_char( int *str_ind, const string &pw_formula, char ch){$/;"	f	file:	signature:( int *str_ind, const string &pw_formula, char ch)
gr_automode	draw/draw_types.h	/^	int gr_automode = 0;$/;"	m	struct:t_draw_state	access:public
graph	base/vpr_context.h	/^    std::shared_ptr<tatum::TimingGraph> graph;$/;"	m	struct:TimingContext	access:public
green	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t green = 0;$/;"	m	class:t_color	access:public
grid	base/vpr_context.h	/^    DeviceGrid grid; \/* FPGA complex block grid [0 .. grid.width()-1][0 .. grid.height()-1] *\/$/;"	m	struct:DeviceContext	access:public
grid_	base/device_grid.h	/^        vtr::Matrix<t_grid_tile> grid_;$/;"	m	class:DeviceGrid	access:private
grid_blocks	base/vpr_context.h	/^    vtr::Matrix<t_grid_blocks> grid_blocks; \/\/[0..device_ctx.grid.width()-1][0..device_ctx.grid.width()-1]$/;"	m	struct:PlacementContext	access:public
grid_layouts	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_grid_def> grid_layouts; \/\/Set of potential device layouts$/;"	m	struct:t_arch	access:public
grid_logic_tile_area	../../libs/libarchfpga/src/physical_types.h	/^	float grid_logic_tile_area;$/;"	m	struct:t_arch	access:public
grid_overused_resources	base/SetupGrid.cpp	/^static std::vector<t_type_ptr> grid_overused_resources(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts) {$/;"	f	file:	signature:(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts)
grid_overused_resources	base/SetupGrid.cpp	/^static std::vector<t_type_ptr> grid_overused_resources(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts);$/;"	p	file:	signature:(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts)
grid_satisfies_instance_counts	base/SetupGrid.cpp	/^static bool grid_satisfies_instance_counts(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts, float maximum_utilization) {$/;"	f	file:	signature:(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts, float maximum_utilization)
grid_satisfies_instance_counts	base/SetupGrid.cpp	/^static bool grid_satisfies_instance_counts(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts, float maximum_utilization);$/;"	p	file:	signature:(const DeviceGrid& grid, std::map<t_type_ptr,size_t> instance_counts, float maximum_utilization)
grid_to_bin_x	route/spatial_route_tree_lookup.cpp	/^size_t grid_to_bin_x(size_t grid_x, const SpatialRouteTreeLookup& spatial_lookup) {$/;"	f	signature:(size_t grid_x, const SpatialRouteTreeLookup& spatial_lookup)
grid_to_bin_x	route/spatial_route_tree_lookup.h	/^size_t grid_to_bin_x(size_t grid_x, const SpatialRouteTreeLookup& spatial_lookup);$/;"	p	signature:(size_t grid_x, const SpatialRouteTreeLookup& spatial_lookup)
grid_to_bin_y	route/spatial_route_tree_lookup.cpp	/^size_t grid_to_bin_y(size_t grid_y, const SpatialRouteTreeLookup& spatial_lookup) {$/;"	f	signature:(size_t grid_y, const SpatialRouteTreeLookup& spatial_lookup)
grid_to_bin_y	route/spatial_route_tree_lookup.h	/^size_t grid_to_bin_y(size_t grid_y, const SpatialRouteTreeLookup& spatial_lookup);$/;"	p	signature:(size_t grid_y, const SpatialRouteTreeLookup& spatial_lookup)
grid_type	../../libs/libarchfpga/src/physical_types.h	/^    GridDefType grid_type = GridDefType::AUTO;  \/\/The type of this grid specification$/;"	m	struct:t_grid_def	access:public
group_size	base/vpr_types.h	/^	int group_size = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
group_size	base/vpr_types.h	/^        int group_size() const { return seg_detail_->group_size; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
group_start	base/vpr_types.h	/^	int group_start = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
group_start	base/vpr_types.h	/^        int group_start() const { return seg_detail_->group_start; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
guess_buffer_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_encoding guess_buffer_encoding(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)$/;"	f	signature:(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
h	draw/hsl.h	/^    double h;       \/\/ a fraction between 0 and 1$/;"	m	struct:hsl	access:public
hButtonsWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hGraphicsBrush	../../libs/libeasygl/src/graphics_state.h	/^    HBRUSH hGraphicsBrush, hGrayBrush;$/;"	m	class:t_win32_state	access:public
hGraphicsDC	../../libs/libeasygl/src/graphics_state.h	/^    HDC hGraphicsDC;	\/\/ Current Active Drawing buffer \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hGraphicsDCPassive	../../libs/libeasygl/src/graphics_state.h	/^	HDC hGraphicsDCPassive;	\/\/ Front Buffer for display purpose \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hGraphicsFont	../../libs/libeasygl/src/graphics_state.h	/^    HFONT hGraphicsFont;$/;"	m	class:t_win32_state	access:public
hGraphicsPassive	../../libs/libeasygl/src/graphics_state.h	/^	HGDIOBJ hGraphicsPassive;	\/\/ Backup of old drawing context object, usage see set_drawing_buffer() \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hGraphicsPen	../../libs/libeasygl/src/graphics_state.h	/^    HPEN hGraphicsPen;$/;"	m	class:t_win32_state	access:public
hGraphicsWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hGrayBrush	../../libs/libeasygl/src/graphics_state.h	/^    HBRUSH hGraphicsBrush, hGrayBrush;$/;"	m	class:t_win32_state	access:public
hMainWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hStatusWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
hTNS	route/route_timing.cpp	/^    float hTNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
hWNS	route/route_timing.cpp	/^    float hWNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
h_	../../libs/libvtrutil/src/picosha2.h	/^	word_t h_[8];$/;"	m	class:picosha2::hash256_one_by_one	access:private
h_ptr	util/hash.h	/^	t_hash *h_ptr;$/;"	m	struct:t_hash_iterator	access:public
hamming_proximity	route/cb_metrics.h	/^	float hamming_proximity;$/;"	m	class:Conn_Block_Metrics	access:public
hamming_proximity_of_two_sets	route/cb_metrics.cpp	/^static int hamming_proximity_of_two_sets(const set<int> *set1, const set<int> *set2);$/;"	p	file:	signature:(const set<int> *set1, const set<int> *set2)
hamming_proximity_of_two_sets	route/cb_metrics.cpp	/^static int hamming_proximity_of_two_sets(const set<int> *set1, const set<int> *set2){$/;"	f	file:	signature:(const set<int> *set1, const set<int> *set2)
handle_assert	../../libs/libvtrutil/src/vtr_assert.cpp	/^void handle_assert(const char* expr, const char* file, unsigned int line, const char* function, const char* msg) {$/;"	f	namespace:vtr::assert	signature:(const char* expr, const char* file, unsigned int line, const char* function, const char* msg)
handle_assert	../../libs/libvtrutil/src/vtr_assert.h	/^    [[noreturn]] void handle_assert(const char* expr, const char* file, unsigned int line, const char* function, const char* msg);$/;"	p	namespace:vtr::assert	signature:(const char* expr, const char* file, unsigned int line, const char* function, const char* msg)
handle_bracket	../../libs/libarchfpga/src/expr_eval.cpp	/^static void handle_bracket( const Formula_Object &fobj, vector<Formula_Object> &rpn_output,$/;"	f	file:	signature:( const Formula_Object &fobj, vector<Formula_Object> &rpn_output, stack<Formula_Object> &op_stack )
handle_bracket	../../libs/libarchfpga/src/expr_eval.cpp	/^static void handle_bracket( const Formula_Object &fobj, vector<Formula_Object> &rpn_output,$/;"	p	file:	signature:( const Formula_Object &fobj, vector<Formula_Object> &rpn_output, stack<Formula_Object> &op_stack)
handle_comma	../../libs/libarchfpga/src/expr_eval.cpp	/^static void handle_comma( const Formula_Object &fobj, vector<Formula_Object> &rpn_output,$/;"	f	file:	signature:( const Formula_Object &fobj, vector<Formula_Object> &rpn_output, stack<Formula_Object> &op_stack )
handle_comma	../../libs/libarchfpga/src/expr_eval.cpp	/^static void handle_comma( const Formula_Object &fobj, vector<Formula_Object> &rpn_output,$/;"	p	file:	signature:( const Formula_Object &fobj, vector<Formula_Object> &rpn_output, stack<Formula_Object> &op_stack)
handle_operator	../../libs/libarchfpga/src/expr_eval.cpp	/^static void handle_operator( const Formula_Object &fobj, vector<Formula_Object> &rpn_output,$/;"	f	file:	signature:( const Formula_Object &fobj, vector<Formula_Object> &rpn_output, stack<Formula_Object> &op_stack)
handle_operator	../../libs/libarchfpga/src/expr_eval.cpp	/^static void handle_operator( const Formula_Object &fobj, vector<Formula_Object> &rpn_output,$/;"	p	file:	signature:( const Formula_Object &fobj, vector<Formula_Object> &rpn_output, stack<Formula_Object> &op_stack)
handle_zoom_in	../../libs/libeasygl/src/graphics.cpp	/^handle_zoom_in(float x, float y, void (*drawscreen) ()) {$/;"	f	file:	signature:(float x, float y, void (*drawscreen) ())
handle_zoom_in	../../libs/libeasygl/src/graphics.cpp	/^static void handle_zoom_in(float x, float y, void (*drawscreen) ());$/;"	p	file:	signature:(float x, float y, void (*drawscreen) ())
handle_zoom_out	../../libs/libeasygl/src/graphics.cpp	/^handle_zoom_out(float x, float y, void (*drawscreen) ()) {$/;"	f	file:	signature:(float x, float y, void (*drawscreen) ())
handle_zoom_out	../../libs/libeasygl/src/graphics.cpp	/^static void handle_zoom_out(float x, float y, void (*drawscreen) ());$/;"	p	file:	signature:(float x, float y, void (*drawscreen) ())
has_adjacent_channel	route/check_rr_graph.cpp	/^static bool has_adjacent_channel(const t_rr_node& node, const DeviceGrid& grid) {$/;"	f	file:	signature:(const t_rr_node& node, const DeviceGrid& grid)
has_adjacent_channel	route/check_rr_graph.cpp	/^static bool has_adjacent_channel(const t_rr_node& node, const DeviceGrid& grid);$/;"	p	file:	signature:(const t_rr_node& node, const DeviceGrid& grid)
has_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool has_declaration(xml_node_struct* node)$/;"	f	signature:(xml_node_struct* node)
has_element_node_siblings	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static bool has_element_node_siblings(xml_node_struct* node)$/;"	f	struct:xml_parser	access:public	signature:(xml_node_struct* node)
has_modes	base/vpr_types.h	/^	bool has_modes() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
has_selection	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::has_selection() const {$/;"	f	class:t_selected_sub_block_info	signature:() const
has_selection	draw/intra_logic_block.h	/^	bool has_selection() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
has_unknowns	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bool has_unknowns()$/;"	f	class:BitSpace::BitFields	access:public	signature:()
has_unknowns	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        bool has_unknowns()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
has_valid_T_arr	timing/path_delay.cpp	/^static inline bool has_valid_T_arr(int inode) {$/;"	f	file:	signature:(int inode)
has_valid_T_arr	timing/path_delay.cpp	/^static inline bool has_valid_T_arr(int inode);$/;"	p	file:	signature:(int inode)
has_valid_T_req	timing/path_delay.cpp	/^static inline bool has_valid_T_req(int inode) {$/;"	f	file:	signature:(int inode)
has_valid_T_req	timing/path_delay.cpp	/^static inline bool has_valid_T_req(int inode);$/;"	p	file:	signature:(int inode)
has_valid_normalized_T_arr	timing/path_delay.cpp	/^bool has_valid_normalized_T_arr(int inode) {$/;"	f	signature:(int inode)
has_valid_normalized_T_arr	timing/path_delay.h	/^bool has_valid_normalized_T_arr(int inode);$/;"	p	signature:(int inode)
hash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_hash_table hash;$/;"	m	struct:xml_document_struct	file:	access:public
hash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static unsigned int hash(const void* key)$/;"	f	class:compact_hash_table	file:	access:private	signature:(const void* key)
hash	../../libs/libvtrutil/src/vtr_strong_id.h	/^    struct hash<vtr::StrongId<tag,T,sentinel>> {$/;"	s	namespace:std
hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(RaIter first, RaIter last, OutContainer& dst){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last, OutContainer& dst)
hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(RaIter first, RaIter last, OutIter first2, OutIter last2){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last, OutIter first2, OutIter last2)
hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(const RaContainer& src, OutContainer& dst){$/;"	f	namespace:picosha2	signature:(const RaContainer& src, OutContainer& dst)
hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(const RaContainer& src, OutIter first, OutIter last){$/;"	f	namespace:picosha2	signature:(const RaContainer& src, OutIter first, OutIter last)
hash256_block	../../libs/libvtrutil/src/picosha2.h	/^void hash256_block(RaIter1 message_digest, RaIter2 first, RaIter2 \/*last*\/){$/;"	f	namespace:picosha2::detail	signature:(RaIter1 message_digest, RaIter2 first, RaIter2 )
hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^inline void hash256_hex_string(const std::string& src, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const std::string& src, std::string& hex_str)
hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string hash256_hex_string(RaIter first, RaIter last){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last)
hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string hash256_hex_string(const RaContainer& src){$/;"	f	namespace:picosha2	signature:(const RaContainer& src)
hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void hash256_hex_string(RaIter first, RaIter last, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last, std::string& hex_str)
hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void hash256_hex_string(const RaContainer& src, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const RaContainer& src, std::string& hex_str)
hash256_one_by_one	../../libs/libvtrutil/src/picosha2.h	/^	hash256_one_by_one(){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:()
hash256_one_by_one	../../libs/libvtrutil/src/picosha2.h	/^class hash256_one_by_one {$/;"	c	namespace:picosha2
hash_combine	../../libs/libvtrutil/src/vtr_hash.h	/^inline void hash_combine(std::size_t& seed, const T& v)$/;"	f	namespace:vtr	signature:(std::size_t& seed, const T& v)
hash_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned int hash_string(const char_t* str)$/;"	f	signature:(const char_t* str)
hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xml_attribute::hash_value() const$/;"	f	class:pugi::xml_attribute	signature:() const
hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xml_node::hash_value() const$/;"	f	class:pugi::xml_node	signature:() const
hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t hash_value() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t hash_value() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
hash_value	util/hash.cpp	/^int hash_value(const char *name) {$/;"	f	signature:(const char *name)
hash_value	util/hash.h	/^int hash_value(const char *name);$/;"	p	signature:(const char *name)
head	route/route_common.cpp	/^    t_trace* head;$/;"	m	struct:t_trace_branch	file:	access:public
head	route/route_traceback.h	/^    t_trace* head = nullptr;$/;"	m	struct:t_traceback	access:public
header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_header header;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_header header;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
heap	route/route_common.cpp	/^static t_heap **heap; \/* Indexed from [1..heap_size] *\/$/;"	v	file:
heap_	route/route_common.cpp	/^namespace heap_ {$/;"	n	file:
heap_	route/route_common.h	/^namespace heap_ {$/;"	n
heap_::build_heap	route/route_common.cpp	/^	void build_heap() {$/;"	f	namespace:heap_	signature:()
heap_::build_heap	route/route_common.h	/^	void build_heap();$/;"	p	namespace:heap_	signature:()
heap_::expand_heap_if_full	route/route_common.cpp	/^	void expand_heap_if_full() {$/;"	f	namespace:heap_	signature:()
heap_::expand_heap_if_full	route/route_common.cpp	/^	void expand_heap_if_full();$/;"	p	namespace:heap_	file:	signature:()
heap_::is_valid	route/route_common.cpp	/^	bool is_valid() {$/;"	f	namespace:heap_	signature:()
heap_::is_valid	route/route_common.h	/^	bool is_valid();$/;"	p	namespace:heap_	signature:()
heap_::left	route/route_common.cpp	/^	size_t left(size_t i) {return i << 1;}$/;"	f	namespace:heap_	signature:(size_t i)
heap_::left	route/route_common.cpp	/^	size_t left(size_t i);$/;"	p	namespace:heap_	file:	signature:(size_t i)
heap_::parent	route/route_common.cpp	/^	size_t parent(size_t i) {return i >> 1;}$/;"	f	namespace:heap_	signature:(size_t i)
heap_::parent	route/route_common.cpp	/^	size_t parent(size_t i);$/;"	p	namespace:heap_	file:	signature:(size_t i)
heap_::pop_heap	route/route_common.cpp	/^	void pop_heap() {$/;"	f	namespace:heap_	signature:()
heap_::pop_heap	route/route_common.h	/^	void pop_heap();$/;"	p	namespace:heap_	signature:()
heap_::print_heap	route/route_common.cpp	/^	void print_heap() {$/;"	f	namespace:heap_	signature:()
heap_::print_heap	route/route_common.h	/^	void print_heap();$/;"	p	namespace:heap_	signature:()
heap_::push_back	route/route_common.cpp	/^	void push_back(t_heap* const hptr) {$/;"	f	namespace:heap_	signature:(t_heap* const hptr)
heap_::push_back	route/route_common.h	/^	void push_back(t_heap* const hptr);$/;"	p	namespace:heap_	signature:(t_heap* const hptr)
heap_::push_back_node	route/route_common.cpp	/^	void push_back_node(int inode, float total_cost, int prev_node, int prev_edge,$/;"	f	namespace:heap_	signature:(int inode, float total_cost, int prev_node, int prev_edge, float backward_path_cost, float R_upstream)
heap_::push_back_node	route/route_common.h	/^	void push_back_node(int inode, float total_cost, int prev_node, int prev_edge,$/;"	p	namespace:heap_	signature:(int inode, float total_cost, int prev_node, int prev_edge, float backward_path_cost, float R_upstream)
heap_::right	route/route_common.cpp	/^	size_t right(size_t i) {return (i << 1) + 1;}$/;"	f	namespace:heap_	signature:(size_t i)
heap_::right	route/route_common.cpp	/^	size_t right(size_t i);$/;"	p	namespace:heap_	file:	signature:(size_t i)
heap_::sift_down	route/route_common.cpp	/^	void sift_down(size_t hole) {$/;"	f	namespace:heap_	signature:(size_t hole)
heap_::sift_down	route/route_common.h	/^	void sift_down(size_t hole);$/;"	p	namespace:heap_	signature:(size_t hole)
heap_::sift_up	route/route_common.cpp	/^	void sift_up(size_t leaf, t_heap* const node) {$/;"	f	namespace:heap_	signature:(size_t leaf, t_heap* const node)
heap_::sift_up	route/route_common.h	/^	void sift_up(size_t tail, t_heap* const hptr);$/;"	p	namespace:heap_	signature:(size_t tail, t_heap* const hptr)
heap_::size	route/route_common.cpp	/^	size_t size() {return static_cast<size_t>(heap_tail - 1);}	\/\/ heap[0] is not valid element$/;"	f	namespace:heap_	signature:()
heap_::size	route/route_common.cpp	/^	size_t size();$/;"	p	namespace:heap_	file:	signature:()
heap_::verify_extract_top	route/route_common.cpp	/^	void verify_extract_top() {$/;"	f	namespace:heap_	signature:()
heap_::verify_extract_top	route/route_common.h	/^	void verify_extract_top();$/;"	p	namespace:heap_	signature:()
heap_ch	route/route_common.cpp	/^static vtr::t_chunk heap_ch;$/;"	v	file:
heap_free_head	route/route_common.cpp	/^static t_heap *heap_free_head = nullptr;$/;"	v	file:
heap_pops	route/router_stats.h	/^    size_t heap_pops = 0;$/;"	m	struct:RouterStats	access:public
heap_pushes	route/router_stats.h	/^    size_t heap_pushes = 0;$/;"	m	struct:RouterStats	access:public
heap_size	route/route_common.cpp	/^static int heap_size; \/* Number of slots in the heap array *\/$/;"	v	file:
heap_tail	route/route_common.cpp	/^static int heap_tail; \/* Index of first unused slot in the heap array *\/$/;"	v	file:
height	../../libs/libarchfpga/src/physical_types.h	/^	int height = 0;$/;"	m	struct:t_type_descriptor	access:public
height	../../libs/libarchfpga/src/physical_types.h	/^    int height = -1;                            \/\/Fixed device height (only valid for grid_type == FIXED)$/;"	m	struct:t_grid_def	access:public
height	../../libs/libeasygl/src/graphics.cpp	/^    int height;$/;"	m	struct:__anon18	file:	access:public
height	../../libs/libvtrutil/src/vtr_geometry.h	/^        T height() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
height	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::height() const {$/;"	f	class:vtr::Rect	signature:() const
height	base/device_grid.h	/^        size_t height() const { return grid_.dim_size(1); }$/;"	f	class:DeviceGrid	access:public	signature:() const
height_offset	base/vpr_types.h	/^	int height_offset = 0;$/;"	m	struct:ScreenUpdatePriority::t_grid_tile	access:public
height_offset	route/rr_graph.cpp	/^    int height_offset;$/;"	m	struct:t_pin_loc	file:	access:public
hierarchical_type_name	base/vpr_types.h	/^    std::string hierarchical_type_name() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:latin1_writer	access:public	signature:(value_type result, uint32_t ch)
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer	access:public	signature:(value_type result, uint32_t ch)
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer	access:public	signature:(value_type result, uint32_t ch)
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer	access:public	signature:(value_type result, uint32_t ch)
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf16_counter	access:public	signature:(value_type result, uint32_t)
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf32_counter	access:public	signature:(value_type result, uint32_t)
high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf8_counter	access:public	signature:(value_type result, uint32_t)
high_fanout_threshold	base/vpr_types.h	/^    int high_fanout_threshold;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
high_idx	../../libs/libarchfpga/src/arch_util.h	/^            int high_idx = UNSPECIFIED;$/;"	m	struct:InstPort::name_index	access:public
highlight_blocks	draw/draw.cpp	/^static void highlight_blocks(float abs_x, float abs_y, t_event_buttonPressed button_info) {$/;"	f	file:	signature:(float abs_x, float abs_y, t_event_buttonPressed button_info)
highlight_blocks	draw/draw.cpp	/^static void highlight_blocks(float x, float y, t_event_buttonPressed button_info);$/;"	p	file:	signature:(float x, float y, t_event_buttonPressed button_info)
highlight_nets	draw/draw.cpp	/^static void highlight_nets(char *message, int hit_node) {$/;"	f	file:	signature:(char *message, int hit_node)
highlight_nets	draw/draw.cpp	/^static void highlight_nets(char *message, int hit_node);$/;"	p	file:	signature:(char *message, int hit_node)
highlight_rr_nodes	draw/draw.cpp	/^static bool highlight_rr_nodes(float x, float y) {$/;"	f	file:	signature:(float x, float y)
highlight_rr_nodes	draw/draw.cpp	/^static bool highlight_rr_nodes(float x, float y);$/;"	p	file:	signature:(float x, float y)
highlight_sub_block	draw/intra_logic_block.cpp	/^int highlight_sub_block(const t_point& point_in_clb, ClusterBlockId clb_index, t_pb *pb) {$/;"	f	signature:(const t_point& point_in_clb, ClusterBlockId clb_index, t_pb *pb)
highlight_sub_block	draw/intra_logic_block.h	/^int highlight_sub_block(const t_point& point_in_clb, const ClusterBlockId clb_index, t_pb *pb);$/;"	p	signature:(const t_point& point_in_clb, const ClusterBlockId clb_index, t_pb *pb)
highlight_sub_block_helper	draw/intra_logic_block.cpp	/^t_pb* highlight_sub_block_helper($/;"	f	signature:( const ClusterBlockId clb_index, t_pb* pb, const t_point& local_pt, int max_depth)
highlight_sub_block_helper	draw/intra_logic_block.cpp	/^t_pb* highlight_sub_block_helper(const ClusterBlockId clb_index, t_pb* pb, const t_point& local_pt, int max_depth);$/;"	p	file:	signature:(const ClusterBlockId clb_index, t_pb* pb, const t_point& local_pt, int max_depth)
hill_climbing_flag	base/vpr_types.h	/^	bool hill_climbing_flag;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
hillgain	pack/pack_types.h	/^	std::map<AtomBlockId, float> hillgain;$/;"	m	struct:t_pb_stats	access:public
hist_fac	pack/pack_types.h	/^	float hist_fac;$/;"	m	struct:t_lb_router_params	access:public
historical_usage	pack/pack_types.h	/^	int historical_usage;					\/* Historical usage of using this node *\/$/;"	m	struct:t_lb_rr_node_stats	access:public
history_factor_	route/routing_predictor.h	/^    float history_factor_;$/;"	m	class:RoutingPredictor	access:private
hmetis_input_file	base/read_options.h	/^    argparse::ArgValue<std::string> hmetis_input_file;$/;"	m	struct:t_options	access:public
hmetis_input_file	base/vpr_types.h	/^	std::string hmetis_input_file;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
hold_analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::HoldTimingAnalyzer> hold_analyzer() const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:() const
hold_analyzer_	timing/concrete_timing_info.h	/^        std::shared_ptr<tatum::HoldTimingAnalyzer> hold_analyzer_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
hold_capture_cycle	timing/read_sdc2.cpp	/^        int hold_capture_cycle(tatum::DomainId from, tatum::DomainId to) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId from, tatum::DomainId to) const
hold_mcp_overrides_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>,int> hold_mcp_overrides_;$/;"	m	class:SdcParseCallback2	file:	access:private
hold_override_constraints_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>, float> hold_override_constraints_;$/;"	m	class:SdcParseCallback2	file:	access:private
hold_pin_criticality	timing/slack_evaluation.cpp	/^float HoldSlackCrit::hold_pin_criticality(AtomPinId pin) const { return pin_criticalities_[pin]; }$/;"	f	class:HoldSlackCrit	signature:(AtomPinId pin) const
hold_pin_criticality	timing/slack_evaluation.h	/^        float hold_pin_criticality(AtomPinId pin) const;$/;"	p	class:HoldSlackCrit	access:public	signature:(AtomPinId pin) const
hold_pin_criticality	timing/timing_info.h	/^        virtual float hold_pin_criticality(AtomPinId pin) const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:(AtomPinId pin) const
hold_pin_slack	timing/slack_evaluation.cpp	/^float HoldSlackCrit::hold_pin_slack(AtomPinId pin) const { return pin_slacks_[pin]; }$/;"	f	class:HoldSlackCrit	signature:(AtomPinId pin) const
hold_pin_slack	timing/slack_evaluation.h	/^        float hold_pin_slack(AtomPinId pin) const;$/;"	p	class:HoldSlackCrit	access:public	signature:(AtomPinId pin) const
hold_pin_slack	timing/timing_info.h	/^        virtual float hold_pin_slack(AtomPinId pin) const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:(AtomPinId pin) const
hold_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
hold_timing_	timing/concrete_timing_info.h	/^        ConcreteHoldTimingInfo<DelayCalc> hold_timing_;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
hold_total_negative_slack	timing/timing_info.h	/^        virtual float hold_total_negative_slack() const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:() const
hold_worst_negative_slack	timing/timing_info.h	/^        virtual float hold_worst_negative_slack() const = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:() const
hsl	draw/hsl.h	/^struct hsl {$/;"	s
hsl2color	draw/hsl.cpp	/^t_color hsl2color(hsl in) {$/;"	f	signature:(hsl in)
hsl2color	draw/hsl.h	/^t_color   hsl2color(hsl in);$/;"	p	signature:(hsl in)
hsl::h	draw/hsl.h	/^    double h;       \/\/ a fraction between 0 and 1$/;"	m	struct:hsl	access:public
hsl::l	draw/hsl.h	/^    double l;       \/\/ a fraction between 0 and 1$/;"	m	struct:hsl	access:public
hsl::s	draw/hsl.h	/^    double s;       \/\/ a fraction between 0 and 1$/;"	m	struct:hsl	access:public
hue2rgb	draw/hsl.cpp	/^float hue2rgb(float v1, float v2, float vH) {$/;"	f	signature:(float v1, float v2, float vH)
hue2rgb	draw/hsl.cpp	/^float hue2rgb(float v1, float v2, float vH);$/;"	p	file:	signature:(float v1, float v2, float vH)
hwnd	../../libs/libeasygl/src/graphics.cpp	/^    HWND hwnd;$/;"	m	struct:__anon18	file:	access:public
i	util/hash.h	/^	int i;$/;"	m	struct:t_hash_iterator	access:public
i_ds	power/power.h	/^	float i_ds;$/;"	m	struct:t_power_nmos_leakage_pair	access:public
id_	../../libs/libvtrutil/src/vtr_strong_id.h	/^        T id_;$/;"	m	class:vtr::StrongId	access:private
identifier_length	../../libs/libarchfpga/src/expr_eval.cpp	/^static int identifier_length (const char* str) {$/;"	f	file:	signature:(const char* str)
identifier_length	../../libs/libarchfpga/src/expr_eval.cpp	/^static int identifier_length (const char* str);$/;"	p	file:	signature:(const char* str)
identify_buffer_luts	base/atom_netlist_utils.cpp	/^std::vector<AtomBlockId> identify_buffer_luts(const AtomNetlist& netlist) {$/;"	f	signature:(const AtomNetlist& netlist)
identify_buffer_luts	base/atom_netlist_utils.cpp	/^std::vector<AtomBlockId> identify_buffer_luts(const AtomNetlist& netlist);$/;"	p	file:	signature:(const AtomNetlist& netlist)
identify_non_configurable_rr_sets	route/check_route.cpp	/^static t_non_configurable_rr_sets identify_non_configurable_rr_sets() {$/;"	f	file:	signature:()
identify_non_configurable_rr_sets	route/check_route.cpp	/^static t_non_configurable_rr_sets identify_non_configurable_rr_sets();$/;"	p	file:	signature:()
identify_primitive_candidate_block_types	pack/cluster.cpp	/^static std::map<const t_model*,std::vector<t_type_ptr>> identify_primitive_candidate_block_types() {$/;"	f	file:	signature:()
identify_primitive_candidate_block_types	pack/cluster.cpp	/^static std::map<const t_model*,std::vector<t_type_ptr>> identify_primitive_candidate_block_types();$/;"	p	file:	signature:()
identify_strongly_connected_components	timing/path_delay2.cpp	/^std::vector<std::vector<int> > identify_strongly_connected_components(size_t min_size) {$/;"	f	signature:(size_t min_size)
identify_strongly_connected_components	timing/path_delay2.cpp	/^std::vector<std::vector<int> > identify_strongly_connected_components(size_t min_size);$/;"	p	file:	signature:(size_t min_size)
idim_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const size_t idim_;$/;"	m	class:vtr::NdMatrixProxy	access:private
idim_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const size_t idim_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
if_set	route/route_budgets.cpp	/^bool route_budgets::if_set() const {$/;"	f	class:route_budgets	signature:() const
if_set	route/route_budgets.h	/^    bool if_set() const;$/;"	p	class:route_budgets	access:public	signature:() const
impl_	../../libs/libeasygl/src/Surface.h	/^        std::unique_ptr<SurfaceImpl> impl_;$/;"	m	class:Surface	access:private
in_dens	power/power.h	/^	float * in_dens; \/* Switching density of inputs *\/$/;"	m	struct:t_rr_node_power	access:public
in_flight	base/vpr_types.h	/^	t_cluster_placement_primitive *in_flight; \/* ptrs to primitives currently being considered *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
in_prob	power/power.h	/^	float * in_prob; \/* Static probability of inputs *\/$/;"	m	struct:t_rr_node_power	access:public
in_selected_subtree	draw/intra_logic_block.h	/^	std::unordered_set< gnode_clb_pair, sel_subblk_hasher > in_selected_subtree;$/;"	m	struct:t_selected_sub_block_info	access:private
in_value	../../libs/libarchfpga/src/physical_types.h	/^    float in_value;					\/\/Input Fc value$/;"	m	struct:t_default_fc_spec	access:public
in_value_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_value_type in_value_type;	\/\/Type of the input value (frac or abs)$/;"	m	struct:t_default_fc_spec	access:public
incr_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string incr_expr;   \/\/Distance between block instantiations$/;"	m	struct:t_grid_loc_spec	access:public
incr_reroute_delay_ripup	base/read_options.h	/^    argparse::ArgValue<e_incr_reroute_delay_ripup> incr_reroute_delay_ripup;$/;"	m	struct:t_options	access:public
incr_reroute_delay_ripup	base/vpr_types.h	/^    e_incr_reroute_delay_ripup incr_reroute_delay_ripup;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
incremental_cost	../../libs/libarchfpga/src/cad_types.h	/^	float incremental_cost; \/* cost dependant on current status of packing *\/$/;"	m	struct:t_cluster_placement_primitive	access:public
indent	base/netlist_writer.cpp	/^std::string indent(size_t depth) {$/;"	f	signature:(size_t depth)
indent	base/netlist_writer.cpp	/^std::string indent(size_t depth);$/;"	p	file:	signature:(size_t depth)
indent_flags_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum indent_flags_t$/;"	g	file:
indent_indent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		indent_indent = 2$/;"	e	enum:indent_flags_t	file:
indent_newline	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		indent_newline = 1,$/;"	e	enum:indent_flags_t	file:
index	../../libs/libarchfpga/src/cad_types.h	/^	int index; \/* array index  for pattern*\/$/;"	m	struct:t_pack_patterns	access:public
index	../../libs/libarchfpga/src/logic_types.h	/^	int index = -1; \/* indexing for array look-up *\/$/;"	m	struct:t_model_ports	access:public
index	../../libs/libarchfpga/src/logic_types.h	/^	int index = -1;$/;"	m	struct:t_model	access:public
index	../../libs/libarchfpga/src/physical_types.h	/^	int index = -1; \/* index of type descriptor in array (allows for index referencing) *\/$/;"	m	struct:t_type_descriptor	access:public
index	../../libs/libarchfpga/src/physical_types.h	/^	int index;$/;"	m	struct:t_mode	access:public
index	../../libs/libarchfpga/src/physical_types.h	/^	int index;$/;"	m	struct:t_port	access:public
index	base/vpr_types.h	/^	int index = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
index	base/vpr_types.h	/^	int index;$/;"	m	struct:ScreenUpdatePriority::t_trace	access:public
index	base/vpr_types.h	/^        int index() const { return seg_detail_->index; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
index	route/route_common.h	/^	int index = OPEN;$/;"	m	struct:t_heap	access:public
index	util/hash.h	/^	int index;$/;"	m	struct:t_hash	access:public
index_into_correct_chan	route/build_switchblocks.cpp	/^static const t_chan_details& index_into_correct_chan(int tile_x, int tile_y, enum e_side side,$/;"	f	file:	signature:(int tile_x, int tile_y, enum e_side side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int *set_x, int *set_y, t_rr_type* chan_type)
index_into_correct_chan	route/build_switchblocks.cpp	/^static const t_chan_details& index_into_correct_chan(int tile_x, int tile_y, enum e_side side,$/;"	p	file:	signature:(int tile_x, int tile_y, enum e_side side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int *chan_x, int *chan_y, t_rr_type* chan_type)
inet	pack/pack_types.h	/^	int inet;				\/* net index of route tree *\/$/;"	m	struct:t_explored_node_tb	access:public
infer_and_mark_block_combinational_outputs_constant	base/atom_netlist_utils.cpp	/^int infer_and_mark_block_combinational_outputs_constant(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_block_combinational_outputs_constant	base/atom_netlist_utils.cpp	/^int infer_and_mark_block_combinational_outputs_constant(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity);$/;"	p	file:	signature:(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_block_pins_constant	base/atom_netlist_utils.cpp	/^int infer_and_mark_block_pins_constant(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity);$/;"	p	file:	signature:(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_block_pins_constant	base/atom_netlist_utils.cpp	/^int infer_and_mark_block_pins_constant(AtomNetlist& netlist, AtomBlockId block, e_const_gen_inference const_gen_inference_method, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, AtomBlockId block, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_block_sequential_outputs_constant	base/atom_netlist_utils.cpp	/^int infer_and_mark_block_sequential_outputs_constant(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_block_sequential_outputs_constant	base/atom_netlist_utils.cpp	/^int infer_and_mark_block_sequential_outputs_constant(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity);$/;"	p	file:	signature:(AtomNetlist& netlist, AtomBlockId blk, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_constant_pins	base/atom_netlist_utils.cpp	/^int infer_and_mark_constant_pins(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_and_mark_constant_pins	base/atom_netlist_utils.cpp	/^int infer_and_mark_constant_pins(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity);$/;"	p	file:	signature:(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity)
infer_annotations	../../libs/libarchfpga/src/physical_types.h	/^	bool infer_annotations;$/;"	m	struct:t_interconnect	access:public
infer_logic_block_type	util/vpr_utils.cpp	/^t_type_ptr infer_logic_block_type(const DeviceGrid& grid) {$/;"	f	signature:(const DeviceGrid& grid)
infer_logic_block_type	util/vpr_utils.h	/^t_type_ptr infer_logic_block_type(const DeviceGrid& grid);$/;"	p	signature:(const DeviceGrid& grid)
infer_pattern	../../libs/libarchfpga/src/physical_types.h	/^	bool infer_pattern; \/*If true, infer pattern based on patterns connected to it*\/$/;"	m	struct:t_pb_graph_edge	access:public
inferno_data	../../libs/libvtrutil/src/vtr_color_map.cpp	/^static std::vector<Color<float>> inferno_data = {$/;"	m	namespace:vtr	file:
inferr_unspecified_pb_graph_edge_delays	pack/pb_type_graph_annotations.cpp	/^static void inferr_unspecified_pb_graph_edge_delays(t_pb_graph_edge* pb_graph_edge) {$/;"	f	file:	signature:(t_pb_graph_edge* pb_graph_edge)
inferr_unspecified_pb_graph_edge_delays	pack/pb_type_graph_annotations.cpp	/^static void inferr_unspecified_pb_graph_edge_delays(t_pb_graph_edge* pb_graph_pin);$/;"	p	file:	signature:(t_pb_graph_edge* pb_graph_pin)
inferr_unspecified_pb_graph_node_delays	pack/pb_type_graph_annotations.cpp	/^static void inferr_unspecified_pb_graph_node_delays(t_pb_graph_node* pb_graph_node) {$/;"	f	file:	signature:(t_pb_graph_node* pb_graph_node)
inferr_unspecified_pb_graph_node_delays	pack/pb_type_graph_annotations.cpp	/^static void inferr_unspecified_pb_graph_node_delays(t_pb_graph_node* pb_graph_node);$/;"	p	file:	signature:(t_pb_graph_node* pb_graph_node)
inferr_unspecified_pb_graph_pin_delays	pack/pb_type_graph_annotations.cpp	/^static void inferr_unspecified_pb_graph_pin_delays(t_pb_graph_pin* pb_graph_pin) {$/;"	f	file:	signature:(t_pb_graph_pin* pb_graph_pin)
inferr_unspecified_pb_graph_pin_delays	pack/pb_type_graph_annotations.cpp	/^static void inferr_unspecified_pb_graph_pin_delays(t_pb_graph_pin* pb_graph_pin);$/;"	p	file:	signature:(t_pb_graph_pin* pb_graph_pin)
init	../../libs/libvtrutil/src/picosha2.h	/^	void init(){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:()
init_atom_timing_net_pins	timing/path_delay.cpp	/^static std::vector<size_t> init_atom_timing_net_pins();$/;"	p	file:	signature:()
init_atom_timing_net_pins	timing/path_delay.cpp	/^std::vector<size_t> init_atom_timing_net_pins() {$/;"	f	signature:()
init_cairo	../../libs/libeasygl/src/graphics.cpp	/^static void init_cairo() {$/;"	f	file:	signature:()
init_cairo	../../libs/libeasygl/src/graphics.cpp	/^static void init_cairo();$/;"	p	file:	signature:()
init_cb_structs	route/cb_metrics.cpp	/^static void init_cb_structs( const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf,$/;"	p	file:	signature:( const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf, const e_pin_type pin_type, const int num_pin_type_pins, const int nodes_per_chan, const int Fc, Conn_Block_Metrics *cb_metrics)
init_cb_structs	route/cb_metrics.cpp	/^static void init_cb_structs(const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf,$/;"	f	file:	signature:(const t_type_ptr block_type, int *****tracks_connected_to_pin, const int num_segments, const t_segment_inf *segment_inf, const e_pin_type pin_type, const int num_pin_type_pins, const int nodes_per_chan, const int Fc, Conn_Block_Metrics *cb_metrics)
init_chan	base/place_and_route.cpp	/^t_chan_width init_chan(int cfactor, t_chan_width_dist chan_width_dist) {$/;"	f	signature:(int cfactor, t_chan_width_dist chan_width_dist)
init_chan	base/place_and_route.h	/^t_chan_width init_chan(int cfactor, t_chan_width_dist chan_width_dist);$/;"	p	signature:(int cfactor, t_chan_width_dist chan_width_dist)
init_chan_details	route/rr_graph2.cpp	/^t_chan_details init_chan_details($/;"	f	signature:( const DeviceGrid& grid, const t_chan_width* nodes_per_chan, const int num_seg_details, const t_seg_details* seg_details, const enum e_seg_details_type seg_details_type)
init_chan_details	route/rr_graph2.h	/^t_chan_details init_chan_details($/;"	p	signature:( const DeviceGrid& grid, const t_chan_width *nodes_per_chan, const int num_seg_details, const t_seg_details *seg_details, const enum e_seg_details_type seg_details_type)
init_draw_coords	draw/draw.cpp	/^void init_draw_coords(float width_val) {$/;"	f	signature:(float width_val)
init_draw_coords	draw/draw.h	/^void init_draw_coords(float clb_width);$/;"	p	signature:(float clb_width)
init_draw_coords	draw/draw_types.h	/^	friend void init_draw_coords(float);$/;"	p	struct:t_draw_coords	access:friend	signature:(float)
init_fan_in	route/rr_graph.cpp	/^void init_fan_in(std::vector<t_rr_node>& L_rr_node, const int num_rr_nodes) {$/;"	f	signature:(std::vector<t_rr_node>& L_rr_node, const int num_rr_nodes)
init_fan_in	route/rr_graph.h	/^void init_fan_in(std::vector<t_rr_node>& L_rr_node, const int num_rr_nodes);$/;"	p	signature:(std::vector<t_rr_node>& L_rr_node, const int num_rr_nodes)
init_graphics	../../libs/libeasygl/src/graphics.cpp	/^init_graphics(const std::string& window_name, int cindex) {$/;"	f	signature:(const std::string& window_name, int cindex)
init_graphics	../../libs/libeasygl/src/graphics.cpp	/^void init_graphics(const std::string& \/*window_name*\/, const t_color& \/*background*\/) { }$/;"	f	signature:(const std::string& , const t_color& )
init_graphics	../../libs/libeasygl/src/graphics.cpp	/^void init_graphics(const std::string& \/*window_name*\/, int \/*cindex*\/) { }$/;"	f	signature:(const std::string& , int )
init_graphics	../../libs/libeasygl/src/graphics.cpp	/^void init_graphics(const std::string& window_name, const t_color& background) {$/;"	f	signature:(const std::string& window_name, const t_color& background)
init_graphics	../../libs/libeasygl/src/graphics.h	/^void init_graphics(const std::string& window_name, const t_color& background);$/;"	p	signature:(const std::string& window_name, const t_color& background)
init_graphics	../../libs/libeasygl/src/graphics.h	/^void init_graphics(const std::string& window_name, int cindex_background);$/;"	p	signature:(const std::string& window_name, int cindex_background)
init_graphics_state	draw/draw.cpp	/^void init_graphics_state(bool show_graphics_val, int gr_automode_val,$/;"	f	signature:(bool show_graphics_val, int gr_automode_val, enum e_route_type route_type)
init_graphics_state	draw/draw.h	/^void init_graphics_state(bool show_graphics_val, int gr_automode_val,$/;"	p	signature:(bool show_graphics_val, int gr_automode_val, enum e_route_type route_type)
init_grid_blocks	place/place_util.cpp	/^static vtr::Matrix<t_grid_blocks> init_grid_blocks() {$/;"	f	file:	signature:()
init_grid_blocks	place/place_util.cpp	/^static vtr::Matrix<t_grid_blocks> init_grid_blocks();$/;"	p	file:	signature:()
init_heap	route/route_common.cpp	/^void init_heap(const DeviceGrid& grid) {$/;"	f	signature:(const DeviceGrid& grid)
init_heap	route/route_common.h	/^void init_heap(const DeviceGrid& grid);$/;"	p	signature:(const DeviceGrid& grid)
init_lookup	base/clustered_netlist_utils.cpp	/^void ClusteredPinAtomPinsLookup::init_lookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup) {$/;"	f	class:ClusteredPinAtomPinsLookup	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
init_lookup	base/clustered_netlist_utils.h	/^        void init_lookup(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup);$/;"	p	class:ClusteredPinAtomPinsLookup	access:private	signature:(const ClusteredNetlist& clustered_netlist, const IntraLbPbPinLookup& pb_gpin_lookup)
init_mux_arch_default	power/power_util.cpp	/^static void init_mux_arch_default(t_mux_arch * mux_arch, int levels,$/;"	f	file:	signature:(t_mux_arch * mux_arch, int levels, int num_inputs, float transistor_size)
init_mux_arch_default	power/power_util.cpp	/^static void init_mux_arch_default(t_mux_arch * mux_arch, int levels,$/;"	p	file:	signature:(t_mux_arch * mux_arch, int levels, int num_inputs, float transistor_size)
init_placement_context	place/place_util.cpp	/^void init_placement_context() {$/;"	f	signature:()
init_placement_context	place/place_util.h	/^void init_placement_context();$/;"	p	signature:()
init_postscript	../../libs/libeasygl/src/graphics.cpp	/^int init_postscript(const char *fname) {$/;"	f	signature:(const char *fname)
init_postscript	../../libs/libeasygl/src/graphics.cpp	/^int init_postscript(const char* \/*fname*\/) {$/;"	f	signature:(const char* )
init_postscript	../../libs/libeasygl/src/graphics.h	/^int init_postscript(const char *fname); \/* Returns 1 if successful *\/$/;"	p	signature:(const char *fname)
init_route_structs	route/route_common.cpp	/^void init_route_structs(int bb_factor) {$/;"	f	signature:(int bb_factor)
init_route_structs	route/route_common.h	/^void init_route_structs(int bb_factor);$/;"	p	signature:(int bb_factor)
init_route_tree_to_source	route/route_tree_timing.cpp	/^t_rt_node* init_route_tree_to_source(ClusterNetId inet) {$/;"	f	signature:(ClusterNetId inet)
init_route_tree_to_source	route/route_tree_timing.h	/^t_rt_node *init_route_tree_to_source(ClusterNetId inet);$/;"	p	signature:(ClusterNetId inet)
init_route_tree_to_source_no_net	route/route_tree_timing.cpp	/^init_route_tree_to_source_no_net(int inode) {$/;"	f	signature:(int inode)
init_route_tree_to_source_no_net	route/route_tree_timing.h	/^t_rt_node* init_route_tree_to_source_no_net(int inode);$/;"	p	signature:(int inode)
init_t	base/vpr_types.h	/^	float init_t;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
init_timing_net_pins	timing/path_delay.cpp	/^static std::vector<size_t> init_timing_net_pins();$/;"	p	file:	signature:()
init_timing_net_pins	timing/path_delay.cpp	/^std::vector<size_t> init_timing_net_pins() {$/;"	f	signature:()
init_xleft	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
init_xright	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
init_ybot	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
init_ytop	../../libs/libeasygl/src/graphics.cpp	/^    float init_xleft, init_xright, init_ytop, init_ybot;$/;"	m	struct:__anon20	file:	access:public
initial_max_rss_	../../libs/libvtrutil/src/vtr_time.h	/^            size_t initial_max_rss_; \/\/Maximum resident set size In bytes$/;"	m	class:vtr::Timer	access:private
initial_message_digest	../../libs/libvtrutil/src/picosha2.h	/^const word_t initial_message_digest[8] = {$/;"	m	namespace:picosha2::detail
initial_placement	place/place.cpp	/^static void initial_placement(enum e_pad_loc_type pad_loc_type,$/;"	f	file:	signature:(enum e_pad_loc_type pad_loc_type, const char *pad_loc_file)
initial_placement	place/place.cpp	/^static void initial_placement(enum e_pad_loc_type pad_loc_type,$/;"	p	file:	signature:(enum e_pad_loc_type pad_loc_type, const char *pad_loc_file)
initial_placement_blocks	place/place.cpp	/^static void initial_placement_blocks(int * free_locations, enum e_pad_loc_type pad_loc_type) {$/;"	f	file:	signature:(int * free_locations, enum e_pad_loc_type pad_loc_type)
initial_placement_blocks	place/place.cpp	/^static void initial_placement_blocks(int * free_locations, enum e_pad_loc_type pad_loc_type);$/;"	p	file:	signature:(int * free_locations, enum e_pad_loc_type pad_loc_type)
initial_placement_location	place/place.cpp	/^static void initial_placement_location(int * free_locations, ClusterBlockId blk_id,$/;"	f	file:	signature:(int * free_locations, ClusterBlockId blk_id, int *pipos, int *px_to, int *py_to, int *pz_to)
initial_placement_location	place/place.cpp	/^static void initial_placement_location(int * free_locations, ClusterBlockId blk_id,$/;"	p	file:	signature:(int * free_locations, ClusterBlockId blk_id, int *pipos, int *px, int *py, int *pz)
initial_placement_pl_macros	place/place.cpp	/^static void initial_placement_pl_macros(int macros_max_num_tries, int * free_locations) {$/;"	f	file:	signature:(int macros_max_num_tries, int * free_locations)
initial_placement_pl_macros	place/place.cpp	/^static void initial_placement_pl_macros(int macros_max_num_tries, int * free_locations);$/;"	p	file:	signature:(int macros_max_num_tries, int * free_locations)
initial_pres_fac	base/read_options.h	/^    argparse::ArgValue<float> initial_pres_fac;$/;"	m	struct:t_options	access:public
initial_pres_fac	base/vpr_types.h	/^	float initial_pres_fac;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
initial_value_	base/netlist_writer.cpp	/^        vtr::LogicValue initial_value_;$/;"	m	class:LatchInst	file:	access:private
initialize_seed_atoms	pack/cluster.cpp	/^static std::vector<AtomBlockId> initialize_seed_atoms(const e_cluster_seed seed_type,$/;"	f	file:	signature:(const e_cluster_seed seed_type, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const t_molecule_stats& max_molecule_stats, const vtr::vector<AtomBlockId,float>& atom_criticality)
initialize_seed_atoms	pack/cluster.cpp	/^static std::vector<AtomBlockId> initialize_seed_atoms(const e_cluster_seed seed_type,$/;"	p	file:	signature:(const e_cluster_seed seed_type, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const t_molecule_stats& max_molecule_stats, const vtr::vector<AtomBlockId,float>& atom_criticality)
initialized	../../libs/libeasygl/src/graphics_state.h	/^    bool initialized = false;$/;"	m	struct:t_gl_state	access:public
inner_loop_recompute_divider	base/read_options.h	/^    argparse::ArgValue<int> inner_loop_recompute_divider;$/;"	m	struct:t_options	access:public
inner_loop_recompute_divider	base/vpr_types.h	/^	int inner_loop_recompute_divider;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
inner_num	base/vpr_types.h	/^	float inner_num;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	access:public
inode	route/route_tree_type.h	/^	int inode;$/;"	m	struct:t_rt_node	access:public
inode	timing/net_delay.cpp	/^	int inode;$/;"	m	struct:t_rc_node	file:	access:public
inport_link_pin	../../libs/libarchfpga/src/cad_types.h	/^	int inport_link_pin; \/* applicable pin of chain input port *\/$/;"	m	struct:t_model_chain_pattern	access:public
input_edges	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_edge** input_edges = nullptr; \/* [0..num_input_edges] *\/$/;"	m	struct:t_pb_graph_pin	access:public
input_link_port	../../libs/libarchfpga/src/cad_types.h	/^	t_model_ports *input_link_port; \/* pointer to port of chain input *\/$/;"	m	struct:t_model_chain_pattern	access:public
input_pin	pack/pb_type_graph.h	/^	t_pb_graph_pin* input_pin;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
input_pin_class_size	../../libs/libarchfpga/src/physical_types.h	/^	int *input_pin_class_size; \/* Stores the number of pins that belong to a particular input pin class *\/$/;"	m	struct:t_pb_graph_node	access:public
input_pin_id_in_cluster	pack/pb_type_graph.h	/^	int input_pin_id_in_cluster;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
input_pin_util	base/vpr_types.h	/^    float input_pin_util = 1.;$/;"	m	struct:ScreenUpdatePriority::t_ext_pin_util	access:public
input_pins	../../libs/libarchfpga/src/physical_types.h	/^	char *input_pins;$/;"	m	struct:t_pin_to_pin_annotation	access:public
input_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin ***input_pins; \/\/ [0..num_input_ports-1][0..num_pins_per_port-1]$/;"	m	struct:t_interconnect_pins	access:public
input_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **input_pins; \/* [0..num_input_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:t_pb_graph_node	access:public
input_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **input_pins;$/;"	m	struct:t_pb_graph_edge	access:public
input_pins_used	pack/pack_types.h	/^    std::vector<std::vector<AtomNetId>> input_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of input pins of this class that are used *\/$/;"	m	struct:t_pb_stats	access:public
input_port_conns_	base/netlist_writer.cpp	/^        std::map<std::string,std::vector<std::string>> input_port_conns_;$/;"	m	class:BlackBoxInst	file:	access:private
input_string	../../libs/libarchfpga/src/physical_types.h	/^	char *input_string;$/;"	m	struct:t_interconnect	access:public
input_types	base/vpr_context.h	/^    std::set<t_type_ptr> input_types;$/;"	m	struct:DeviceContext	access:public
inputs	../../libs/libarchfpga/src/logic_types.h	/^	t_model_ports *inputs = nullptr; \/* linked list of input\/clock ports *\/$/;"	m	struct:t_model	access:public
inputs_	base/netlist_writer.cpp	/^        std::vector<std::string> inputs_; \/\/Name of circuit inputs$/;"	m	class:NetlistWriterVisitor	file:	access:private
insert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void** insert(const void* key)$/;"	f	class:compact_hash_table	access:public	signature:(const void* key)
insert	../../libs/libvtrutil/src/vtr_bimap.h	/^        std::pair<iterator,bool> insert(const K key, const V value) {$/;"	f	class:vtr::bimap	access:public	signature:(const K key, const V value)
insert	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator insert(const_iterator position, const value_type& value) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator position, const value_type& value)
insert	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:vtr::flat_map	access:public	signature:(const value_type& value)
insert	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void insert(InputIterator first, InputIterator last) {$/;"	f	class:vtr::flat_map	access:public	signature:(InputIterator first, InputIterator last)
insert	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:vtr::linear_map	access:public	signature:(const value_type& value)
insert	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void insert(InputIterator first, InputIterator last) {$/;"	f	class:vtr::linear_map	access:public	signature:(InputIterator first, InputIterator last)
insert	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void insert(const K key, const V value) {$/;"	f	class:vtr::vector_map	access:public	signature:(const K key, const V value)
insert_attribute_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_attribute_after(const char_t* name_, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_attribute& attr)
insert_attribute_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void insert_attribute_after(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)$/;"	f	signature:(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)
insert_attribute_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_attribute_after(const char_t* name, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_attribute& attr)
insert_attribute_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_attribute_before(const char_t* name_, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_attribute& attr)
insert_attribute_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void insert_attribute_before(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)$/;"	f	signature:(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)
insert_attribute_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_attribute_before(const char_t* name, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_attribute& attr)
insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_after(const char_t* name_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_node& node)
insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_after(xml_node_type type_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_, const xml_node& node)
insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_after(const char_t* name, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_node& node)
insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_after(xml_node_type type, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type, const xml_node& node)
insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_before(const char_t* name_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_node& node)
insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_before(xml_node_type type_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_, const xml_node& node)
insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_before(const char_t* name, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_node& node)
insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_before(xml_node_type type, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type, const xml_node& node)
insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_copy_after(const xml_attribute& proto, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto, const xml_attribute& attr)
insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_copy_after(const xml_node& proto, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto, const xml_node& node)
insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_copy_after(const xml_attribute& proto, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto, const xml_attribute& attr)
insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_copy_after(const xml_node& proto, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto, const xml_node& node)
insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_copy_before(const xml_attribute& proto, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto, const xml_attribute& attr)
insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_copy_before(const xml_node& proto, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto, const xml_node& node)
insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_copy_before(const xml_attribute& proto, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto, const xml_attribute& attr)
insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_copy_before(const xml_node& proto, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto, const xml_node& node)
insert_in_hash_table	util/hash.cpp	/^insert_in_hash_table(t_hash **hash_table, const char *name,$/;"	f	signature:(t_hash **hash_table, const char *name, int next_free_index)
insert_in_hash_table	util/hash.h	/^t_hash *insert_in_hash_table(t_hash **hash_table, const char *name,$/;"	p	signature:(t_hash **hash_table, const char *name, int next_free_index)
insert_in_int_list	../../libs/libvtrutil/src/vtr_list.cpp	/^t_linked_int *insert_in_int_list(t_linked_int * head, int data,$/;"	f	namespace:vtr	signature:(t_linked_int * head, int data, t_linked_int ** free_list_head_ptr)
insert_in_int_list	../../libs/libvtrutil/src/vtr_list.h	/^    t_linked_int *insert_in_int_list(t_linked_int * head, int data,$/;"	p	namespace:vtr	signature:(t_linked_int * head, int data, t_linked_int ** free_list_head_ptr)
insert_in_vptr_list	../../libs/libvtrutil/src/vtr_list.cpp	/^t_linked_vptr *insert_in_vptr_list(t_linked_vptr *head, void *vptr_to_add) {$/;"	f	namespace:vtr	signature:(t_linked_vptr *head, void *vptr_to_add)
insert_in_vptr_list	../../libs/libvtrutil/src/vtr_list.h	/^    t_linked_vptr *insert_in_vptr_list(t_linked_vptr *head,$/;"	p	namespace:vtr	signature:(t_linked_vptr *head, void *vptr_to_add)
insert_move_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_move_after(const xml_node& moved, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved, const xml_node& node)
insert_move_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_move_after(const xml_node& moved, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved, const xml_node& node)
insert_move_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_move_before(const xml_node& moved, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved, const xml_node& node)
insert_move_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_move_before(const xml_node& moved, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved, const xml_node& node)
insert_node_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void insert_node_after(xml_node_struct* child, xml_node_struct* node)$/;"	f	signature:(xml_node_struct* child, xml_node_struct* node)
insert_node_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void insert_node_before(xml_node_struct* child, xml_node_struct* node)$/;"	f	signature:(xml_node_struct* child, xml_node_struct* node)
insertion_sort	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I, typename Pred, typename T> void insertion_sort(I begin, I end, const Pred& pred, T*)$/;"	f	signature:(I begin, I end, const Pred& pred, T*)
inst_name_	base/netlist_writer.cpp	/^        std::string inst_name_;$/;"	m	class:BlackBoxInst	file:	access:private
inst_name_	base/netlist_writer.cpp	/^        std::string inst_name_;$/;"	m	class:LutInst	file:	access:private
inst_port_to_port_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^std::string inst_port_to_port_name(std::string inst_port) {$/;"	f	signature:(std::string inst_port)
inst_port_to_port_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^std::string inst_port_to_port_name(std::string inst_port);$/;"	p	file:	signature:(std::string inst_port)
instance	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state *t_win32_state::instance = NULL;$/;"	m	class:t_win32_state	file:
instance	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state *t_x11_state::instance = nullptr;$/;"	m	class:t_x11_state	file:
instance	../../libs/libeasygl/src/graphics_state.h	/^    static t_win32_state *instance;$/;"	m	class:t_win32_state	access:private
instance	../../libs/libeasygl/src/graphics_state.h	/^    static t_x11_state *instance;$/;"	m	class:t_x11_state	access:private
instance_	../../libs/libarchfpga/src/arch_util.h	/^        name_index instance_;$/;"	m	class:InstPort	access:private
instance_counts_	base/device_grid.h	/^        std::map<t_type_ptr,size_t> instance_counts_;$/;"	m	class:DeviceGrid	access:private
instance_high_index	../../libs/libarchfpga/src/arch_util.h	/^        int instance_high_index() const { return instance_.high_idx; }$/;"	f	class:InstPort	access:public	signature:() const
instance_low_index	../../libs/libarchfpga/src/arch_util.h	/^        int instance_low_index() const { return instance_.low_idx; }$/;"	f	class:InstPort	access:public	signature:() const
instance_name	../../libs/libarchfpga/src/arch_util.h	/^        std::string instance_name() const { return instance_.name; }$/;"	f	class:InstPort	access:public	signature:() const
instance_name	base/netlist_writer.cpp	/^        std::string instance_name() { return inst_name_; }$/;"	f	class:LutInst	access:public	signature:()
instance_name_	base/netlist_writer.cpp	/^        std::string instance_name_;$/;"	m	class:LatchInst	file:	access:private
instances	../../libs/libarchfpga/src/logic_types.h	/^	void *instances = nullptr;$/;"	m	struct:t_model	access:public
integer_to_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* integer_to_string(char_t* begin, char_t* end, U value, bool negative)$/;"	f	signature:(char_t* begin, char_t* end, U value, bool negative)
inter_cluster_delay	timing/PostClusterDelayCalculator.h	/^	float inter_cluster_delay(ClusterNetId net_id, const int driver_net_pin_index, const int sink_net_pin_index) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(ClusterNetId net_id, const int driver_net_pin_index, const int sink_net_pin_index) const
inter_cluster_delay	timing/PostClusterDelayCalculator.tpp	/^inline float PostClusterDelayCalculator::inter_cluster_delay(const ClusterNetId net_id, const int src_net_pin_index, const int sink_net_pin_index) const {$/;"	f	class:PostClusterDelayCalculator	signature:(const ClusterNetId net_id, const int src_net_pin_index, const int sink_net_pin_index) const
inter_cluster_net_delay	base/vpr_types.h	/^	float inter_cluster_net_delay;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
inter_cluster_net_delay_	timing/PreClusterDelayCalculator.h	/^    const float inter_cluster_net_delay_;$/;"	m	class:PreClusterDelayCalculator	access:private
interconnect	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:t_interconnect_pins	access:public
interconnect	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:t_mode	access:public
interconnect	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:t_pb_graph_edge	access:public
interconnect_delay_breakdown	timing/VprTimingGraphResolver.cpp	/^std::vector<tatum::DelayComponent> VprTimingGraphResolver::interconnect_delay_breakdown(tatum::EdgeId edge, DelayType delay_type) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::EdgeId edge, DelayType delay_type) const
interconnect_delay_breakdown	timing/VprTimingGraphResolver.h	/^        std::vector<tatum::DelayComponent> interconnect_delay_breakdown(tatum::EdgeId edge, DelayType) const;$/;"	p	class:VprTimingGraphResolver	access:private	signature:(tatum::EdgeId edge, DelayType) const
interconnect_name	base/netlist_writer.cpp	/^        std::string interconnect_name(std::string driver_wire, std::string sink_wire) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(std::string driver_wire, std::string sink_wire)
interconnect_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect_pins ** interconnect_pins; \/* [0..num_modes-1][0..num_interconnect_in_mode] *\/$/;"	m	struct:t_pb_graph_node	access:public
interconnect_power	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect_power *interconnect_power;$/;"	m	struct:t_interconnect	access:public
interconnect_type_name	power/power_util.cpp	/^const char * interconnect_type_name(enum e_interconnect type) {$/;"	f	signature:(enum e_interconnect type)
interconnect_type_name	power/power_util.h	/^const char * interconnect_type_name(enum e_interconnect type);$/;"	p	signature:(enum e_interconnect type)
internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_struct* xml_attribute::internal_object() const$/;"	f	class:pugi::xml_attribute	signature:() const
internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_struct* xml_node::internal_object() const$/;"	f	class:pugi::xml_node	signature:() const
internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_struct* internal_object() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* internal_object() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
internal_src_to_clb_output_delay	timing/clb_delay_calc.h	/^        float internal_src_to_clb_output_delay(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:public	signature:(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const
internal_src_to_clb_output_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::internal_src_to_clb_output_delay(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(const ClusterBlockId block_id, const int pin_index, int internal_src_pin, DelayType delay_type) const
internal_src_to_internal_sink_delay	timing/clb_delay_calc.h	/^        float internal_src_to_internal_sink_delay(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:public	signature:(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const
internal_src_to_internal_sink_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::internal_src_to_internal_sink_delay(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(const ClusterBlockId clb, int internal_src_pin, int internal_sink_pin, DelayType delay_type) const
intersects	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_bound_box::intersects(const t_point& test_pt) const {$/;"	f	class:t_bound_box	signature:(const t_point& test_pt) const
intersects	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_bound_box::intersects(float x, float y) const {$/;"	f	class:t_bound_box	signature:(float x, float y) const
intersects	../../libs/libeasygl/src/graphics_types.h	/^    bool intersects(const t_point& test_pt) const;$/;"	p	class:t_bound_box	access:public	signature:(const t_point& test_pt) const
intersects	../../libs/libeasygl/src/graphics_types.h	/^    bool intersects(float x, float y) const;$/;"	p	class:t_bound_box	access:public	signature:(float x, float y) const
intra_lb_nets	pack/pack_types.h	/^    std::vector<t_intra_lb_net> *intra_lb_nets;		\/* Pointer to vector of intra logic cluster_ctx.blocks nets and their connections *\/$/;"	m	struct:t_lb_router_data	access:public
intra_lb_pb_pin_lookup_	timing/clb_delay_calc.h	/^        IntraLbPbPinLookup intra_lb_pb_pin_lookup_;$/;"	m	class:ClbDelayCalc	access:private
intra_lb_pb_pin_lookup_	util/vpr_utils.h	/^        t_pb_graph_pin*** intra_lb_pb_pin_lookup_;$/;"	m	class:IntraLbPbPinLookup	access:private
intrinsic_cost	pack/pack_types.h	/^	float intrinsic_cost;					\/* cost of this node *\/$/;"	m	struct:t_lb_type_rr_node	access:public
intrinsic_cost	pack/pack_types.h	/^	float intrinsic_cost;$/;"	m	struct:t_lb_type_rr_node_edge	access:public
inv_capacity	base/vpr_types.h	/^	float inv_capacity;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
inv_length	route/rr_node.h	/^	float inv_length;$/;"	m	struct:t_rr_indexed_data	access:public
invalid	base/vpr_types.h	/^	t_cluster_placement_primitive *invalid; \/* ptrs to primitives that are invalid *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
invalidate_heap_entries	route/route_common.cpp	/^void invalidate_heap_entries(int sink_node, int ipin_node) {$/;"	f	signature:(int sink_node, int ipin_node)
invalidate_heap_entries	route/route_common.h	/^void invalidate_heap_entries(int sink_node, int ipin_node);$/;"	p	signature:(int sink_node, int ipin_node)
inverse_begin	../../libs/libvtrutil/src/vtr_bimap.h	/^        inverse_iterator inverse_begin() const { return inverse_map_.begin(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
inverse_end	../../libs/libvtrutil/src/vtr_bimap.h	/^        inverse_iterator inverse_end() const { return inverse_map_.end(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
inverse_iterator	../../libs/libvtrutil/src/vtr_bimap.h	/^        typedef typename InvMap<V,K>::const_iterator inverse_iterator;$/;"	t	class:vtr::bimap	access:public
inverse_map_	../../libs/libvtrutil/src/vtr_bimap.h	/^        InvMap<V,K> inverse_map_;$/;"	m	class:vtr::bimap	access:private
invert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits *invert()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
invert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber invert()$/;"	f	class:VNumber	access:public	signature:()
ipin_cblock_switch_name	../../libs/libarchfpga/src/physical_types.h	/^    std::string ipin_cblock_switch_name;$/;"	m	struct:t_arch	access:public
ipow	../../libs/libvtrutil/src/vtr_math.cpp	/^int ipow(int base, int exp) {$/;"	f	namespace:vtr	signature:(int base, int exp)
ipow	../../libs/libvtrutil/src/vtr_math.h	/^    int ipow(int base, int exp);$/;"	p	namespace:vtr	signature:(int base, int exp)
irand	../../libs/libvtrutil/src/vtr_random.cpp	/^int irand(int imax) {$/;"	f	namespace:vtr	signature:(int imax)
irand	../../libs/libvtrutil/src/vtr_random.cpp	/^int irand(int imax, RandState& state) {$/;"	f	namespace:vtr	signature:(int imax, RandState& state)
irand	../../libs/libvtrutil/src/vtr_random.h	/^    int irand(int imax);$/;"	p	namespace:vtr	signature:(int imax)
irand	../../libs/libvtrutil/src/vtr_random.h	/^    int irand(int imax, RandState& rand_state);$/;"	p	namespace:vtr	signature:(int imax, RandState& rand_state)
isEchoFileEnabled	base/echo_files.cpp	/^bool isEchoFileEnabled(enum e_echo_files echo_option) {$/;"	f	signature:(enum e_echo_files echo_option)
isEchoFileEnabled	base/echo_files.h	/^bool isEchoFileEnabled(enum e_echo_files echo_option);$/;"	p	signature:(enum e_echo_files echo_option)
is_any_but	timing/slre.cpp	/^static int is_any_but(const unsigned char *p, int len, const char *s,$/;"	f	file:	signature:(const unsigned char *p, int len, const char *s, int *ofs)
is_any_of	timing/slre.cpp	/^static int is_any_of(const unsigned char *p, int len, const char *s, int *ofs) {$/;"	f	file:	signature:(const unsigned char *p, int len, const char *s, int *ofs)
is_atom_blk_in_pb	pack/cluster.cpp	/^static bool is_atom_blk_in_pb(const AtomBlockId blk_id, const t_pb *pb) {$/;"	f	file:	signature:(const AtomBlockId blk_id, const t_pb *pb)
is_atom_blk_in_pb	pack/cluster.cpp	/^static bool is_atom_blk_in_pb(const AtomBlockId blk_id, const t_pb *pb);$/;"	p	file:	signature:(const AtomBlockId blk_id, const t_pb *pb)
is_attribute_of	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool is_attribute_of(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f	signature:(xml_attribute_struct* attr, xml_node_struct* node)
is_better_quality_routing	route/route_timing.cpp	/^static bool is_better_quality_routing(const vtr::vector<ClusterNetId,t_traceback>& best_routing,$/;"	f	file:	signature:(const vtr::vector<ClusterNetId,t_traceback>& best_routing, const RoutingMetrics& best_routing_metrics, const WirelengthInfo& wirelength_info, std::shared_ptr<const SetupHoldTimingInfo> timing_info)
is_better_quality_routing	route/route_timing.cpp	/^static bool is_better_quality_routing(const vtr::vector<ClusterNetId,t_traceback>& best_routing,$/;"	p	file:	signature:(const vtr::vector<ClusterNetId,t_traceback>& best_routing, const RoutingMetrics& best_routing_metrics, const WirelengthInfo& wirelength_info, std::shared_ptr<const SetupHoldTimingInfo> timing_info)
is_block_optional	../../libs/libarchfpga/src/cad_types.h	/^	bool *is_block_optional; \/* [0..num_blocks-1] is the block_id in this pattern mandatory or optional to form a molecule *\/$/;"	m	struct:t_pack_patterns	access:public
is_buffer	base/atom_netlist_utils.cpp	/^bool is_buffer(const AtomNetlist& netlist, const AtomBlockId blk) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomBlockId blk)
is_buffer	base/atom_netlist_utils.h	/^bool is_buffer(const AtomNetlist& netlist, const AtomBlockId blk);$/;"	p	signature:(const AtomNetlist& netlist, const AtomBlockId blk)
is_buffer_lut	base/atom_netlist_utils.cpp	/^bool is_buffer_lut(const AtomNetlist& netlist, const AtomBlockId blk) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomBlockId blk)
is_buffer_lut	base/atom_netlist_utils.cpp	/^bool is_buffer_lut(const AtomNetlist& netlist, const AtomBlockId blk);$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomBlockId blk)
is_cblock	route/rr_graph2.cpp	/^bool is_cblock(const int chan, const int seg, const int track,$/;"	f	signature:(const int chan, const int seg, const int track, const t_chan_seg_details * seg_details)
is_cblock	route/rr_graph2.h	/^bool is_cblock($/;"	p	signature:( const int chan, const int seg, const int track, const t_chan_seg_details *seg_details)
is_chain	../../libs/libarchfpga/src/cad_types.h	/^	bool is_chain; \/* Does this pattern chain across logic blocks *\/$/;"	m	struct:t_pack_patterns	access:public
is_char_number	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool is_char_number ( const char ch ){$/;"	f	file:	signature:( const char ch )
is_char_number	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool is_char_number( const char ch );$/;"	p	file:	signature:( const char ch )
is_clb_external_pin	util/vpr_utils.cpp	/^bool is_clb_external_pin(ClusterBlockId blk_id, int pb_pin_id) {$/;"	f	signature:(ClusterBlockId blk_id, int pb_pin_id)
is_clb_external_pin	util/vpr_utils.h	/^bool is_clb_external_pin(ClusterBlockId blk_id, int pb_pin_id);$/;"	p	signature:(ClusterBlockId blk_id, int pb_pin_id)
is_clock	../../libs/libarchfpga/src/logic_types.h	/^	bool is_clock = false; \/* clock? *\/$/;"	m	struct:t_model_ports	access:public
is_clock	../../libs/libarchfpga/src/physical_types.h	/^	bool is_clock;$/;"	m	struct:t_port	access:public
is_comb_loop_breakpoint	base/vpr_types.h	/^	unsigned int is_comb_loop_breakpoint : 1; \/* Indicates that this tnode had input edges purposely$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
is_compressed	base/netlist.h	/^        bool is_compressed() const;$/;"	p	class:Netlist	access:public	signature:() const
is_compressed	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::is_compressed() const {$/;"	f	class:Netlist	signature:() const
is_constant_clb_net	place/place_macro.cpp	/^static bool is_constant_clb_net(ClusterNetId clb_net) {$/;"	f	file:	signature:(ClusterNetId clb_net)
is_constant_clb_net	place/place_macro.cpp	/^static bool is_constant_clb_net(ClusterNetId clb_net);$/;"	p	file:	signature:(ClusterNetId clb_net)
is_core	route/build_switchblocks.cpp	/^static bool is_core(const DeviceGrid& grid, int x, int y);$/;"	p	file:	signature:(const DeviceGrid& grid, int x, int y)
is_core	route/build_switchblocks.cpp	/^static bool is_core(const DeviceGrid& grid, int x, int y){$/;"	f	file:	signature:(const DeviceGrid& grid, int x, int y)
is_corner	route/build_switchblocks.cpp	/^static bool is_corner(const DeviceGrid& grid, int x, int y);$/;"	p	file:	signature:(const DeviceGrid& grid, int x, int y)
is_corner	route/build_switchblocks.cpp	/^static bool is_corner(const DeviceGrid& grid, int x, int y){$/;"	f	file:	signature:(const DeviceGrid& grid, int x, int y)
is_dirty	base/netlist.h	/^        bool is_dirty() const;$/;"	p	class:Netlist	access:public	signature:() const
is_dirty	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::is_dirty() const {$/;"	f	class:Netlist	signature:() const
is_done_callibration	power/PowerSpicedComponent.cpp	/^bool PowerSpicedComponent::is_done_callibration() {$/;"	f	class:PowerSpicedComponent	signature:()
is_done_callibration	power/PowerSpicedComponent.h	/^	bool is_done_callibration();$/;"	p	class:PowerSpicedComponent	access:public	signature:()
is_dont_care_string	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool is_dont_care_string()$/;"	f	class:VNumber	access:public	signature:()
is_droppable_event	../../libs/libeasygl/src/graphics.cpp	/^static bool is_droppable_event($/;"	f	file:	signature:( const XEvent* event )
is_droppable_event	../../libs/libeasygl/src/graphics.cpp	/^static bool is_droppable_event($/;"	p	file:	signature:( const XEvent* event )
is_empty_heap	route/route_common.cpp	/^bool is_empty_heap() {$/;"	f	signature:()
is_empty_heap	route/route_common.h	/^bool is_empty_heap();$/;"	p	signature:()
is_empty_type	util/vpr_utils.cpp	/^bool is_empty_type(t_type_ptr type) {$/;"	f	signature:(t_type_ptr type)
is_empty_type	util/vpr_utils.h	/^bool is_empty_type(t_type_ptr type);$/;"	p	signature:(t_type_ptr type)
is_eq	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_eq(){	return (result&(0x2)); }$/;"	f	class:compare_bit	access:public	signature:()
is_equivalent_route_tree	route/route_tree_timing.cpp	/^bool is_equivalent_route_tree(const t_rt_node* root, const t_rt_node* root_clone) {$/;"	f	signature:(const t_rt_node* root, const t_rt_node* root_clone)
is_equivalent_route_tree	route/route_tree_timing.h	/^bool is_equivalent_route_tree(const t_rt_node* rt_root, const t_rt_node* cloned_rt_root);$/;"	p	signature:(const t_rt_node* rt_root, const t_rt_node* cloned_rt_root)
is_fixed	base/vpr_types.h	/^	bool is_fixed = false;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
is_fixed	base/vpr_types.h	/^    bool is_fixed = false; \/\/Whether the net is fixed (i.e. not to be re-routed)$/;"	m	struct:ScreenUpdatePriority::t_net_routing_status	access:public
is_forced_connection	../../libs/libarchfpga/src/physical_types.h	/^	bool is_forced_connection = false; \/* This output pin connects to one and only one input pin *\/$/;"	m	struct:t_pb_graph_pin	access:public
is_forced_connection	pack/cluster_feasibility_filter.cpp	/^static bool is_forced_connection(const t_pb_graph_pin *pb_graph_pin) {$/;"	f	file:	signature:(const t_pb_graph_pin *pb_graph_pin)
is_forced_connection	pack/cluster_feasibility_filter.cpp	/^static bool is_forced_connection(const t_pb_graph_pin *pb_graph_pin);$/;"	p	file:	signature:(const t_pb_graph_pin *pb_graph_pin)
is_function	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool is_function(std::string name) {$/;"	f	file:	signature:(std::string name)
is_function	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool is_function(std::string name);$/;"	p	file:	signature:(std::string name)
is_ge	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_ge(){	return (result&(0x3)); }$/;"	f	class:compare_bit	access:public	signature:()
is_global_pin	../../libs/libarchfpga/src/physical_types.h	/^	bool *is_global_pin = nullptr; \/* [0..num_pins-1] *\/$/;"	m	struct:t_type_descriptor	access:public
is_gt	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_gt(){	return (result&(0x1)); }$/;"	f	class:compare_bit	access:public	signature:()
is_high_fanout	route/route_timing.cpp	/^static bool is_high_fanout(int fanout, int fanout_threshold) {$/;"	f	file:	signature:(int fanout, int fanout_threshold)
is_high_fanout	route/route_timing.cpp	/^static bool is_high_fanout(int fanout, int fanout_threshold);$/;"	p	file:	signature:(int fanout, int fanout_threshold)
is_in_selected_subtree	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_in_selected_subtree(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_in_selected_subtree	draw/intra_logic_block.h	/^	bool is_in_selected_subtree(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_input_type	util/vpr_utils.cpp	/^bool is_input_type(t_type_ptr type) {$/;"	f	signature:(t_type_ptr type)
is_input_type	util/vpr_utils.h	/^bool is_input_type(t_type_ptr type);$/;"	p	signature:(t_type_ptr type)
is_io_type	util/vpr_utils.cpp	/^bool is_io_type(t_type_ptr type) {$/;"	f	signature:(t_type_ptr type)
is_io_type	util/vpr_utils.h	/^bool is_io_type(t_type_ptr type);$/;"	p	signature:(t_type_ptr type)
is_le	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_le(){	return (result&(0x6)); }$/;"	f	class:compare_bit	access:public	signature:()
is_library_model	../../libs/libarchfpga/src/arch_util.cpp	/^bool is_library_model(const char* model_name) {$/;"	f	signature:(const char* model_name)
is_library_model	../../libs/libarchfpga/src/arch_util.cpp	/^bool is_library_model(const t_model* model) {$/;"	f	signature:(const t_model* model)
is_library_model	../../libs/libarchfpga/src/arch_util.h	/^bool is_library_model(const char* model_name);$/;"	p	signature:(const char* model_name)
is_library_model	../../libs/libarchfpga/src/arch_util.h	/^bool is_library_model(const t_model* model);$/;"	p	signature:(const t_model* model)
is_little_endian	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool is_little_endian()$/;"	f	signature:()
is_lt	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_lt(){	return (result&(0x4)); }$/;"	f	class:compare_bit	access:public	signature:()
is_nan	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool is_nan(double value)$/;"	f	signature:(double value)
is_ne	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_ne(){	return (!is_eq()); }$/;"	f	class:compare_bit	access:public	signature:()
is_negative	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool is_negative()$/;"	f	class:VNumber	access:public	signature:()
is_netlist_clock	base/vpr_types.h	/^	bool is_netlist_clock; \/* Is this a netlist or virtual (external) clock? *\/$/;"	m	struct:ScreenUpdatePriority::t_clock	access:public
is_netlist_clock_source	timing/timing_graph_builder.cpp	/^bool TimingGraphBuilder::is_netlist_clock_source(const AtomPinId pin) const {$/;"	f	class:TimingGraphBuilder	signature:(const AtomPinId pin) const
is_netlist_clock_source	timing/timing_graph_builder.h	/^        bool is_netlist_clock_source(const AtomPinId pin) const;$/;"	p	class:TimingGraphBuilder	access:private	signature:(const AtomPinId pin) const
is_non_clock_global	../../libs/libarchfpga/src/logic_types.h	/^	bool is_non_clock_global = false; \/* not a clock but is a special, global, control signal (eg global asynchronous reset, etc) *\/$/;"	m	struct:t_model_ports	access:public
is_non_clock_global	../../libs/libarchfpga/src/physical_types.h	/^	bool is_non_clock_global;$/;"	m	struct:t_port	access:public
is_operator	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool is_operator(const char ch) {$/;"	f	file:	signature:(const char ch)
is_operator	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool is_operator(const char ch);$/;"	p	file:	signature:(const char ch)
is_opin	util/vpr_utils.cpp	/^bool is_opin(int ipin, t_type_ptr type) {$/;"	f	signature:(int ipin, t_type_ptr type)
is_opin	util/vpr_utils.h	/^bool is_opin(int ipin, t_type_ptr type);$/;"	p	signature:(int ipin, t_type_ptr type)
is_output_type	util/vpr_utils.cpp	/^bool is_output_type(t_type_ptr type) {$/;"	f	signature:(t_type_ptr type)
is_output_type	util/vpr_utils.h	/^bool is_output_type(t_type_ptr type);$/;"	p	signature:(t_type_ptr type)
is_perimeter	route/build_switchblocks.cpp	/^static bool is_perimeter(const DeviceGrid& grid, int x, int y);$/;"	p	file:	signature:(const DeviceGrid& grid, int x, int y)
is_perimeter	route/build_switchblocks.cpp	/^static bool is_perimeter(const DeviceGrid& grid, int x, int y){$/;"	f	file:	signature:(const DeviceGrid& grid, int x, int y)
is_piecewise_formula	../../libs/libarchfpga/src/expr_eval.cpp	/^bool is_piecewise_formula( const char *formula ){$/;"	f	signature:( const char *formula )
is_piecewise_formula	../../libs/libarchfpga/src/expr_eval.h	/^bool is_piecewise_formula( const char *formula);$/;"	p	signature:( const char *formula)
is_posinv_expr	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool is_posinv_expr() const$/;"	f	class:xpath_ast_node	access:public	signature:() const
is_posinv_step	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool is_posinv_step() const$/;"	f	class:xpath_ast_node	access:public	signature:() const
is_primitive	base/vpr_types.h	/^    bool is_primitive() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
is_removable_block	base/atom_netlist_utils.cpp	/^bool is_removable_block(const AtomNetlist& netlist, const AtomBlockId blk, std::string* reason=nullptr);$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomBlockId blk, std::string* reason=nullptr)
is_removable_block	base/atom_netlist_utils.cpp	/^bool is_removable_block(const AtomNetlist& netlist, const AtomBlockId blk_id, std::string* reason) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomBlockId blk_id, std::string* reason)
is_removable_input	base/atom_netlist_utils.cpp	/^bool is_removable_input(const AtomNetlist& netlist, const AtomBlockId blk, std::string* reason=nullptr);$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomBlockId blk, std::string* reason=nullptr)
is_removable_input	base/atom_netlist_utils.cpp	/^bool is_removable_input(const AtomNetlist& netlist, const AtomBlockId blk_id, std::string* reason) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomBlockId blk_id, std::string* reason)
is_removable_output	base/atom_netlist_utils.cpp	/^bool is_removable_output(const AtomNetlist& netlist, const AtomBlockId blk, std::string* reason=nullptr);$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomBlockId blk, std::string* reason=nullptr)
is_removable_output	base/atom_netlist_utils.cpp	/^bool is_removable_output(const AtomNetlist& netlist, const AtomBlockId blk_id, std::string* reason) {$/;"	f	signature:(const AtomNetlist& netlist, const AtomBlockId blk_id, std::string* reason)
is_root	base/vpr_types.h	/^    bool is_root() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
is_route_success	pack/cluster_router.cpp	/^static bool is_route_success(t_lb_router_data *router_data) {$/;"	f	file:	signature:(t_lb_router_data *router_data)
is_route_success	pack/cluster_router.cpp	/^static bool is_route_success(t_lb_router_data *router_data);$/;"	p	file:	signature:(t_lb_router_data *router_data)
is_routed	base/vpr_types.h	/^    bool is_routed = false; \/\/Whether the net has been legally routed$/;"	m	struct:ScreenUpdatePriority::t_net_routing_status	access:public
is_routed	pack/pack_types.h	/^	bool is_routed;							\/* Stores whether or not the current logical-to-physical mapping has a routed solution *\/$/;"	m	struct:t_lb_router_data	access:public
is_sblock	route/rr_graph2.cpp	/^bool is_sblock(const int chan, int wire_seg, const int sb_seg, const int track,$/;"	f	signature:(const int chan, int wire_seg, const int sb_seg, const int track, const t_chan_seg_details * seg_details, const enum e_directionality directionality)
is_sblock	route/rr_graph2.h	/^bool is_sblock($/;"	p	signature:( const int chan, int wire_seg, const int sb_seg, const int track, const t_chan_seg_details *seg_details, const enum e_directionality directionality)
is_selected	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_selected	draw/intra_logic_block.h	/^	bool is_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_signed	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool is_signed() const$/;"	f	class:VNumber	access:public	signature:() const
is_sink_of_selected	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_sink_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_sink_of_selected	draw/intra_logic_block.h	/^	bool is_sink_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_skip_route_net	pack/cluster_router.cpp	/^static bool is_skip_route_net(t_lb_trace *rt, t_lb_router_data *router_data) {$/;"	f	file:	signature:(t_lb_trace *rt, t_lb_router_data *router_data)
is_skip_route_net	pack/cluster_router.cpp	/^static bool is_skip_route_net(t_lb_trace *rt, t_lb_router_data *router_data);$/;"	p	file:	signature:(t_lb_trace *rt, t_lb_router_data *router_data)
is_source_of_selected	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_source_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_source_of_selected	draw/intra_logic_block.h	/^	bool is_source_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
is_special_sdf_char	base/netlist_writer.cpp	/^bool is_special_sdf_char(char c) {$/;"	f	signature:(char c)
is_special_sdf_char	base/netlist_writer.cpp	/^bool is_special_sdf_char(char c);$/;"	p	file:	signature:(char c)
is_text_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline bool is_text_node(xml_node_struct* node)$/;"	f	signature:(xml_node_struct* node)
is_top_lvl_block_highlighted	draw/intra_logic_block.cpp	/^static bool is_top_lvl_block_highlighted(const ClusterBlockId blk_id, const t_type_ptr type) {$/;"	f	file:	signature:(const ClusterBlockId blk_id, const t_type_ptr type)
is_top_lvl_block_highlighted	draw/intra_logic_block.cpp	/^static bool is_top_lvl_block_highlighted(const ClusterBlockId blk_id, const t_type_ptr type);$/;"	p	file:	signature:(const ClusterBlockId blk_id, const t_type_ptr type)
is_uncongested_route_tree	route/route_tree_timing.cpp	/^bool is_uncongested_route_tree(const t_rt_node* root) {$/;"	f	signature:(const t_rt_node* root)
is_uncongested_route_tree	route/route_tree_timing.h	/^bool is_uncongested_route_tree(const t_rt_node* root);$/;"	p	signature:(const t_rt_node* root)
is_unk	../../libs/librtlnumber/src/rtl_int.cpp	/^	bool is_unk(){	return (!result); }$/;"	f	class:compare_bit	access:public	signature:()
is_valid	route/route_common.cpp	/^	bool is_valid() {$/;"	f	namespace:heap_	signature:()
is_valid	route/route_common.h	/^	bool is_valid();$/;"	p	namespace:heap_	signature:()
is_valid_clock_name	timing/read_sdc.cpp	/^static bool is_valid_clock_name(const char* clock_name) {$/;"	f	file:	signature:(const char* clock_name)
is_valid_clock_name	timing/read_sdc.cpp	/^static bool is_valid_clock_name(const char* clock_name);$/;"	p	file:	signature:(const char* clock_name)
is_valid_route_tree	route/route_tree_timing.cpp	/^bool is_valid_route_tree(const t_rt_node* root) {$/;"	f	signature:(const t_rt_node* root)
is_valid_route_tree	route/route_tree_timing.h	/^bool is_valid_route_tree(const t_rt_node* rt_root);$/;"	p	signature:(const t_rt_node* rt_root)
is_valid_skeleton_tree	route/route_tree_timing.cpp	/^bool is_valid_skeleton_tree(const t_rt_node* root) {$/;"	f	signature:(const t_rt_node* root)
is_valid_skeleton_tree	route/route_tree_timing.h	/^bool is_valid_skeleton_tree(const t_rt_node* rt_root);$/;"	p	signature:(const t_rt_node* rt_root)
is_xpath_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline bool is_xpath_attribute(const char_t* name)$/;"	f	signature:(const char_t* name)
isclose	../../libs/libvtrutil/src/vtr_math.h	/^    bool isclose(T a, T b) {$/;"	f	namespace:vtr	signature:(T a, T b)
isclose	../../libs/libvtrutil/src/vtr_math.h	/^    bool isclose(T a, T b, T rel_tol, T abs_tol) {$/;"	f	namespace:vtr	signature:(T a, T b, T rel_tol, T abs_tol)
ispressed	../../libs/libeasygl/src/graphics.cpp	/^    bool ispressed;$/;"	m	struct:__anon18	file:	access:public
iswitch	base/vpr_types.h	/^	short iswitch;$/;"	m	struct:ScreenUpdatePriority::t_trace	access:public
iswitch	route/route_tree_type.h	/^	short iswitch;$/;"	m	struct:t_linked_rt_edge	access:public
iswitch	timing/net_delay.cpp	/^	short iswitch;$/;"	m	struct:t_linked_rc_edge	file:	access:public
item_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		struct item_t$/;"	s	class:compact_hash_table	file:	access:private
iter_	../../libs/libvtrutil/src/vtr_pair_util.h	/^        PairIter iter_;$/;"	m	class:vtr::pair_first_iter	access:private
iter_	../../libs/libvtrutil/src/vtr_pair_util.h	/^        PairIter iter_;$/;"	m	class:vtr::pair_second_iter	access:private
iteration_overused_rr_node_counts_	route/routing_predictor.h	/^    std::vector<size_t> iteration_overused_rr_node_counts_;$/;"	m	class:RoutingPredictor	access:private
iterations_	route/routing_predictor.h	/^    std::vector<size_t> iterations_;$/;"	m	class:RoutingPredictor	access:private
iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef It iterator;$/;"	t	class:pugi::xml_object_range	access:public
iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef const xpath_node* iterator;$/;"	t	class:pugi::xpath_node_set	access:public
iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node_iterator iterator;$/;"	t	class:pugi::xml_node	access:public
iterator	../../libs/libvtrutil/src/vtr_bimap.h	/^        typedef typename Map<K,V>::const_iterator iterator;$/;"	t	class:vtr::bimap	access:public
iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::iterator iterator;$/;"	t	class:vtr::flat_map	access:public
iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::iterator iterator;$/;"	t	class:vtr::linear_map	access:public
iterator	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::iterator iterator;$/;"	t	class:vtr::vector_map	access:public
iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_attribute_iterator	access:public
iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_named_node_iterator	access:public
iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_node_iterator	access:public
join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Container container, std::string delim) {$/;"	f	namespace:vtr	signature:(Container container, std::string delim)
join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Container container, std::string delim);$/;"	p	namespace:vtr	signature:(Container container, std::string delim)
join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Iter begin, Iter end, std::string delim) {$/;"	f	namespace:vtr	signature:(Iter begin, Iter end, std::string delim)
join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Iter begin, Iter end, std::string delim);$/;"	p	namespace:vtr	signature:(Iter begin, Iter end, std::string delim)
join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(std::initializer_list<T> list, std::string delim) {$/;"	f	namespace:vtr	signature:(std::initializer_list<T> list, std::string delim)
join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(std::initializer_list<T> list, std::string delim);$/;"	p	namespace:vtr	signature:(std::initializer_list<T> list, std::string delim)
join_identifier	base/netlist_writer.cpp	/^std::string join_identifier(std::string lhs, std::string rhs) {$/;"	f	signature:(std::string lhs, std::string rhs)
join_identifier	base/netlist_writer.cpp	/^std::string join_identifier(std::string lhs, std::string rhs);$/;"	p	file:	signature:(std::string lhs, std::string rhs)
keep_budget_above_value	route/route_budgets.cpp	/^void route_budgets::keep_budget_above_value(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range)
keep_budget_above_value	route/route_budgets.h	/^    void keep_budget_above_value(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range)
keep_budget_in_bounds	route/route_budgets.cpp	/^void route_budgets::keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
keep_budget_in_bounds	route/route_budgets.cpp	/^void route_budgets::keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId pin_id) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId pin_id)
keep_budget_in_bounds	route/route_budgets.h	/^    void keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
keep_budget_in_bounds	route/route_budgets.h	/^    void keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId ipin);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId ipin)
keep_min_below_max_budget	route/route_budgets.cpp	/^void route_budgets::keep_min_below_max_budget() {$/;"	f	class:route_budgets	signature:()
keep_min_below_max_budget	route/route_budgets.h	/^    void keep_min_below_max_budget();$/;"	p	class:route_budgets	access:private	signature:()
kelly_max_contrast_colors	draw/draw.cpp	/^const std::vector<t_color> kelly_max_contrast_colors = {$/;"	v
key	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const void* key;$/;"	m	struct:compact_hash_table::item_t	file:	access:public
key_begin	../../libs/libvtrutil/src/vtr_vector.h	/^        key_iterator key_begin() const { return key_iterator(key_type(0)); }$/;"	f	class:vtr::vector	access:private	signature:() const
key_comp	../../libs/libvtrutil/src/vtr_flat_map.h	/^        key_compare key_comp() const { return key_compare(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
key_compare	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef Compare key_compare;$/;"	t	class:vtr::flat_map	access:public
key_end	../../libs/libvtrutil/src/vtr_vector.h	/^        key_iterator key_end() const { return key_iterator(key_type(size())); }$/;"	f	class:vtr::vector	access:private	signature:() const
key_iterator	../../libs/libvtrutil/src/vtr_vector.h	/^                key_iterator(key_iterator::value_type init): value_(init) {}$/;"	f	class:vtr::vector::key_iterator	access:public	signature:(key_iterator::value_type init)
key_iterator	../../libs/libvtrutil/src/vtr_vector.h	/^        class key_iterator : public std::iterator<std::bidirectional_iterator_tag, key_type> {$/;"	c	class:vtr::vector	inherits:std::iterator	access:public
key_range	../../libs/libvtrutil/src/vtr_vector.h	/^        typedef vtr::Range<key_iterator> key_range;$/;"	t	class:vtr::vector	access:public
key_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef K key_type;$/;"	t	class:vtr::flat_map	access:public
key_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef K key_type;$/;"	t	class:vtr::linear_map	access:public
key_type	../../libs/libvtrutil/src/vtr_vector.h	/^        typedef K key_type;$/;"	t	class:vtr::vector	access:public
keys	../../libs/libvtrutil/src/vtr_vector.h	/^        key_range keys() const {$/;"	f	class:vtr::vector	access:public	signature:() const
keys_equivalent	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool keys_equivalent(const key_type& lhs, const key_type& rhs) const {$/;"	f	class:vtr::flat_map	access:private	signature:(const key_type& lhs, const key_type& rhs) const
l	draw/hsl.h	/^    double l;       \/\/ a fraction between 0 and 1$/;"	m	struct:hsl	access:public
l_and	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_and[4][4] = {$/;"	m	namespace:BitSpace
l_buf	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_buf[4] = {$/;"	m	namespace:BitSpace
l_bufif0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_bufif0[4][4] = {$/;"	m	namespace:BitSpace
l_bufif1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_bufif1[4][4] = {$/;"	m	namespace:BitSpace
l_carry	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_carry[4][4][4] = {$/;"	m	namespace:BitSpace
l_case_eq	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_case_eq[4][4] = {$/;"	m	namespace:BitSpace
l_case_neq	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_case_neq[4][4] =$/;"	m	namespace:BitSpace
l_eq	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_eq[4][4] = $/;"	m	namespace:BitSpace
l_ge	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_ge[4][4] = unroll_2d(l_lt);$/;"	m	namespace:BitSpace
l_gt	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_gt[4][4] = {$/;"	m	namespace:BitSpace
l_half_carry	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_half_carry[4][4] = unroll_2d(l_carry[_0]);$/;"	m	namespace:BitSpace
l_half_sum	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_half_sum[4][4] = unroll_2d(l_sum[_0]);$/;"	m	namespace:BitSpace
l_le	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_le[4][4] = unroll_2d(l_gt);$/;"	m	namespace:BitSpace
l_lt	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_lt[4][4] = {$/;"	m	namespace:BitSpace
l_nand	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_nand[4][4] = $/;"	m	namespace:BitSpace
l_nmos	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_nmos[4][4] = {$/;"	m	namespace:BitSpace
l_nor	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_nor[4][4] = $/;"	m	namespace:BitSpace
l_not	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_not[4] = {$/;"	m	namespace:BitSpace
l_notif0	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_notif0[4][4] = {$/;"	m	namespace:BitSpace
l_notif1	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_notif1[4][4] = {$/;"	m	namespace:BitSpace
l_or	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_or[4][4] = {$/;"	m	namespace:BitSpace
l_rnmos	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_rnmos[4][4] = {$/;"	m	namespace:BitSpace
l_rpmos	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_rpmos[4][4] = {$/;"	m	namespace:BitSpace
l_sum	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_sum[4][4][4] = {$/;"	m	namespace:BitSpace
l_ternary	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_ternary[4][4] = {$/;"	m	namespace:BitSpace
l_unk	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_unk[4][4] = {$/;"	m	namespace:BitSpace
l_xnor	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_xnor[4][4] = $/;"	m	namespace:BitSpace
l_xor	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    static const bit_value_t l_xor[4][4] = {$/;"	m	namespace:BitSpace
label_incoming_wires	route/rr_graph2.cpp	/^static int *label_incoming_wires($/;"	f	file:	signature:( const int chan_num, const int seg_num, const int sb_seg, const t_chan_seg_details * seg_details, const int max_len, const enum e_direction dir, const int max_chan_width, int *num_incoming_wires, int *num_ending_wires)
label_incoming_wires	route/rr_graph2.cpp	/^static int *label_incoming_wires($/;"	p	file:	signature:( const int chan_num, const int seg_num, const int sb_seg, const t_chan_seg_details * seg_details, const int max_len, const enum e_direction dir, const int max_chan_width, int *num_incoming_wires, int *num_ending_wires)
label_wire_muxes	route/rr_graph2.cpp	/^static int *label_wire_muxes($/;"	f	file:	signature:( const int chan_num, const int seg_num, const t_chan_seg_details * seg_details, const int seg_type_index, const int max_len, const enum e_direction dir, const int max_chan_width, const bool check_cb, int *num_wire_muxes, int *num_wire_muxes_cb_restricted)
label_wire_muxes	route/rr_graph2.cpp	/^static int *label_wire_muxes($/;"	p	file:	signature:( const int chan_num, const int seg_num, const t_chan_seg_details * seg_details, const int seg_type_index, const int max_len, const enum e_direction dir, const int max_chan_width, const bool check_cb, int *num_wire_muxes, int *num_wire_muxes_cb_restricted)
last_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::last_attribute() const$/;"	f	class:pugi::xml_node	signature:() const
last_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute last_attribute() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
last_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::last_child() const$/;"	f	class:pugi::xml_node	signature:() const
last_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node last_child() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
last_stable_critical_path_delay	route/connection_based_routing.h	/^	float last_stable_critical_path_delay;$/;"	m	class:Connection_based_routing_resources	access:private
latin1_decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct latin1_decoder$/;"	s	file:
latin1_decoder::process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:latin1_decoder	access:public	signature:(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)
latin1_decoder::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t type;$/;"	t	struct:latin1_decoder	file:	access:public
latin1_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct latin1_writer$/;"	s	file:
latin1_writer::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:latin1_writer	access:public	signature:(value_type result, uint32_t ch)
latin1_writer::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:latin1_writer	access:public	signature:(value_type result, uint32_t ch)
latin1_writer::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t* value_type;$/;"	t	struct:latin1_writer	file:	access:public
launch	timing/DomainPair.h	/^    tatum::DomainId launch;$/;"	m	struct:DomainPair	access:public
lb_rr_node_stats	pack/pack_types.h	/^	t_lb_rr_node_stats *lb_rr_node_stats;		\/* [0..lb_type_graph->size()-1] Stats for each logic cluster_ctx.blocks rr node instance *\/$/;"	m	struct:t_lb_router_data	access:public
lb_type	pack/pack_types.h	/^	t_type_ptr lb_type;$/;"	m	struct:t_lb_router_data	access:public
lb_type_graph	pack/pack_types.h	/^    std::vector<t_lb_type_rr_node> *lb_type_graph;	\/* Pointer to physical intra-logic cluster_ctx.blocks type rr graph *\/$/;"	m	struct:t_lb_router_data	access:public
lcm	../../libs/libvtrutil/src/vtr_math.h	/^    T lcm(T x, T y) {$/;"	f	namespace:vtr	signature:(T x, T y)
leakage	../../libs/libarchfpga/src/physical_types.h	/^	float leakage;$/;"	m	struct:t_power_usage	access:public
leakage_default_mode	../../libs/libarchfpga/src/physical_types.h	/^	int leakage_default_mode; \/* Default mode for leakage analysis, if block has no set mode *\/$/;"	m	struct:t_pb_type_power	access:public
leakage_gate	power/power.h	/^	float leakage_gate;$/;"	m	struct:t_transistor_size_inf	access:public
leakage_pairs	power/power.h	/^	t_power_nmos_leakage_pair * leakage_pairs;$/;"	m	struct:t_power_nmos_leakage_inf	access:public
leakage_subthreshold	power/power.h	/^	float leakage_subthreshold;$/;"	m	struct:t_transistor_size_inf	access:public
least_slack	base/vpr_types.h	/^	float ** least_slack;$/;"	m	struct:ScreenUpdatePriority::t_timing_stats	access:public
least_slack_critical_path	timing/timing_info.h	/^        virtual tatum::TimingPathInfo least_slack_critical_path() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
left	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::left() const {$/;"	f	class:t_bound_box	signature:() const
left	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::left() {$/;"	f	class:t_bound_box	signature:()
left	../../libs/libeasygl/src/graphics_types.h	/^    const float& left() const;$/;"	p	class:t_bound_box	access:public	signature:() const
left	../../libs/libeasygl/src/graphics_types.h	/^    float& left();$/;"	p	class:t_bound_box	access:public	signature:()
left	route/route_common.cpp	/^	size_t left(size_t i) {return i << 1;}$/;"	f	namespace:heap_	signature:(size_t i)
left	route/route_common.cpp	/^	size_t left(size_t i);$/;"	p	namespace:heap_	file:	signature:(size_t i)
left_bracket	../../libs/libarchfpga/src/expr_eval.cpp	/^		bool left_bracket;	\/*for bracket objects -- specifies if this is a left bracket*\/$/;"	m	union:Formula_Object::u_Data	file:	access:public
legal_pos	place/place.cpp	/^static t_legal_pos **legal_pos = nullptr; \/* [0..device_ctx.num_block_types-1][0..type_tsize - 1] *\/$/;"	v	file:
lemieux_cost_func	route/cb_metrics.h	/^	float lemieux_cost_func;$/;"	m	class:Conn_Block_Metrics	access:public
len	timing/slre.cpp	/^  int len;          \/\/ Substring length$/;"	m	struct:cap	file:	access:public
length	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t length() const$/;"	f	class:xpath_string	access:public	signature:() const
length	../../libs/libarchfpga/src/physical_types.h	/^	int length;$/;"	m	struct:t_segment_inf	access:public
length	base/vpr_types.h	/^	int length = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
length	base/vpr_types.h	/^        int length() const { return length_; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
length	route/build_switchblocks.cpp	/^	int length;		\/* the length of this type of wire segment in tiles *\/$/;"	m	class:Wire_Info	file:	access:public
length	route/rr_node.cpp	/^short t_rr_node::length() const {$/;"	f	class:t_rr_node	signature:() const
length	route/rr_node.h	/^        signed short length() const;$/;"	p	class:t_rr_node	access:public	signature:() const
length_	base/vpr_types.h	/^        int length_ = -1;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
length_and_bends_stats	base/stats.cpp	/^static void length_and_bends_stats();$/;"	p	file:	signature:()
length_and_bends_stats	base/stats.cpp	/^void length_and_bends_stats() {$/;"	f	signature:()
less	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct less$/;"	s	file:
less::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:less	access:public	signature:(const T& lhs, const T& rhs) const
less_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct less_equal$/;"	s	file:
less_equal::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:less_equal	access:public	signature:(const T& lhs, const T& rhs) const
level	power/power.h	/^	int level; \/* Level in the full multilevel mux - 0 = primary inputs to mux *\/$/;"	m	struct:t_mux_node	access:public
level_restorer	power/power.h	/^	bool level_restorer; \/* Whether the output of this mux is level restored *\/$/;"	m	struct:t_mux_node	access:public
levels	power/power.h	/^	int levels;$/;"	m	struct:t_mux_arch	access:public
lex_axis_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_axis_attribute,$/;"	e	enum:lexeme_t	file:
lex_close_brace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_close_brace,$/;"	e	enum:lexeme_t	file:
lex_close_square_brace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_close_square_brace,$/;"	e	enum:lexeme_t	file:
lex_comma	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_comma,$/;"	e	enum:lexeme_t	file:
lex_dot	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_dot,$/;"	e	enum:lexeme_t	file:
lex_double_colon	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_double_colon,$/;"	e	enum:lexeme_t	file:
lex_double_dot	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_double_dot,$/;"	e	enum:lexeme_t	file:
lex_double_slash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_double_slash,$/;"	e	enum:lexeme_t	file:
lex_eof	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_eof$/;"	e	enum:lexeme_t	file:
lex_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_equal,$/;"	e	enum:lexeme_t	file:
lex_greater	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_greater,$/;"	e	enum:lexeme_t	file:
lex_greater_or_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_greater_or_equal,$/;"	e	enum:lexeme_t	file:
lex_less	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_less,$/;"	e	enum:lexeme_t	file:
lex_less_or_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_less_or_equal,$/;"	e	enum:lexeme_t	file:
lex_minus	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_minus,$/;"	e	enum:lexeme_t	file:
lex_multiply	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_multiply,$/;"	e	enum:lexeme_t	file:
lex_none	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_none = 0,$/;"	e	enum:lexeme_t	file:
lex_not_equal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_not_equal,$/;"	e	enum:lexeme_t	file:
lex_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_number,$/;"	e	enum:lexeme_t	file:
lex_open_brace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_open_brace,$/;"	e	enum:lexeme_t	file:
lex_open_square_brace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_open_square_brace,$/;"	e	enum:lexeme_t	file:
lex_plus	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_plus,$/;"	e	enum:lexeme_t	file:
lex_quoted_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_quoted_string,$/;"	e	enum:lexeme_t	file:
lex_slash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_slash,$/;"	e	enum:lexeme_t	file:
lex_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_string,$/;"	e	enum:lexeme_t	file:
lex_union	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_union,$/;"	e	enum:lexeme_t	file:
lex_var_ref	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lex_var_ref,$/;"	e	enum:lexeme_t	file:
lexeme_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum lexeme_t$/;"	g	file:
library_arch_models_	base/read_blif.cpp	/^        const t_model* library_arch_models_ = nullptr;$/;"	m	struct:BlifAllocCallback	file:	access:private
library_models	base/vpr_types.h	/^	t_model * library_models; \/* blif models in VPR *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
lighten_color	draw/draw.cpp	/^t_color lighten_color(t_color color, float amount) {$/;"	f	signature:(t_color color, float amount)
lighten_color	draw/draw.cpp	/^t_color lighten_color(t_color color, float amount);$/;"	p	file:	signature:(t_color color, float amount)
limiting_resources	base/device_grid.h	/^        std::vector<t_type_ptr> limiting_resources() const { return limiting_resources_; }$/;"	f	class:DeviceGrid	access:public	signature:() const
limiting_resources_	base/device_grid.h	/^        std::vector<t_type_ptr> limiting_resources_;$/;"	m	class:DeviceGrid	access:private
line	../../libs/libarchfpga/src/physical_types.h	/^	int line;$/;"	m	struct:t_direct_inf	access:public
line	../../libs/libpugiutil/src/pugixml_loc.cpp	/^std::size_t loc_data::line(std::ptrdiff_t offset) const {$/;"	f	class:pugiutil::loc_data	signature:(std::ptrdiff_t offset) const
line	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t line(pugi::xml_node node) const {$/;"	f	class:pugiutil::loc_data	access:public	signature:(pugi::xml_node node) const
line	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t line(std::ptrdiff_t offset) const;$/;"	p	class:pugiutil::loc_data	access:public	signature:(std::ptrdiff_t offset) const
line	../../libs/libpugiutil/src/pugixml_util.hpp	/^            size_t line() const { return linenumber_; }$/;"	f	class:pugiutil::XmlError	access:public	signature:() const
line	../../libs/libvtrutil/src/vtr_error.h	/^        size_t line() const { return linenumber_; }$/;"	f	class:vtr::VtrError	access:public	signature:() const
line_caps	../../libs/libeasygl/src/easygl_constants.h	/^enum line_caps {$/;"	g
line_num	../../libs/libarchfpga/src/physical_types.h	/^	int line_num; \/* Interconnect is processed later, need to know what line number it messed up on to give proper error message *\/$/;"	m	struct:t_interconnect	access:public
line_num	../../libs/libarchfpga/src/physical_types.h	/^	int line_num; \/* used to report what line number this annotation is found in architecture file *\/$/;"	m	struct:t_pin_to_pin_annotation	access:public
line_types	../../libs/libeasygl/src/easygl_constants.h	/^enum line_types {$/;"	g
linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.cpp	/^template double linear_interpolate_or_extrapolate(const std::map<double,double> *xy_map, double requested_x);	\/* (double,double) *\/$/;"	p	namespace:vtr	file:	signature:(const std::map<double,double> *xy_map, double requested_x)
linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.cpp	/^template double linear_interpolate_or_extrapolate(const std::map<int,double> *xy_map, int requested_x);	\/* (int,double) *\/$/;"	p	namespace:vtr	file:	signature:(const std::map<int,double> *xy_map, int requested_x)
linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.cpp	/^template<typename X, typename Y> Y linear_interpolate_or_extrapolate(const std::map<X,Y> *xy_map, X requested_x){$/;"	f	namespace:vtr	signature:(const std::map<X,Y> *xy_map, X requested_x)
linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.h	/^    Y linear_interpolate_or_extrapolate(const std::map<X,Y> *xy_map, X requested_x);$/;"	p	namespace:vtr	signature:(const std::map<X,Y> *xy_map, X requested_x)
linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map() = default;$/;"	p	class:vtr::linear_map	access:public	signature:()
linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map(const linear_map&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(const linear_map&)
linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map(linear_map&&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(linear_map&&)
linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map(size_t num_keys)$/;"	f	class:vtr::linear_map	access:public	signature:(size_t num_keys)
linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^class linear_map {$/;"	c	namespace:vtr
linear_regression_vector	base/stats.h	/^double linear_regression_vector(const std::vector<T>& vals, size_t start_x = 0) {$/;"	f	signature:(const std::vector<T>& vals, size_t start_x = 0)
lineno_	base/read_blif.cpp	/^        int lineno_ = -1;$/;"	m	struct:BlifAllocCallback	file:	access:private
lineno_	timing/read_sdc.cpp	/^        int lineno_ = -1;$/;"	m	class:SdcCallback	file:	access:private
lineno_	timing/read_sdc2.cpp	/^        int lineno_ = -1;$/;"	m	class:SdcParseCallback2	file:	access:private
linenumber_	../../libs/libpugiutil/src/pugixml_util.hpp	/^            size_t linenumber_;$/;"	m	class:pugiutil::XmlError	access:private
linenumber_	../../libs/libvtrutil/src/vtr_error.h	/^        size_t linenumber_;$/;"	m	class:vtr::VtrError	access:private
list_of_connectable_input_pin_ptrs	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin ***list_of_connectable_input_pin_ptrs = nullptr; \/* [0..depth-1][0..num_connectable_primitive_input_pins-1] what input pins this output can connect to without exiting cluster at given depth *\/$/;"	m	struct:t_pb_graph_pin	access:public
list_size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t list_size()$/;"	f	class:BitSpace::VerilogBits	access:private	signature:()
load	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load(const char_t* contents, unsigned int options)$/;"	f	class:pugi::xml_document	signature:(const char_t* contents, unsigned int options)
load	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)
load	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)$/;"	f	class:pugi::xml_document	signature:(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)
load	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load(const char_t* contents, unsigned int options = parse_default);$/;"	p	class:pugi::xml_document	access:public	signature:(const char_t* contents, unsigned int options = parse_default)
load	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
load	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default);$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default)
load_atom_index_for_pb_pin	base/read_netlist.cpp	/^static void load_atom_index_for_pb_pin(t_pb_routes& pb_route, int ipin) {$/;"	f	file:	signature:(t_pb_routes& pb_route, int ipin)
load_atom_index_for_pb_pin	base/read_netlist.cpp	/^static void load_atom_index_for_pb_pin(t_pb_routes& pb_route, int ipin);$/;"	p	file:	signature:(t_pb_routes& pb_route, int ipin)
load_atom_pin_mapping	base/read_netlist.cpp	/^static void load_atom_pin_mapping(const ClusteredNetlist& clb_nlist) {$/;"	f	file:	signature:(const ClusteredNetlist& clb_nlist)
load_atom_pin_mapping	base/read_netlist.cpp	/^static void load_atom_pin_mapping(const ClusteredNetlist& clb_nlist);$/;"	p	file:	signature:(const ClusteredNetlist& clb_nlist)
load_block_rr_indices	route/rr_graph2.cpp	/^static void load_block_rr_indices($/;"	f	file:	signature:( const DeviceGrid& grid, t_rr_node_indices& indices, int* index)
load_block_rr_indices	route/rr_graph2.cpp	/^static void load_block_rr_indices($/;"	p	file:	signature:( const DeviceGrid& grid, t_rr_node_indices& indices, int* index)
load_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
load_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
load_buffer_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result load_buffer_impl(xml_document_struct* doc, xml_node_struct* root, void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own, char_t** out_buffer)$/;"	f	signature:(xml_document_struct* doc, xml_node_struct* root, void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own, char_t** out_buffer)
load_buffer_inplace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(void* contents, size_t size, unsigned int options, xml_encoding encoding)
load_buffer_inplace	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_buffer_inplace(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
load_buffer_inplace_own	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(void* contents, size_t size, unsigned int options, xml_encoding encoding)
load_buffer_inplace_own	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_buffer_inplace_own(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
load_chan_rr_indices	route/rr_graph2.cpp	/^static void load_chan_rr_indices($/;"	f	file:	signature:( const int max_chan_width, const int chan_len, const int num_chans, const t_rr_type type, const t_chan_details& chan_details, t_rr_node_indices& indices, int *index)
load_chan_rr_indices	route/rr_graph2.cpp	/^static void load_chan_rr_indices($/;"	p	file:	signature:( const int max_chan_width, const int chan_len, const int num_chans, const t_rr_type type, const t_chan_details& chan_details, t_rr_node_indices& indices, int *index)
load_channel_occupancies	base/stats.cpp	/^static void load_channel_occupancies(vtr::Matrix<int>& chanx_occ, vtr::Matrix<int>& chany_occ) {$/;"	f	file:	signature:(vtr::Matrix<int>& chanx_occ, vtr::Matrix<int>& chany_occ)
load_channel_occupancies	base/stats.cpp	/^static void load_channel_occupancies(vtr::Matrix<int>& chanx_occ, vtr::Matrix<int>& chany_occ);$/;"	p	file:	signature:(vtr::Matrix<int>& chanx_occ, vtr::Matrix<int>& chany_occ)
load_clock_domain_and_clock_and_io_delay	timing/path_delay.cpp	/^static void load_clock_domain_and_clock_and_io_delay(bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping) {$/;"	f	file:	signature:(bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
load_clock_domain_and_clock_and_io_delay	timing/path_delay.cpp	/^static void load_clock_domain_and_clock_and_io_delay(bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping);$/;"	p	file:	signature:(bool is_prepacked, vtr::vector<ClusterBlockId, std::vector<int>> &lookup_tnode_from_pin_id, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
load_cluster_placement_stats_for_pb_graph_node	pack/cluster_placement.cpp	/^static void load_cluster_placement_stats_for_pb_graph_node($/;"	f	file:	signature:( t_cluster_placement_stats *cluster_placement_stats, t_pb_graph_node *pb_graph_node)
load_cluster_placement_stats_for_pb_graph_node	pack/cluster_placement.cpp	/^static void load_cluster_placement_stats_for_pb_graph_node($/;"	p	file:	signature:( t_cluster_placement_stats *cluster_placement_stats, t_pb_graph_node *pb_graph_node)
load_criticalities	place/timing_place.cpp	/^void load_criticalities(SetupTimingInfo& timing_info, float crit_exponent, const ClusteredPinAtomPinsLookup& pin_lookup) {$/;"	f	signature:(SetupTimingInfo& timing_info, float crit_exponent, const ClusteredPinAtomPinsLookup& pin_lookup)
load_criticalities	place/timing_place.h	/^void load_criticalities(SetupTimingInfo& timing_info, float crit_exponent, const ClusteredPinAtomPinsLookup& pin_lookup);$/;"	p	signature:(SetupTimingInfo& timing_info, float crit_exponent, const ClusteredPinAtomPinsLookup& pin_lookup)
load_delay_annotations	pack/pb_type_graph_annotations.cpp	/^static void load_delay_annotations(const int line_num,$/;"	f	file:	signature:(const int line_num, t_pb_graph_node *pb_graph_node, const int mode, const enum e_pin_to_pin_annotation_format input_format, const enum e_pin_to_pin_delay_annotations delay_type, const char *annot_in_pins, const char *annot_out_pins, const char* clock, const char* value)
load_delay_annotations	pack/pb_type_graph_annotations.cpp	/^static void load_delay_annotations(const int line_num,$/;"	p	file:	signature:(const int line_num, t_pb_graph_node *pb_graph_node, const int mode, const enum e_pin_to_pin_annotation_format input_format, const enum e_pin_to_pin_delay_annotations delay_type, const char *annot_in_pins, const char *annot_out_pins, const char* clock, const char* value)
load_external_nets_and_cb	base/read_netlist.cpp	/^static void load_external_nets_and_cb(ClusteredNetlist& clb_nlist) {$/;"	f	file:	signature:(ClusteredNetlist& clb_nlist)
load_external_nets_and_cb	base/read_netlist.cpp	/^static void load_external_nets_and_cb(ClusteredNetlist& clb_nlist);$/;"	p	file:	signature:(ClusteredNetlist& clb_nlist)
load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_file(const char* path_, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(const char* path_, unsigned int options, xml_encoding encoding)
load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_file(const wchar_t* path_, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(const wchar_t* path_, unsigned int options, xml_encoding encoding)
load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_file(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_file(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
load_file_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result load_file_impl(xml_document_struct* doc, FILE* file, unsigned int options, xml_encoding encoding, char_t** out_buffer)$/;"	f	signature:(xml_document_struct* doc, FILE* file, unsigned int options, xml_encoding encoding, char_t** out_buffer)
load_initial_budgets	route/route_budgets.cpp	/^void route_budgets::load_initial_budgets() {$/;"	f	class:route_budgets	signature:()
load_initial_budgets	route/route_budgets.h	/^    void load_initial_budgets();$/;"	p	class:route_budgets	access:private	signature:()
load_internal_to_block_net_nums	base/read_netlist.cpp	/^static void load_internal_to_block_net_nums(const t_type_ptr type, t_pb_routes& pb_route) {$/;"	f	file:	signature:(const t_type_ptr type, t_pb_routes& pb_route)
load_internal_to_block_net_nums	base/read_netlist.cpp	/^static void load_internal_to_block_net_nums(const t_type_ptr type, t_pb_routes& pb_route);$/;"	p	file:	signature:(const t_type_ptr type, t_pb_routes& pb_route)
load_legal_placements	place/place.cpp	/^static void load_legal_placements() {$/;"	f	file:	signature:()
load_legal_placements	place/place.cpp	/^static void load_legal_placements();$/;"	p	file:	signature:()
load_list_of_connectable_input_pin_ptrs	pack/cluster_feasibility_filter.cpp	/^static void load_list_of_connectable_input_pin_ptrs($/;"	f	file:	signature:( t_pb_graph_node *pb_graph_node)
load_list_of_connectable_input_pin_ptrs	pack/cluster_feasibility_filter.cpp	/^static void load_list_of_connectable_input_pin_ptrs($/;"	p	file:	signature:( t_pb_graph_node *pb_graph_node)
load_lut_mask	base/netlist_writer.cpp	/^        LogicVec load_lut_mask(size_t num_inputs, \/\/LUT size$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(size_t num_inputs, const t_pb* atom)
load_net_delay_from_routing	timing/net_delay.cpp	/^void load_net_delay_from_routing(vtr::vector<ClusterNetId, float *> &net_delay) {$/;"	f	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
load_net_delay_from_routing	timing/net_delay.h	/^void load_net_delay_from_routing(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
load_net_route_bb	route/route_common.cpp	/^t_bb load_net_route_bb(ClusterNetId net_id, int bb_factor) {$/;"	f	signature:(ClusterNetId net_id, int bb_factor)
load_net_route_bb	route/route_common.h	/^t_bb load_net_route_bb(ClusterNetId net_id, int bb_factor);$/;"	p	signature:(ClusterNetId net_id, int bb_factor)
load_net_rr_terminals	route/route_common.cpp	/^static vtr::vector<ClusterNetId, std::vector<int>> load_net_rr_terminals(const t_rr_node_indices& L_rr_node_indices) {$/;"	f	file:	signature:(const t_rr_node_indices& L_rr_node_indices)
load_net_rr_terminals	route/route_common.cpp	/^static vtr::vector<ClusterNetId, std::vector<int>> load_net_rr_terminals(const t_rr_node_indices& L_rr_node_indices);$/;"	p	file:	signature:(const t_rr_node_indices& L_rr_node_indices)
load_new_subtree_C_downstream	route/route_tree_timing.cpp	/^float load_new_subtree_C_downstream(t_rt_node* rt_node) {$/;"	f	signature:(t_rt_node* rt_node)
load_new_subtree_C_downstream	route/route_tree_timing.h	/^float load_new_subtree_C_downstream(t_rt_node* rt_node);$/;"	p	signature:(t_rt_node* rt_node)
load_new_subtree_R_upstream	route/route_tree_timing.cpp	/^void load_new_subtree_R_upstream(t_rt_node* rt_node) {$/;"	f	signature:(t_rt_node* rt_node)
load_new_subtree_R_upstream	route/route_tree_timing.h	/^void load_new_subtree_R_upstream(t_rt_node* rt_node);$/;"	p	signature:(t_rt_node* rt_node)
load_one_constant_net_delay	timing/net_delay.cpp	/^static void load_one_constant_net_delay(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, float delay_value) {$/;"	f	file:	signature:(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, float delay_value)
load_one_constant_net_delay	timing/net_delay.cpp	/^static void load_one_constant_net_delay(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, float delay_value);$/;"	p	file:	signature:(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, float delay_value)
load_one_net_delay	timing/net_delay.cpp	/^static void load_one_net_delay(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, t_linked_rc_ptr * rr_node_to_rc_node) {$/;"	f	file:	signature:(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, t_linked_rc_ptr * rr_node_to_rc_node)
load_one_net_delay	timing/net_delay.cpp	/^static void load_one_net_delay(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, t_linked_rc_ptr * rr_node_to_rc_node);$/;"	p	file:	signature:(vtr::vector<ClusterNetId, float *> &net_delay, ClusterNetId net_id, t_linked_rc_ptr * rr_node_to_rc_node)
load_pack_pattern_annotations	pack/pb_type_graph_annotations.cpp	/^static void load_pack_pattern_annotations(const int line_num, t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(const int line_num, t_pb_graph_node *pb_graph_node, const int mode, const char *annot_in_pins, const char *annot_out_pins, const char *value)
load_pack_pattern_annotations	pack/pb_type_graph_annotations.cpp	/^static void load_pack_pattern_annotations(const int line_num, t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(const int line_num, t_pb_graph_node *pb_graph_node, const int mode, const char *annot_in_pins, const char *annot_out_pins, const char *value)
load_pb_graph_pin_lookup_from_index_rec	util/vpr_utils.cpp	/^static void load_pb_graph_pin_lookup_from_index_rec(t_pb_graph_pin ** pb_graph_pin_lookup_from_index, t_pb_graph_node *pb_graph_node) {$/;"	f	file:	signature:(t_pb_graph_pin ** pb_graph_pin_lookup_from_index, t_pb_graph_node *pb_graph_node)
load_pb_graph_pin_lookup_from_index_rec	util/vpr_utils.cpp	/^static void load_pb_graph_pin_lookup_from_index_rec(t_pb_graph_pin ** pb_graph_pin_lookup_from_index, t_pb_graph_node *pb_graph_node);$/;"	p	file:	signature:(t_pb_graph_pin ** pb_graph_pin_lookup_from_index, t_pb_graph_node *pb_graph_node)
load_pb_graph_pin_to_pin_annotations	pack/pb_type_graph_annotations.cpp	/^void load_pb_graph_pin_to_pin_annotations(t_pb_graph_node *pb_graph_node) {$/;"	f	signature:(t_pb_graph_node *pb_graph_node)
load_pb_graph_pin_to_pin_annotations	pack/pb_type_graph_annotations.h	/^void load_pb_graph_pin_to_pin_annotations(t_pb_graph_node *pb_graph_node);$/;"	p	signature:(t_pb_graph_node *pb_graph_node)
load_perturbed_connection_block_pattern	route/rr_graph.cpp	/^static void load_perturbed_connection_block_pattern($/;"	f	file:	signature:( vtr::NdMatrix<int, 5>& tracks_connected_to_pin, const std::vector<t_pin_loc>& pin_locations, const int x_chan_width, const int y_chan_width, const int Fc, enum e_directionality directionality)
load_perturbed_connection_block_pattern	route/rr_graph.cpp	/^static void load_perturbed_connection_block_pattern($/;"	p	file:	signature:( vtr::NdMatrix<int, 5>& tracks_connected_to_pin, const std::vector<t_pin_loc>& pin_locations, const int x_chan_width, const int y_chan_width, const int Fc, const enum e_directionality directionality)
load_pin_class_by_depth	pack/cluster_feasibility_filter.cpp	/^static void load_pin_class_by_depth(t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(t_pb_graph_node *pb_graph_node, const int depth, int *input_count, int *output_count)
load_pin_class_by_depth	pack/cluster_feasibility_filter.cpp	/^static void load_pin_class_by_depth(t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(t_pb_graph_node *pb_graph_node, const int depth, int *input_count, int *output_count)
load_pin_classes_in_pb_graph_head	pack/cluster_feasibility_filter.cpp	/^void load_pin_classes_in_pb_graph_head(t_pb_graph_node *pb_graph_node) {$/;"	f	signature:(t_pb_graph_node *pb_graph_node)
load_pin_classes_in_pb_graph_head	pack/cluster_feasibility_filter.h	/^void load_pin_classes_in_pb_graph_head(t_pb_graph_node *pb_graph_node);$/;"	p	signature:(t_pb_graph_node *pb_graph_node)
load_pin_id_to_pb_mapping_rec	util/vpr_utils.cpp	/^static void load_pin_id_to_pb_mapping_rec(t_pb *cur_pb, t_pb **pin_id_to_pb_mapping) {$/;"	f	file:	signature:(t_pb *cur_pb, t_pb **pin_id_to_pb_mapping)
load_pin_id_to_pb_mapping_rec	util/vpr_utils.cpp	/^static void load_pin_id_to_pb_mapping_rec(t_pb *cur_pb, t_pb **pin_id_to_pb_mapping);$/;"	p	file:	signature:(t_pb *cur_pb, t_pb **pin_id_to_pb_mapping)
load_png_from_file	../../libs/libeasygl/src/graphics.cpp	/^Surface load_png_from_file(const char* file_path) {$/;"	f	signature:(const char* file_path)
load_png_from_file	../../libs/libeasygl/src/graphics.h	/^Surface load_png_from_file(const char* file_path);$/;"	p	signature:(const char* file_path)
load_rc_tree_C	timing/net_delay.cpp	/^static float load_rc_tree_C(t_rc_node * rc_node) {$/;"	f	file:	signature:(t_rc_node * rc_node)
load_rc_tree_C	timing/net_delay.cpp	/^static float load_rc_tree_C(t_rc_node * rc_node);$/;"	p	file:	signature:(t_rc_node * rc_node)
load_rc_tree_T	timing/net_delay.cpp	/^static void load_rc_tree_T(t_rc_node * rc_node, float T_arrival) {$/;"	f	file:	signature:(t_rc_node * rc_node, float T_arrival)
load_rc_tree_T	timing/net_delay.cpp	/^static void load_rc_tree_T(t_rc_node * rc_node, float T_arrival);$/;"	p	file:	signature:(t_rc_node * rc_node, float T_arrival)
load_route_bb	route/route_common.cpp	/^vtr::vector<ClusterNetId, t_bb> load_route_bb(int bb_factor) {$/;"	f	signature:(int bb_factor)
load_route_bb	route/route_common.h	/^vtr::vector<ClusterNetId, t_bb> load_route_bb(int bb_factor);$/;"	p	signature:(int bb_factor)
load_route_budgets	route/route_budgets.cpp	/^void route_budgets::load_route_budgets(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
load_route_budgets	route/route_budgets.h	/^    void load_route_budgets(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	p	class:route_budgets	access:public	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
load_route_tree_Tdel	route/route_tree_timing.cpp	/^void load_route_tree_Tdel(t_rt_node * subtree_rt_root, float Tarrival) {$/;"	f	signature:(t_rt_node * subtree_rt_root, float Tarrival)
load_route_tree_Tdel	route/route_tree_timing.h	/^void load_route_tree_Tdel(t_rt_node* rt_root, float Tarrival);$/;"	p	signature:(t_rt_node* rt_root, float Tarrival)
load_route_tree_rr_route_inf	route/route_tree_timing.cpp	/^void load_route_tree_rr_route_inf(t_rt_node* root) {$/;"	f	signature:(t_rt_node* root)
load_route_tree_rr_route_inf	route/route_tree_timing.h	/^void load_route_tree_rr_route_inf(t_rt_node* root);$/;"	p	signature:(t_rt_node* root)
load_rr_clb_sources	route/route_common.cpp	/^static vtr::vector<ClusterBlockId, std::vector<int>> load_rr_clb_sources(const t_rr_node_indices& L_rr_node_indices) {$/;"	f	file:	signature:(const t_rr_node_indices& L_rr_node_indices)
load_rr_clb_sources	route/route_common.cpp	/^static vtr::vector<ClusterBlockId, std::vector<int>> load_rr_clb_sources(const t_rr_node_indices& L_rr_node_indices);$/;"	p	file:	signature:(const t_rr_node_indices& L_rr_node_indices)
load_rr_file	route/rr_graph_reader.cpp	/^void load_rr_file(const t_graph_type graph_type,$/;"	f	signature:(const t_graph_type graph_type, const DeviceGrid& grid, t_chan_width nodes_per_chan, const int num_seg_types, const t_segment_inf * segment_inf, const enum e_base_cost_type base_cost_type, int *wire_to_rr_ipin_switch, int *num_rr_switches, const char* read_rr_graph_name)
load_rr_file	route/rr_graph_reader.h	/^void load_rr_file(const t_graph_type graph_type,$/;"	p	signature:(const t_graph_type graph_type, const DeviceGrid& grid, t_chan_width nodes_per_chan, const int num_seg_types, const t_segment_inf * segment_inf, const enum e_base_cost_type base_cost_type, int *wire_to_rr_ipin_switch, int *num_rr_switches, const char* read_rr_graph_name)
load_rr_index_segments	route/rr_graph_indexed_data.cpp	/^void load_rr_index_segments(const int num_segment) {$/;"	f	signature:(const int num_segment)
load_rr_index_segments	route/rr_graph_indexed_data.h	/^void load_rr_index_segments(const int num_segment);$/;"	p	signature:(const int num_segment)
load_rr_indexed_data_T_values	route/rr_graph_indexed_data.cpp	/^static void load_rr_indexed_data_T_values(int index_start,$/;"	f	file:	signature:(int index_start, int num_indices_to_load, t_rr_type rr_type, int nodes_per_chan, const t_rr_node_indices& L_rr_node_indices)
load_rr_indexed_data_T_values	route/rr_graph_indexed_data.cpp	/^static void load_rr_indexed_data_T_values(int index_start,$/;"	p	file:	signature:(int index_start, int num_indices_to_load, t_rr_type rr_type, int nodes_per_chan, const t_rr_node_indices& L_rr_node_indices)
load_rr_indexed_data_base_costs	route/rr_graph_indexed_data.cpp	/^static void load_rr_indexed_data_base_costs(int nodes_per_chan,$/;"	f	file:	signature:(int nodes_per_chan, const t_rr_node_indices& L_rr_node_indices, enum e_base_cost_type base_cost_type)
load_rr_indexed_data_base_costs	route/rr_graph_indexed_data.cpp	/^static void load_rr_indexed_data_base_costs(int nodes_per_chan,$/;"	p	file:	signature:(int nodes_per_chan, const t_rr_node_indices& L_rr_node_indices, enum e_base_cost_type base_cost_type)
load_rr_switch_inf	route/rr_graph.cpp	/^static void load_rr_switch_inf(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos, const t_arch_switch_fanin& arch_switch_fanins) {$/;"	f	file:	signature:(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos, const t_arch_switch_fanin& arch_switch_fanins)
load_rr_switch_inf	route/rr_graph.cpp	/^static void load_rr_switch_inf(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos, const t_arch_switch_fanin& switch_fanin);$/;"	p	file:	signature:(const int num_arch_switches, const float R_minW_nmos, const float R_minW_pmos, const t_arch_switch_fanin& switch_fanin)
load_sblock_pattern_lookup	route/rr_graph2.cpp	/^void load_sblock_pattern_lookup($/;"	f	signature:( const int i, const int j, const DeviceGrid& grid, const t_chan_width *nodes_per_chan, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const int , const enum e_switch_block_type switch_block_type, t_sblock_pattern& sblock_pattern)
load_sblock_pattern_lookup	route/rr_graph2.h	/^void load_sblock_pattern_lookup($/;"	p	signature:( const int i, const int j, const DeviceGrid& grid, const t_chan_width *nodes_per_chan, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, const int Fs, const enum e_switch_block_type switch_block_type, t_sblock_pattern& sblock_pattern)
load_stream_data_noseek	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> PUGI__FN xml_parse_status load_stream_data_noseek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)$/;"	f	signature:(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)
load_stream_data_seek	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> PUGI__FN xml_parse_status load_stream_data_seek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)$/;"	f	signature:(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)
load_stream_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> PUGI__FN xml_parse_result load_stream_impl(xml_document_struct* doc, std::basic_istream<T>& stream, unsigned int options, xml_encoding encoding, char_t** out_buffer)$/;"	f	signature:(xml_document_struct* doc, std::basic_istream<T>& stream, unsigned int options, xml_encoding encoding, char_t** out_buffer)
load_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_string(const char_t* contents, unsigned int options)$/;"	f	class:pugi::xml_document	signature:(const char_t* contents, unsigned int options)
load_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_string(const char_t* contents, unsigned int options = parse_default);$/;"	p	class:pugi::xml_document	access:public	signature:(const char_t* contents, unsigned int options = parse_default)
load_timing_graph_net_delays	timing/path_delay.cpp	/^void load_timing_graph_net_delays(vtr::vector<ClusterNetId, float *> &net_delay) {$/;"	f	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
load_timing_graph_net_delays	timing/path_delay.h	/^void load_timing_graph_net_delays(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
load_tnode	timing/path_delay.cpp	/^static void load_tnode(t_pb_graph_pin *pb_graph_pin, const ClusterBlockId iblock,$/;"	f	file:	signature:(t_pb_graph_pin *pb_graph_pin, const ClusterBlockId iblock, int *inode)
load_tnode	timing/path_delay.cpp	/^static void load_tnode(t_pb_graph_pin *pb_graph_pin, const ClusterBlockId iblock,$/;"	p	file:	signature:(t_pb_graph_pin *pb_graph_pin, const ClusterBlockId iblock, int *inode)
load_trace_to_pb_route	pack/cluster_router.cpp	/^static void load_trace_to_pb_route(t_pb_routes& pb_route, const int total_pins, const AtomNetId net_id, const int prev_pin_id, const t_lb_trace *trace) {$/;"	f	file:	signature:(t_pb_routes& pb_route, const int total_pins, const AtomNetId net_id, const int prev_pin_id, const t_lb_trace *trace)
load_trace_to_pb_route	pack/cluster_router.cpp	/^static void load_trace_to_pb_route(t_pb_routes& pb_route, const int total_pins, const AtomNetId net_id, const int prev_pin_id, const t_lb_trace *trace);$/;"	p	file:	signature:(t_pb_routes& pb_route, const int total_pins, const AtomNetId net_id, const int prev_pin_id, const t_lb_trace *trace)
load_transitive_fanout_candidates	pack/cluster.cpp	/^static void load_transitive_fanout_candidates(ClusterBlockId clb_index,$/;"	f	file:	signature:(ClusterBlockId clb_index, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, t_pb_stats *pb_stats, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets)
load_transitive_fanout_candidates	pack/cluster.cpp	/^static void load_transitive_fanout_candidates(ClusterBlockId cluster_index,$/;"	p	file:	signature:(ClusterBlockId cluster_index, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, t_pb_stats *pb_stats, vtr::vector<ClusterBlockId,std::vector<AtomNetId>> &clb_inter_blk_nets)
load_uniform_connection_block_pattern	route/rr_graph.cpp	/^static void load_uniform_connection_block_pattern($/;"	f	file:	signature:( vtr::NdMatrix<int, 5>& tracks_connected_to_pin, const std::vector<t_pin_loc>& pin_locations, const int x_chan_width, const int y_chan_width, const int Fc, enum e_directionality directionality)
load_uniform_connection_block_pattern	route/rr_graph.cpp	/^static void load_uniform_connection_block_pattern($/;"	p	file:	signature:( vtr::NdMatrix<int, 5>& tracks_connected_to_pin, const std::vector<t_pin_loc>& pin_locations, const int x_chan_width, const int y_chan_width, const int Fc, const enum e_directionality directionality)
load_xml	../../libs/libpugiutil/src/pugixml_util.cpp	/^    loc_data load_xml(pugi::xml_document& doc,  \/\/Document object to be loaded with file contents$/;"	f	namespace:pugiutil	signature:(pugi::xml_document& doc, const std::string filename)
load_xml	../../libs/libpugiutil/src/pugixml_util.hpp	/^    loc_data load_xml(pugi::xml_document& doc,  \/\/Document object to be loaded with file contents$/;"	p	namespace:pugiutil	signature:(pugi::xml_document& doc, const std::string filename)
loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            loc_data() = default;$/;"	p	class:pugiutil::loc_data	access:public	signature:()
loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            loc_data(std::string filename_val)$/;"	f	class:pugiutil::loc_data	access:public	signature:(std::string filename_val)
loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^    class loc_data {$/;"	c	namespace:pugiutil
loc_defs	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_grid_loc_def> loc_defs;       \/\/The list of grid location definitions for this grid specification$/;"	m	struct:t_grid_def	access:public
local_interc_factor	../../libs/libarchfpga/src/physical_types.h	/^	float local_interc_factor;$/;"	m	struct:t_power_arch	access:public
local_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* local_name(const xpath_node& node)$/;"	f	signature:(const xpath_node& node)
location	../../libs/libarchfpga/src/physical_types.h	/^	e_sb_location location;			\/* where on the FPGA this switchblock should be built (i.e. perimeter, core, everywhere) *\/$/;"	m	struct:t_switchblock_inf	access:public
locations	place/timing_place_lookup.cpp	/^    std::vector<t_profile_loc> locations;$/;"	m	struct:t_profile_info	file:	access:public
log_close	../../libs/liblog/src/log.cpp	/^void log_close() {$/;"	f	signature:()
log_close	../../libs/liblog/src/log.h	/^void log_close();$/;"	p	signature:()
log_error	../../libs/liblog/src/log.cpp	/^static int log_error = 0;$/;"	v	file:
log_msg	power/power_util.cpp	/^static void log_msg(t_log * log_ptr, const char * msg) {$/;"	f	file:	signature:(t_log * log_ptr, const char * msg)
log_msg	power/power_util.cpp	/^static void log_msg(t_log * log_ptr, const char * msg);$/;"	p	file:	signature:(t_log * log_ptr, const char * msg)
log_print_direct	../../libs/liblog/src/log.cpp	/^void log_print_direct(const char* message, ...) {$/;"	f	signature:(const char* message, ...)
log_print_direct	../../libs/liblog/src/log.h	/^void log_print_direct(const char* message, ...);$/;"	p	signature:(const char* message, ...)
log_print_error	../../libs/liblog/src/log.cpp	/^void log_print_error(const char* \/*filename*\/, unsigned int \/*line_num*\/, const char* message, ...) {$/;"	f	signature:(const char* , unsigned int , const char* message, ...)
log_print_error	../../libs/liblog/src/log.h	/^void log_print_error(const char* filename, unsigned int line_num, const char* message, ...);$/;"	p	signature:(const char* filename, unsigned int line_num, const char* message, ...)
log_print_info	../../libs/liblog/src/log.cpp	/^void log_print_info(const char* message, ...) {$/;"	f	signature:(const char* message, ...)
log_print_info	../../libs/liblog/src/log.h	/^void log_print_info(const char* message, ...);$/;"	p	signature:(const char* message, ...)
log_print_warning	../../libs/liblog/src/log.cpp	/^void log_print_warning(const char* \/*filename*\/, unsigned int \/*line_num*\/, const char* message, ...) {$/;"	f	signature:(const char* , unsigned int , const char* message, ...)
log_print_warning	../../libs/liblog/src/log.h	/^void log_print_warning(const char* filename, unsigned int line_num, const char* message, ...);$/;"	p	signature:(const char* filename, unsigned int line_num, const char* message, ...)
log_set_output_file	../../libs/liblog/src/log.cpp	/^void log_set_output_file(const char *filename) {$/;"	f	signature:(const char *filename)
log_set_output_file	../../libs/liblog/src/log.h	/^void log_set_output_file(const char *filename);$/;"	p	signature:(const char *filename)
log_stream	../../libs/liblog/src/log.cpp	/^FILE *log_stream = nullptr;$/;"	v
log_warning	../../libs/liblog/src/log.cpp	/^static int log_warning = 0;$/;"	v	file:
logical_effort_factor	../../libs/libarchfpga/src/physical_types.h	/^	float logical_effort_factor;$/;"	m	struct:t_power_arch	access:public
logical_net_drivers_	base/netlist_writer.cpp	/^        std::map<AtomNetId, std::pair<std::string,tatum::NodeId>> logical_net_drivers_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
logical_net_sink_delays_	base/netlist_writer.cpp	/^        std::map<std::string, float> logical_net_sink_delays_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
logical_net_sinks_	base/netlist_writer.cpp	/^        std::map<AtomNetId, std::vector<std::pair<std::string,tatum::NodeId>>> logical_net_sinks_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
logs	power/power.h	/^	t_log * logs;$/;"	m	struct:t_power_output	access:public
long_trans_inf	power/power.h	/^	t_transistor_size_inf * long_trans_inf; \/* Long transistor (W=1,L=2) *\/$/;"	m	struct:t_transistor_inf	access:public
longest_critical_path	timing/timing_info.h	/^        virtual tatum::TimingPathInfo longest_critical_path() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
longline	../../libs/libarchfpga/src/physical_types.h	/^	bool longline;$/;"	m	struct:t_segment_inf	access:public
longline	base/vpr_types.h	/^	bool longline = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
longline	base/vpr_types.h	/^        bool longline() const { return seg_detail_->longline; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
lookahead_input_pins_used	pack/pack_types.h	/^    std::vector<std::vector<AtomNetId>> lookahead_input_pins_used; \/* [0..pb_graph_node->num_pin_classes-1] vector of input pins of this class that are speculatively used *\/$/;"	m	struct:t_pb_stats	access:public
lookahead_output_pins_used	pack/pack_types.h	/^    std::vector<std::vector<AtomNetId>> lookahead_output_pins_used; \/* [0..pb_graph_node->num_pin_classes-1] vector of input pins of this class that are speculatively used *\/$/;"	m	struct:t_pb_stats	access:public
lookahead_type	base/vpr_types.h	/^    e_router_lookahead lookahead_type;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
lookup	base/vpr_context.h	/^    AtomLookup lookup;$/;"	m	struct:AtomContext	access:public
lookup_	timing/read_sdc2.cpp	/^        const AtomLookup& lookup_;$/;"	m	class:SdcParseCallback2	file:	access:private
loop_greedy	timing/slre.cpp	/^static void loop_greedy(const struct slre *r, int pc, const char *s, int len,$/;"	f	file:	signature:(const struct slre *r, int pc, const char *s, int len, int *ofs)
loop_non_greedy	timing/slre.cpp	/^static void loop_non_greedy(const struct slre *r, int pc, const char *s,$/;"	f	file:	signature:(const struct slre *r, int pc, const char *s, int len, int *ofs)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:latin1_writer	access:public	signature:(value_type result, uint32_t ch)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer	access:public	signature:(value_type result, uint32_t ch)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer	access:public	signature:(value_type result, uint32_t ch)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf8_counter	access:public	signature:(value_type result, uint32_t ch)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer	access:public	signature:(value_type result, uint32_t ch)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t)$/;"	f	struct:utf16_counter	access:public	signature:(value_type result, uint32_t)
low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t)$/;"	f	struct:utf32_counter	access:public	signature:(value_type result, uint32_t)
low_idx	../../libs/libarchfpga/src/arch_util.h	/^            int low_idx = UNSPECIFIED;$/;"	m	struct:InstPort::name_index	access:public
lower_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator lower_bound(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
lower_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator lower_bound(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
lower_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator lower_bound(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
lower_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator lower_bound(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
lower_bound_connection_delay	route/connection_based_routing.h	/^	vtr::vector<ClusterNetId, std::vector<float>> lower_bound_connection_delay;$/;"	m	class:Connection_based_routing_resources	access:private
lower_bound_delay_ch	route/route_budgets.h	/^    vtr::t_chunk lower_bound_delay_ch;$/;"	m	class:route_budgets	access:private
lower_budgets	route/route_budgets.cpp	/^void route_budgets::lower_budgets(float delay_decrement) {$/;"	f	class:route_budgets	signature:(float delay_decrement)
lower_budgets	route/route_budgets.h	/^    void lower_budgets(float delay_decrement);$/;"	p	class:route_budgets	access:public	signature:(float delay_decrement)
lowercase	timing/slre.cpp	/^static int lowercase(const char *s) {$/;"	f	file:	signature:(const char *s)
lut_mask_	base/netlist_writer.cpp	/^        LogicVec lut_mask_;$/;"	m	class:LutInst	file:	access:private
lut_size_	base/netlist_writer.cpp	/^        size_t lut_size_;$/;"	m	class:LutInst	file:	access:private
lval_	base/netlist_writer.cpp	/^        std::string lval_;$/;"	m	class:Assignment	file:	access:private
mSurface	../../libs/libeasygl/src/SurfaceImpl.h	/^        std::shared_ptr<cairo_surface_t> mSurface;$/;"	m	class:SurfaceImpl	access:private
main	../../libs/libarchfpga/src/main.cpp	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	../../libs/liblog/src/main.cpp	/^int main() {$/;"	f	signature:()
main	main.cpp	/^int main(int argc, const char **argv) {$/;"	f	signature:(int argc, const char **argv)
main_netlist_	base/read_blif.cpp	/^        AtomNetlist& main_netlist_; \/\/User object we fill$/;"	m	struct:BlifAllocCallback	file:	access:private
maj	../../libs/libvtrutil/src/picosha2.h	/^inline word_t maj(word_t x, word_t y, word_t z){$/;"	f	namespace:picosha2::detail	signature:(word_t x, word_t y, word_t z)
make_adder_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_adder_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
make_constant_timing_info	timing/timing_info.h	/^inline std::unique_ptr<SetupHoldTimingInfo> make_constant_timing_info(const float criticality) {$/;"	f	signature:(const float criticality)
make_flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^flat_map<K,V> make_flat_map(std::vector<std::pair<K, V>> vec) {$/;"	f	namespace:vtr	signature:(std::vector<std::pair<K, V>> vec)
make_hold_timing_info	timing/timing_info.h	/^std::unique_ptr<HoldTimingInfo> make_hold_timing_info(std::shared_ptr<DelayCalc> delay_calculator) {$/;"	f	signature:(std::shared_ptr<DelayCalc> delay_calculator)
make_hold_timing_info	timing/timing_info.h	/^std::unique_ptr<HoldTimingInfo> make_hold_timing_info(std::shared_ptr<DelayCalc> delay_calculator);$/;"	p	signature:(std::shared_ptr<DelayCalc> delay_calculator)
make_insert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        T make_insert(size_t loc, bit_value_t value)$/;"	f	class:BitSpace::BitFields	access:private	signature:(size_t loc, bit_value_t value)
make_inst_port	../../libs/libarchfpga/src/read_xml_util.cpp	/^InstPort make_inst_port(pugi::xml_attribute attr, pugi::xml_node node, const pugiutil::loc_data& loc_data) {$/;"	f	signature:(pugi::xml_attribute attr, pugi::xml_node node, const pugiutil::loc_data& loc_data)
make_inst_port	../../libs/libarchfpga/src/read_xml_util.cpp	/^InstPort make_inst_port(std::string str, pugi::xml_node node, const pugiutil::loc_data& loc_data) {$/;"	f	signature:(std::string str, pugi::xml_node node, const pugiutil::loc_data& loc_data)
make_inst_port	../../libs/libarchfpga/src/read_xml_util.h	/^InstPort make_inst_port(pugi::xml_attribute attr, pugi::xml_node node, const pugiutil::loc_data& loc_data);$/;"	p	signature:(pugi::xml_attribute attr, pugi::xml_node node, const pugiutil::loc_data& loc_data)
make_inst_port	../../libs/libarchfpga/src/read_xml_util.h	/^InstPort make_inst_port(std::string str, pugi::xml_node node, const pugiutil::loc_data& loc_data);$/;"	p	signature:(std::string str, pugi::xml_node node, const pugiutil::loc_data& loc_data)
make_inst_wire	base/netlist_writer.cpp	/^        std::string make_inst_wire(AtomNetId atom_net_id, \/\/The id of the net in the atom netlist$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(AtomNetId atom_net_id, tatum::NodeId tnode_id, std::string inst_name, PortType port_type, int port_idx, int pin_idx)
make_io	base/netlist_writer.cpp	/^        std::string make_io(const t_pb* atom, \/\/The implementation primitive representing the I\/O$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom, PortType dir)
make_key_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_key_range(T b, T e) {$/;"	f	namespace:vtr	signature:(T b, T e)
make_key_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_key_range(const Container& c) {$/;"	f	namespace:vtr	signature:(const Container& c)
make_latch_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_latch_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
make_lut_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_lut_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
make_mask	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        T make_mask(size_t loc)$/;"	f	class:BitSpace::BitFields	access:private	signature:(size_t loc)
make_multiply_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_multiply_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
make_no_op_timing_info	timing/timing_info.h	/^std::unique_ptr<SetupHoldTimingInfo> make_no_op_timing_info();$/;"	p	signature:()
make_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline xml_parse_result make_parse_result(xml_parse_status status, ptrdiff_t offset = 0)$/;"	f	signature:(xml_parse_status status, ptrdiff_t offset = 0)
make_poor_cb_pattern	route/cb_metrics.cpp	/^void make_poor_cb_pattern(const e_pin_type pin_type, const t_type_ptr block_type, const int *Fc_array,$/;"	f	signature:(const e_pin_type pin_type, const t_type_ptr block_type, const int *Fc_array, const t_chan_width *chan_width_inf, int *****cb)
make_poor_cb_pattern	route/cb_metrics.h	/^void make_poor_cb_pattern(const e_pin_type pin_type, const t_type_ptr block_type, const int *Fc_array,$/;"	p	signature:(const e_pin_type pin_type, const t_type_ptr block_type, const int *Fc_array, const t_chan_width *chan_width_inf, int *****cb)
make_ram_instance	base/netlist_writer.cpp	/^        std::shared_ptr<Instance> make_ram_instance(const t_pb* atom)  {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const t_pb* atom)
make_range	../../libs/libvtrutil/src/vtr_range.h	/^auto make_range(T b, T e) { return Range<T>(b, e); }$/;"	f	namespace:vtr	signature:(T b, T e)
make_range	../../libs/libvtrutil/src/vtr_range.h	/^auto make_range(const Container& c) { return make_range(std::begin(c), std::end(c)); }$/;"	f	namespace:vtr	signature:(const Container& c)
make_router_lookahead	route/router_lookahead.cpp	/^std::unique_ptr<RouterLookahead> make_router_lookahead(e_router_lookahead router_lookahead_type) {$/;"	f	signature:(e_router_lookahead router_lookahead_type)
make_router_lookahead	route/router_lookahead.h	/^std::unique_ptr<RouterLookahead> make_router_lookahead(e_router_lookahead router_lookahead_type);$/;"	p	signature:(e_router_lookahead router_lookahead_type)
make_setup_hold_timing_info	timing/timing_info.h	/^std::unique_ptr<SetupHoldTimingInfo> make_setup_hold_timing_info(std::shared_ptr<DelayCalc> delay_calculator) {$/;"	f	signature:(std::shared_ptr<DelayCalc> delay_calculator)
make_setup_hold_timing_info	timing/timing_info.h	/^std::unique_ptr<SetupHoldTimingInfo> make_setup_hold_timing_info(std::shared_ptr<DelayCalc> delay_calculator);$/;"	p	signature:(std::shared_ptr<DelayCalc> delay_calculator)
make_setup_timing_info	timing/timing_info.h	/^std::unique_ptr<SetupTimingInfo> make_setup_timing_info(std::shared_ptr<DelayCalc> delay_calculator) {$/;"	f	signature:(std::shared_ptr<DelayCalc> delay_calculator)
make_setup_timing_info	timing/timing_info.h	/^std::unique_ptr<SetupTimingInfo> make_setup_timing_info(std::shared_ptr<DelayCalc> delay_calculator);$/;"	p	signature:(std::shared_ptr<DelayCalc> delay_calculator)
make_unconn	base/atom_netlist_utils.cpp	/^std::string make_unconn(size_t& unconn_count, PinType \/*pin_type*\/) {$/;"	f	signature:(size_t& unconn_count, PinType )
make_unconn	base/atom_netlist_utils.cpp	/^std::string make_unconn(size_t& unconn_count, PinType type);$/;"	p	file:	signature:(size_t& unconn_count, PinType type)
make_value_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_value_range(T b, T e) {$/;"	f	namespace:vtr	signature:(T b, T e)
make_value_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_value_range(const Container& c) {$/;"	f	namespace:vtr	signature:(const Container& c)
malloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* malloc(size_t size) {$/;"	f	namespace:vtr	signature:(size_t size)
malloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* malloc(size_t size);$/;"	p	namespace:vtr	signature:(size_t size)
malloc_trim	../../libs/libvtrutil/src/vtr_memory.cpp	/^int malloc_trim(size_t \/*pad*\/) {$/;"	f	namespace:vtr	signature:(size_t )
malloc_trim	../../libs/libvtrutil/src/vtr_memory.h	/^    int malloc_trim(size_t pad);$/;"	p	namespace:vtr	signature:(size_t pad)
map_	../../libs/libvtrutil/src/vtr_bimap.h	/^        Map<K,V> map_;$/;"	m	class:vtr::bimap	access:private
map_button	../../libs/libeasygl/src/graphics.cpp	/^static void map_button(int bnum) {$/;"	f	file:	signature:(int bnum)
map_button	../../libs/libeasygl/src/graphics.cpp	/^static void map_button(int bnum);$/;"	p	file:	signature:(int bnum)
map_has_key	route/cb_metrics.cpp	/^template< typename F, typename T > bool map_has_key( const F key, const std::map< F, T > *my_map ){$/;"	f	signature:( const F key, const std::map< F, T > *my_map )
mapped_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef T mapped_type;$/;"	t	class:vtr::flat_map	access:public
mapped_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef T mapped_type;$/;"	t	class:vtr::linear_map	access:public
mark_all_molecules_valid	pack/cluster.cpp	/^static void mark_all_molecules_valid(t_pack_molecule* molecule_head) {$/;"	f	file:	signature:(t_pack_molecule* molecule_head)
mark_all_molecules_valid	pack/cluster.cpp	/^static void mark_all_molecules_valid(t_pack_molecule* molecule_head);$/;"	p	file:	signature:(t_pack_molecule* molecule_head)
mark_and_update_partial_gain	pack/cluster.cpp	/^static void mark_and_update_partial_gain(const AtomNetId inet, enum e_gain_update gain_flag,$/;"	p	file:	signature:(const AtomNetId inet, enum e_gain_update gain_flag, const AtomBlockId clustered_blk_id, bool timing_driven, bool connection_driven, enum e_net_relation_to_clustered_block net_relation_to_clustered_block, const SetupTimingInfo& timing_info, const std::unordered_set<AtomNetId>& is_global)
mark_and_update_partial_gain	pack/cluster.cpp	/^static void mark_and_update_partial_gain(const AtomNetId net_id, enum e_gain_update gain_flag,$/;"	f	file:	signature:(const AtomNetId net_id, enum e_gain_update gain_flag, const AtomBlockId clustered_blk_id, bool timing_driven, bool connection_driven, enum e_net_relation_to_clustered_block net_relation_to_clustered_block, const SetupTimingInfo& timing_info, const std::unordered_set<AtomNetId>& is_global)
mark_clustering_net_delays	timing/timing_graph_builder.h	/^        void mark_clustering_net_delays(float inter_cluster_net_delay);$/;"	p	class:TimingGraphBuilder	access:private	signature:(float inter_cluster_net_delay)
mark_constant_generators	base/atom_netlist_utils.cpp	/^int mark_constant_generators(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity)
mark_constant_generators	base/atom_netlist_utils.h	/^int mark_constant_generators(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, int verbosity)
mark_constant_generators	base/read_netlist.cpp	/^static void mark_constant_generators(const ClusteredNetlist& clb_nlist) {$/;"	f	file:	signature:(const ClusteredNetlist& clb_nlist)
mark_constant_generators	base/read_netlist.cpp	/^static void mark_constant_generators(const ClusteredNetlist& clb_nlist);$/;"	p	file:	signature:(const ClusteredNetlist& clb_nlist)
mark_constant_generators	timing/read_sdc2.cpp	/^void mark_constant_generators(const AtomNetlist& netlist,$/;"	f	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& tc)
mark_constant_generators	timing/read_sdc2.cpp	/^void mark_constant_generators(const AtomNetlist& netlist,$/;"	p	file:	signature:(const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingConstraints& tc)
mark_constant_generators_rec	base/read_netlist.cpp	/^static void mark_constant_generators_rec(const t_pb *pb, const t_pb_routes& pb_route) {$/;"	f	file:	signature:(const t_pb *pb, const t_pb_routes& pb_route)
mark_constant_generators_rec	base/read_netlist.cpp	/^static void mark_constant_generators_rec(const t_pb *pb, const t_pb_routes& pb_route);$/;"	p	file:	signature:(const t_pb *pb, const t_pb_routes& pb_route)
mark_direct_of_pins	util/vpr_utils.cpp	/^static void mark_direct_of_pins(int start_pin_index, int end_pin_index, int itype,$/;"	f	file:	signature:(int start_pin_index, int end_pin_index, int itype, int iport, int ** idirect_from_blk_pin, int idirect, int ** direct_type_from_blk_pin, int direct_type, int line, char * src_string)
mark_direct_of_pins	util/vpr_utils.cpp	/^static void mark_direct_of_pins(int start_pin_index, int end_pin_index, int itype,$/;"	p	file:	signature:(int start_pin_index, int end_pin_index, int itype, int iport, int ** idirect_from_blk_pin, int idirect, int ** direct_type_from_blk_pin, int direct_type, int line, char * src_string)
mark_direct_of_ports	util/vpr_utils.cpp	/^static void mark_direct_of_ports (int idirect, int direct_type, char * pb_type_name,$/;"	f	file:	signature:(int idirect, int direct_type, char * pb_type_name, char * port_name, int end_pin_index, int start_pin_index, char * src_string, int line, int ** idirect_from_blk_pin, int ** direct_type_from_blk_pin)
mark_direct_of_ports	util/vpr_utils.cpp	/^static void mark_direct_of_ports (int idirect, int direct_type, char * pb_type_name,$/;"	p	file:	signature:(int idirect, int direct_type, char * pb_type_name, char * port_name, int end_pin_index, int start_pin_index, char * src_string, int line, int ** idirect_from_blk_pin, int ** direct_type_from_blk_pin)
mark_ends	route/route_common.cpp	/^void mark_ends(ClusterNetId net_id) {$/;"	f	signature:(ClusterNetId net_id)
mark_ends	route/route_common.h	/^void mark_ends(ClusterNetId net_id);$/;"	p	signature:(ClusterNetId net_id)
mark_for_forced_reroute	route/route_profiling.cpp	/^void mark_for_forced_reroute() {}$/;"	f	namespace:profiling	signature:()
mark_for_forced_reroute	route/route_profiling.h	/^void mark_for_forced_reroute();$/;"	p	namespace:profiling	signature:()
mark_max_block_delay	timing/path_delay.cpp	/^static void mark_max_block_delay(const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode) {$/;"	f	file:	signature:(const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode)
mark_max_block_delay	timing/path_delay.cpp	/^static void mark_max_block_delay(const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode);$/;"	p	file:	signature:(const std::unordered_map<AtomBlockId,t_pb_graph_node*>& expected_lowest_cost_pb_gnode)
mark_remaining_ends	route/route_common.cpp	/^void mark_remaining_ends(const vector<int>& remaining_sinks) {$/;"	f	signature:(const vector<int>& remaining_sinks)
mark_remaining_ends	route/route_common.h	/^void mark_remaining_ends(const std::vector<int>& remaining_sinks);$/;"	p	signature:(const std::vector<int>& remaining_sinks)
mark_undriven_primitive_outputs_as_constant	base/atom_netlist_utils.cpp	/^int mark_undriven_primitive_outputs_as_constant(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
mark_undriven_primitive_outputs_as_constant	base/atom_netlist_utils.cpp	/^int mark_undriven_primitive_outputs_as_constant(AtomNetlist& netlist, int verbosity);$/;"	p	file:	signature:(AtomNetlist& netlist, int verbosity)
marked_blocks	pack/pack_types.h	/^    std::vector<AtomBlockId> marked_blocks; \/\/List of blocks with the num_pins_of_net_in_pb and gain entries altered$/;"	m	struct:t_pb_stats	access:public
marked_nets	pack/pack_types.h	/^    std::vector<AtomNetId> marked_nets; \/\/List of nets with the num_pins_of_net_in_pb and gain entries altered$/;"	m	struct:t_pb_stats	access:public
mask_32bit	../../libs/libvtrutil/src/picosha2.h	/^inline word_t mask_32bit(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
mask_8bit	../../libs/libvtrutil/src/picosha2.h	/^inline byte_t mask_8bit(byte_t x){$/;"	f	namespace:picosha2::detail	signature:(byte_t x)
match	timing/slre.cpp	/^static const char *match(const struct slre *, int, const char *, int, int *,$/;"	p	file:	signature:(const struct slre *, int, const char *, int, int *, struct cap *)
match	timing/slre.cpp	/^static const char *match(const struct slre *r, int pc, const char *s, int len,$/;"	f	file:	signature:(const struct slre *r, int pc, const char *s, int len, int *ofs, struct cap *caps)
match2	timing/slre.cpp	/^static const char *match2(const struct slre *r, const char *buf, int len,$/;"	f	file:	signature:(const struct slre *r, const char *buf, int len, struct cap *caps)
max	../../libs/libvtrutil/src/vtr_color_map.cpp	/^float ColorMap::max() const {$/;"	f	class:vtr::ColorMap	signature:() const
max	../../libs/libvtrutil/src/vtr_color_map.h	/^        float max() const;$/;"	p	class:vtr::ColorMap	access:public	signature:() const
max	base/vpr_types.h	/^	int max = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
max_	../../libs/libvtrutil/src/vtr_color_map.h	/^        float max_;$/;"	m	class:vtr::ColorMap	access:private
max_IPIN_fanin	power/power.h	/^	int max_IPIN_fanin;$/;"	m	struct:t_power_commonly_used	access:public
max_budget_delay_ch	route/route_budgets.h	/^    vtr::t_chunk max_budget_delay_ch;$/;"	m	class:route_budgets	access:private
max_buffer_size	power/power.h	/^	int max_buffer_size;$/;"	m	struct:t_power_tech	access:public
max_convergence_count	base/vpr_types.h	/^    int max_convergence_count;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
max_criticality	base/read_options.h	/^    argparse::ArgValue<float> max_criticality;$/;"	m	struct:t_options	access:public
max_criticality	base/vpr_types.h	/^	float max_criticality;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
max_delay	route/route_timing.h	/^    float max_delay; \/\/Maximum legal connection delay$/;"	m	struct:t_conn_delay_budget	access:public
max_delta_x	place/timing_place_lookup.cpp	/^    int max_delta_x;$/;"	m	struct:t_profile_info	file:	access:public
max_delta_y	place/timing_place_lookup.cpp	/^    int max_delta_y;$/;"	m	struct:t_profile_info	file:	access:public
max_edge_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::max_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
max_index	route/rr_graph.cpp	/^    int max_index;$/;"	m	struct:t_mux_size_distribution	file:	access:public
max_internal_delay	../../libs/libarchfpga/src/physical_types.h	/^	float max_internal_delay = -1; \/\/TODO: remove when VPR's classic timing analyzer is removed$/;"	m	struct:t_pb_type	access:public
max_iterations	pack/pack_types.h	/^	int max_iterations;$/;"	m	struct:t_lb_router_params	access:public
max_mux_sl_size	power/power.h	/^	int max_mux_sl_size;$/;"	m	struct:t_power_nmos_mux_inf	access:public
max_pins_per_grid_tile	util/vpr_utils.cpp	/^int max_pins_per_grid_tile() {$/;"	f	signature:()
max_pins_per_grid_tile	util/vpr_utils.h	/^int max_pins_per_grid_tile();$/;"	p	signature:()
max_router_iterations	base/read_options.h	/^    argparse::ArgValue<int> max_router_iterations;$/;"	m	struct:t_options	access:public
max_router_iterations	base/vpr_types.h	/^	int max_router_iterations;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
max_routing_mux_size	power/power.h	/^	int max_routing_mux_size;$/;"	m	struct:t_power_commonly_used	access:public
max_rss_mib	../../libs/libvtrutil/src/vtr_time.cpp	/^float Timer::max_rss_mib() const {$/;"	f	class:vtr::Timer	signature:() const
max_rss_mib	../../libs/libvtrutil/src/vtr_time.h	/^            float max_rss_mib() const;$/;"	p	class:vtr::Timer	access:public	signature:() const
max_seg_fanout	power/power.h	/^	int max_seg_fanout;$/;"	m	struct:t_power_commonly_used	access:public
max_seg_to_IPIN_fanout	power/power.h	/^	int max_seg_to_IPIN_fanout;$/;"	m	struct:t_power_commonly_used	access:public
max_seg_to_seg_fanout	power/power.h	/^	int max_seg_to_seg_fanout;$/;"	m	struct:t_power_commonly_used	access:public
max_size	../../libs/libvtrutil/src/vtr_flat_map.h	/^        size_type max_size() const { return vec_.max_size(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
max_size	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type max_size() const { return vec_.max_size(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
max_sub_blk_lvl	draw/draw_types.h	/^	int max_sub_blk_lvl = 0;$/;"	m	struct:t_draw_state	access:public
max_value	util/histogram.h	/^    float max_value = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:HistogramBucket	access:public
median	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I, typename Pred> void median(I first, I middle, I last, const Pred& pred)$/;"	f	signature:(I first, I middle, I last, const Pred& pred)
median	../../libs/libvtrutil/src/vtr_math.h	/^    double median(Container c) {$/;"	f	namespace:vtr	signature:(Container c)
median	../../libs/libvtrutil/src/vtr_math.h	/^    double median(InputIterator first, InputIterator last) {$/;"	f	namespace:vtr	signature:(InputIterator first, InputIterator last)
median3	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I, typename Pred> void median3(I first, I middle, I last, const Pred& pred)$/;"	f	signature:(I first, I middle, I last, const Pred& pred)
mem_avail	../../libs/libvtrutil/src/vtr_memory.h	/^        int mem_avail = 0; \/* number of bytes left in the current chunk *\/$/;"	m	struct:vtr::t_chunk	access:public
members	place/place_macro.h	/^	t_pl_macro_member* members;$/;"	m	struct:t_pl_macro	access:public
memory_pool	pack/cluster.cpp	/^static t_molecule_link *memory_pool; \/*Declared here so I can free easily.*\/$/;"	v	file:
menu	../../libs/libeasygl/src/graphics_state.h	/^    Window toplevel, menu, textarea;$/;"	m	class:t_x11_state	access:public
menu_draw	../../libs/libeasygl/src/graphics_state.h	/^            *menu_draw = nullptr,$/;"	m	class:t_x11_state	access:public
menutext	../../libs/libeasygl/src/graphics.cpp	/^static void menutext(XftDraw* draw, int xc, int yc, const char *text) {$/;"	f	file:	signature:(XftDraw* draw, int xc, int yc, const char *text)
menutext	../../libs/libeasygl/src/graphics.cpp	/^static void menutext(XftDraw* draw, int xc, int yc, const char *text);$/;"	p	file:	signature:(XftDraw* draw, int xc, int yc, const char *text)
merge_nets	base/netlist.h	/^        void merge_nets(const NetId driver_net, const NetId sink_net);$/;"	p	class:Netlist	access:public	signature:(const NetId driver_net, const NetId sink_net)
merge_nets	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::merge_nets(const NetId driver_net, const NetId sink_net) {$/;"	f	class:Netlist	signature:(const NetId driver_net, const NetId sink_net)
messages	power/power.h	/^	char ** messages;$/;"	m	struct:t_log	access:public
meta_characters	timing/slre.cpp	/^static const char *meta_characters = "|.*+?()[\\\\";$/;"	v	file:
min	../../libs/libvtrutil/src/vtr_color_map.cpp	/^float ColorMap::min() const {$/;"	f	class:vtr::ColorMap	signature:() const
min	../../libs/libvtrutil/src/vtr_color_map.h	/^        float min() const;$/;"	p	class:vtr::ColorMap	access:public	signature:() const
min_	../../libs/libvtrutil/src/vtr_color_map.h	/^        float min_;$/;"	m	class:vtr::ColorMap	access:private
min_budget_delay_ch	route/route_budgets.h	/^    vtr::t_chunk min_budget_delay_ch;$/;"	m	class:route_budgets	access:private
min_channel_width_hint	base/vpr_types.h	/^    int min_channel_width_hint; \/\/Hint to binary search of what the minimum channel width is$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
min_delay	route/route_timing.h	/^    float min_delay; \/\/Minimum legal connection delay$/;"	m	struct:t_conn_delay_budget	access:public
min_edge_delay	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::min_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
min_element	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I, typename Pred> I min_element(I begin, I end, const Pred& pred)$/;"	f	signature:(I begin, I end, const Pred& pred)
min_history_	route/routing_predictor.h	/^    size_t min_history_;$/;"	m	class:RoutingPredictor	access:private
min_incremental_reroute_fanout	base/read_options.h	/^    argparse::ArgValue<int> min_incremental_reroute_fanout;$/;"	m	struct:t_options	access:public
min_incremental_reroute_fanout	base/vpr_types.h	/^	int min_incremental_reroute_fanout;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
min_route_chan_width_hint	base/read_options.h	/^    argparse::ArgValue<int> min_route_chan_width_hint; \/\/Hint to binary search router about what the min chan width is$/;"	m	struct:t_options	access:public
min_size	../../libs/libarchfpga/src/logic_types.h	/^	int min_size = 0; \/* minimum number of pins *\/$/;"	m	struct:t_model_ports	access:public
min_value	util/histogram.h	/^    float min_value = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:HistogramBucket	access:public
minimax_PERT	route/route_budgets.cpp	/^float route_budgets::minimax_PERT(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets,$/;"	f	class:route_budgets	signature:(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets, vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type analysis_type, bool keep_in_bounds, slack_allocated_type slack_type)
minimax_PERT	route/route_budgets.h	/^    float minimax_PERT(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets,$/;"	p	class:route_budgets	access:private	signature:(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets, vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type analysis_type, bool keep_in_bounds, slack_allocated_type slack_type = BOTH)
mode	base/vpr_types.h	/^	int mode = 0; \/* mode that this pb is set to *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
mode	pack/pack_types.h	/^	int mode;								\/* Mode that this rr_node is set to *\/$/;"	m	struct:t_lb_rr_node_stats	access:public
mode_power	../../libs/libarchfpga/src/physical_types.h	/^	t_mode_power * mode_power;$/;"	m	struct:t_mode	access:public
model	../../libs/libarchfpga/src/cad_types.h	/^	t_model *model; \/* block associated with chain *\/$/;"	m	struct:t_model_chain_pattern	access:public
model	../../libs/libarchfpga/src/physical_types.h	/^	t_model *model = nullptr;$/;"	m	struct:t_pb_type	access:public
model_library	../../libs/libarchfpga/src/physical_types.h	/^	t_model *model_library;$/;"	m	struct:t_arch	access:public
model_pin	base/vpr_types.h	/^	int model_port, model_pin; \/* technology mapped model pin *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
model_port	../../libs/libarchfpga/src/physical_types.h	/^	t_model_ports *model_port;$/;"	m	struct:t_port	access:public
model_port	base/vpr_types.h	/^	int model_port, model_pin; \/* technology mapped model pin *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
model_port_ptr	base/vpr_types.h	/^	t_model_ports *model_port_ptr;$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
models	../../libs/libarchfpga/src/physical_types.h	/^	t_model *models;$/;"	m	struct:t_arch	access:public
modes	../../libs/libarchfpga/src/physical_types.h	/^	t_mode *modes = nullptr; \/* [0..num_modes-1] *\/$/;"	m	struct:t_pb_type	access:public
moleculeptr	pack/cluster.cpp	/^	t_pack_molecule *moleculeptr;$/;"	m	struct:t_molecule_link	file:	access:public
more_sinks_than	route/route_timing.cpp	/^struct more_sinks_than {$/;"	s	file:
more_sinks_than::operator ()	route/route_timing.cpp	/^    inline bool operator()(const ClusterNetId net_index1, const ClusterNetId net_index2) {$/;"	f	struct:more_sinks_than	access:public	signature:(const ClusterNetId net_index1, const ClusterNetId net_index2)
moved_blocks	base/vpr_types.h	/^	t_pl_moved_block * moved_blocks;$/;"	m	struct:ScreenUpdatePriority::t_pl_blocks_to_be_moved	access:public
msb_index	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    size_t msb_index()$/;"	f	class:VNumber	access:public	signature:()
mutable_atom	base/vpr_context.h	/^        AtomContext& mutable_atom() { return atom_; }$/;"	f	class:VprContext	access:public	signature:()
mutable_clustering	base/vpr_context.h	/^        ClusteringContext& mutable_clustering() { return clustering_; }$/;"	f	class:VprContext	access:public	signature:()
mutable_device	base/vpr_context.h	/^        DeviceContext& mutable_device() { return device_; }$/;"	f	class:VprContext	access:public	signature:()
mutable_placement	base/vpr_context.h	/^        PlacementContext& mutable_placement() { return placement_; }$/;"	f	class:VprContext	access:public	signature:()
mutable_power	base/vpr_context.h	/^        PowerContext& mutable_power() { return power_; }$/;"	f	class:VprContext	access:public	signature:()
mutable_routing	base/vpr_context.h	/^        RoutingContext& mutable_routing() { return routing_; }$/;"	f	class:VprContext	access:public	signature:()
mutable_timing	base/vpr_context.h	/^        TimingContext& mutable_timing() { return timing_; }$/;"	f	class:VprContext	access:public	signature:()
mux_arch	power/power.h	/^	t_mux_arch * mux_arch;$/;"	m	struct:t_power_mux_info	access:public
mux_arch_fix_levels	power/power_util.cpp	/^void mux_arch_fix_levels(t_mux_arch * mux_arch) {$/;"	f	signature:(t_mux_arch * mux_arch)
mux_arch_fix_levels	power/power_util.h	/^void mux_arch_fix_levels(t_mux_arch * mux_arch);$/;"	p	signature:(t_mux_arch * mux_arch)
mux_arch_max_size	power/power.h	/^	int mux_arch_max_size;$/;"	m	struct:t_power_mux_info	access:public
mux_count	route/rr_graph.cpp	/^    int mux_count;$/;"	m	struct:t_mux_size_distribution	file:	access:public
mux_find_selector_values	power/power_util.cpp	/^bool mux_find_selector_values(int * selector_values, t_mux_node * mux_node,$/;"	f	signature:(int * selector_values, t_mux_node * mux_node, int selected_input_pin)
mux_find_selector_values	power/power_util.h	/^bool mux_find_selector_values(int * selector_values, t_mux_node * mux_node,$/;"	p	signature:(int * selector_values, t_mux_node * mux_node, int selected_input_pin)
mux_graph_head	power/power.h	/^	t_mux_node * mux_graph_head;$/;"	m	struct:t_mux_arch	access:public
mux_info	power/power.h	/^	std::map<float, t_power_mux_info*> mux_info;$/;"	m	struct:t_power_commonly_used	access:public
mux_size	power/power.h	/^	int mux_size;$/;"	m	struct:t_power_buffer_sc_levr_inf	access:public
mux_trans_size	../../libs/libarchfpga/src/physical_types.h	/^	float mux_trans_size = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
mux_trans_size	../../libs/libarchfpga/src/physical_types.h	/^        float mux_trans_size = 1.;$/;"	m	struct:t_arch_switch_inf	access:public
mux_transistor_size	../../libs/libarchfpga/src/physical_types.h	/^	float mux_transistor_size;$/;"	m	struct:t_power_arch	access:public
mux_voltage_inf	power/power.h	/^	t_power_mux_volt_inf * mux_voltage_inf;$/;"	m	struct:t_power_nmos_mux_inf	access:public
mux_voltage_pairs	power/power.h	/^	t_power_mux_volt_pair * mux_voltage_pairs;$/;"	m	struct:t_power_mux_volt_inf	access:public
my_atof_2D	util/token.cpp	/^void my_atof_2D(float **matrix, const int max_i, const int max_j,$/;"	f	signature:(float **matrix, const int max_i, const int max_j, const char *instring)
my_atof_2D	util/token.h	/^void my_atof_2D(float **matrix, const int max_i, const int max_j, const char *instring);$/;"	p	signature:(float **matrix, const int max_i, const int max_j, const char *instring)
my_malloc	../../libs/libeasygl/src/graphics.cpp	/^static void *my_malloc(int ibytes) {$/;"	f	file:	signature:(int ibytes)
my_malloc	../../libs/libeasygl/src/graphics.cpp	/^static void *my_malloc(int ibytes);$/;"	p	file:	signature:(int ibytes)
my_realloc	../../libs/libeasygl/src/graphics.cpp	/^static void *my_realloc(void *memblk, int ibytes) {$/;"	f	file:	signature:(void *memblk, int ibytes)
my_realloc	../../libs/libeasygl/src/graphics.cpp	/^static void *my_realloc(void *memblk, int ibytes);$/;"	p	file:	signature:(void *memblk, int ibytes)
n	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node n;$/;"	m	struct:xpath_context	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_boolean	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_node_set	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_number	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_string	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* name;$/;"	m	struct:name_null_sentry	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<4, 2> name;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<4, 2> name;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_attribute::name() const$/;"	f	class:pugi::xml_attribute	signature:() const
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::name() const$/;"	f	class:pugi::xml_node	signature:() const
name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xpath_variable::name() const$/;"	f	class:pugi::xpath_variable	signature:() const
name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* name() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* name() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* name() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
name	../../libs/libarchfpga/src/arch_util.h	/^            std::string name = "";$/;"	m	struct:InstPort::name_index	access:public
name	../../libs/libarchfpga/src/cad_types.h	/^	char *name; \/* name of this chain of logic *\/$/;"	m	struct:t_model_chain_pattern	access:public
name	../../libs/libarchfpga/src/cad_types.h	/^	char *name; \/* name of this logic model pattern *\/$/;"	m	struct:t_pack_patterns	access:public
name	../../libs/libarchfpga/src/logic_types.h	/^	char *name = nullptr; \/* name of this logic model *\/$/;"	m	struct:t_model	access:public
name	../../libs/libarchfpga/src/logic_types.h	/^	char *name = nullptr; \/* name of this port *\/$/;"	m	struct:t_model_ports	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char *name = nullptr;$/;"	m	struct:t_type_descriptor	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char *name;$/;"	m	struct:t_direct_inf	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char *name;$/;"	m	struct:t_interconnect	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char *name;$/;"	m	struct:t_segment_inf	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char* name = nullptr;$/;"	m	struct:t_pb_type	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char* name;$/;"	m	struct:t_mode	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	char* name;$/;"	m	struct:t_port	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	const char *name = nullptr;$/;"	m	struct:t_rr_switch_inf	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^	std::string name;			\/* the name of this switchblock *\/$/;"	m	struct:t_switchblock_inf	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^        char *name = nullptr;$/;"	m	struct:t_arch_switch_inf	access:public
name	../../libs/libarchfpga/src/physical_types.h	/^    std::string name = "";                      \/\/The name of this device$/;"	m	struct:t_grid_def	access:public
name	base/device_grid.h	/^        const std::string& name() const { return name_; }$/;"	f	class:DeviceGrid	access:public	signature:() const
name	base/vpr_types.h	/^	char * name; \/* I\/O port name with an SDC constraint *\/$/;"	m	struct:ScreenUpdatePriority::t_io	access:public
name	base/vpr_types.h	/^	char * name;$/;"	m	struct:ScreenUpdatePriority::t_clock	access:public
name	base/vpr_types.h	/^	char *name = nullptr; \/* Name of this physical block *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
name	power/PowerSpicedComponent.h	/^	std::string name;$/;"	m	class:PowerSpicedComponent	access:public
name	power/power.h	/^	char * name;$/;"	m	struct:t_log	access:public
name	timing/read_sdc.cpp	/^	char * name;$/;"	m	struct:t_sdc_clock	file:	access:public
name	util/hash.h	/^	char *name;$/;"	m	struct:t_hash	access:public
name_	base/device_grid.h	/^        std::string name_;$/;"	m	class:DeviceGrid	access:private
name_index	../../libs/libarchfpga/src/arch_util.h	/^        struct name_index {$/;"	s	class:InstPort	access:private
name_null_sentry	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		name_null_sentry(xml_node_struct* node_): node(node_), name(node_->name)$/;"	f	struct:name_null_sentry	access:public	signature:(xml_node_struct* node_)
name_null_sentry	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct name_null_sentry$/;"	s	file:
name_null_sentry::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* name;$/;"	m	struct:name_null_sentry	file:	access:public
name_null_sentry::name_null_sentry	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		name_null_sentry(xml_node_struct* node_): node(node_), name(node_->name)$/;"	f	struct:name_null_sentry	access:public	signature:(xml_node_struct* node_)
name_null_sentry::node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_node_struct* node;$/;"	m	struct:name_null_sentry	file:	access:public
name_null_sentry::~name_null_sentry	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~name_null_sentry()$/;"	f	struct:name_null_sentry	access:public	signature:()
names_encodes_on_set	base/netlist_writer.cpp	/^        bool names_encodes_on_set(vtr::t_linked_vptr* names_row_ptr) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(vtr::t_linked_vptr* names_row_ptr)
names_row_to_logic_vec	base/netlist_writer.cpp	/^        LogicVec names_row_to_logic_vec(const std::string names_row, size_t num_inputs, bool encoding_on_set) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(const std::string names_row, size_t num_inputs, bool encoding_on_set)
namespace_uri	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* namespace_uri(const xpath_node& node)$/;"	f	signature:(const xpath_node& node)
namespace_uri	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* namespace_uri(xml_attribute attr, xml_node parent)$/;"	f	signature:(xml_attribute attr, xml_node parent)
namespace_uri	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* namespace_uri(xml_node node)$/;"	f	signature:(xml_node node)
namespace_uri_predicate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		namespace_uri_predicate(const char_t* name)$/;"	f	struct:namespace_uri_predicate	access:public	signature:(const char_t* name)
namespace_uri_predicate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct namespace_uri_predicate$/;"	s	file:
namespace_uri_predicate::namespace_uri_predicate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		namespace_uri_predicate(const char_t* name)$/;"	f	struct:namespace_uri_predicate	access:public	signature:(const char_t* name)
namespace_uri_predicate::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator()(xml_attribute a) const$/;"	f	struct:namespace_uri_predicate	access:public	signature:(xml_attribute a) const
namespace_uri_predicate::prefix	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* prefix;$/;"	m	struct:namespace_uri_predicate	file:	access:public
namespace_uri_predicate::prefix_length	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t prefix_length;$/;"	m	struct:namespace_uri_predicate	file:	access:public
namevalue_base	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t namevalue_base;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
namevalue_base	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t namevalue_base;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
narrow_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		std::basic_ostream<char, std::char_traits<char> >* narrow_stream;$/;"	m	class:pugi::xml_writer_stream	access:private
ndims	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t ndims() const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:() const
ndims	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t ndims() const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:() const
need_endian_swap_utf	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool need_endian_swap_utf(xml_encoding le, xml_encoding re)$/;"	f	signature:(xml_encoding le, xml_encoding re)
net	pack/pack_types.h	/^	int	net;				\/* net of flat, technology-mapped, netlist using this node *\/$/;"	m	struct:t_lb_traceback	access:public
net_color	draw/draw_types.h	/^	vtr::vector<ClusterNetId, t_color> net_color;$/;"	m	struct:t_draw_state	access:public
net_cost	place/place.cpp	/^static vtr::vector<ClusterNetId, float> net_cost, temp_net_cost;$/;"	v	file:
net_delay_	timing/PostClusterDelayCalculator.h	/^	vtr::vector<ClusterNetId, float *> net_delay_;$/;"	m	class:PostClusterDelayCalculator	access:private
net_driver	base/netlist.h	/^        PinId               net_driver(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
net_driver	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::net_driver(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
net_driver_block	base/netlist.h	/^        BlockId             net_driver_block(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
net_driver_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::net_driver_block(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
net_fanout_end	route/route_profiling.cpp	/^void net_fanout_end(unsigned \/*net_fanout*\/) {}$/;"	f	namespace:profiling	signature:(unsigned )
net_fanout_end	route/route_profiling.h	/^void net_fanout_end(unsigned net_fanout);$/;"	p	namespace:profiling	signature:(unsigned net_fanout)
net_fanout_start	route/route_profiling.cpp	/^void net_fanout_start() {}$/;"	f	namespace:profiling	signature:()
net_fanout_start	route/route_profiling.h	/^void net_fanout_start();$/;"	p	namespace:profiling	signature:()
net_id_map_	base/netlist.h	/^        vtr::vector_map<NetId, NetId> net_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
net_ids_	base/netlist.h	/^        vtr::vector_map<NetId,NetId>              net_ids_;     \/\/Valid net ids$/;"	m	class:Netlist	access:private
net_is_constant	base/netlist.h	/^        bool                net_is_constant(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
net_is_constant	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::net_is_constant(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
net_is_driven_by_direct	place/place_macro.cpp	/^static bool net_is_driven_by_direct(ClusterNetId clb_net) {$/;"	f	file:	signature:(ClusterNetId clb_net)
net_is_driven_by_direct	place/place_macro.cpp	/^static bool net_is_driven_by_direct(ClusterNetId clb_net);$/;"	p	file:	signature:(ClusterNetId clb_net)
net_is_global	base/clustered_netlist.cpp	/^bool ClusteredNetlist::net_is_global(const ClusterNetId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterNetId id) const
net_is_global	base/clustered_netlist.h	/^        bool net_is_global(const ClusterNetId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterNetId id) const
net_is_global_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterNetId, bool> net_is_global_;     \/\/Boolean mapping indicating if the net is global$/;"	m	class:ClusteredNetlist	access:private
net_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<NetId, NetId>::const_iterator                  net_iterator;$/;"	t	class:Netlist	access:public
net_name	base/netlist.h	/^        const std::string&  net_name(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
net_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::net_name(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
net_name_to_net_id_	base/netlist.h	/^        vtr::vector_map<StringId,NetId>                 net_name_to_net_id_;$/;"	m	class:Netlist	access:private
net_names_	base/netlist.h	/^        vtr::vector_map<NetId,StringId>           net_names_;   \/\/Name of each net$/;"	m	class:Netlist	access:private
net_num	power/power.h	/^	ClusterNetId net_num; \/* Net number using the associated rr_node *\/$/;"	m	struct:t_rr_node_power	access:public
net_output_feeds_driving_block_input	pack/cluster.cpp	/^static std::unordered_map<AtomNetId,int> net_output_feeds_driving_block_input;$/;"	v	file:
net_pin	base/netlist.h	/^        PinId               net_pin(const NetId net_id, int net_pin_index) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id, int net_pin_index) const
net_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::net_pin(const NetId net_id, int net_pin_index) const {$/;"	f	class:Netlist	signature:(const NetId net_id, int net_pin_index) const
net_pin_block	base/netlist.h	/^        BlockId             net_pin_block(const NetId net_id, int net_pin_index) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id, int net_pin_index) const
net_pin_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::net_pin_block(const NetId net_id, int net_pin_index) const {$/;"	f	class:Netlist	signature:(const NetId net_id, int net_pin_index) const
net_pin_indices	place/place.cpp	/^static vtr::vector<ClusterBlockId,std::vector<int>> net_pin_indices;$/;"	v	file:
net_pin_physical_index	base/clustered_netlist.cpp	/^int ClusteredNetlist::net_pin_physical_index(const ClusterNetId net_id, int net_pin_index) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterNetId net_id, int net_pin_index) const
net_pin_physical_index	base/clustered_netlist.h	/^        int net_pin_physical_index(const ClusterNetId net_id, int net_pin_index) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterNetId net_id, int net_pin_index) const
net_pins	base/netlist.h	/^        pin_range           net_pins(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
net_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::net_pins(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
net_pins_	base/netlist.h	/^        vtr::vector_map<NetId,std::vector<PinId>> net_pins_;    \/\/Pins associated with each net$/;"	m	class:Netlist	access:private
net_range	base/netlist.h	/^        typedef typename vtr::Range<net_iterator>   net_range;$/;"	t	class:Netlist	access:public
net_rebuild_end	route/route_profiling.cpp	/^void net_rebuild_end(unsigned \/*net_fanout*\/, unsigned \/*sinks_left_to_route*\/) {}$/;"	f	namespace:profiling	signature:(unsigned , unsigned )
net_rebuild_end	route/route_profiling.h	/^void net_rebuild_end(unsigned net_fanout, unsigned sinks_left_to_route);$/;"	p	namespace:profiling	signature:(unsigned net_fanout, unsigned sinks_left_to_route)
net_rebuild_start	route/route_profiling.cpp	/^void net_rebuild_start() {}$/;"	f	namespace:profiling	signature:()
net_rebuild_start	route/route_profiling.h	/^void net_rebuild_start();$/;"	p	namespace:profiling	signature:()
net_rerouted	route/route_profiling.cpp	/^void net_rerouted() {}$/;"	f	namespace:profiling	signature:()
net_rerouted	route/route_profiling.h	/^void net_rerouted();$/;"	p	namespace:profiling	signature:()
net_rr_terminals	base/vpr_context.h	/^	vtr::vector<ClusterNetId, std::vector<int>> net_rr_terminals; \/* [0..num_nets-1][0..num_pins-1] *\/$/;"	m	struct:RoutingContext	access:public
net_sinks	base/netlist.h	/^        pin_range           net_sinks(const NetId net_id) const;$/;"	p	class:Netlist	access:public	signature:(const NetId net_id) const
net_sinks	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::net_sinks(const NetId net_id) const {$/;"	f	class:Netlist	signature:(const NetId net_id) const
net_sinks_reachable_in_cluster	pack/cluster.cpp	/^int net_sinks_reachable_in_cluster(const t_pb_graph_pin* driver_pb_gpin, const int depth, const AtomNetId net_id) {$/;"	f	signature:(const t_pb_graph_pin* driver_pb_gpin, const int depth, const AtomNetId net_id)
net_sinks_reachable_in_cluster	pack/cluster.cpp	/^int net_sinks_reachable_in_cluster(const t_pb_graph_pin* driver_pb_gpin, const int depth, const AtomNetId net_id);$/;"	p	file:	signature:(const t_pb_graph_pin* driver_pb_gpin, const int depth, const AtomNetId net_id)
net_status	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_net_routing_status> net_status; \/\/[0..cluster_ctx.clb_nlist.nets().size()-1]$/;"	m	struct:RoutingContext	access:public
netlist_	timing/PostClusterDelayCalculator.h	/^    const AtomNetlist& netlist_;$/;"	m	class:PostClusterDelayCalculator	access:private
netlist_	timing/PreClusterDelayCalculator.h	/^    const AtomNetlist& netlist_;$/;"	m	class:PreClusterDelayCalculator	access:private
netlist_	timing/VprTimingGraphResolver.h	/^        const AtomNetlist& netlist_;$/;"	m	class:VprTimingGraphResolver	access:private
netlist_	timing/atom_delay_calc.h	/^        const AtomNetlist& netlist_;$/;"	m	class:AtomDelayCalc	access:private
netlist_	timing/read_sdc2.cpp	/^        const AtomNetlist& netlist_;$/;"	m	class:SdcParseCallback2	file:	access:private
netlist_	timing/slack_evaluation.h	/^        const AtomNetlist& netlist_;$/;"	m	class:HoldSlackCrit	access:private
netlist_	timing/slack_evaluation.h	/^        const AtomNetlist& netlist_;$/;"	m	class:SetupSlackCrit	access:private
netlist_	timing/timing_graph_builder.h	/^        const AtomNetlist& netlist_;$/;"	m	class:TimingGraphBuilder	access:private
netlist_clock_drivers_	timing/read_sdc2.cpp	/^        std::set<AtomPinId> netlist_clock_drivers_;$/;"	m	class:SdcParseCallback2	file:	access:private
netlist_clock_drivers_	timing/timing_graph_builder.h	/^        std::set<AtomPinId> netlist_clock_drivers_;$/;"	m	class:TimingGraphBuilder	access:private
netlist_clocks	timing/read_sdc.cpp	/^char ** netlist_clocks; \/* [0..num_netlist_clocks - 1] array of names of clocks in netlist *\/$/;"	v
netlist_file_name	base/read_netlist.cpp	/^static const char* netlist_file_name = nullptr;$/;"	v	file:
netlist_id	base/netlist.h	/^        const std::string& netlist_id() const;$/;"	p	class:Netlist	access:public	signature:() const
netlist_id	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::netlist_id() const {$/;"	f	class:Netlist	signature:() const
netlist_id_	base/netlist.h	/^        std::string netlist_id_;    \/\/Unique identifier for the netlist$/;"	m	class:Netlist	access:private
netlist_id_	base/read_blif.cpp	/^        const std::string netlist_id_; \/\/Unique identifier based on the contents of the blif file$/;"	m	struct:BlifAllocCallback	file:	access:private
netlist_ios	timing/read_sdc.cpp	/^char ** netlist_ios; \/* [0..num_netlist_clocks - 1] array of names of ios in netlist *\/$/;"	v
netlist_lookup_	timing/PostClusterDelayCalculator.h	/^    const AtomLookup& netlist_lookup_;$/;"	m	class:PostClusterDelayCalculator	access:private
netlist_lookup_	timing/PreClusterDelayCalculator.h	/^    const AtomLookup& netlist_lookup_;$/;"	m	class:PreClusterDelayCalculator	access:private
netlist_lookup_	timing/VprTimingGraphResolver.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:VprTimingGraphResolver	access:private
netlist_lookup_	timing/atom_delay_calc.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:AtomDelayCalc	access:private
netlist_lookup_	timing/slack_evaluation.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:HoldSlackCrit	access:private
netlist_lookup_	timing/slack_evaluation.h	/^        const AtomLookup& netlist_lookup_;$/;"	m	class:SetupSlackCrit	access:private
netlist_lookup_	timing/timing_graph_builder.h	/^        AtomLookup& netlist_lookup_;$/;"	m	class:TimingGraphBuilder	access:private
netlist_name	base/netlist.h	/^        const std::string& netlist_name() const;$/;"	p	class:Netlist	access:public	signature:() const
netlist_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::netlist_name() const {$/;"	f	class:Netlist	signature:() const
netlist_name_	base/netlist.h	/^        std::string netlist_name_;  \/\/Name of the top-level netlist$/;"	m	class:Netlist	access:private
netlist_primary_ios_	timing/read_sdc2.cpp	/^        std::map<std::string,AtomPinId> netlist_primary_ios_;$/;"	m	class:SdcParseCallback2	file:	access:private
netlist_verbosity	base/read_options.h	/^    argparse::ArgValue<int> netlist_verbosity;$/;"	m	struct:t_options	access:public
netlist_verbosity	base/vpr_types.h	/^    int netlist_verbosity = 1; \/\/Verbose output during netlist cleaning$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
netlist_writer	base/netlist_writer.cpp	/^void netlist_writer(const std::string basename, std::shared_ptr<const AnalysisDelayCalculator> delay_calc) {$/;"	f	signature:(const std::string basename, std::shared_ptr<const AnalysisDelayCalculator> delay_calc)
netlist_writer	base/netlist_writer.h	/^void netlist_writer(const std::string basename, std::shared_ptr<const AnalysisDelayCalculator> delay_calc);$/;"	p	signature:(const std::string basename, std::shared_ptr<const AnalysisDelayCalculator> delay_calc)
nets	base/netlist.h	/^        net_range   nets() const;$/;"	p	class:Netlist	access:public	signature:() const
nets	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::net_range Netlist<BlockId, PortId, PinId, NetId>::nets() const {$/;"	f	class:Netlist	signature:() const
nets_and_pins_synced_to_z_coordinate	base/vpr_types.h	/^    bool nets_and_pins_synced_to_z_coordinate = false;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
nets_routed	route/router_stats.h	/^    size_t nets_routed = 0;$/;"	m	struct:RouterStats	access:public
new_block_id	base/netlist.h	/^        BlockId new_block_id(BlockId old_blk) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(BlockId old_blk) const
new_block_id	base/netlist.tpp	/^BlockId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_block_id(BlockId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(BlockId old_id) const
new_net_id	base/netlist.h	/^        NetId new_net_id(NetId old_net) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(NetId old_net) const
new_net_id	base/netlist.tpp	/^NetId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_net_id(NetId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(NetId old_id) const
new_pin_id	base/netlist.h	/^        PinId new_pin_id(PinId old_pin) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(PinId old_pin) const
new_pin_id	base/netlist.tpp	/^PinId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_pin_id(PinId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(PinId old_id) const
new_port_id	base/netlist.h	/^        PortId new_port_id(PortId old_port) const;$/;"	p	class:NetlistIdRemapper	access:public	signature:(PortId old_port) const
new_port_id	base/netlist.tpp	/^PortId NetlistIdRemapper<BlockId, PortId, PinId, NetId>::new_port_id(PortId old_id) const {$/;"	f	class:NetlistIdRemapper	signature:(PortId old_id) const
new_xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* new_xpath_variable(xpath_value_type type, const char_t* name)$/;"	f	signature:(xpath_value_type type, const char_t* name)
new_xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> PUGI__FN T* new_xpath_variable(const char_t* name)$/;"	f	signature:(const char_t* name)
next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void next()$/;"	f	class:xpath_lexer	access:public	signature:()
next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_extra_buffer* next;$/;"	m	struct:xml_extra_buffer	file:	access:public
next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* next;$/;"	m	struct:xml_memory_page	file:	access:public
next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_stream_chunk* next;$/;"	m	struct:xml_stream_chunk	file:	access:public
next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block* next;$/;"	m	struct:xpath_memory_block	file:	access:public
next	../../libs/libarchfpga/src/cad_types.h	/^	t_model_chain_pattern *next; \/* next chain (linked list) *\/$/;"	m	struct:t_model_chain_pattern	access:public
next	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_connections *next;$/;"	m	struct:t_pack_pattern_connections	access:public
next	../../libs/libarchfpga/src/logic_types.h	/^	t_model *next = nullptr; \/* next model (linked list) *\/$/;"	m	struct:t_model	access:public
next	../../libs/libarchfpga/src/logic_types.h	/^	t_model_ports *next = nullptr; \/* next port *\/$/;"	m	struct:t_model_ports	access:public
next	../../libs/libvtrutil/src/vtr_list.h	/^        struct t_linked_vptr *next;$/;"	m	struct:vtr::t_linked_vptr	typeref:struct:vtr::t_linked_vptr::t_linked_vptr	access:public
next	../../libs/libvtrutil/src/vtr_list.h	/^        t_linked_int *next;$/;"	m	struct:vtr::t_linked_int	access:public
next	base/place_and_route.h	/^	t_fmap_cell *next;$/;"	m	struct:t_fmap_cell	access:public
next	base/vpr_types.h	/^	t_linked_f_pointer *next;$/;"	m	struct:ScreenUpdatePriority::t_linked_f_pointer	access:public
next	base/vpr_types.h	/^	t_pack_molecule *next;$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
next	base/vpr_types.h	/^	t_trace *next;$/;"	m	struct:ScreenUpdatePriority::t_trace	access:public
next	pack/cluster.cpp	/^	t_molecule_link *next;$/;"	m	struct:t_molecule_link	file:	access:public
next	route/route_common.h	/^    t_heap *next = nullptr;$/;"	m	struct:t_heap	access:public
next	route/route_tree_type.h	/^		t_rt_node *next;$/;"	m	union:t_rt_node::__anon7	access:public
next	route/route_tree_type.h	/^	t_linked_rt_edge *next;$/;"	m	struct:t_linked_rt_edge	access:public
next	route/rr_graph.cpp	/^    t_mux *next;$/;"	m	struct:t_mux	file:	access:public
next	route/rr_graph.cpp	/^    t_mux_size_distribution *next;$/;"	m	struct:t_mux_size_distribution	file:	access:public
next	timing/net_delay.cpp	/^		t_rc_node *next;$/;"	m	union:t_rc_node::__anon11	file:	access:public
next	timing/net_delay.cpp	/^	t_linked_rc_edge *next;$/;"	m	struct:t_linked_rc_edge	file:	access:public
next	timing/net_delay.cpp	/^	t_linked_rc_ptr *next;$/;"	m	struct:t_linked_rc_ptr	file:	access:public
next	util/hash.h	/^	t_hash *next;$/;"	m	struct:t_hash	access:public
next_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_attribute_struct, 7, 0> next_attribute;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
next_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_attribute::next_attribute() const$/;"	f	class:pugi::xml_attribute	signature:() const
next_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute next_attribute() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
next_mem_loc_ptr	../../libs/libvtrutil/src/vtr_memory.h	/^        char *next_mem_loc_ptr = nullptr;\/* pointer to the first available (free) *$/;"	m	struct:vtr::t_chunk	access:public
next_nodes	pack/pack_types.h	/^    std::vector<t_lb_trace> next_nodes;		\/* index of previous edge that drives current node *\/$/;"	m	struct:t_lb_trace	access:public
next_primitive	../../libs/libarchfpga/src/cad_types.h	/^	t_cluster_placement_primitive *next_primitive;$/;"	m	struct:t_cluster_placement_primitive	access:public
next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_node_struct, 10, 0> next_sibling;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::next_sibling() const$/;"	f	class:pugi::xml_node	signature:() const
next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::next_sibling(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node next_sibling() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node next_sibling(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
nint	../../libs/libvtrutil/src/vtr_math.h	/^    constexpr int nint(float val) { return static_cast<int>(val + 0.5); }$/;"	f	namespace:vtr	signature:(float val)
nlist	base/vpr_context.h	/^    AtomNetlist nlist;$/;"	m	struct:AtomContext	access:public
nmos_leakage_info	power/power.h	/^	t_power_nmos_leakage_inf * nmos_leakage_info;$/;"	m	struct:t_power_tech	access:public
nmos_mux_info	power/power.h	/^	t_power_nmos_mux_inf * nmos_mux_info;$/;"	m	struct:t_power_tech	access:public
nmos_size	power/power.h	/^	float nmos_size;$/;"	m	struct:t_power_nmos_leakage_inf	access:public
nmos_size	power/power.h	/^	float nmos_size;$/;"	m	struct:t_power_nmos_mux_inf	access:public
node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_node_struct* node;$/;"	m	struct:name_null_sentry	file:	access:public
node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xpath_node::node() const$/;"	f	class:pugi::xpath_node	signature:() const
node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node node() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
node_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_cdata,			\/\/ Character data, i.e. '<![CDATA[text]]>'$/;"	e	enum:pugi::xml_node_type
node_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_comment,		\/\/ Comment tag, i.e. '<!-- text -->'$/;"	e	enum:pugi::xml_node_type
node_copy_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_copy_attribute(xml_attribute_struct* da, xml_attribute_struct* sa)$/;"	f	signature:(xml_attribute_struct* da, xml_attribute_struct* sa)
node_copy_contents	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_copy_contents(xml_node_struct* dn, xml_node_struct* sn, xml_allocator* shared_alloc)$/;"	f	signature:(xml_node_struct* dn, xml_node_struct* sn, xml_allocator* shared_alloc)
node_copy_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_copy_string(String& dest, Header& header, uintptr_t header_mask, char_t* source, Header& source_header, xml_allocator* alloc)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, char_t* source, Header& source_header, xml_allocator* alloc)
node_copy_tree	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_copy_tree(xml_node_struct* dn, xml_node_struct* sn)$/;"	f	signature:(xml_node_struct* dn, xml_node_struct* sn)
node_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_declaration,	\/\/ Document declaration, i.e. '<?xml version="1.0"?>'$/;"	e	enum:pugi::xml_node_type
node_doctype	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_doctype		\/\/ Document type declaration, i.e. '<!DOCTYPE doc>'$/;"	e	enum:pugi::xml_node_type
node_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_document,		\/\/ A document tree's absolute root$/;"	e	enum:pugi::xml_node_type
node_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_element,		\/\/ Element tag, i.e. '<node\/>'$/;"	e	enum:pugi::xml_node_type
node_highlighted	draw/draw_types.h	/^	bool node_highlighted;$/;"	m	struct:__anon12	access:public
node_index	pack/pack_types.h	/^	int node_index;		\/* Index of logic cluster_ctx.blocks rr node this expansion node represents *\/$/;"	m	struct:t_expansion_node	access:public
node_index	pack/pack_types.h	/^	int node_index;$/;"	m	struct:t_lb_type_rr_node_edge	access:public
node_is_ancestor	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool node_is_ancestor(xml_node_struct* parent, xml_node_struct* node)$/;"	f	signature:(xml_node_struct* parent, xml_node_struct* node)
node_is_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool node_is_before(xml_node_struct* ln, xml_node_struct* rn)$/;"	f	signature:(xml_node_struct* ln, xml_node_struct* rn)
node_is_before_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool node_is_before_sibling(xml_node_struct* ln, xml_node_struct* rn)$/;"	f	signature:(xml_node_struct* ln, xml_node_struct* rn)
node_name	timing/VprTimingGraphResolver.cpp	/^std::string VprTimingGraphResolver::node_name(tatum::NodeId node) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::NodeId node) const
node_null	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_null,			\/\/ Empty (null) node handle$/;"	e	enum:pugi::xml_node_type
node_output	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_output(xml_buffered_writer& writer, xml_node_struct* root, const char_t* indent, unsigned int flags, unsigned int depth)$/;"	f	signature:(xml_buffered_writer& writer, xml_node_struct* root, const char_t* indent, unsigned int flags, unsigned int depth)
node_output_attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_output_attributes(xml_buffered_writer& writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)$/;"	f	signature:(xml_buffered_writer& writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)
node_output_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_output_comment(xml_buffered_writer& writer, const char_t* s)$/;"	f	signature:(xml_buffered_writer& writer, const char_t* s)
node_output_end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_output_end(xml_buffered_writer& writer, xml_node_struct* node)$/;"	f	signature:(xml_buffered_writer& writer, xml_node_struct* node)
node_output_pi_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_output_pi_value(xml_buffered_writer& writer, const char_t* s)$/;"	f	signature:(xml_buffered_writer& writer, const char_t* s)
node_output_simple	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void node_output_simple(xml_buffered_writer& writer, xml_node_struct* node, unsigned int flags)$/;"	f	signature:(xml_buffered_writer& writer, xml_node_struct* node, unsigned int flags)
node_output_start	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool node_output_start(xml_buffered_writer& writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)$/;"	f	signature:(xml_buffered_writer& writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)
node_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_pcdata,		\/\/ Plain character data, i.e. 'text'$/;"	e	enum:pugi::xml_node_type
node_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_pi,			\/\/ Processing instruction, i.e. '<?name?>'$/;"	e	enum:pugi::xml_node_type
node_sets	route/check_route.cpp	/^    std::set<std::set<int>> node_sets;$/;"	m	struct:t_non_configurable_rr_sets	file:	access:public
node_to_heap	route/route_common.cpp	/^void node_to_heap(int inode, float total_cost, int prev_node, int prev_edge,$/;"	f	signature:(int inode, float total_cost, int prev_node, int prev_edge, float backward_path_cost, float R_upstream)
node_to_heap	route/route_common.h	/^void node_to_heap(int inode, float cost, int prev_node, int prev_edge,$/;"	p	signature:(int inode, float cost, int prev_node, int prev_edge, float backward_path_cost, float R_upstream)
node_type_name	timing/VprTimingGraphResolver.cpp	/^std::string VprTimingGraphResolver::node_type_name(tatum::NodeId node) const {$/;"	f	class:VprTimingGraphResolver	signature:(tatum::NodeId node) const
nodeset_eval_all	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodeset_eval_all,$/;"	e	enum:nodeset_eval_t	file:
nodeset_eval_any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodeset_eval_any,$/;"	e	enum:nodeset_eval_t	file:
nodeset_eval_first	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodeset_eval_first$/;"	e	enum:nodeset_eval_t	file:
nodeset_eval_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum nodeset_eval_t$/;"	g	file:
nodetest	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const char_t* nodetest;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
nodetest_all	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_all,$/;"	e	enum:nodetest_t	file:
nodetest_all_in_namespace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_all_in_namespace$/;"	e	enum:nodetest_t	file:
nodetest_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_name,$/;"	e	enum:nodetest_t	file:
nodetest_none	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_none,$/;"	e	enum:nodetest_t	file:
nodetest_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_pi,$/;"	e	enum:nodetest_t	file:
nodetest_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum nodetest_t$/;"	g	file:
nodetest_type_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_type_comment,$/;"	e	enum:nodetest_t	file:
nodetest_type_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_type_node,$/;"	e	enum:nodetest_t	file:
nodetest_type_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_type_pi,$/;"	e	enum:nodetest_t	file:
nodetest_type_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_type_text,$/;"	e	enum:nodetest_t	file:
non_configurable_edges	route/rr_node.h	/^        edge_idx_range non_configurable_edges() const { return vtr::make_range(edge_idx_iterator(num_edges() - num_non_configurable_edges()), edge_idx_iterator(num_edges())); }$/;"	f	class:t_rr_node	access:public	signature:() const
normalize_space	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* normalize_space(char_t* buffer)$/;"	f	signature:(char_t* buffer)
normalize_xbar	route/cb_metrics.cpp	/^static void normalize_xbar(const float fraction_wires_used, t_xbar_matrix *xbar ){$/;"	f	file:	signature:(const float fraction_wires_used, t_xbar_matrix *xbar )
normalized_T_arr	base/vpr_types.h	/^	float normalized_T_arr; \/* arrival time (normalized with respect to max time) *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
normalized_slack	base/vpr_types.h	/^	float normalized_slack; \/* slack (normalized with respect to max slack) *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
normalized_total_critical_paths	base/vpr_types.h	/^	float normalized_total_critical_paths; \/* critical path count (normalized with respect to max count) *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
not_congested_this_iteration	route/route_budgets.cpp	/^void route_budgets::not_congested_this_iteration(ClusterNetId net_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id)
not_congested_this_iteration	route/route_budgets.h	/^    void not_congested_this_iteration(ClusterNetId net_id);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id)
not_equal_to	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct not_equal_to$/;"	s	file:
not_equal_to::operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:not_equal_to	access:public	signature:(const T& lhs, const T& rhs) const
num	../../libs/libarchfpga/src/expr_eval.cpp	/^		int num;		\/*for number objects*\/$/;"	m	union:Formula_Object::u_Data	file:	access:public
num_annotations	../../libs/libarchfpga/src/physical_types.h	/^	int num_annotations = 0;$/;"	m	struct:t_pb_type	access:public
num_annotations	../../libs/libarchfpga/src/physical_types.h	/^	int num_annotations;$/;"	m	struct:t_interconnect	access:public
num_arch_switches	base/vpr_context.h	/^    int num_arch_switches;$/;"	m	struct:DeviceContext	access:public
num_block_types	base/vpr_context.h	/^    int num_block_types;$/;"	m	struct:DeviceContext	access:public
num_blocks	../../libs/libarchfpga/src/cad_types.h	/^	int num_blocks; \/* number of blocks in pattern *\/$/;"	m	struct:t_pack_patterns	access:public
num_blocks	base/vpr_types.h	/^	int num_blocks; \/* number of atom blocks of molecule *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
num_blocks	pack/cluster.cpp	/^    int num_blocks = 0;        \/\/Number of blocks across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_blocks	place/place_macro.h	/^	int num_blocks;$/;"	m	struct:t_pl_macro	access:public
num_buttons	../../libs/libeasygl/src/graphics.cpp	/^    int num_buttons;$/;"	m	struct:__anon19	file:	access:public
num_caps	timing/slre.cpp	/^  int num_caps;   \/\/ Number of bracket pairs$/;"	m	struct:slre	file:	access:public
num_cb_buffers	power/power.h	/^	int num_cb_buffers;$/;"	m	struct:t_power_commonly_used	access:public
num_cc_constraints	base/vpr_types.h	/^	int num_cc_constraints; \/* number of special-case clock-to-clock constraints overriding default, calculated, timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_cf_constraints	base/vpr_types.h	/^	int num_cf_constraints; \/* number of special-case clock-to-flipflop constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_child_blocks_in_pb	pack/pack_types.h	/^	int num_child_blocks_in_pb;$/;"	m	struct:t_pb_stats	access:public
num_class	../../libs/libarchfpga/src/physical_types.h	/^	int num_class = 0;$/;"	m	struct:t_type_descriptor	access:public
num_clock_names	timing/read_sdc.cpp	/^	int num_clock_names;$/;"	m	struct:t_sdc_exclusive_group	file:	access:public
num_clock_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_clock_pins; \/* [0..num_clock_ports - 1] *\/$/;"	m	struct:t_pb_graph_node	access:public
num_clock_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_clock_pins = 0;$/;"	m	struct:t_pb_type	access:public
num_clock_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_clock_ports;$/;"	m	struct:t_pb_graph_node	access:public
num_commands	timing/read_sdc2.cpp	/^        size_t num_commands() { return num_commands_; }$/;"	f	class:SdcParseCallback2	access:public	signature:()
num_commands_	timing/read_sdc2.cpp	/^        size_t num_commands_ = 0;$/;"	m	class:SdcParseCallback2	file:	access:private
num_configurable_edges	route/rr_node.h	/^        short num_configurable_edges() const { return num_edges() - num_non_configurable_edges(); }$/;"	f	class:t_rr_node	access:public	signature:() const
num_connectable_primitive_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_connectable_primitive_input_pins = nullptr; \/* [0..depth-1] number of input pins that this output pin can reach without exiting cluster at given depth *\/$/;"	m	struct:t_pb_graph_pin	access:public
num_conns_formula	../../libs/libarchfpga/src/physical_types.h	/^    std::string num_conns_formula;      \/* Specifies how many connections should be made for this wireconn.$/;"	m	struct:t_wireconn_inf	access:public
num_constrained_clocks	base/vpr_types.h	/^	int num_constrained_clocks; \/* number of clocks with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_constrained_inputs	base/vpr_types.h	/^	int num_constrained_inputs; \/* number of inputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_constrained_outputs	base/vpr_types.h	/^	int num_constrained_outputs; \/* number of outputs with timing constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_critical_input_paths	base/vpr_types.h	/^	long num_critical_input_paths, num_critical_output_paths; \/* count of critical paths fanning into\/out of this tnode *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
num_critical_output_paths	base/vpr_types.h	/^	long num_critical_input_paths, num_critical_output_paths; \/* count of critical paths fanning into\/out of this tnode *\/$/;"	m	struct:ScreenUpdatePriority::t_prepacked_tnode_data	access:public
num_directs	../../libs/libarchfpga/src/physical_types.h	/^	int num_directs;$/;"	m	struct:t_arch	access:public
num_drivers	../../libs/libarchfpga/src/physical_types.h	/^	int num_drivers = 0;$/;"	m	struct:t_type_descriptor	access:public
num_edges	base/vpr_types.h	/^	int num_edges;$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
num_edges	route/rr_node.h	/^        short num_edges() const { return num_edges_; }$/;"	f	class:t_rr_node	access:public	signature:() const
num_edges_	route/rr_node.h	/^        uint16_t num_edges_ = 0;$/;"	m	class:t_rr_node	access:private
num_edges_head	pack/pb_type_graph.cpp	/^static vtr::t_linked_vptr *num_edges_head;$/;"	v	file:
num_ext_inputs_atom_block	util/vpr_utils.cpp	/^int num_ext_inputs_atom_block(AtomBlockId blk_id) {$/;"	f	signature:(AtomBlockId blk_id)
num_ext_inputs_atom_block	util/vpr_utils.h	/^int num_ext_inputs_atom_block(AtomBlockId blk_id);$/;"	p	signature:(AtomBlockId blk_id)
num_fanout	pack/pack_types.h	/^	short *num_fanout;		\/* [0..num_modes - 1] Mode dependant fanout *\/$/;"	m	struct:t_lb_type_rr_node	access:public
num_fc_constraints	base/vpr_types.h	/^	int num_fc_constraints; \/* number of special-case flipflop-to-clock constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_feasible_blocks	pack/pack_types.h	/^	int num_feasible_blocks; \/* [0..num_marked_models-1] *\/$/;"	m	struct:t_pb_stats	access:public
num_ff_constraints	base/vpr_types.h	/^	int num_ff_constraints; \/* number of special-case flipflop-to-flipflop constraints *\/$/;"	m	struct:ScreenUpdatePriority::t_timing_constraints	access:public
num_full_hold_updates	base/vpr_context.h	/^        size_t num_full_hold_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
num_full_setup_hold_updates	base/vpr_context.h	/^        size_t num_full_setup_hold_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
num_full_setup_updates	base/vpr_context.h	/^        size_t num_full_setup_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
num_full_updates	base/vpr_context.h	/^        size_t num_full_updates() const {$/;"	f	struct:TimingContext::timing_analysis_profile_info	access:public	signature:() const
num_global_clocks	../../libs/libarchfpga/src/physical_types.h	/^	int num_global_clocks;$/;"	m	struct:t_clock_arch	access:public
num_heap_allocated	route/route_common.cpp	/^static int num_heap_allocated = 0;$/;"	v	file:
num_input_edges	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_edges = 0;$/;"	m	struct:t_pb_graph_pin	access:public
num_input_pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_pin_class; \/* number of input pin classes that this pb_graph_node has *\/$/;"	m	struct:t_pb_graph_node	access:public
num_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_input_pins; \/* [0..num_input_ports - 1] *\/$/;"	m	struct:t_pb_graph_node	access:public
num_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_pins = 0; \/* inputs not including clock pins *\/$/;"	m	struct:t_pb_type	access:public
num_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_pins;$/;"	m	struct:t_pb_graph_edge	access:public
num_input_pins	pack/cluster.cpp	/^    int num_input_pins = 0;    \/\/Number of input pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_input_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_ports;$/;"	m	struct:t_interconnect_power	access:public
num_input_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_ports;$/;"	m	struct:t_pb_graph_node	access:public
num_inputs	power/PowerSpicedComponent.h	/^	int num_inputs;$/;"	m	class:PowerCallibInputs	access:public
num_inputs	power/power.h	/^	int num_inputs; \/* Number of inputs *\/$/;"	m	struct:t_mux_node	access:public
num_inputs	power/power.h	/^	int num_inputs;$/;"	m	struct:t_mux_arch	access:public
num_inputs	power/power.h	/^	short num_inputs; \/* Number of inputs *\/$/;"	m	struct:t_rr_node_power	access:public
num_instances	../../libs/libarchfpga/src/arch_util.cpp	/^int InstPort::num_instances() const {$/;"	f	class:InstPort	signature:() const
num_instances	../../libs/libarchfpga/src/arch_util.h	/^        int num_instances() const;$/;"	p	class:InstPort	access:public	signature:() const
num_instances	base/device_grid.cpp	/^size_t DeviceGrid::num_instances(t_type_ptr type) const {$/;"	f	class:DeviceGrid	signature:(t_type_ptr type) const
num_instances	base/device_grid.h	/^        size_t num_instances(t_type_ptr type) const;$/;"	p	class:DeviceGrid	access:public	signature:(t_type_ptr type) const
num_interconnect	../../libs/libarchfpga/src/physical_types.h	/^	int num_interconnect;$/;"	m	struct:t_mode	access:public
num_leakage_pairs	power/power.h	/^	int num_leakage_pairs;$/;"	m	struct:t_power_nmos_leakage_inf	access:public
num_legal_pos	place/place.cpp	/^static int *num_legal_pos = nullptr; \/* [0..num_legal_pos-1] *\/$/;"	v	file:
num_levr_entries	power/power.h	/^	int num_levr_entries;$/;"	m	struct:t_power_buffer_strength_inf	access:public
num_linked_f_pointer_allocated	route/route_common.cpp	/^static int num_linked_f_pointer_allocated = 0;$/;"	v	file:
num_logs	power/power.h	/^	int num_logs;$/;"	m	struct:t_power_output	access:public
num_messages	power/power.h	/^	int num_messages;$/;"	m	struct:t_log	access:public
num_modes	../../libs/libarchfpga/src/physical_types.h	/^	int num_modes = 0;$/;"	m	struct:t_pb_type	access:public
num_moved_blocks	base/vpr_types.h	/^	int num_moved_blocks;$/;"	m	struct:ScreenUpdatePriority::t_pl_blocks_to_be_moved	access:public
num_multicycles	base/vpr_types.h	/^	int num_multicycles;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
num_netlist_clocks	timing/read_sdc.cpp	/^int num_netlist_clocks = 0; \/* number of clocks in netlist *\/$/;"	v
num_netlist_ios	timing/read_sdc.cpp	/^int num_netlist_ios = 0; \/* number of clocks in netlist *\/$/;"	v
num_nmos_leakage_info	power/power.h	/^	int num_nmos_leakage_info;$/;"	m	struct:t_power_tech	access:public
num_nmos_mux_info	power/power.h	/^	int num_nmos_mux_info;$/;"	m	struct:t_power_tech	access:public
num_non_configurable_edges	route/rr_node.h	/^        short num_non_configurable_edges() const { return num_non_configurable_edges_; }$/;"	f	class:t_rr_node	access:public	signature:() const
num_non_configurable_edges_	route/rr_node.h	/^        uint8_t num_non_configurable_edges_ = 0;$/;"	m	class:t_rr_node	access:private
num_old_sta_full_updates	base/vpr_context.h	/^        size_t num_old_sta_full_updates = 0;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
num_output_edges	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_edges = 0;$/;"	m	struct:t_pb_graph_pin	access:public
num_output_pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_pin_class; \/* number of output pin classes that this pb_graph_node has *\/$/;"	m	struct:t_pb_graph_node	access:public
num_output_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_output_pins; \/* [0..num_output_ports - 1] *\/$/;"	m	struct:t_pb_graph_node	access:public
num_output_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_pins = 0;$/;"	m	struct:t_pb_type	access:public
num_output_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_pins;$/;"	m	struct:t_pb_graph_edge	access:public
num_output_pins	pack/cluster.cpp	/^    int num_output_pins = 0;   \/\/Number of output pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_output_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_ports;$/;"	m	struct:t_interconnect_power	access:public
num_output_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_ports;$/;"	m	struct:t_pb_graph_node	access:public
num_pack_patterns	../../libs/libarchfpga/src/physical_types.h	/^	int num_pack_patterns;$/;"	m	struct:t_pb_graph_edge	access:public
num_pb	../../libs/libarchfpga/src/physical_types.h	/^	int num_pb = 0;$/;"	m	struct:t_pb_type	access:public
num_pb_type_children	../../libs/libarchfpga/src/physical_types.h	/^	int num_pb_type_children;$/;"	m	struct:t_mode	access:public
num_pb_types	base/vpr_types.h	/^	int num_pb_types; \/* num primitive pb_types inside complex block *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
num_pin_loc_assignments	../../libs/libarchfpga/src/physical_types.h	/^	int ***num_pin_loc_assignments = nullptr; \/* [0..width-1][0..height-1][0..3] *\/$/;"	m	struct:t_type_descriptor	access:public
num_pin_timing	../../libs/libarchfpga/src/physical_types.h	/^	int num_pin_timing = 0; \/* Number of ipin to opin timing edges*\/$/;"	m	struct:t_pb_graph_pin	access:public
num_pin_timing_del_max_annotated	../../libs/libarchfpga/src/physical_types.h	/^    int num_pin_timing_del_max_annotated = 0; \/\/The list of valid pin_timing_del_max entries runs from [0..num_pin_timing_del_max_annotated-1]$/;"	m	struct:t_pb_graph_pin	access:public
num_pin_timing_del_min_annotated	../../libs/libarchfpga/src/physical_types.h	/^    int num_pin_timing_del_min_annotated = 0; \/\/The list of valid pin_timing_del_max entries runs from [0..num_pin_timing_del_min_annotated-1]$/;"	m	struct:t_pb_graph_pin	access:public
num_pins	../../libs/libarchfpga/src/arch_util.cpp	/^int InstPort::num_pins() const {$/;"	f	class:InstPort	signature:() const
num_pins	../../libs/libarchfpga/src/arch_util.h	/^        int num_pins() const;$/;"	p	class:InstPort	access:public	signature:() const
num_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins = 0;$/;"	m	struct:t_type_descriptor	access:public
num_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins;$/;"	m	struct:t_class	access:public
num_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins;$/;"	m	struct:t_port	access:public
num_pins	../../libs/libarchfpga/src/physical_types.h	/^    int num_pins() {$/;"	f	struct:t_pb_graph_node	access:public	signature:()
num_pins	pack/cluster.cpp	/^    int num_pins = 0;          \/\/Number of pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_pins_of_net_in_pb	pack/pack_types.h	/^	std::map<AtomNetId, int> num_pins_of_net_in_pb;$/;"	m	struct:t_pb_stats	access:public
num_pins_per_port	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins_per_port;$/;"	m	struct:t_interconnect_power	access:public
num_pl_macros	place/place.cpp	/^static int num_pl_macros;$/;"	v	file:
num_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_ports = 0;$/;"	m	struct:t_pb_type	access:public
num_receivers	../../libs/libarchfpga/src/physical_types.h	/^	int num_receivers = 0;$/;"	m	struct:t_type_descriptor	access:public
num_rr_indexed_data	base/vpr_context.h	/^    int num_rr_indexed_data;$/;"	m	struct:DeviceContext	access:public
num_rr_switches	base/vpr_context.h	/^    int num_rr_switches;$/;"	m	struct:DeviceContext	access:public
num_sb_buffers	power/power.h	/^	int num_sb_buffers;$/;"	m	struct:t_power_commonly_used	access:public
num_segment	base/vpr_types.h	/^	int num_segment;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
num_segments	../../libs/libarchfpga/src/physical_types.h	/^	int num_segments;$/;"	m	struct:t_arch	access:public
num_sink	base/vpr_types.h	/^	int num_sink;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
num_size_entries	power/power.h	/^	int num_size_entries;$/;"	m	struct:t_transistor_inf	access:public
num_source	base/vpr_types.h	/^	int num_source;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
num_strengths	power/power.h	/^	int num_strengths;$/;"	m	struct:t_power_buffer_size_inf	access:public
num_swap_aborted	place/place.cpp	/^static int num_swap_aborted = 0;$/;"	v	file:
num_swap_accepted	place/place.cpp	/^static int num_swap_accepted = 0;$/;"	v	file:
num_swap_rejected	place/place.cpp	/^static int num_swap_rejected = 0;$/;"	v	file:
num_switches	../../libs/libarchfpga/src/physical_types.h	/^	int num_switches;$/;"	m	struct:t_arch	access:public
num_times_congested	route/route_budgets.h	/^    vtr::vector<ClusterNetId, int> num_times_congested; \/\/[0..num_nets]$/;"	m	class:route_budgets	access:private
num_timing_net_pins	timing/path_delay.cpp	/^size_t num_timing_net_pins(int inet) {$/;"	f	signature:(int inet)
num_timing_net_pins	timing/path_delay.cpp	/^size_t num_timing_net_pins(int inet);$/;"	p	file:	signature:(int inet)
num_timing_net_sinks	timing/path_delay.cpp	/^size_t num_timing_net_sinks(int inet) {$/;"	f	signature:(int inet)
num_timing_net_sinks	timing/path_delay.cpp	/^size_t num_timing_net_sinks(int inet);$/;"	p	file:	signature:(int inet)
num_timing_nets	timing/path_delay.cpp	/^size_t num_timing_nets() {$/;"	f	signature:()
num_timing_nets	timing/path_delay.cpp	/^size_t num_timing_nets();$/;"	p	file:	signature:()
num_tnode_levels	base/vpr_context.h	/^    int num_tnode_levels; \/* Number of levels in the timing graph. *\/$/;"	m	struct:TimingContext	access:public
num_tnodes	base/vpr_context.h	/^    int num_tnodes; \/* Number of nodes (pins) in the timing graph *\/$/;"	m	struct:TimingContext	access:public
num_trace_allocated	route/route_common.cpp	/^static int num_trace_allocated = 0; \/* To watch for memory leaks. *\/$/;"	v	file:
num_ts_called	place/place.cpp	/^static int num_ts_called = 0;$/;"	v	file:
num_types_	util/vpr_utils.h	/^        int num_types_;$/;"	m	class:IntraLbPbPinLookup	access:private
num_used_ext_inputs	pack/cluster.cpp	/^    int num_used_ext_inputs = 0;   \/\/Number of *used external* input pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_used_ext_outputs	pack/cluster.cpp	/^    int num_used_ext_outputs = 0;  \/\/Number of *used external* output pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_used_ext_pins	pack/cluster.cpp	/^    int num_used_ext_pins = 0;     \/\/Number of *used external* pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
num_value_prop_pairs	../../libs/libarchfpga/src/physical_types.h	/^	int num_value_prop_pairs;$/;"	m	struct:t_pin_to_pin_annotation	access:public
num_voltage_pairs	power/power.h	/^	int num_voltage_pairs;$/;"	m	struct:t_power_mux_volt_inf	access:public
num_wire_types	route/cb_metrics.h	/^	int num_wire_types;			\/* the number of different wire types, used for computing pin diversity *\/$/;"	m	class:Conn_Block_Metrics	access:public
num_wires	route/build_switchblocks.cpp	/^	int num_wires;		\/* total number of wires in a channel segment (basically W) *\/$/;"	m	class:Wire_Info	file:	access:public
num_wires	route/cb_metrics.h	/^	int num_wires = 0;$/;"	m	class:Wire_Counting	access:public
num_workers	base/read_options.h	/^    argparse::ArgValue<size_t> num_workers;$/;"	m	struct:t_options	access:public
number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			double number;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
obstruct_chan_details	route/rr_graph2.cpp	/^void obstruct_chan_details($/;"	f	signature:( const DeviceGrid& grid, const t_chan_width* nodes_per_chan, const bool trim_empty_channels, const bool trim_obs_channels, t_chan_details& chan_details_x, t_chan_details& chan_details_y)
obstruct_chan_details	route/rr_graph2.h	/^void obstruct_chan_details($/;"	p	signature:( const DeviceGrid& grid, const t_chan_width *nodes_per_chan, const bool trim_empty_channels, const bool trim_obs_channels, t_chan_details& chan_details_x, t_chan_details& chan_details_y)
occ	base/vpr_types.h	/^        short occ() const { return occ_; }$/;"	f	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public	signature:() const
occ	pack/pack_types.h	/^	int occ;								\/* Number of nets currently using this lb_rr_node *\/$/;"	m	struct:t_lb_rr_node_stats	access:public
occ_	base/vpr_types.h	/^        short occ_ = 0;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:private
occupancy	base/vpr_types.h	/^	float occupancy;$/;"	m	struct:ScreenUpdatePriority::t_place_region	access:public
offset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		ptrdiff_t offset;$/;"	m	struct:pugi::xml_parse_result	access:public
offset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		ptrdiff_t offset;$/;"	m	struct:pugi::xpath_parse_result	access:public
offset	../../libs/libeasygl/src/graphics_types.cpp	/^void t_bound_box::offset(const t_point& relative_to) {$/;"	f	class:t_bound_box	signature:(const t_point& relative_to)
offset	../../libs/libeasygl/src/graphics_types.cpp	/^void t_bound_box::offset(float by_x, float by_y) {$/;"	f	class:t_bound_box	signature:(float by_x, float by_y)
offset	../../libs/libeasygl/src/graphics_types.cpp	/^void t_point::offset(float _x, float _y) {$/;"	f	class:t_point	signature:(float _x, float _y)
offset	../../libs/libeasygl/src/graphics_types.h	/^    void offset(const t_point& make_relative_to);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& make_relative_to)
offset	../../libs/libeasygl/src/graphics_types.h	/^    void offset(float by_x, float by_y);$/;"	p	class:t_bound_box	access:public	signature:(float by_x, float by_y)
offset	../../libs/libeasygl/src/graphics_types.h	/^    void offset(float x, float y);$/;"	p	class:t_point	access:public	signature:(float x, float y)
offset_debug	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN ptrdiff_t xml_node::offset_debug() const$/;"	f	class:pugi::xml_node	signature:() const
offset_debug	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		ptrdiff_t offset_debug() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
offsets_	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::vector<std::ptrdiff_t> offsets_;$/;"	m	class:pugiutil::loc_data	access:private
old_delay_annotation_wallclock_time	base/vpr_context.h	/^        double old_delay_annotation_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
old_sta_wallclock_time	base/vpr_context.h	/^        double old_sta_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
old_timing_analysis_wallclock_time	base/vpr_context.h	/^        double old_timing_analysis_wallclock_time() const {$/;"	f	struct:TimingContext::timing_analysis_profile_info	access:public	signature:() const
op	../../libs/libarchfpga/src/expr_eval.cpp	/^		t_operator op;		\/*for operator objects*\/$/;"	m	union:Formula_Object::u_Data	file:	access:public
op_associativity_is_left	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool op_associativity_is_left( const t_operator &\/*op*\/ ){$/;"	f	file:	signature:( const t_operator & )
op_associativity_is_left	../../libs/libarchfpga/src/expr_eval.cpp	/^static bool op_associativity_is_left( const t_operator &op );$/;"	p	file:	signature:( const t_operator &op )
open_file_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)$/;"	f	signature:(const wchar_t* path, const wchar_t* mode)
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator!() const$/;"	f	class:pugi::xml_attribute	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator!() const$/;"	f	class:pugi::xml_node	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::operator!() const$/;"	f	class:pugi::xml_text	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node::operator!() const$/;"	f	class:pugi::xpath_node	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_query::operator!() const$/;"	f	class:pugi::xpath_query	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator!=(const xpath_string& o) const$/;"	f	class:xpath_string	access:public	signature:(const xpath_string& o) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator!=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute_iterator::operator!=(const xml_attribute_iterator& rhs) const$/;"	f	class:pugi::xml_attribute_iterator	signature:(const xml_attribute_iterator& rhs) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_named_node_iterator::operator!=(const xml_named_node_iterator& rhs) const$/;"	f	class:pugi::xml_named_node_iterator	signature:(const xml_named_node_iterator& rhs) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator!=(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node_iterator::operator!=(const xml_node_iterator& rhs) const$/;"	f	class:pugi::xml_node_iterator	signature:(const xml_node_iterator& rhs) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node::operator!=(const xpath_node& n) const$/;"	f	class:pugi::xpath_node	signature:(const xpath_node& n) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_attribute_iterator& rhs) const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(const xml_attribute_iterator& rhs) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_named_node_iterator& rhs) const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(const xml_named_node_iterator& rhs) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_node_iterator& rhs) const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(const xml_node_iterator& rhs) const
operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xpath_node& n) const;$/;"	p	class:pugi::xpath_node	access:public	signature:(const xpath_node& n) const
operator !=	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator!=(color_types rhs) const {$/;"	f	class:t_color	signature:(color_types rhs) const
operator !=	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator!=(const t_color& rhs) const {$/;"	f	class:t_color	signature:(const t_color& rhs) const
operator !=	../../libs/libeasygl/src/graphics_types.h	/^    bool operator!=(color_types rhs) const;$/;"	p	class:t_color	access:public	signature:(color_types rhs) const
operator !=	../../libs/libeasygl/src/graphics_types.h	/^    bool operator!=(const t_color& rhs) const;$/;"	p	class:t_color	access:public	signature:(const t_color& rhs) const
operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator!= <>(Point<T> lhs, Point<T> rhs);$/;"	p	class:vtr::Point	access:friend	signature:(Point<T> lhs, Point<T> rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator!= <>(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	class:vtr::Rect	access:friend	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator!= <>(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	class:vtr::RectUnion	access:friend	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator!=(Point<T> lhs, Point<T> rhs);$/;"	p	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator!=(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator!=(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator!=(Point<T> lhs, Point<T> rhs) {$/;"	f	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator!=(const Rect<T>& lhs, const Rect<T>& rhs) {$/;"	f	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator!=(const RectUnion<T>& lhs, const RectUnion<T>& rhs) {$/;"	f	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator!= (const pair_first_iter lhs, const pair_first_iter rhs) { return !(lhs == rhs); }$/;"	f	class:vtr::pair_first_iter	access:friend	signature:(const pair_first_iter lhs, const pair_first_iter rhs)
operator !=	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator!= (const pair_second_iter lhs, const pair_second_iter rhs) { return !(lhs == rhs); }$/;"	f	class:vtr::pair_second_iter	access:friend	signature:(const pair_second_iter lhs, const pair_second_iter rhs)
operator !=	../../libs/libvtrutil/src/vtr_strong_id.h	/^        friend bool operator!= <>(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	class:vtr::StrongId	access:friend	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator!=(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs) {$/;"	f	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator!=(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator !=	../../libs/libvtrutil/src/vtr_vector.h	/^                friend bool operator!= (const key_iterator lhs, const key_iterator rhs) { return !(lhs == rhs); }$/;"	f	class:vtr::vector::key_iterator	access:friend	signature:(const key_iterator lhs, const key_iterator rhs)
operator !=	route/rr_node.h	/^            friend bool operator!= (const edge_idx_iterator lhs, const edge_idx_iterator rhs) { return !(lhs == rhs); }$/;"	f	class:t_rr_node::edge_idx_iterator	access:friend	signature:(const edge_idx_iterator lhs, const edge_idx_iterator rhs)
operator &	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uintptr_t operator&(uintptr_t mod) const$/;"	f	class:compact_header	access:public	signature:(uintptr_t mod) const
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xml_attribute& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xml_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xml_text& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xpath_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xml_attribute& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xml_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xml_text& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xpath_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
operator &=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator&=(uintptr_t mod)$/;"	f	class:compact_header	access:public	signature:(uintptr_t mod)
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const$/;"	f	struct:document_order_comparator	access:public	signature:(const xpath_node& lhs, const xpath_node& rhs) const
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const$/;"	f	struct:duplicate_comparator	access:public	signature:(const xpath_node& lhs, const xpath_node& rhs) const
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator()(xml_attribute a) const$/;"	f	struct:namespace_uri_predicate	access:public	signature:(xml_attribute a) const
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:equal_to	access:public	signature:(const T& lhs, const T& rhs) const
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:less	access:public	signature:(const T& lhs, const T& rhs) const
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:less_equal	access:public	signature:(const T& lhs, const T& rhs) const
operator ()	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:not_equal_to	access:public	signature:(const T& lhs, const T& rhs) const
operator ()	../../libs/libeasygl/src/fontcache.h	/^        inline std::size_t operator()(const font_descriptor& v) const {$/;"	f	struct:FontCache::fontdesc_hasher	access:public	signature:(const font_descriptor& v) const
operator ()	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool operator() (const value_type& x, const key_type& y) const {$/;"	f	class:vtr::flat_map::value_compare	access:public	signature:(const value_type& x, const key_type& y) const
operator ()	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool operator() (const value_type& x, const value_type& y) const {$/;"	f	class:vtr::flat_map::value_compare	access:public	signature:(const value_type& x, const value_type& y) const
operator ()	../../libs/libvtrutil/src/vtr_strong_id.h	/^        std::size_t operator()(const vtr::StrongId<tag,T,sentinel> k) const {$/;"	f	struct:std::hash	access:public	signature:(const vtr::StrongId<tag,T,sentinel> k) const
operator ()	draw/intra_logic_block.h	/^		inline std::size_t operator()(const clb_pin_tuple& v) const {$/;"	f	struct:t_selected_sub_block_info::sel_subblk_hasher	access:public	signature:(const clb_pin_tuple& v) const
operator ()	draw/intra_logic_block.h	/^		inline std::size_t operator()(const gnode_clb_pair& v) const {$/;"	f	struct:t_selected_sub_block_info::sel_subblk_hasher	access:public	signature:(const gnode_clb_pair& v) const
operator ()	draw/intra_logic_block.h	/^		inline std::size_t operator()(const std::pair<clb_pin_tuple, clb_pin_tuple>& v) const {$/;"	f	struct:t_selected_sub_block_info::sel_subblk_hasher	access:public	signature:(const std::pair<clb_pin_tuple, clb_pin_tuple>& v) const
operator ()	pack/pack_types.h	/^    bool operator()(t_expansion_node& e1, t_expansion_node& e2) \/\/ Returns true if t1 is earlier than t2$/;"	f	class:compare_expansion_node	access:public	signature:(t_expansion_node& e1, t_expansion_node& e2)
operator ()	route/build_switchblocks.h	/^	size_t operator()(const Switchblock_Lookup &obj) const{$/;"	f	struct:t_hash_Switchblock_Lookup	access:public	signature:(const Switchblock_Lookup &obj) const
operator ()	route/route_timing.cpp	/^    bool operator()(int a, int b) const {$/;"	f	struct:Criticality_comp	access:public	signature:(int a, int b) const
operator ()	route/route_timing.cpp	/^    inline bool operator()(const ClusterNetId net_index1, const ClusterNetId net_index2) {$/;"	f	struct:more_sinks_than	access:public	signature:(const ClusterNetId net_index1, const ClusterNetId net_index2)
operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute_iterator::operator*() const$/;"	f	class:pugi::xml_attribute_iterator	signature:() const
operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node& xml_named_node_iterator::operator*() const$/;"	f	class:pugi::xml_named_node_iterator	signature:() const
operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node& xml_node_iterator::operator*() const$/;"	f	class:pugi::xml_node_iterator	signature:() const
operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator*() const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:() const
operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node& operator*() const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:() const
operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node& operator*() const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:() const
operator *	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_point::operator*(float rhs) const {$/;"	f	class:t_point	signature:(float rhs) const
operator *	../../libs/libeasygl/src/graphics_types.h	/^    t_point operator*(float rhs) const;$/;"	p	class:t_point	access:public	signature:(float rhs) const
operator *	../../libs/libeasygl/src/graphics_types.h	/^t_point operator*(float lhs, const t_point& rhs);$/;"	p	signature:(float lhs, const t_point& rhs)
operator *	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator*() { return iter_->first; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
operator *	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator*() { return iter_->second; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
operator *	../../libs/libvtrutil/src/vtr_vector.h	/^                reference operator*() { return value_; }$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
operator *	route/rr_node.h	/^            reference operator*() { return value_; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
operator *=	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator*=(float rhs) {$/;"	f	class:t_point	signature:(float rhs)
operator *=	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator*=(float rhs);$/;"	p	class:t_point	access:public	signature:(float rhs)
operator +	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box t_bound_box::operator+(const t_point& rhs) const {$/;"	f	class:t_bound_box	signature:(const t_point& rhs) const
operator +	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_point::operator+(const t_point& rhs) const {$/;"	f	class:t_point	signature:(const t_point& rhs) const
operator +	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box operator+(const t_point& rhs) const;$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs) const
operator +	../../libs/libeasygl/src/graphics_types.h	/^    t_point operator+(const t_point& rhs) const;$/;"	p	class:t_point	access:public	signature:(const t_point& rhs) const
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator++()$/;"	f	class:pugi::xml_attribute_iterator	signature:()
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator++()$/;"	f	class:pugi::xml_named_node_iterator	signature:()
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_node_iterator& xml_node_iterator::operator++()$/;"	f	class:pugi::xml_node_iterator	signature:()
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator++(int)$/;"	f	class:pugi::xml_attribute_iterator	signature:(int)
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator++(int)$/;"	f	class:pugi::xml_named_node_iterator	signature:(int)
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator xml_node_iterator::operator++(int)$/;"	f	class:pugi::xml_node_iterator	signature:(int)
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_attribute_iterator& operator++();$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:()
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_named_node_iterator& operator++();$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:()
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_node_iterator& operator++();$/;"	p	class:pugi::xml_node_iterator	access:public	signature:()
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator operator++(int);$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(int)
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator operator++(int);$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(int)
operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator operator++(int);$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(int)
operator ++	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator++() { iter_++; return *this; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
operator ++	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator++() { iter_++; return *this; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
operator ++	../../libs/libvtrutil/src/vtr_vector.h	/^                key_iterator operator++() {$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
operator ++	route/rr_node.h	/^            iterator operator++() { value_ += 1; return *this; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
operator +=	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box& t_bound_box::operator+=(const t_point& rhs) {$/;"	f	class:t_bound_box	signature:(const t_point& rhs)
operator +=	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator+=(const t_point& rhs) {$/;"	f	class:t_point	signature:(const t_point& rhs)
operator +=	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box& operator+=(const t_point& rhs);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs)
operator +=	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator+=(const t_point& rhs);$/;"	p	class:t_point	access:public	signature:(const t_point& rhs)
operator -	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box t_bound_box::operator-(const t_point& rhs) const {$/;"	f	class:t_bound_box	signature:(const t_point& rhs) const
operator -	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_point::operator-(const t_point& rhs) const {$/;"	f	class:t_point	signature:(const t_point& rhs) const
operator -	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box operator-(const t_point& rhs) const;$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs) const
operator -	../../libs/libeasygl/src/graphics_types.h	/^    t_point operator-(const t_point& rhs) const;$/;"	p	class:t_point	access:public	signature:(const t_point& rhs) const
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator--()$/;"	f	class:pugi::xml_attribute_iterator	signature:()
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator--()$/;"	f	class:pugi::xml_named_node_iterator	signature:()
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_node_iterator& xml_node_iterator::operator--()$/;"	f	class:pugi::xml_node_iterator	signature:()
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator--(int)$/;"	f	class:pugi::xml_attribute_iterator	signature:(int)
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator--(int)$/;"	f	class:pugi::xml_named_node_iterator	signature:(int)
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator xml_node_iterator::operator--(int)$/;"	f	class:pugi::xml_node_iterator	signature:(int)
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_attribute_iterator& operator--();$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:()
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_named_node_iterator& operator--();$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:()
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_node_iterator& operator--();$/;"	p	class:pugi::xml_node_iterator	access:public	signature:()
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator operator--(int);$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(int)
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator operator--(int);$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(int)
operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator operator--(int);$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(int)
operator --	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator--() { iter_--; return *this; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
operator --	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator--() { iter_--; return *this; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
operator --	../../libs/libvtrutil/src/vtr_vector.h	/^                key_iterator operator--() {$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
operator --	route/rr_node.h	/^            iterator operator--() { value_ -= 1; return *this; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
operator -=	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box& t_bound_box::operator-=(const t_point& rhs) {$/;"	f	class:t_bound_box	signature:(const t_point& rhs)
operator -=	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator-=(const t_point& rhs) {$/;"	f	class:t_point	signature:(const t_point& rhs)
operator -=	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box& operator-=(const t_point& rhs);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs)
operator -=	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator-=(const t_point& rhs);$/;"	p	class:t_point	access:public	signature:(const t_point& rhs)
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* operator->() const$/;"	f	class:compact_pointer	access:public	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* operator->() const$/;"	f	class:compact_pointer_parent	access:public	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute* xml_attribute_iterator::operator->() const$/;"	f	class:pugi::xml_attribute_iterator	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node* xml_named_node_iterator::operator->() const$/;"	f	class:pugi::xml_named_node_iterator	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node* xml_node_iterator::operator->() const$/;"	f	class:pugi::xml_node_iterator	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute* operator->() const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node* operator->() const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:() const
operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node* operator->() const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:() const
operator ->	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator->() { return &iter_->first; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
operator ->	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator->() { return &iter_->second; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
operator ->	../../libs/libvtrutil/src/vtr_vector.h	/^                pointer operator->() { return &value_; }$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
operator ->	route/rr_node.h	/^            pointer operator->() { return &value_; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator<(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator<(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
operator <	../../libs/libarchfpga/src/physical_types.h	/^	bool operator < (const SB_Side_Connection &obj) const{$/;"	f	class:SB_Side_Connection	access:public	signature:(const SB_Side_Connection &obj) const
operator <	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator< <>(Point<T> lhs, Point<T> rhs);$/;"	p	class:vtr::Point	access:friend	signature:(Point<T> lhs, Point<T> rhs)
operator <	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator<(Point<T> lhs, Point<T> rhs);$/;"	p	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
operator <	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator<(Point<T> lhs, Point<T> rhs) {$/;"	f	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
operator <	../../libs/libvtrutil/src/vtr_strong_id.h	/^        friend bool operator< <>(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	class:vtr::StrongId	access:friend	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator <	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator<(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs) {$/;"	f	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator <	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator<(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator <	pack/pb_type_graph.cpp	/^static bool operator<(const t_pb_graph_edge_comparator & edge1,$/;"	f	file:	signature:(const t_pb_graph_edge_comparator & edge1, const t_pb_graph_edge_comparator & edge2)
operator <	pack/pb_type_graph.cpp	/^static bool operator<(const t_pb_graph_edge_comparator & edge1,$/;"	p	file:	signature:(const t_pb_graph_edge_comparator & edge1, const t_pb_graph_edge_comparator & edge2)
operator <	place/place_delay_model.h	/^            friend bool operator<(const t_override& lhs, const t_override& rhs) {$/;"	f	struct:OverrideDelayModel::t_override	access:friend	signature:(const t_override& lhs, const t_override& rhs)
operator <	power/PowerSpicedComponent.h	/^	bool operator<(const PowerCallibSize & rhs) {$/;"	f	class:PowerCallibSize	access:public	signature:(const PowerCallibSize & rhs)
operator <	route/check_route.cpp	/^    friend bool operator<(const t_node_edge& lhs, const t_node_edge& rhs) {$/;"	f	struct:t_node_edge	access:friend	signature:(const t_node_edge& lhs, const t_node_edge& rhs)
operator <	route/router_lookahead_map.cpp	/^	bool operator < (const PQ_Entry &obj) const{$/;"	f	class:PQ_Entry	access:public	signature:(const PQ_Entry &obj) const
operator <	route/rr_graph2.h	/^    friend bool operator<(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs) {$/;"	f	struct:t_rr_edge_info	access:friend	signature:(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs)
operator <	timing/DomainPair.h	/^    friend bool operator<(const DomainPair& lhs, const DomainPair& rhs) {$/;"	f	struct:DomainPair	access:friend	signature:(const DomainPair& lhs, const DomainPair& rhs)
operator <<	base/netlist_writer.cpp	/^        friend std::ostream& operator<<(std::ostream& os, LogicVec logic_vec) {$/;"	f	class:LogicVec	access:friend	signature:(std::ostream& os, LogicVec logic_vec)
operator <<	base/netlist_writer.cpp	/^        friend std::ostream& operator<<(std::ostream& os, const Type& type) {$/;"	f	class:LatchInst	access:friend	signature:(std::ostream& os, const Type& type)
operator <<	base/netlist_writer.cpp	/^std::ostream& operator<<(std::ostream& os, vtr::LogicValue val) {$/;"	f	signature:(std::ostream& os, vtr::LogicValue val)
operator <<	base/netlist_writer.cpp	/^std::ostream& operator<<(std::ostream& os, vtr::LogicValue val);$/;"	p	file:	signature:(std::ostream& os, vtr::LogicValue val)
operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator<=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator<=(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<=(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<=(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(T* value)$/;"	f	class:compact_pointer	access:public	signature:(T* value)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(T* value)$/;"	f	class:compact_pointer_parent	access:public	signature:(T* value)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(char_t* value)$/;"	f	class:compact_string	access:public	signature:(char_t* value)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(const compact_pointer& rhs)$/;"	f	class:compact_pointer	access:public	signature:(const compact_pointer& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(const compact_pointer_parent& rhs)$/;"	f	class:compact_pointer_parent	access:public	signature:(const compact_pointer_parent& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator=(const compact_string& rhs)$/;"	f	class:compact_string	access:public	signature:(const compact_string& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_buffered_writer& operator=(const xml_buffered_writer&);$/;"	p	class:xml_buffered_writer	file:	access:private	signature:(const xml_buffered_writer&)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node& operator=(const xpath_ast_node&);$/;"	p	class:xpath_ast_node	file:	access:private	signature:(const xpath_ast_node&)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(bool rhs)$/;"	f	class:pugi::xml_attribute	signature:(bool rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(const char_t* rhs)$/;"	f	class:pugi::xml_attribute	signature:(const char_t* rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(double rhs)$/;"	f	class:pugi::xml_attribute	signature:(double rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(float rhs)$/;"	f	class:pugi::xml_attribute	signature:(float rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(int rhs)$/;"	f	class:pugi::xml_attribute	signature:(int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned int rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(bool rhs)$/;"	f	class:pugi::xml_text	signature:(bool rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(const char_t* rhs)$/;"	f	class:pugi::xml_text	signature:(const char_t* rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(double rhs)$/;"	f	class:pugi::xml_text	signature:(double rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(float rhs)$/;"	f	class:pugi::xml_text	signature:(float rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(int rhs)$/;"	f	class:pugi::xml_text	signature:(int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(long long rhs)$/;"	f	class:pugi::xml_text	signature:(long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(unsigned int rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(unsigned long long rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set& xpath_node_set::operator=(const xpath_node_set& ns)$/;"	f	class:pugi::xpath_node_set	signature:(const xpath_node_set& ns)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set& xpath_node_set::operator=(xpath_node_set&& rhs)$/;"	f	class:pugi::xpath_node_set	signature:(xpath_node_set&& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query& xpath_query::operator=(xpath_query&& rhs)$/;"	f	class:pugi::xpath_query	signature:(xpath_query&& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set& xpath_variable_set::operator=(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(const xpath_variable_set& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set& xpath_variable_set::operator=(xpath_variable_set&& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable_set&& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(bool rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(bool rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(const char_t* rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(double rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(double rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(float rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(float rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(unsigned int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(unsigned long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_document& operator=(const xml_document&);$/;"	p	class:pugi::xml_document	access:private	signature:(const xml_document&)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(bool rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(bool rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(const char_t* rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(const char_t* rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(double rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(double rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(float rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(float rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(unsigned int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned int rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(unsigned long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned long long rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set& operator=(const xpath_node_set& ns);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(const xpath_node_set& ns)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set& operator=(xpath_node_set&& rhs);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(xpath_node_set&& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query& operator=(const xpath_query&);$/;"	p	class:pugi::xpath_query	access:private	signature:(const xpath_query&)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query& operator=(xpath_query&& rhs);$/;"	p	class:pugi::xpath_query	access:public	signature:(xpath_query&& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable& operator=(const xpath_variable&);$/;"	p	class:pugi::xpath_variable	access:protected	signature:(const xpath_variable&)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set& operator=(const xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const xpath_variable_set& rhs)
operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set& operator=(xpath_variable_set&& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(xpath_variable_set&& rhs)
operator =	../../libs/libeasygl/src/Surface.cpp	/^Surface& Surface::operator=(Surface rhs) {$/;"	f	class:Surface	signature:(Surface rhs)
operator =	../../libs/libeasygl/src/Surface.h	/^        Surface& operator=(Surface rhs); \/\/ assignment operator$/;"	p	class:Surface	access:public	signature:(Surface rhs)
operator =	../../libs/libeasygl/src/fontcache.h	/^    FontCache& operator=(const FontCache&) = delete;$/;"	p	class:FontCache	access:private	signature:(const FontCache&)
operator =	../../libs/libeasygl/src/graphics_types.cpp	/^color_types t_color::operator=(color_types \/*color_enum*\/) {$/;"	f	class:t_color	signature:(color_types )
operator =	../../libs/libeasygl/src/graphics_types.cpp	/^color_types t_color::operator=(color_types color_enum) {$/;"	f	class:t_color	signature:(color_types color_enum)
operator =	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box& t_bound_box::operator=(const t_bound_box& src) {$/;"	f	class:t_bound_box	signature:(const t_bound_box& src)
operator =	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator=(const t_point&) = default;$/;"	p	class:t_point	file:	signature:(const t_point&)
operator =	../../libs/libeasygl/src/graphics_types.h	/^    color_types operator=(color_types color_enum);$/;"	p	class:t_color	access:public	signature:(color_types color_enum)
operator =	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box& operator=(const t_bound_box& src);$/;"	p	class:t_bound_box	access:public	signature:(const t_bound_box& src)
operator =	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator=(const t_point& src);$/;"	p	class:t_point	access:public	signature:(const t_point& src)
operator =	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber& operator=(VNumber&&) = default;$/;"	p	class:VNumber	access:public	signature:(VNumber&&)
operator =	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map& operator=(const flat_map&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(const flat_map&)
operator =	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map& operator=(flat_map&&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(flat_map&&)
operator =	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map& operator=(const linear_map&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(const linear_map&)
operator =	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map& operator=(linear_map&&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(linear_map&&)
operator =	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase& operator=(NdMatrixBase rhs) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(NdMatrixBase rhs)
operator =	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase& operator=(NdOffsetMatrixBase rhs) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(NdOffsetMatrixBase rhs)
operator =	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard& operator=(const OsFormatGuard&&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&&)
operator =	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard& operator=(const OsFormatGuard&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&)
operator =	../../libs/libvtrutil/src/vtr_time.h	/^            Timer& operator=(Timer&&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&&)
operator =	../../libs/libvtrutil/src/vtr_time.h	/^            Timer& operator=(Timer&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&)
operator =	base/vpr_context.h	/^    Context& operator=(Context&) = delete;$/;"	p	struct:Context	access:public	signature:(Context&)
operator =	route/route_traceback.cpp	/^t_traceback t_traceback::operator=(t_traceback other) {$/;"	f	class:t_traceback	signature:(t_traceback other)
operator =	route/route_traceback.h	/^    t_traceback operator=(t_traceback);$/;"	p	struct:t_traceback	access:public	signature:(t_traceback)
operator =	util/vpr_utils.cpp	/^IntraLbPbPinLookup& IntraLbPbPinLookup::operator=(IntraLbPbPinLookup rhs) {$/;"	f	class:IntraLbPbPinLookup	signature:(IntraLbPbPinLookup rhs)
operator =	util/vpr_utils.h	/^        IntraLbPbPinLookup& operator=(IntraLbPbPinLookup rhs);$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(IntraLbPbPinLookup rhs)
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator==(const char_t* other) const$/;"	f	struct:xpath_lexer_string	access:public	signature:(const char_t* other) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator==(const xpath_string& o) const$/;"	f	class:xpath_string	access:public	signature:(const xpath_string& o) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator==(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute_iterator::operator==(const xml_attribute_iterator& rhs) const$/;"	f	class:pugi::xml_attribute_iterator	signature:(const xml_attribute_iterator& rhs) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_named_node_iterator::operator==(const xml_named_node_iterator& rhs) const$/;"	f	class:pugi::xml_named_node_iterator	signature:(const xml_named_node_iterator& rhs) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator==(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node_iterator::operator==(const xml_node_iterator& rhs) const$/;"	f	class:pugi::xml_node_iterator	signature:(const xml_node_iterator& rhs) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node::operator==(const xpath_node& n) const$/;"	f	class:pugi::xpath_node	signature:(const xpath_node& n) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_attribute_iterator& rhs) const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(const xml_attribute_iterator& rhs) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_named_node_iterator& rhs) const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(const xml_named_node_iterator& rhs) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_node_iterator& rhs) const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(const xml_node_iterator& rhs) const
operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xpath_node& n) const;$/;"	p	class:pugi::xpath_node	access:public	signature:(const xpath_node& n) const
operator ==	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator==(color_types \/*rhs*\/) const {$/;"	f	class:t_color	signature:(color_types ) const
operator ==	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator==(color_types rhs) const {$/;"	f	class:t_color	signature:(color_types rhs) const
operator ==	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator==(const t_color& rhs) const {$/;"	f	class:t_color	signature:(const t_color& rhs) const
operator ==	../../libs/libeasygl/src/graphics_types.h	/^    bool operator==(color_types rhs) const;$/;"	p	class:t_color	access:public	signature:(color_types rhs) const
operator ==	../../libs/libeasygl/src/graphics_types.h	/^    bool operator==(const t_color& rhs) const;$/;"	p	class:t_color	access:public	signature:(const t_color& rhs) const
operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator== <>(Point<T> lhs, Point<T> rhs);$/;"	p	class:vtr::Point	access:friend	signature:(Point<T> lhs, Point<T> rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator== <>(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	class:vtr::Rect	access:friend	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator== <>(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	class:vtr::RectUnion	access:friend	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator==(Point<T> lhs, Point<T> rhs);$/;"	p	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator==(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator==(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator==(Point<T> lhs, Point<T> rhs) {$/;"	f	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator==(const Rect<T>& lhs, const Rect<T>& rhs) {$/;"	f	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator==(const RectUnion<T>& lhs, const RectUnion<T>& rhs) {$/;"	f	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator== (const pair_first_iter lhs, const pair_first_iter rhs) { return lhs.iter_ == rhs.iter_; }$/;"	f	class:vtr::pair_first_iter	access:friend	signature:(const pair_first_iter lhs, const pair_first_iter rhs)
operator ==	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator== (const pair_second_iter lhs, const pair_second_iter rhs) { return lhs.iter_ == rhs.iter_; }$/;"	f	class:vtr::pair_second_iter	access:friend	signature:(const pair_second_iter lhs, const pair_second_iter rhs)
operator ==	../../libs/libvtrutil/src/vtr_strong_id.h	/^        friend bool operator== <>(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	class:vtr::StrongId	access:friend	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator==(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs) {$/;"	f	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator==(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
operator ==	../../libs/libvtrutil/src/vtr_vector.h	/^                friend bool operator== (const key_iterator lhs, const key_iterator rhs) { return lhs.value_ == rhs.value_; }$/;"	f	class:vtr::vector::key_iterator	access:friend	signature:(const key_iterator lhs, const key_iterator rhs)
operator ==	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::clb_pin_tuple::operator==(const clb_pin_tuple& rhs) const {$/;"	f	class:t_selected_sub_block_info::clb_pin_tuple	signature:(const clb_pin_tuple& rhs) const
operator ==	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::gnode_clb_pair::operator==(const gnode_clb_pair& rhs) const {$/;"	f	class:t_selected_sub_block_info::gnode_clb_pair	signature:(const gnode_clb_pair& rhs) const
operator ==	draw/intra_logic_block.h	/^		bool operator==(const clb_pin_tuple&) const;$/;"	p	struct:t_selected_sub_block_info::clb_pin_tuple	access:public	signature:(const clb_pin_tuple&) const
operator ==	draw/intra_logic_block.h	/^		bool operator==(const gnode_clb_pair &) const;$/;"	p	struct:t_selected_sub_block_info::gnode_clb_pair	access:public	signature:(const gnode_clb_pair &) const
operator ==	route/build_switchblocks.h	/^	bool operator == (const Switchblock_Lookup &obj) const{$/;"	f	class:Switchblock_Lookup	access:public	signature:(const Switchblock_Lookup &obj) const
operator ==	route/rr_graph2.h	/^    friend bool operator==(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs) {$/;"	f	struct:t_rr_edge_info	access:friend	signature:(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs)
operator ==	route/rr_node.h	/^            friend bool operator== (const edge_idx_iterator lhs, const edge_idx_iterator rhs) { return lhs.value_ == rhs.value_; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:friend	signature:(const edge_idx_iterator lhs, const edge_idx_iterator rhs)
operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator>(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator>(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator>=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator>=(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>=(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>=(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
operator >>	base/netlist_writer.cpp	/^        friend std::istream& operator>>(std::istream& is, Type& type) {$/;"	f	class:LatchInst	access:friend	signature:(std::istream& is, Type& type)
operator T*	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		operator T*() const$/;"	f	class:compact_pointer	access:public	signature:() const
operator T*	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		operator T*() const$/;"	f	class:compact_pointer_parent	access:public	signature:() const
operator []	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_node& xpath_node_set::operator[](size_t index) const$/;"	f	class:pugi::xpath_node_set	signature:(size_t index) const
operator []	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_node& operator[](size_t index) const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_bimap.h	/^        const K& operator[] (const V value) const {$/;"	f	class:vtr::bimap	access:public	signature:(const V value) const
operator []	../../libs/libvtrutil/src/vtr_bimap.h	/^        const V& operator[] (const K key) const {$/;"	f	class:vtr::bimap	access:public	signature:(const K key) const
operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        T& operator[](const K& key) {$/;"	f	class:vtr::flat_map2	access:public	signature:(const K& key)
operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const T& operator[](const K& key) const {$/;"	f	class:vtr::flat_map2	access:public	signature:(const K& key) const
operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const mapped_type& operator[](const key_type& key) const  {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        mapped_type& operator[](const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
operator []	../../libs/libvtrutil/src/vtr_linear_map.h	/^        mapped_type& operator[](const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const NdMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const NdMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index)
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const NdOffsetMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const NdOffsetMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index) const
operator []	../../libs/libvtrutil/src/vtr_vector.h	/^        const_reference operator[](const key_type id) const {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id) const
operator []	../../libs/libvtrutil/src/vtr_vector.h	/^        reference operator[](const key_type id) {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id)
operator []	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_reference operator[] (const K n) const {$/;"	f	class:vtr::vector_map	access:public	signature:(const K n) const
operator []	../../libs/libvtrutil/src/vtr_vector_map.h	/^        reference operator[] (const K n) {$/;"	f	class:vtr::vector_map	access:public	signature:(const K n)
operator []	base/device_grid.h	/^        auto operator[](size_t index) const { return grid_[index]; }$/;"	f	class:DeviceGrid	access:public	signature:(size_t index) const
operator []	base/device_grid.h	/^        auto operator[](size_t index) { return grid_[index]; }$/;"	f	class:DeviceGrid	access:public	signature:(size_t index)
operator []	base/netlist_writer.cpp	/^        vtr::LogicValue& operator[](size_t i) { return values_[i]; }$/;"	f	class:LogicVec	access:public	signature:(size_t i)
operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result::operator bool() const$/;"	f	class:pugi::xml_parse_result	signature:() const
operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_parse_result::operator bool() const$/;"	f	class:pugi::xpath_parse_result	signature:() const
operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator bool() const;$/;"	p	struct:pugi::xml_parse_result	access:public	signature:() const
operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator bool() const;$/;"	p	struct:pugi::xpath_parse_result	access:public	signature:() const
operator bool	../../libs/libvtrutil/src/vtr_strong_id.h	/^        explicit operator bool() const { return *this != INVALID(); }$/;"	f	class:vtr::StrongId	access:public	signature:() const
operator bool	base/vpr_types.h	/^        operator bool() const { return success(); }$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:() const
operator char_t*	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		operator char_t*() const$/;"	f	class:compact_string	access:public	signature:() const
operator std::size_t	../../libs/libvtrutil/src/vtr_strong_id.h	/^        explicit operator std::size_t() const { return static_cast<std::size_t>(id_); }$/;"	f	class:vtr::StrongId	access:public	signature:() const
operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
operator xml_attribute::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute::operator xml_attribute::unspecified_bool_type() const$/;"	f	class:pugi::xml_attribute	signature:() const
operator xml_node::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::operator xml_node::unspecified_bool_type() const$/;"	f	class:pugi::xml_node	signature:() const
operator xml_text::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text::operator xml_text::unspecified_bool_type() const$/;"	f	class:pugi::xml_text	signature:() const
operator xpath_node::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::operator xpath_node::unspecified_bool_type() const$/;"	f	class:pugi::xpath_node	signature:() const
operator xpath_query::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::operator xpath_query::unspecified_bool_type() const$/;"	f	class:pugi::xpath_query	signature:() const
operator |=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void operator|=(uintptr_t mod)$/;"	f	class:compact_header	access:public	signature:(uintptr_t mod)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xml_attribute& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xml_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xml_text& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xpath_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xml_attribute& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xml_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xml_text& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xpath_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
opt_false	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct opt_false$/;"	s	file:
opt_false::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		enum { value = 0 };$/;"	e	enum:opt_false::__anon25	file:
opt_memory_layout	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::opt_memory_layout() {$/;"	f	class:TimingGraphBuilder	signature:()
opt_memory_layout	timing/timing_graph_builder.h	/^        void opt_memory_layout();$/;"	p	class:TimingGraphBuilder	access:private	signature:()
opt_true	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct opt_true$/;"	s	file:
opt_true::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		enum { value = 1 };$/;"	e	enum:opt_true::__anon26	file:
optimize	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void optimize(xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_allocator* alloc)
optimize_self	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void optimize_self(xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_allocator* alloc)
options	timing/slre.cpp	/^  enum slre_option options;$/;"	m	struct:slre	typeref:enum:slre::slre_option	file:	access:public
order_rotated	../../libs/libeasygl/src/fontcache.h	/^    font_queue order_rotated;$/;"	m	class:FontCache	access:private
order_zeros	../../libs/libeasygl/src/fontcache.h	/^    font_queue order_zeros;$/;"	m	class:FontCache	access:private
orig_blif_name	timing/read_sdc2.cpp	/^std::string orig_blif_name(std::string name) {$/;"	f	signature:(std::string name)
orig_blif_name	timing/read_sdc2.cpp	/^std::string orig_blif_name(std::string name);$/;"	p	file:	signature:(std::string name)
ortho_cost_index	route/rr_node.h	/^	int ortho_cost_index;$/;"	m	struct:t_rr_indexed_data	access:public
os_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::ostream& os_;$/;"	m	class:vtr::OsFormatGuard	access:private
other	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber& operator=(const VNumber& other) = default;$/;"	m	class:VNumber	access:public
other	base/netlist_writer.cpp	/^        NetlistWriterVisitor(NetlistWriterVisitor& other) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
other	base/netlist_writer.cpp	/^        NetlistWriterVisitor(NetlistWriterVisitor&& other) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
out	power/power.h	/^	FILE * out;$/;"	m	struct:t_power_output	access:public
out_edges	base/vpr_types.h	/^	t_tedge *out_edges; \/* [0..num_edges - 1] array of edges fanning out from this tnode.$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
out_file_prefix	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string out_file_prefix; \/* used by fopen *\/$/;"	m	namespace:vtr	file:
out_file_prefix	base/read_options.h	/^    argparse::ArgValue<std::string> out_file_prefix;$/;"	m	struct:t_options	access:public
out_file_prefix	base/vpr_types.h	/^	std::string out_file_prefix;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
out_value	../../libs/libarchfpga/src/physical_types.h	/^    float out_value;				\/\/Output Fc value$/;"	m	struct:t_default_fc_spec	access:public
out_value_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_value_type out_value_type; \/\/Type of the output value (frac or abs)$/;"	m	struct:t_default_fc_spec	access:public
outedges	pack/pack_types.h	/^	t_lb_type_rr_node_edge **outedges;						\/* [0..num_modes - 1][0..num_fanout-1] index and cost of out edges *\/$/;"	m	struct:t_lb_type_rr_node	access:public
outer_loop_recompute_criticalities	place/place.cpp	/^static void outer_loop_recompute_criticalities(t_placer_opts placer_opts,$/;"	f	file:	signature:(t_placer_opts placer_opts, t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, int num_connections, float crit_exponent, float * place_delay_value, int * outer_crit_iter_count, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_slack* slacks, t_timing_inf timing_inf, const PlaceDelayModel& delay_model, SetupTimingInfo& timing_info)
outer_loop_recompute_criticalities	place/place.cpp	/^static void outer_loop_recompute_criticalities(t_placer_opts placer_opts,$/;"	p	file:	signature:(t_placer_opts placer_opts, t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, int num_connections, float crit_exponent, float * place_delay_value, int * outer_crit_iter_count, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_slack* slacks, t_timing_inf timing_inf, const PlaceDelayModel& delay_model, SetupTimingInfo& timing_info)
outport_link_pin	../../libs/libarchfpga/src/cad_types.h	/^	int outport_link_pin; \/* applicable pin of chain output port *\/$/;"	m	struct:t_model_chain_pattern	access:public
output	base/vpr_context.h	/^    t_power_output* output;$/;"	m	struct:PowerContext	access:public
outputFileNames	base/echo_files.cpp	/^static char **outputFileNames = nullptr;$/;"	v	file:
output_blif	pack/output_blif.cpp	/^void output_blif(const t_arch *arch, const char *out_fname) {$/;"	f	signature:(const t_arch *arch, const char *out_fname)
output_blif	pack/output_blif.h	/^void output_blif (const t_arch *arch, const char *out_fname);$/;"	p	signature:(const t_arch *arch, const char *out_fname)
output_clustering	pack/output_clustering.cpp	/^void output_clustering(const vtr::vector<ClusterBlockId, std::vector<t_intra_lb_net>*> &intra_lb_routing, bool global_clocks,$/;"	f	signature:(const vtr::vector<ClusterBlockId, std::vector<t_intra_lb_net>*> &intra_lb_routing, bool global_clocks, const std::unordered_set<AtomNetId>& is_clock, const std::string& architecture_id, const char *out_fname, bool skip_clustering)
output_clustering	pack/output_clustering.h	/^void output_clustering(const vtr::vector<ClusterBlockId, std::vector<t_intra_lb_net>*> &intra_lb_routing, bool global_clocks,$/;"	p	signature:(const vtr::vector<ClusterBlockId, std::vector<t_intra_lb_net>*> &intra_lb_routing, bool global_clocks, const std::unordered_set<AtomNetId>& is_clock, const std::string& architecture_id, const char *out_fname, bool skip_clustering)
output_edges	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_edge** output_edges = nullptr; \/* [0..num_output_edges] *\/$/;"	m	struct:t_pb_graph_pin	access:public
output_file	base/vpr_types.h	/^	std::string output_file;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
output_hex	../../libs/libvtrutil/src/picosha2.h	/^void output_hex(InIter first, InIter last, std::ostream& os){$/;"	f	namespace:picosha2	signature:(InIter first, InIter last, std::ostream& os)
output_link_port	../../libs/libarchfpga/src/cad_types.h	/^	t_model_ports *output_link_port; \/* pointer to port of chain output *\/$/;"	m	struct:t_model_chain_pattern	access:public
output_log	power/power_util.cpp	/^void output_log(t_log * log_ptr, FILE * fp) {$/;"	f	signature:(t_log * log_ptr, FILE * fp)
output_log	power/power_util.h	/^void output_log(t_log * log_ptr, FILE * fp);$/;"	p	signature:(t_log * log_ptr, FILE * fp)
output_logs	power/power_util.cpp	/^void output_logs(FILE * fp, t_log * logs, int num_logs) {$/;"	f	signature:(FILE * fp, t_log * logs, int num_logs)
output_logs	power/power_util.h	/^void output_logs(FILE * fp, t_log * logs, int num_logs);$/;"	p	signature:(FILE * fp, t_log * logs, int num_logs)
output_pin	pack/pb_type_graph.h	/^	t_pb_graph_pin* output_pin;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
output_pin_class_size	../../libs/libarchfpga/src/physical_types.h	/^	int *output_pin_class_size; \/* Stores the number of pins that belong to a particular output pin class *\/$/;"	m	struct:t_pb_graph_node	access:public
output_pin_id_in_cluster	pack/pb_type_graph.h	/^	int output_pin_id_in_cluster;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
output_pin_util	base/vpr_types.h	/^    float output_pin_util = 1.;$/;"	m	struct:ScreenUpdatePriority::t_ext_pin_util	access:public
output_pins	../../libs/libarchfpga/src/physical_types.h	/^	char *output_pins;$/;"	m	struct:t_pin_to_pin_annotation	access:public
output_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin ***output_pins; \/\/ [0..num_output_ports-1][0..num_pins_per_port-1]$/;"	m	struct:t_interconnect_pins	access:public
output_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **output_pins; \/* [0..num_output_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:t_pb_graph_node	access:public
output_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **output_pins;$/;"	m	struct:t_pb_graph_edge	access:public
output_pins_used	pack/pack_types.h	/^	std::vector<std::vector<AtomNetId>> output_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of output pins of this class that are used *\/$/;"	m	struct:t_pb_stats	access:public
output_port_conns_	base/netlist_writer.cpp	/^        std::map<std::string,std::vector<std::string>> output_port_conns_;$/;"	m	class:BlackBoxInst	file:	access:private
output_string	../../libs/libarchfpga/src/physical_types.h	/^	char *output_string;$/;"	m	struct:t_interconnect	access:public
output_types	base/vpr_context.h	/^    std::set<t_type_ptr> output_types;$/;"	m	struct:DeviceContext	access:public
outputs	../../libs/libarchfpga/src/logic_types.h	/^	t_model_ports *outputs = nullptr; \/* linked list of output ports *\/$/;"	m	struct:t_model	access:public
outputs_	base/netlist_writer.cpp	/^        std::vector<std::string> outputs_; \/\/Name of circuit outputs$/;"	m	class:NetlistWriterVisitor	file:	access:private
override	base/atom_netlist.h	/^        bool validate_block_sizes_impl(size_t num_blocks) const override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        bool validate_net_sizes_impl(size_t num_nets) const override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        bool validate_pin_sizes_impl(size_t num_pins) const override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        bool validate_port_sizes_impl(size_t num_ports) const override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void clean_blocks_impl(const vtr::vector_map<AtomBlockId,AtomBlockId>& block_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void clean_nets_impl(const vtr::vector_map<AtomNetId, AtomNetId>& net_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void clean_pins_impl(const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void clean_ports_impl(const vtr::vector_map<AtomPortId,AtomPortId>& port_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void rebuild_block_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map, const vtr::vector_map<AtomPortId, AtomPortId>& port_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void rebuild_net_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void rebuild_pin_refs_impl(const vtr::vector_map<AtomPortId, AtomPortId>& port_id_map, const vtr::vector_map<AtomNetId, AtomNetId>& net_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void rebuild_port_refs_impl(const vtr::vector_map<AtomBlockId, AtomBlockId>& block_id_map, const vtr::vector_map<AtomPinId, AtomPinId>& pin_id_map) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void remove_block_impl(const AtomBlockId blk_id) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void remove_net_impl(const AtomNetId net_id) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void remove_pin_impl(const AtomPinId pin_id) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void remove_port_impl(const AtomPortId port_id) override;$/;"	m	class:AtomNetlist	access:private
override	base/atom_netlist.h	/^        void shrink_to_fit_impl() override;$/;"	m	class:AtomNetlist	access:private
override	base/clustered_netlist.h	/^        bool validate_block_sizes_impl(size_t num_blocks) const override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        bool validate_net_sizes_impl(size_t num_nets) const override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        bool validate_pin_sizes_impl(size_t num_pins) const override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        bool validate_port_sizes_impl(size_t num_ports) const override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void clean_blocks_impl(const vtr::vector_map<ClusterBlockId,ClusterBlockId>& block_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void clean_nets_impl(const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void clean_pins_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void clean_ports_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void rebuild_block_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map, const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void rebuild_net_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void rebuild_pin_refs_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& port_id_map, const vtr::vector_map<ClusterNetId, ClusterNetId>& net_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void rebuild_port_refs_impl(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& block_id_map, const vtr::vector_map<ClusterPinId, ClusterPinId>& pin_id_map) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void remove_block_impl(const ClusterBlockId blk_id) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void remove_net_impl(const ClusterNetId net_id) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void remove_pin_impl(const ClusterPinId pin_id) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void remove_port_impl(const ClusterPortId port_id) override;$/;"	m	class:ClusteredNetlist	access:private
override	base/clustered_netlist.h	/^        void shrink_to_fit_impl() override;$/;"	m	class:ClusteredNetlist	access:private
override	place/place_delay_model.h	/^        float delay(int from_x, int from_y, int \/*from_pin*\/, int to_x, int to_y, int \/*to_pin*\/) const override;$/;"	m	class:DeltaDelayModel	access:public
override	place/place_delay_model.h	/^        float delay(int from_x, int from_y, int from_pin, int to_x, int to_y, int to_pin) const override;$/;"	m	class:OverrideDelayModel	access:public
override	place/place_delay_model.h	/^        void dump_echo(std::string filepath) const override;$/;"	m	class:DeltaDelayModel	access:public
override	place/place_delay_model.h	/^        void dump_echo(std::string filepath) const override;$/;"	m	class:OverrideDelayModel	access:public
override	route/router_lookahead.h	/^        float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const override;$/;"	m	class:ClassicLookahead	access:public
override	route/router_lookahead.h	/^        float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const override;$/;"	m	class:MapLookahead	access:protected
override	route/router_lookahead.h	/^        float get_expected_cost(int node, int target_node, const t_conn_cost_params& params, float R_upstream) const override;$/;"	m	class:NoOpLookahead	access:protected
override	timing/PostClusterDelayCalculator.h	/^    tatum::Time hold_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
override	timing/PostClusterDelayCalculator.h	/^    tatum::Time max_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
override	timing/PostClusterDelayCalculator.h	/^    tatum::Time min_edge_delay(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
override	timing/PostClusterDelayCalculator.h	/^    tatum::Time setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const override;$/;"	m	class:PostClusterDelayCalculator	access:public
override	timing/VprTimingGraphResolver.h	/^        std::string node_name(tatum::NodeId node) const override;$/;"	m	class:VprTimingGraphResolver	access:public
override	timing/VprTimingGraphResolver.h	/^        std::string node_type_name(tatum::NodeId node) const override;$/;"	m	class:VprTimingGraphResolver	access:public
override	timing/VprTimingGraphResolver.h	/^        tatum::EdgeDelayBreakdown edge_delay_breakdown(tatum::EdgeId edge, tatum::DelayType delay_type) const override;$/;"	m	class:VprTimingGraphResolver	access:public
overrides_	base/vpr_types.h	/^    std::map<std::string,t_ext_pin_util> overrides_;$/;"	m	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:private
overused_node_ratio	route/route_timing.cpp	/^    float overused_node_ratio() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
overused_nodes	route/route_timing.cpp	/^    size_t overused_nodes() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
overused_nodes_	route/route_timing.cpp	/^    size_t overused_nodes_;$/;"	m	class:OveruseInfo	file:	access:private
pack_pattern	base/vpr_types.h	/^	t_pack_patterns *pack_pattern; \/* If this is a forced_pack molecule, pattern this molecule matches *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
pack_pattern_indices	../../libs/libarchfpga/src/physical_types.h	/^	int *pack_pattern_indices; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:t_pb_graph_edge	access:public
pack_pattern_names	../../libs/libarchfpga/src/physical_types.h	/^	const char **pack_pattern_names; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:t_pb_graph_edge	access:public
pack_verbosity	base/read_options.h	/^    argparse::ArgValue<int> pack_verbosity;$/;"	m	struct:t_options	access:public
pack_verbosity	base/vpr_types.h	/^	int pack_verbosity;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
packer_algorithm	base/vpr_types.h	/^	enum e_packer_algorithm packer_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	typeref:enum:ScreenUpdatePriority::t_packer_opts::e_packer_algorithm	access:public
pad	../../libs/libvtrutil/src/vtr_time.cpp	/^std::string ScopedActionTimer::pad() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
pad	../../libs/libvtrutil/src/vtr_time.h	/^            std::string pad() const;$/;"	p	class:vtr::ScopedActionTimer	access:protected	signature:() const
pad_loc_file	base/read_options.h	/^    argparse::ArgValue<std::string> pad_loc_file;$/;"	m	struct:t_options	access:public
pad_loc_file	base/vpr_types.h	/^    std::string pad_loc_file;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
pad_loc_type	base/read_options.h	/^    argparse::ArgValue<e_pad_loc_type> pad_loc_type;$/;"	m	struct:t_options	access:public
pad_loc_type	base/vpr_types.h	/^	enum e_pad_loc_type pad_loc_type;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	typeref:enum:ScreenUpdatePriority::t_placer_opts::e_pad_loc_type	access:public
page_offset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t page_offset; \/\/ offset from page->data$/;"	m	struct:xml_memory_string_header	file:	access:public
pair_first_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^        pair_first_iter(PairIter init): iter_(init) {}$/;"	f	class:vtr::pair_first_iter	access:public	signature:(PairIter init)
pair_first_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^class pair_first_iter {$/;"	c	namespace:vtr
pair_second_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^        pair_second_iter(PairIter init): iter_(init) {}$/;"	f	class:vtr::pair_second_iter	access:public	signature:(PairIter init)
pair_second_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^class pair_second_iter {$/;"	c	namespace:vtr
pan_state	../../libs/libeasygl/src/graphics.cpp	/^static t_panning_state pan_state = {0, 0, false};$/;"	v	file:
panning_enabled	../../libs/libeasygl/src/graphics.cpp	/^    bool panning_enabled;$/;"	m	struct:__anon21	file:	access:public
panning_execute	../../libs/libeasygl/src/graphics.cpp	/^panning_execute(int x, int y, void (*drawscreen) ()) {$/;"	f	file:	signature:(int x, int y, void (*drawscreen) ())
panning_execute	../../libs/libeasygl/src/graphics.cpp	/^static void panning_execute(int x, int y, void (*drawscreen) ());$/;"	p	file:	signature:(int x, int y, void (*drawscreen) ())
panning_off	../../libs/libeasygl/src/graphics.cpp	/^panning_off() {$/;"	f	file:	signature:()
panning_off	../../libs/libeasygl/src/graphics.cpp	/^static void panning_off();$/;"	p	file:	signature:()
panning_on	../../libs/libeasygl/src/graphics.cpp	/^panning_on(int start_x, int start_y) {$/;"	f	file:	signature:(int start_x, int start_y)
panning_on	../../libs/libeasygl/src/graphics.cpp	/^static void panning_on(int start_x, int start_y);$/;"	p	file:	signature:(int start_x, int start_y)
param_iterator	base/netlist.h	/^        typedef typename std::unordered_map<std::string, std::string>::const_iterator   param_iterator;$/;"	t	class:Netlist	access:public
param_range	base/netlist.h	/^        typedef typename vtr::Range<param_iterator> param_range;$/;"	t	class:Netlist	access:public
params	pack/pack_types.h	/^	t_lb_router_params params;$/;"	m	struct:t_lb_router_data	access:public
params_	base/netlist_writer.cpp	/^        std::map<std::string,std::string> params_;$/;"	m	class:BlackBoxInst	file:	access:private
parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer_parent<xml_node_struct, 6> parent;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::parent() const$/;"	f	class:pugi::xml_node	signature:() const
parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xpath_node::parent() const$/;"	f	class:pugi::xpath_node	signature:() const
parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node parent() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node parent() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
parent	power/PowerSpicedComponent.h	/^	PowerSpicedComponent * parent;$/;"	m	class:PowerCallibInputs	access:public
parent	route/route_common.cpp	/^	size_t parent(size_t i) {return i >> 1;}$/;"	f	namespace:heap_	signature:(size_t i)
parent	route/route_common.cpp	/^	size_t parent(size_t i);$/;"	p	namespace:heap_	file:	signature:(size_t i)
parent_edge	pack/pb_type_graph.h	/^	t_pb_graph_edge* parent_edge;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
parent_mode	../../libs/libarchfpga/src/physical_types.h	/^	t_mode *parent_mode = nullptr;$/;"	m	struct:t_pb_type	access:public
parent_mode	../../libs/libarchfpga/src/physical_types.h	/^	t_mode *parent_mode;$/;"	m	struct:t_interconnect	access:public
parent_mode_index	../../libs/libarchfpga/src/physical_types.h	/^	int parent_mode_index;$/;"	m	struct:t_interconnect	access:public
parent_node	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node *parent_node = nullptr;$/;"	m	struct:t_pb_graph_pin	access:public
parent_node	route/route_tree_type.h	/^	t_rt_node *parent_node;$/;"	m	struct:t_rt_node	access:public
parent_pb	base/vpr_types.h	/^	t_pb *parent_pb = nullptr; \/* pointer to parent node *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
parent_pb_graph_node	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node *parent_pb_graph_node;$/;"	m	struct:t_pb_graph_node	access:public
parent_pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *parent_pb_type;$/;"	m	struct:t_mode	access:public
parent_pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *parent_pb_type;$/;"	m	struct:t_port	access:public
parent_pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int *parent_pin_class = nullptr; \/* [0..depth-1] the grouping of pins that this particular pin belongs to *\/$/;"	m	struct:t_pb_graph_pin	access:public
parent_switch	route/route_tree_type.h	/^	short parent_switch;$/;"	m	struct:t_rt_node	access:public
parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			static binary_op_t parse(xpath_lexer& lexer)$/;"	f	struct:xpath_parser::binary_op_t	access:public	signature:(xpath_lexer& lexer)
parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse(char_t* s)$/;"	f	struct:strconv_pcdata_impl	access:public	signature:(char_t* s)
parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xml_parse_result parse(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)$/;"	f	struct:xml_parser	access:public	signature:(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)
parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_ast_node* parse(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)$/;"	f	struct:xpath_parser	access:public	signature:(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)
parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse()$/;"	f	struct:xpath_parser	access:public	signature:()
parse_axis_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_t parse_axis_name(const xpath_lexer_string& name, bool& specified)$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& name, bool& specified)
parse_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_cdata = 0x0004;$/;"	m	namespace:pugi
parse_comma_separated_wire_points	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_comma_separated_wire_points(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints);$/;"	p	file:	signature:(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints)
parse_comma_separated_wire_points	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_comma_separated_wire_points(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints){$/;"	f	file:	signature:(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints)
parse_comma_separated_wire_types	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_comma_separated_wire_types(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints) {$/;"	f	file:	signature:(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints)
parse_comma_separated_wire_types	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_comma_separated_wire_types(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints);$/;"	p	file:	signature:(const char *ch, std::vector<t_wire_switchpoints>& wire_switchpoints)
parse_comments	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_comments = 0x0002;$/;"	m	namespace:pugi
parse_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_declaration = 0x0100;$/;"	m	namespace:pugi
parse_default	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_default = parse_cdata | parse_escapes | parse_wconv_attribute | parse_eol;$/;"	m	namespace:pugi
parse_direct_pin_name	util/vpr_utils.cpp	/^void parse_direct_pin_name(char * src_string, int line, int * start_pin_index,$/;"	f	signature:(char * src_string, int line, int * start_pin_index, int * end_pin_index, char * pb_type_name, char * port_name)
parse_direct_pin_name	util/vpr_utils.h	/^void parse_direct_pin_name(char * src_string, int line, int * start_pin_index,$/;"	p	signature:(char * src_string, int line, int * start_pin_index, int * end_pin_index, char * pb_type_name, char * port_name)
parse_doctype	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_doctype = 0x0200;$/;"	m	namespace:pugi
parse_doctype_group	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_doctype_group(char_t* s, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, char_t endch)
parse_doctype_ignore	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_doctype_ignore(char_t* s)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s)
parse_doctype_primitive	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_doctype_primitive(char_t* s)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s)
parse_eol	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_eol(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
parse_eol	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_eol = 0x0020;$/;"	m	namespace:pugi
parse_escapes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_escapes = 0x0010;$/;"	m	namespace:pugi
parse_exclamation	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)
parse_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
parse_expression_rec	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_expression_rec(xpath_ast_node* lhs, int limit)$/;"	f	struct:xpath_parser	access:public	signature:(xpath_ast_node* lhs, int limit)
parse_filter_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_filter_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
parse_formula	../../libs/libarchfpga/src/expr_eval.cpp	/^int parse_formula(std::string formula, const t_formula_data& mydata ){$/;"	f	signature:(std::string formula, const t_formula_data& mydata )
parse_formula	../../libs/libarchfpga/src/expr_eval.h	/^int parse_formula(std::string formula, const t_formula_data &mydata);$/;"	p	signature:(std::string formula, const t_formula_data &mydata)
parse_fragment	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_fragment = 0x1000;$/;"	m	namespace:pugi
parse_full	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_full = parse_default | parse_pi | parse_comments | parse_declaration | parse_doctype;$/;"	m	namespace:pugi
parse_function	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_function(const xpath_lexer_string& name, size_t argc, xpath_ast_node* args[2])$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& name, size_t argc, xpath_ast_node* args[2])
parse_function_helper	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_function_helper(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])$/;"	f	struct:xpath_parser	access:public	signature:(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])
parse_location_path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_location_path()$/;"	f	struct:xpath_parser	access:public	signature:()
parse_minimal	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_minimal = 0x0000;$/;"	m	namespace:pugi
parse_name_index	../../libs/libarchfpga/src/arch_util.cpp	/^InstPort::name_index InstPort::parse_name_index(std::string str) {$/;"	f	class:InstPort	signature:(std::string str)
parse_name_index	../../libs/libarchfpga/src/arch_util.h	/^        name_index parse_name_index(std::string str);$/;"	p	class:InstPort	access:private	signature:(std::string str)
parse_node_test_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_t parse_node_test_type(const xpath_lexer_string& name)$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& name)
parse_num_conns	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_num_conns(std::string num_conns, t_wireconn_inf& wireconn) {$/;"	f	file:	signature:(std::string num_conns, t_wireconn_inf& wireconn)
parse_num_conns	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_num_conns(std::string num_conns, t_wireconn_inf& wireconn);$/;"	p	file:	signature:(std::string num_conns, t_wireconn_inf& wireconn)
parse_path_or_unary_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_path_or_unary_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
parse_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_pi = 0x0001;$/;"	m	namespace:pugi
parse_piecewise_formula	../../libs/libarchfpga/src/expr_eval.cpp	/^int parse_piecewise_formula( const char *formula, const t_formula_data &mydata ){$/;"	f	signature:( const char *formula, const t_formula_data &mydata )
parse_piecewise_formula	../../libs/libarchfpga/src/expr_eval.h	/^int parse_piecewise_formula(const char *formula, const t_formula_data &mydata);$/;"	p	signature:(const char *formula, const t_formula_data &mydata)
parse_primary_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_primary_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
parse_question	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_question(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)
parse_relative_location_path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_relative_location_path(xpath_ast_node* set)$/;"	f	struct:xpath_parser	access:public	signature:(xpath_ast_node* set)
parse_rpn_vector	../../libs/libarchfpga/src/expr_eval.cpp	/^static int parse_rpn_vector( vector<Formula_Object> &rpn_vec );$/;"	p	file:	signature:( vector<Formula_Object> &rpn_vec )
parse_rpn_vector	../../libs/libarchfpga/src/expr_eval.cpp	/^static int parse_rpn_vector( vector<Formula_Object> &rpn_vec ){$/;"	f	file:	signature:( vector<Formula_Object> &rpn_vec )
parse_simple	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_simple(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
parse_skip_bom	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_skip_bom(char_t* s)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s)
parse_step	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_step(xpath_ast_node* set)$/;"	f	struct:xpath_parser	access:public	signature:(xpath_ast_node* set)
parse_switchpoint_order	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_switchpoint_order(const char* order, SwitchPointOrder& switchpoint_order) {$/;"	f	file:	signature:(const char* order, SwitchPointOrder& switchpoint_order)
parse_switchpoint_order	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^static void parse_switchpoint_order(const char* order, SwitchPointOrder& switchpoint_order);$/;"	p	file:	signature:(const char* order, SwitchPointOrder& switchpoint_order)
parse_target_external_pin_util	pack/pack.cpp	/^static t_ext_pin_util_targets parse_target_external_pin_util(std::vector<std::string> specs) {$/;"	f	file:	signature:(std::vector<std::string> specs)
parse_target_external_pin_util	pack/pack.cpp	/^static t_ext_pin_util_targets parse_target_external_pin_util(std::vector<std::string> specs);$/;"	p	file:	signature:(std::vector<std::string> specs)
parse_tree	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_tree(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)
parse_trim_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_trim_pcdata = 0x0800;$/;"	m	namespace:pugi
parse_wconv	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_wconv(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
parse_wconv_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_wconv_attribute = 0x0040;$/;"	m	namespace:pugi
parse_wireconn	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^t_wireconn_inf parse_wireconn(pugi::xml_node node, const pugiutil::loc_data& loc_data) {$/;"	f	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data)
parse_wireconn_from_to_node	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^t_wire_switchpoints parse_wireconn_from_to_node(pugi::xml_node node, const pugiutil::loc_data& loc_data) {$/;"	f	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data)
parse_wireconn_from_to_node	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^t_wire_switchpoints parse_wireconn_from_to_node(pugi::xml_node node, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data)
parse_wireconn_inline	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void parse_wireconn_inline(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc) {$/;"	f	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc)
parse_wireconn_inline	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void parse_wireconn_inline(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc);$/;"	p	file:	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc)
parse_wireconn_multinode	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void parse_wireconn_multinode(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc) {$/;"	f	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc)
parse_wireconn_multinode	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void parse_wireconn_multinode(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc);$/;"	p	file:	signature:(pugi::xml_node node, const pugiutil::loc_data& loc_data, t_wireconn_inf& wc)
parse_wnorm	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_wnorm(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
parse_wnorm_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_wnorm_attribute = 0x0080;$/;"	m	namespace:pugi
parse_ws_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_ws_pcdata = 0x0008;$/;"	m	namespace:pugi
parse_ws_pcdata_single	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_ws_pcdata_single = 0x0400;$/;"	m	namespace:pugi
partition	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I, typename Pred> void partition(I begin, I middle, I end, const Pred& pred, I* out_eqbeg, I* out_eqend)$/;"	f	signature:(I begin, I middle, I end, const Pred& pred, I* out_eqbeg, I* out_eqend)
partition_edges	route/rr_node.cpp	/^void t_rr_node::partition_edges() {$/;"	f	class:t_rr_node	signature:()
partition_edges	route/rr_node.h	/^        void partition_edges();$/;"	p	class:t_rr_node	access:public	signature:()
partition_rr_graph_edges	route/rr_graph2.cpp	/^void partition_rr_graph_edges(DeviceContext& device_ctx) {$/;"	f	signature:(DeviceContext& device_ctx)
partition_rr_graph_edges	route/rr_graph2.h	/^void partition_rr_graph_edges(DeviceContext& device_ctx);$/;"	p	signature:(DeviceContext& device_ctx)
path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN string_t xml_node::path(char_t delimiter) const$/;"	f	class:pugi::xml_node	signature:(char_t delimiter) const
path	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		string_t path(char_t delimiter = '\/') const;$/;"	p	class:pugi::xml_node	access:public	signature:(char_t delimiter = Ã) const
path_cost	base/vpr_types.h	/^	float path_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
pathfinder_update_cost	route/route_common.cpp	/^void pathfinder_update_cost(float pres_fac, float acc_fac) {$/;"	f	signature:(float pres_fac, float acc_fac)
pathfinder_update_cost	route/route_common.h	/^void pathfinder_update_cost(float pres_fac, float acc_fac);$/;"	p	signature:(float pres_fac, float acc_fac)
pathfinder_update_cost_from_route_tree	route/route_tree_timing.cpp	/^void pathfinder_update_cost_from_route_tree(const t_rt_node* rt_root, int add_or_sub, float pres_fac) {$/;"	f	signature:(const t_rt_node* rt_root, int add_or_sub, float pres_fac)
pathfinder_update_cost_from_route_tree	route/route_tree_timing.h	/^void pathfinder_update_cost_from_route_tree(const t_rt_node* rt_root, int add_or_sub, float pres_fac);$/;"	p	signature:(const t_rt_node* rt_root, int add_or_sub, float pres_fac)
pathfinder_update_path_cost	route/route_common.cpp	/^void pathfinder_update_path_cost(t_trace *route_segment_start,$/;"	f	signature:(t_trace *route_segment_start, int add_or_sub, float pres_fac)
pathfinder_update_path_cost	route/route_common.h	/^void pathfinder_update_path_cost(t_trace *route_segment_start,$/;"	p	signature:(t_trace *route_segment_start, int add_or_sub, float pres_fac)
pathfinder_update_single_node_cost	route/route_common.cpp	/^void pathfinder_update_single_node_cost(int inode, int add_or_sub, float pres_fac) {$/;"	f	signature:(int inode, int add_or_sub, float pres_fac)
pathfinder_update_single_node_cost	route/route_common.h	/^void pathfinder_update_single_node_cost(int inode, int add_or_sub, float pres_fac);$/;"	p	signature:(int inode, int add_or_sub, float pres_fac)
pattern_index	../../libs/libarchfpga/src/cad_types.h	/^	int pattern_index; \/* index of pattern that this block is a part of *\/$/;"	m	struct:t_pack_pattern_block	access:public
pb_atom	base/atom_lookup.cpp	/^AtomBlockId AtomLookup::pb_atom(const t_pb* pb) const {$/;"	f	class:AtomLookup	signature:(const t_pb* pb) const
pb_atom	base/atom_lookup.h	/^        AtomBlockId pb_atom(const t_pb* pb) const;$/;"	p	class:AtomLookup	access:public	signature:(const t_pb* pb) const
pb_foreach_pin	power/power_util.h	/^void pb_foreach_pin(t_pb_graph_node * pb_node,$/;"	p	signature:(t_pb_graph_node * pb_node, void (*fn)(t_pb_graph_pin *, void *), void * context)
pb_gnode	draw/intra_logic_block.h	/^		const t_pb_graph_node* pb_gnode = nullptr;$/;"	m	struct:t_selected_sub_block_info::gnode_clb_pair	access:public
pb_gnode	draw/intra_logic_block.h	/^		const t_pb_graph_node* pb_gnode;$/;"	m	struct:t_selected_sub_block_info::clb_pin_tuple	access:public
pb_gpin	util/vpr_utils.cpp	/^const t_pb_graph_pin* IntraLbPbPinLookup::pb_gpin(int itype, int ipin) const {$/;"	f	class:IntraLbPbPinLookup	signature:(int itype, int ipin) const
pb_gpin	util/vpr_utils.h	/^        const t_pb_graph_pin* pb_gpin(int itype, int ipin) const;$/;"	p	class:IntraLbPbPinLookup	access:public	signature:(int itype, int ipin) const
pb_graph_head	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node *pb_graph_head = nullptr;$/;"	m	struct:t_type_descriptor	access:public
pb_graph_node	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_node *pb_graph_node;$/;"	m	struct:t_cluster_placement_primitive	access:public
pb_graph_node	base/vpr_types.h	/^	t_pb_graph_node *pb_graph_node = nullptr; \/* pointer to pb_graph_node this pb corresponds to *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
pb_graph_pin	base/vpr_types.h	/^	t_pb_graph_pin *pb_graph_pin; \/* pb_graph_pin that this block is connected to *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
pb_graph_pin	base/vpr_types.h	/^    const t_pb_graph_pin* pb_graph_pin = nullptr; \/* The graph pin associated with this node *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
pb_graph_pin	pack/pack_types.h	/^	t_pb_graph_pin *pb_graph_pin;	\/* pb_graph_pin associated with this lb_rr_node if exists, NULL otherwise *\/$/;"	m	struct:t_lb_type_rr_node	access:public
pb_graph_pin_lookup_from_index_by_type	pack/output_clustering.cpp	/^static t_pb_graph_pin ***pb_graph_pin_lookup_from_index_by_type = nullptr; \/* [0..device_ctx.num_block_types-1][0..num_pb_graph_pins-1] lookup pointer to pb_graph_pin from pb_graph_pin index *\/$/;"	v	file:
pb_max_internal_delay	base/vpr_context.h	/^    float pb_max_internal_delay = UNDEFINED; \/* biggest internal delay of block *\/$/;"	m	struct:DeviceContext	access:public
pb_node_power	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node_power * pb_node_power;$/;"	m	struct:t_pb_graph_node	access:public
pb_route	base/vpr_types.h	/^    t_pb_routes pb_route;$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
pb_route_delay	timing/clb_delay_calc.h	/^        float pb_route_delay(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const
pb_route_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::pb_route_delay(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(ClusterBlockId clb, int pb_route_idx, DelayType delay_type) const
pb_stats	base/vpr_types.h	/^	t_pb_stats *pb_stats = nullptr; \/* statistics for current pb *\/$/;"	m	struct:ScreenUpdatePriority::t_pb	access:public
pb_type	../../libs/libarchfpga/src/cad_types.h	/^	const t_pb_type *pb_type; \/* pb_type that this block is an instance of *\/$/;"	m	struct:t_pack_pattern_block	access:public
pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *pb_type = nullptr;$/;"	m	struct:t_type_descriptor	access:public
pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *pb_type;$/;"	m	struct:t_pb_graph_node	access:public
pb_type_children	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *pb_type_children; \/* [0..num_child_pb_types] *\/$/;"	m	struct:t_mode	access:public
pb_type_contains_blif_model	util/vpr_utils.cpp	/^bool pb_type_contains_blif_model(const t_pb_type* pb_type, const std::string& blif_model_name) {$/;"	f	signature:(const t_pb_type* pb_type, const std::string& blif_model_name)
pb_type_contains_blif_model	util/vpr_utils.cpp	/^static bool pb_type_contains_blif_model(const t_pb_type* pb_type, const std::regex& blif_model_regex) {$/;"	f	file:	signature:(const t_pb_type* pb_type, const std::regex& blif_model_regex)
pb_type_contains_blif_model	util/vpr_utils.cpp	/^static bool pb_type_contains_blif_model(const t_pb_type* pb_type, const std::regex& blif_model_regex);$/;"	p	file:	signature:(const t_pb_type* pb_type, const std::regex& blif_model_regex)
pb_type_contains_blif_model	util/vpr_utils.h	/^bool pb_type_contains_blif_model(const t_pb_type* pb_type, const std::string& blif_model_name);$/;"	p	signature:(const t_pb_type* pb_type, const std::string& blif_model_name)
pb_type_power	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type_power * pb_type_power = nullptr;$/;"	m	struct:t_pb_type	access:public
pb_types	../../libs/libarchfpga/src/logic_types.h	/^    vtr::t_linked_vptr *pb_types = nullptr; \/* Physical block types that implement this model *\/$/;"	m	struct:t_model	access:public
pbtype_max_internal_delay	base/vpr_context.h	/^    const t_pb_type *pbtype_max_internal_delay; \/* block type with highest internal delay *\/$/;"	m	struct:DeviceContext	access:public
peak	../../libs/libarchfpga/src/physical_types.h	/^	float peak;$/;"	m	struct:t_chan	access:public
perform_forced_reroute	route/route_profiling.cpp	/^void perform_forced_reroute() {}$/;"	f	namespace:profiling	signature:()
perform_forced_reroute	route/route_profiling.h	/^void perform_forced_reroute();$/;"	p	namespace:profiling	signature:()
perform_sta	route/route_budgets.cpp	/^std::shared_ptr<SetupHoldTimingInfo> route_budgets::perform_sta(vtr::vector<ClusterNetId, float *> &temp_budgets) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
perform_sta	route/route_budgets.h	/^    std::shared_ptr<SetupHoldTimingInfo> perform_sta(vtr::vector<ClusterNetId, float *> &temp_budgets);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
period	../../libs/libarchfpga/src/physical_types.h	/^	float period; \/* Period of clock *\/$/;"	m	struct:t_clock_network	access:public
period	timing/read_sdc.cpp	/^	float period;$/;"	m	struct:t_sdc_clock	file:	access:public
permutation_map	../../libs/libarchfpga/src/physical_types.h	/^	t_permutation_map permutation_map;	\/* map holding the permutation functions attributed to this switchblock *\/$/;"	m	struct:t_switchblock_inf	access:public
permute_truth_table	base/atom_netlist_utils.cpp	/^AtomNetlist::TruthTable permute_truth_table(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs, const std::vector<int>& permutation) {$/;"	f	signature:(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs, const std::vector<int>& permutation)
permute_truth_table	base/atom_netlist_utils.h	/^AtomNetlist::TruthTable permute_truth_table(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs, const std::vector<int>& permutation);$/;"	p	signature:(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs, const std::vector<int>& permutation)
pfreq	base/vpr_types.h	/^enum pfreq {$/;"	g	class:ScreenUpdatePriority	access:private
pic_on_screen	draw/draw_types.h	/^	pic_type pic_on_screen = NO_PICTURE;$/;"	m	struct:t_draw_state	access:public
pic_type	base/vpr_types.h	/^enum pic_type {$/;"	g	class:ScreenUpdatePriority	access:private
pick_best_direct_connect_target_rr_node	route/rr_graph.cpp	/^static int pick_best_direct_connect_target_rr_node($/;"	f	file:	signature:( const std::vector<t_rr_node>& rr_nodes, int from_rr, const std::vector<int>& candidate_rr_nodes)
pick_best_direct_connect_target_rr_node	route/rr_graph.cpp	/^static int pick_best_direct_connect_target_rr_node($/;"	p	file:	signature:( const std::vector<t_rr_node>& rr_nodes, int from_rr, const std::vector<int>& candidate_rr_nodes)
pick_from_block	place/place.cpp	/^static ClusterBlockId pick_from_block() {$/;"	f	file:	signature:()
pick_from_block	place/place.cpp	/^static ClusterBlockId pick_from_block();$/;"	p	file:	signature:()
picosha2	../../libs/libvtrutil/src/picosha2.h	/^namespace picosha2$/;"	n
picosha2::byte_t	../../libs/libvtrutil/src/picosha2.h	/^typedef unsigned char byte_t;$/;"	t	namespace:picosha2
picosha2::bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string bytes_to_hex_string(InIter first, InIter last){$/;"	f	namespace:picosha2	signature:(InIter first, InIter last)
picosha2::bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string bytes_to_hex_string(const InContainer& bytes){$/;"	f	namespace:picosha2	signature:(const InContainer& bytes)
picosha2::bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void bytes_to_hex_string(InIter first, InIter last, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(InIter first, InIter last, std::string& hex_str)
picosha2::bytes_to_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void bytes_to_hex_string(const InContainer& bytes, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const InContainer& bytes, std::string& hex_str)
picosha2::detail	../../libs/libvtrutil/src/picosha2.h	/^namespace detail$/;"	n	namespace:picosha2
picosha2::detail::add_constant	../../libs/libvtrutil/src/picosha2.h	/^const word_t add_constant[64] = {$/;"	m	namespace:picosha2::detail
picosha2::detail::bsig0	../../libs/libvtrutil/src/picosha2.h	/^inline word_t bsig0(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
picosha2::detail::bsig1	../../libs/libvtrutil/src/picosha2.h	/^inline word_t bsig1(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
picosha2::detail::ch	../../libs/libvtrutil/src/picosha2.h	/^inline word_t ch(word_t x, word_t y, word_t z){$/;"	f	namespace:picosha2::detail	signature:(word_t x, word_t y, word_t z)
picosha2::detail::hash256_block	../../libs/libvtrutil/src/picosha2.h	/^void hash256_block(RaIter1 message_digest, RaIter2 first, RaIter2 \/*last*\/){$/;"	f	namespace:picosha2::detail	signature:(RaIter1 message_digest, RaIter2 first, RaIter2 )
picosha2::detail::initial_message_digest	../../libs/libvtrutil/src/picosha2.h	/^const word_t initial_message_digest[8] = {$/;"	m	namespace:picosha2::detail
picosha2::detail::maj	../../libs/libvtrutil/src/picosha2.h	/^inline word_t maj(word_t x, word_t y, word_t z){$/;"	f	namespace:picosha2::detail	signature:(word_t x, word_t y, word_t z)
picosha2::detail::mask_32bit	../../libs/libvtrutil/src/picosha2.h	/^inline word_t mask_32bit(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
picosha2::detail::mask_8bit	../../libs/libvtrutil/src/picosha2.h	/^inline byte_t mask_8bit(byte_t x){$/;"	f	namespace:picosha2::detail	signature:(byte_t x)
picosha2::detail::rotr	../../libs/libvtrutil/src/picosha2.h	/^inline word_t rotr(word_t x, std::size_t n){$/;"	f	namespace:picosha2::detail	signature:(word_t x, std::size_t n)
picosha2::detail::shr	../../libs/libvtrutil/src/picosha2.h	/^inline word_t shr(word_t x, std::size_t n){$/;"	f	namespace:picosha2::detail	signature:(word_t x, std::size_t n)
picosha2::detail::ssig0	../../libs/libvtrutil/src/picosha2.h	/^inline word_t ssig0(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
picosha2::detail::ssig1	../../libs/libvtrutil/src/picosha2.h	/^inline word_t ssig1(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
picosha2::get_hash_hex_string	../../libs/libvtrutil/src/picosha2.h	/^inline std::string get_hash_hex_string(const hash256_one_by_one& hasher){$/;"	f	namespace:picosha2	signature:(const hash256_one_by_one& hasher)
picosha2::get_hash_hex_string	../../libs/libvtrutil/src/picosha2.h	/^inline void get_hash_hex_string(const hash256_one_by_one& hasher, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const hash256_one_by_one& hasher, std::string& hex_str)
picosha2::hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(RaIter first, RaIter last, OutContainer& dst){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last, OutContainer& dst)
picosha2::hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(RaIter first, RaIter last, OutIter first2, OutIter last2){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last, OutIter first2, OutIter last2)
picosha2::hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(const RaContainer& src, OutContainer& dst){$/;"	f	namespace:picosha2	signature:(const RaContainer& src, OutContainer& dst)
picosha2::hash256	../../libs/libvtrutil/src/picosha2.h	/^void hash256(const RaContainer& src, OutIter first, OutIter last){$/;"	f	namespace:picosha2	signature:(const RaContainer& src, OutIter first, OutIter last)
picosha2::hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^inline void hash256_hex_string(const std::string& src, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const std::string& src, std::string& hex_str)
picosha2::hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string hash256_hex_string(RaIter first, RaIter last){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last)
picosha2::hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^std::string hash256_hex_string(const RaContainer& src){$/;"	f	namespace:picosha2	signature:(const RaContainer& src)
picosha2::hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void hash256_hex_string(RaIter first, RaIter last, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(RaIter first, RaIter last, std::string& hex_str)
picosha2::hash256_hex_string	../../libs/libvtrutil/src/picosha2.h	/^void hash256_hex_string(const RaContainer& src, std::string& hex_str){$/;"	f	namespace:picosha2	signature:(const RaContainer& src, std::string& hex_str)
picosha2::hash256_one_by_one	../../libs/libvtrutil/src/picosha2.h	/^class hash256_one_by_one {$/;"	c	namespace:picosha2
picosha2::hash256_one_by_one::add_to_data_length	../../libs/libvtrutil/src/picosha2.h	/^	void add_to_data_length(word_t n) {$/;"	f	class:picosha2::hash256_one_by_one	access:private	signature:(word_t n)
picosha2::hash256_one_by_one::buffer_	../../libs/libvtrutil/src/picosha2.h	/^	std::vector<byte_t> buffer_;$/;"	m	class:picosha2::hash256_one_by_one	access:private
picosha2::hash256_one_by_one::data_length_digits_	../../libs/libvtrutil/src/picosha2.h	/^	word_t data_length_digits_[4]; \/\/as 64bit integer (16bit x 4 integer)$/;"	m	class:picosha2::hash256_one_by_one	access:private
picosha2::hash256_one_by_one::finish	../../libs/libvtrutil/src/picosha2.h	/^	void finish(){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:()
picosha2::hash256_one_by_one::get_hash_bytes	../../libs/libvtrutil/src/picosha2.h	/^	void get_hash_bytes(OutIter first, OutIter last)const{$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:(OutIter first, OutIter last) const
picosha2::hash256_one_by_one::h_	../../libs/libvtrutil/src/picosha2.h	/^	word_t h_[8];$/;"	m	class:picosha2::hash256_one_by_one	access:private
picosha2::hash256_one_by_one::hash256_one_by_one	../../libs/libvtrutil/src/picosha2.h	/^	hash256_one_by_one(){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:()
picosha2::hash256_one_by_one::init	../../libs/libvtrutil/src/picosha2.h	/^	void init(){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:()
picosha2::hash256_one_by_one::process	../../libs/libvtrutil/src/picosha2.h	/^	void process(RaIter first, RaIter last){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:(RaIter first, RaIter last)
picosha2::hash256_one_by_one::write_data_bit_length	../../libs/libvtrutil/src/picosha2.h	/^	void write_data_bit_length(byte_t* begin) {$/;"	f	class:picosha2::hash256_one_by_one	access:private	signature:(byte_t* begin)
picosha2::output_hex	../../libs/libvtrutil/src/picosha2.h	/^void output_hex(InIter first, InIter last, std::ostream& os){$/;"	f	namespace:picosha2	signature:(InIter first, InIter last, std::ostream& os)
picosha2::word_t	../../libs/libvtrutil/src/picosha2.h	/^typedef unsigned long word_t;$/;"	t	namespace:picosha2
pin_block	base/netlist.h	/^        BlockId     pin_block(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::pin_block(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_cache_max_	timing/PostClusterDelayCalculator.h	/^	mutable vtr::vector<tatum::EdgeId,std::pair<ClusterPinId,ClusterPinId>> pin_cache_max_;$/;"	m	class:PostClusterDelayCalculator	access:private
pin_cache_min_	timing/PostClusterDelayCalculator.h	/^	mutable vtr::vector<tatum::EdgeId,std::pair<ClusterPinId,ClusterPinId>> pin_cache_min_;$/;"	m	class:PostClusterDelayCalculator	access:private
pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int *pin_class = nullptr; \/* [0..num_pins-1] *\/$/;"	m	struct:t_type_descriptor	access:public
pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int pin_class = 0;$/;"	m	struct:t_pb_graph_pin	access:public
pin_count_in_cluster	../../libs/libarchfpga/src/physical_types.h	/^	int pin_count_in_cluster = 0;$/;"	m	struct:t_pb_graph_pin	access:public
pin_criticalities_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_criticalities_;$/;"	m	class:HoldSlackCrit	access:private
pin_criticalities_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_criticalities_;$/;"	m	class:SetupSlackCrit	access:private
pin_criticality	route/route_timing.h	/^    float* pin_criticality; \/* [1..max_pins_per_net-1] *\/$/;"	m	struct:timing_driven_route_structs	access:public
pin_dens	power/power_util.cpp	/^float pin_dens(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk) {$/;"	f	signature:(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
pin_dens	power/power_util.h	/^float pin_dens(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk);$/;"	p	signature:(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
pin_diversity	route/cb_metrics.h	/^	float pin_diversity;$/;"	m	class:Conn_Block_Metrics	access:public
pin_height_offset	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> pin_height_offset; \/\/[0..num_pins-1]$/;"	m	struct:t_type_descriptor	access:public
pin_id_map_	base/netlist.h	/^        vtr::vector_map<PinId, PinId> pin_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
pin_id_to_tnode_lookup_	base/netlist_writer.cpp	/^        std::map<std::pair<ClusterBlockId,int>,tatum::NodeId> pin_id_to_tnode_lookup_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
pin_ids_	base/netlist.h	/^        vtr::vector_map<PinId, PinId>       pin_ids_;           \/\/Valid pin ids$/;"	m	class:Netlist	access:private
pin_index	route/rr_graph.cpp	/^    int pin_index;$/;"	m	struct:t_pin_loc	file:	access:public
pin_index_by_num	route/rr_graph_reader.cpp	/^static int pin_index_by_num(const t_class &class_inf, int num) {$/;"	f	file:	signature:(const t_class &class_inf, int num)
pin_is_constant	base/netlist.h	/^        bool        pin_is_constant(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_is_constant	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::pin_is_constant(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_is_constant_	base/netlist.h	/^        vtr::vector_map<PinId, bool>        pin_is_constant_;   \/\/Indicates if the pin always keeps a constant value$/;"	m	class:Netlist	access:private
pin_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<PinId, PinId>::const_iterator                  pin_iterator;$/;"	t	class:Netlist	access:public
pin_loc_assignments	../../libs/libarchfpga/src/physical_types.h	/^	char *****pin_loc_assignments = nullptr; \/* [0..width-1][0..height-1][0..3][0..num_tokens-1][0..string_name] *\/$/;"	m	struct:t_type_descriptor	access:public
pin_location_distribution	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_location_distr pin_location_distribution = E_SPREAD_PIN_DISTR;$/;"	m	struct:t_type_descriptor	typeref:enum:t_type_descriptor::e_pin_location_distr	access:public
pin_locations	route/cb_metrics.h	/^	t_2d_int_vec pin_locations;		\/* [0..3][0..num_on_this_side-1]. Keeps track of which pins come out on which side of the block *\/$/;"	m	class:Conn_Block_Metrics	access:public
pin_name	base/netlist.h	/^        std::string pin_name(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_name	base/netlist.tpp	/^std::string Netlist<BlockId, PortId, PinId, NetId>::pin_name(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_net	base/netlist.h	/^        NetId       pin_net(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::pin_net(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_net_index	base/netlist.h	/^        int         pin_net_index(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_net_index	base/netlist.tpp	/^int Netlist<BlockId, PortId, PinId, NetId>::pin_net_index(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_net_indices_	base/netlist.h	/^        vtr::vector_map<PinId, int>         pin_net_indices_;   \/\/Index of the specified pin within it's associated net$/;"	m	class:Netlist	access:private
pin_nets_	base/netlist.h	/^        vtr::vector_map<PinId, NetId>       pin_nets_;          \/\/Net associated with each pin$/;"	m	class:Netlist	access:private
pin_num	route/rr_node.cpp	/^short t_rr_node::pin_num() const {$/;"	f	class:t_rr_node	signature:() const
pin_num	route/rr_node.h	/^            int16_t pin_num;$/;"	m	union:t_rr_node::__anon9	access:public
pin_num	route/rr_node.h	/^        short pin_num() const; \/\/Same as ptc_num() but checks that type() is consistent$/;"	p	class:t_rr_node	access:public	signature:() const
pin_number	../../libs/libarchfpga/src/physical_types.h	/^	int pin_number = 0;$/;"	m	struct:t_pb_graph_pin	access:public
pin_physical_index	base/clustered_netlist.cpp	/^int ClusteredNetlist::pin_physical_index(const ClusterPinId id) const {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPinId id) const
pin_physical_index	base/clustered_netlist.h	/^        int pin_physical_index(const ClusterPinId id) const;$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterPinId id) const
pin_physical_index_	base/clustered_netlist.h	/^        vtr::vector_map<ClusterPinId, int> pin_physical_index_; \/\/The physical pin index (i.e. pin index$/;"	m	class:ClusteredNetlist	access:private
pin_port	base/netlist.h	/^        PortId      pin_port(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_port	base/netlist.tpp	/^PortId Netlist<BlockId, PortId, PinId, NetId>::pin_port(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_port_bit	base/netlist.h	/^        BitIndex    pin_port_bit(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_port_bit	base/netlist.tpp	/^BitIndex Netlist<BlockId, PortId, PinId, NetId>::pin_port_bit(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_port_bits_	base/netlist.h	/^        vtr::vector_map<PinId, BitIndex>    pin_port_bits_;     \/\/The pins bit position in the port$/;"	m	class:Netlist	access:private
pin_port_type	base/netlist.h	/^        PortType    pin_port_type(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_port_type	base/netlist.tpp	/^PortType Netlist<BlockId, PortId, PinId, NetId>::pin_port_type(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_ports_	base/netlist.h	/^        vtr::vector_map<PinId, PortId>      pin_ports_;         \/\/Type of each pin$/;"	m	class:Netlist	access:private
pin_power	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin_power* pin_power = nullptr;$/;"	m	struct:t_pb_graph_pin	access:public
pin_prob	power/power_util.cpp	/^float pin_prob(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk) {$/;"	f	signature:(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
pin_prob	power/power_util.h	/^float pin_prob(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk);$/;"	p	signature:(t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
pin_range	base/netlist.h	/^        typedef typename vtr::Range<pin_iterator>   pin_range;$/;"	t	class:Netlist	access:public
pin_rotations_	base/vpr_types.h	/^    std::map<const t_pb_graph_pin*,BitIndex> pin_rotations_; \/\/Contains the atom netlist port bit index associated$/;"	m	struct:ScreenUpdatePriority::t_pb	access:private
pin_size	draw/draw_types.h	/^	float pin_size;$/;"	m	struct:t_draw_coords	access:public
pin_slacks_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_slacks_;$/;"	m	class:HoldSlackCrit	access:private
pin_slacks_	timing/slack_evaluation.h	/^        vtr::vector<AtomPinId, float> pin_slacks_;$/;"	m	class:SetupSlackCrit	access:private
pin_timing	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin** pin_timing = nullptr; \/* timing edge sink pins  [0..num_pin_timing-1]*\/$/;"	m	struct:t_pb_graph_pin	access:public
pin_timing_del_max	../../libs/libarchfpga/src/physical_types.h	/^	float *pin_timing_del_max = nullptr; \/* primitive ipin to opin max-delay [0..num_pin_timing-1]*\/$/;"	m	struct:t_pb_graph_pin	access:public
pin_timing_del_min	../../libs/libarchfpga/src/physical_types.h	/^	float *pin_timing_del_min = nullptr; \/* primitive ipin to opin min-delay [0..num_pin_timing-1]*\/$/;"	m	struct:t_pb_graph_pin	access:public
pin_to_tracks	route/cb_metrics.h	/^	t_vec_vec_set pin_to_tracks;		\/* [0..3][0..num_pins_on_side-1][0..tracks_connected-1]. A lookup for which tracks connect to a given pin *\/$/;"	m	class:Conn_Block_Metrics	access:public
pin_toggle_initialized	../../libs/libarchfpga/src/physical_types.h	/^	bool pin_toggle_initialized;$/;"	m	struct:t_port_power	access:public
pin_type	base/netlist.h	/^        PinType     pin_type(const PinId pin_id) const;$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id) const
pin_type	base/netlist.tpp	/^PinType Netlist<BlockId, PortId, PinId, NetId>::pin_type(const PinId pin_id) const {$/;"	f	class:Netlist	signature:(const PinId pin_id) const
pin_width_offset	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> pin_width_offset; \/\/[0..num_pins-1]$/;"	m	struct:t_type_descriptor	access:public
pinlist	../../libs/libarchfpga/src/physical_types.h	/^	int *pinlist; \/* [0..num_pins - 1] *\/$/;"	m	struct:t_class	access:public
pinloc	../../libs/libarchfpga/src/physical_types.h	/^	bool ****pinloc = nullptr; \/* [0..width-1][0..height-1][0..3][0..num_pins-1] *\/$/;"	m	struct:t_type_descriptor	access:public
pins	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> pins;          \/\/The block pins collectively effected by this Fc$/;"	m	struct:t_fc_specification	access:public
pins	base/netlist.h	/^        pin_range   pins() const;$/;"	p	class:Netlist	access:public	signature:() const
pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::pins() const {$/;"	f	class:Netlist	signature:() const
pl_macros	place/place.cpp	/^static t_pl_macro * pl_macros = nullptr;$/;"	v	file:
place_algorithm	base/vpr_types.h	/^	enum e_place_algorithm place_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	typeref:enum:ScreenUpdatePriority::t_placer_opts::e_place_algorithm	access:public
place_and_route	base/place_and_route.h	/^bool place_and_route($/;"	p	signature:( t_placer_opts placer_opts, t_file_name_opts filename_opts, const t_arch* arch, t_annealing_sched annealing_sched, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_timing_inf timing_inf)
place_chan_width	base/vpr_types.h	/^	int place_chan_width;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
place_cost_exp	base/vpr_types.h	/^	float place_cost_exp;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
place_delay_model	base/read_options.h	/^    argparse::ArgValue<PlaceDelayModelType> place_delay_model;$/;"	m	struct:t_options	access:public
place_delay_model_reducer	base/read_options.h	/^    argparse::ArgValue<e_reducer> place_delay_model_reducer;$/;"	m	struct:t_options	access:public
place_delay_offset	base/read_options.h	/^    argparse::ArgValue<float> place_delay_offset;$/;"	m	struct:t_options	access:public
place_delay_ramp_delta_threshold	base/read_options.h	/^    argparse::ArgValue<int> place_delay_ramp_delta_threshold;$/;"	m	struct:t_options	access:public
place_delay_ramp_slope	base/read_options.h	/^    argparse::ArgValue<float> place_delay_ramp_slope;$/;"	m	struct:t_options	access:public
place_exp_first	base/read_options.h	/^    argparse::ArgValue<float> place_exp_first;$/;"	m	struct:t_options	access:public
place_exp_last	base/read_options.h	/^    argparse::ArgValue<float> place_exp_last;$/;"	m	struct:t_options	access:public
place_freq	base/vpr_types.h	/^	enum pfreq place_freq;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	typeref:enum:ScreenUpdatePriority::t_placer_opts::pfreq	access:public
place_sync_external_block_connections	util/vpr_utils.cpp	/^void place_sync_external_block_connections(ClusterBlockId iblk) {$/;"	f	signature:(ClusterBlockId iblk)
place_sync_external_block_connections	util/vpr_utils.h	/^void place_sync_external_block_connections(ClusterBlockId iblk);$/;"	p	signature:(ClusterBlockId iblk)
place_tsu_abs_margin	base/read_options.h	/^    argparse::ArgValue<float> place_tsu_abs_margin;$/;"	m	struct:t_options	access:public
place_tsu_rel_margin	base/read_options.h	/^    argparse::ArgValue<float> place_tsu_rel_margin;$/;"	m	struct:t_options	access:public
placement	base/vpr_context.h	/^        const PlacementContext& placement() const { return placement_; }$/;"	f	class:VprContext	access:public	signature:() const
placement_	base/vpr_context.h	/^        PlacementContext placement_;$/;"	m	class:VprContext	access:private
placement_id	base/vpr_context.h	/^    std::string placement_id;$/;"	m	struct:PlacementContext	access:public
placement_index	../../libs/libarchfpga/src/physical_types.h	/^	int placement_index;$/;"	m	struct:t_pb_graph_node	access:public
placement_inner_loop	place/place.cpp	/^static void placement_inner_loop(float t, float rlim, t_placer_opts placer_opts,$/;"	f	file:	signature:(float t, float rlim, t_placer_opts placer_opts, int move_lim, float crit_exponent, int inner_recompute_limit, t_placer_statistics *stats, t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, int* moves_since_cost_recompute, t_slack* slacks, t_timing_inf timing_inf, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, const PlaceDelayModel& delay_model, SetupTimingInfo& timing_info)
placement_inner_loop	place/place.cpp	/^static void placement_inner_loop(float t, float rlim, t_placer_opts placer_opts,$/;"	p	file:	signature:(float t, float rlim, t_placer_opts placer_opts, int move_lim, float crit_exponent, int inner_recompute_limit, t_placer_statistics *stats, t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, int* moves_since_cost_recompute, t_slack* slacks, t_timing_inf timing_inf, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, const PlaceDelayModel& delay_model, SetupTimingInfo& timing_info)
plasma_data	../../libs/libvtrutil/src/vtr_color_map.cpp	/^static std::vector<Color<float>> plasma_data = {$/;"	m	namespace:vtr	file:
point_iter	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef typename std::vector<Point<T>>::const_iterator point_iter;$/;"	t	class:vtr::Line	access:public
point_range	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef vtr::Range<point_iter> point_range;$/;"	t	class:vtr::Line	access:public
point_to_point_delay_cost	place/place.cpp	/^static vtr::vector<ClusterNetId, float *> point_to_point_delay_cost;$/;"	v	file:
point_to_point_timing_cost	place/place.cpp	/^static vtr::vector<ClusterNetId, float *> point_to_point_timing_cost;$/;"	v	file:
pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute* pointer;$/;"	t	class:pugi::xml_attribute_iterator	access:public
pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node* pointer;$/;"	t	class:pugi::xml_named_node_iterator	access:public
pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node* pointer;$/;"	t	class:pugi::xml_node_iterator	access:public
points	../../libs/libvtrutil/src/vtr_geometry.h	/^        point_range points() const;$/;"	p	class:vtr::Line	access:public	signature:() const
points	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    typename Line<T>::point_range Line<T>::points() const {$/;"	f	class:vtr::Line	signature:() const
points_	../../libs/libvtrutil/src/vtr_geometry.h	/^        std::vector<Point<T>> points_;$/;"	m	class:vtr::Line	access:private
poly	../../libs/libeasygl/src/graphics.cpp	/^    int poly[3][2];$/;"	m	struct:__anon18	file:	access:public
pop_heap	route/route_common.cpp	/^	void pop_heap() {$/;"	f	namespace:heap_	signature:()
pop_heap	route/route_common.h	/^	void pop_heap();$/;"	p	namespace:heap_	signature:()
port	../../libs/libarchfpga/src/physical_types.h	/^	t_port *port = nullptr;$/;"	m	struct:t_pb_graph_pin	access:public
port_	../../libs/libarchfpga/src/arch_util.h	/^        name_index port_;$/;"	m	class:InstPort	access:private
port_block	base/netlist.h	/^        BlockId             port_block(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
port_block	base/netlist.tpp	/^BlockId Netlist<BlockId, PortId, PinId, NetId>::port_block(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
port_blocks_	base/netlist.h	/^        vtr::vector_map<PortId, BlockId>                port_blocks_;   \/\/Block associated with each port$/;"	m	class:Netlist	access:private
port_class	../../libs/libarchfpga/src/physical_types.h	/^	char * port_class;$/;"	m	struct:t_port	access:public
port_connections_	base/netlist_writer.cpp	/^        std::map<std::string,std::string> port_connections_;$/;"	m	class:LatchInst	file:	access:private
port_conns_	base/netlist_writer.cpp	/^        std::map<std::string,std::vector<std::string>> port_conns_;$/;"	m	class:LutInst	file:	access:private
port_high_index	../../libs/libarchfpga/src/arch_util.h	/^        int port_high_index() const { return port_.high_idx; }$/;"	f	class:InstPort	access:public	signature:() const
port_id_map_	base/netlist.h	/^        vtr::vector_map<PortId, PortId> port_id_map_;$/;"	m	class:NetlistIdRemapper	access:private
port_ids_	base/netlist.h	/^        vtr::vector_map<PortId, PortId>                 port_ids_;      \/\/Valid port ids$/;"	m	class:Netlist	access:private
port_index_by_type	../../libs/libarchfpga/src/physical_types.h	/^	int port_index_by_type;$/;"	m	struct:t_port	access:public
port_info_initialized	../../libs/libarchfpga/src/physical_types.h	/^	bool port_info_initialized;$/;"	m	struct:t_interconnect_power	access:public
port_iterator	base/netlist.h	/^        typedef typename vtr::vector_map<PortId, PortId>::const_iterator                port_iterator;$/;"	t	class:Netlist	access:public
port_low_index	../../libs/libarchfpga/src/arch_util.h	/^        int port_low_index() const { return port_.low_idx; }$/;"	f	class:InstPort	access:public	signature:() const
port_model	base/atom_netlist.cpp	/^const t_model_ports* AtomNetlist::port_model(const AtomPortId id) const {$/;"	f	class:AtomNetlist	signature:(const AtomPortId id) const
port_model	base/atom_netlist.h	/^        const t_model_ports* port_model(const AtomPortId id) const;$/;"	p	class:AtomNetlist	access:public	signature:(const AtomPortId id) const
port_models_	base/atom_netlist.h	/^        vtr::vector_map<AtomPortId, const t_model_ports*>   port_models_;   \/\/Architecture port models of each port$/;"	m	class:AtomNetlist	access:private
port_name	../../libs/libarchfpga/src/arch_util.h	/^        std::string port_name() const { return port_.name; }$/;"	f	class:InstPort	access:public	signature:() const
port_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    std::string port_name;$/;"	m	struct:t_fc_override	file:	access:public
port_name	base/netlist.h	/^        const std::string&  port_name(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
port_name	base/netlist.tpp	/^const std::string& Netlist<BlockId, PortId, PinId, NetId>::port_name(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
port_names_	base/netlist.h	/^        vtr::vector_map<PortId, StringId>               port_names_;    \/\/Name of each port$/;"	m	class:Netlist	access:private
port_net	base/netlist.h	/^        NetId               port_net(const PortId port_id, const BitIndex port_bit) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id, const BitIndex port_bit) const
port_net	base/netlist.tpp	/^NetId Netlist<BlockId, PortId, PinId, NetId>::port_net(const PortId port_id, const BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(const PortId port_id, const BitIndex port_bit) const
port_pin	base/netlist.h	/^        PinId               port_pin(const PortId port_id, const BitIndex port_bit) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id, const BitIndex port_bit) const
port_pin	base/netlist.tpp	/^PinId Netlist<BlockId, PortId, PinId, NetId>::port_pin(const PortId port_id, const BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(const PortId port_id, const BitIndex port_bit) const
port_pins	base/netlist.h	/^        pin_range           port_pins(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
port_pins	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::pin_range Netlist<BlockId, PortId, PinId, NetId>::port_pins(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
port_pins_	base/netlist.h	/^        vtr::vector_map<PortId, std::vector<PinId>>     port_pins_;     \/\/Pins associated with each port$/;"	m	class:Netlist	access:private
port_power	../../libs/libarchfpga/src/physical_types.h	/^	t_port_power *port_power;$/;"	m	struct:t_port	access:public
port_range	base/netlist.h	/^        typedef typename vtr::Range<port_iterator>  port_range;$/;"	t	class:Netlist	access:public
port_type	base/netlist.h	/^        PortType            port_type(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
port_type	base/netlist.tpp	/^PortType Netlist<BlockId, PortId, PinId, NetId>::port_type(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
port_types_	base/netlist.h	/^        vtr::vector_map<PortId, PortType>               port_types_;    \/\/Type of the port (INPUT, OUTPUT, CLOCK)$/;"	m	class:Netlist	access:private
port_width	base/netlist.h	/^        BitIndex            port_width(const PortId port_id) const;$/;"	p	class:Netlist	access:public	signature:(const PortId port_id) const
port_width	base/netlist.tpp	/^BitIndex Netlist<BlockId, PortId, PinId, NetId>::port_width(const PortId port_id) const {$/;"	f	class:Netlist	signature:(const PortId port_id) const
port_widths_	base/netlist.h	/^        vtr::vector_map<PortId, BitIndex>               port_widths_;   \/\/Width (in bits) of each port$/;"	m	class:Netlist	access:private
ports	../../libs/libarchfpga/src/physical_types.h	/^	t_port *ports = nullptr; \/* [0..num_ports] *\/$/;"	m	struct:t_pb_type	access:public
ports	base/netlist.h	/^        port_range  ports() const;$/;"	p	class:Netlist	access:public	signature:() const
ports	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::port_range Netlist<BlockId, PortId, PinId, NetId>::ports() const {$/;"	f	class:Netlist	signature:() const
ports_tcq_	base/netlist_writer.cpp	/^        std::map<std::string,double> ports_tcq_;$/;"	m	class:BlackBoxInst	file:	access:private
ports_thld_	base/netlist_writer.cpp	/^        std::map<std::string,double> ports_thld_;$/;"	m	class:BlackBoxInst	file:	access:private
ports_tsu_	base/netlist_writer.cpp	/^        std::map<std::string,double> ports_tsu_;$/;"	m	class:BlackBoxInst	file:	access:private
position	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t position, size;$/;"	m	struct:xpath_context	file:	access:public
post_place_sync	base/place_and_route.cpp	/^void post_place_sync() {$/;"	f	signature:()
post_place_sync	base/place_and_route.h	/^void post_place_sync();$/;"	p	signature:()
post_place_timing_report_file	base/read_options.h	/^    argparse::ArgValue<std::string> post_place_timing_report_file;$/;"	m	struct:t_options	access:public
post_place_timing_report_file	base/vpr_types.h	/^    std::string post_place_timing_report_file;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
postscript	../../libs/libeasygl/src/graphics.cpp	/^postscript(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
postscript	../../libs/libeasygl/src/graphics.cpp	/^static void postscript(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
power	../../libs/libarchfpga/src/physical_types.h	/^	t_power_arch * power;$/;"	m	struct:t_arch	access:public
power	base/vpr_context.h	/^        const PowerContext& power() const { return power_; }$/;"	f	class:VprContext	access:public	signature:() const
power	power/PowerSpicedComponent.h	/^	float power;$/;"	m	class:PowerCallibSize	access:public
power_	base/vpr_context.h	/^        PowerContext power_;$/;"	m	class:VprContext	access:private
power_MTAs	power/power_sizing.cpp	/^static double power_MTAs(float W_size) {$/;"	f	file:	signature:(float W_size)
power_MTAs	power/power_sizing.cpp	/^static double power_MTAs(float W_size);$/;"	p	file:	signature:(float W_size)
power_MTAs_L	power/power_sizing.cpp	/^static double power_MTAs_L(float L_size) {$/;"	f	file:	signature:(float L_size)
power_MTAs_L	power/power_sizing.cpp	/^static double power_MTAs_L(float L_size);$/;"	p	file:	signature:(float L_size)
power_add_usage	power/power_util.cpp	/^void power_add_usage(t_power_usage * dest, const t_power_usage * src) {$/;"	f	signature:(t_power_usage * dest, const t_power_usage * src)
power_add_usage	power/power_util.h	/^void power_add_usage(t_power_usage * dest, const t_power_usage * src);$/;"	p	signature:(t_power_usage * dest, const t_power_usage * src)
power_alloc_and_init_pb_pin	power/power.cpp	/^void power_alloc_and_init_pb_pin(t_pb_graph_pin * pin) {$/;"	f	signature:(t_pb_graph_pin * pin)
power_alloc_and_init_pb_pin	power/power.cpp	/^void power_alloc_and_init_pb_pin(t_pb_graph_pin * pin);$/;"	p	file:	signature:(t_pb_graph_pin * pin)
power_buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float power_buffer_size = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
power_buffer_size	../../libs/libarchfpga/src/physical_types.h	/^        float power_buffer_size = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
power_buffer_size_from_logical_effort	power/power_util.cpp	/^float power_buffer_size_from_logical_effort(float C_load) {$/;"	f	signature:(float C_load)
power_buffer_size_from_logical_effort	power/power_util.h	/^float power_buffer_size_from_logical_effort(float C_load);$/;"	p	signature:(float C_load)
power_buffer_type	../../libs/libarchfpga/src/physical_types.h	/^	e_power_buffer_type power_buffer_type = POWER_BUFFER_TYPE_UNDEFINED;$/;"	m	struct:t_rr_switch_inf	access:public
power_buffer_type	../../libs/libarchfpga/src/physical_types.h	/^        e_power_buffer_type power_buffer_type = POWER_BUFFER_TYPE_AUTO;$/;"	m	struct:t_arch_switch_inf	access:public
power_calc_buffer_num_stages	power/power_util.cpp	/^int power_calc_buffer_num_stages(float final_stage_size,$/;"	f	signature:(float final_stage_size, float desired_stage_effort)
power_calc_buffer_num_stages	power/power_util.h	/^int power_calc_buffer_num_stages(float final_stage_size, float desired_stage_effort);$/;"	p	signature:(float final_stage_size, float desired_stage_effort)
power_calc_buffer_size_from_Cout	power/power_lowlevel.cpp	/^float power_calc_buffer_size_from_Cout(float C_out) {$/;"	f	signature:(float C_out)
power_calc_buffer_size_from_Cout	power/power_lowlevel.h	/^float power_calc_buffer_size_from_Cout(float C_out);$/;"	p	signature:(float C_out)
power_calc_leakage_gate	power/power_lowlevel.cpp	/^static float power_calc_leakage_gate(e_tx_type transistor_type, float size) {$/;"	f	file:	signature:(e_tx_type transistor_type, float size)
power_calc_leakage_gate	power/power_lowlevel.cpp	/^static float power_calc_leakage_gate(e_tx_type transistor_type, float size);$/;"	p	file:	signature:(e_tx_type transistor_type, float size)
power_calc_leakage_st	power/power_lowlevel.cpp	/^static float power_calc_leakage_st(e_tx_type transistor_type, float size) {$/;"	f	file:	signature:(e_tx_type transistor_type, float size)
power_calc_leakage_st	power/power_lowlevel.cpp	/^static float power_calc_leakage_st(e_tx_type transistor_type, float size);$/;"	p	file:	signature:(e_tx_type transistor_type, float size)
power_calc_leakage_st_pass_transistor	power/power_lowlevel.cpp	/^static float power_calc_leakage_st_pass_transistor(float size, float v_ds) {$/;"	f	file:	signature:(float size, float v_ds)
power_calc_leakage_st_pass_transistor	power/power_lowlevel.cpp	/^static float power_calc_leakage_st_pass_transistor(float size, float v_ds);$/;"	p	file:	signature:(float size, float v_ds)
power_calc_mux_v_out	power/power_lowlevel.cpp	/^float power_calc_mux_v_out(int num_inputs, float transistor_size, float v_in,$/;"	f	signature:(int num_inputs, float transistor_size, float v_in, float in_prob_avg)
power_calc_mux_v_out	power/power_lowlevel.h	/^float power_calc_mux_v_out(int num_inputs, float transistor_size, float v_in,$/;"	p	signature:(int num_inputs, float transistor_size, float v_in, float in_prob_avg)
power_calc_node_switching	power/power_lowlevel.cpp	/^float power_calc_node_switching(float capacitance, float density,$/;"	f	signature:(float capacitance, float density, float period)
power_calc_node_switching	power/power_lowlevel.h	/^float power_calc_node_switching(float capacitance, float density, float period);$/;"	p	signature:(float capacitance, float density, float period)
power_calc_node_switching_v	power/power_lowlevel.cpp	/^static float power_calc_node_switching_v(float capacitance, float density,$/;"	f	file:	signature:(float capacitance, float density, float period, float voltage)
power_calc_node_switching_v	power/power_lowlevel.cpp	/^static float power_calc_node_switching_v(float capacitance, float density,$/;"	p	file:	signature:(float capacitance, float density, float period, float voltage)
power_calc_pb_switching_from_c_internal	power/power_lowlevel.h	/^float power_calc_pb_switching_from_c_internal(t_pb * pb,$/;"	p	signature:(t_pb * pb, t_pb_graph_node * pb_graph_node)
power_calc_pin_fanout	power/power_util.h	/^int power_calc_pin_fanout(t_pb_graph_pin * pin, int mode_idx);$/;"	p	signature:(t_pb_graph_pin * pin, int mode_idx)
power_calc_transistor_capacitance	power/power_lowlevel.cpp	/^static void power_calc_transistor_capacitance(float *C_d, float *C_s,$/;"	f	file:	signature:(float *C_d, float *C_s, float *C_g, e_tx_type transistor_type, float size)
power_calc_transistor_capacitance	power/power_lowlevel.cpp	/^static void power_calc_transistor_capacitance(float *C_d, float *C_s,$/;"	p	file:	signature:(float *C_d, float *C_s, float *C_g, e_tx_type transistor_type, float size)
power_callib_period	power/power_callibrate.h	/^const float power_callib_period = 5e-9;$/;"	v
power_callibrate	power/power_callibrate.cpp	/^void power_callibrate() {$/;"	f	signature:()
power_callibrate	power/power_callibrate.h	/^void power_callibrate();$/;"	p	signature:()
power_compare_buffer_sc_levr	power/power_cmos_tech.cpp	/^static int power_compare_buffer_sc_levr(const void * key_void, const void * elem_void);$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_compare_buffer_sc_levr	power/power_cmos_tech.cpp	/^static int power_compare_buffer_sc_levr(const void * key_void,$/;"	f	file:	signature:(const void * key_void, const void * elem_void)
power_compare_buffer_strength	power/power_cmos_tech.cpp	/^static int power_compare_buffer_strength(const void * key_void, const void * elem_void);$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_compare_buffer_strength	power/power_cmos_tech.cpp	/^static int power_compare_buffer_strength(const void * key_void,$/;"	f	file:	signature:(const void * key_void, const void * elem_void)
power_compare_buffer_strength	tags	/^power_compare_buffer_strength	power\/power_cmos_tech.cpp	\/^static int power_compare_buffer_strength(const void * key_void, const void * elem_void);$\/;"	p	file:	signature:(const void * key_void, const void * elem_void)$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_compare_leakage_pair	power/power_cmos_tech.cpp	/^static int power_compare_leakage_pair(const void * key_void, const void * elem_void) {$/;"	f	file:	signature:(const void * key_void, const void * elem_void)
power_compare_leakage_pair	power/power_cmos_tech.cpp	/^static int power_compare_leakage_pair(const void * key_void, const void * elem_void);$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_compare_transistor_size	power/power_cmos_tech.cpp	/^static int power_compare_transistor_size(const void * key_void, const void * elem_void);$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_compare_transistor_size	power/power_cmos_tech.cpp	/^static int power_compare_transistor_size(const void * key_void,$/;"	f	file:	signature:(const void * key_void, const void * elem_void)
power_compare_voltage_pair	power/power_cmos_tech.cpp	/^static int power_compare_voltage_pair(const void * key_void, const void * elem_void);$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_compare_voltage_pair	power/power_cmos_tech.cpp	/^static int power_compare_voltage_pair(const void * key_void,$/;"	f	file:	signature:(const void * key_void, const void * elem_void)
power_compare_voltage_pair	tags	/^power_compare_voltage_pair	power\/power_cmos_tech.cpp	\/^static int power_compare_voltage_pair(const void * key_void, const void * elem_void);$\/;"	p	file:	signature:(const void * key_void, const void * elem_void)$/;"	p	file:	signature:(const void * key_void, const void * elem_void)
power_component_add_usage	power/power_components.cpp	/^void power_component_add_usage(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, e_power_component_type component_idx)
power_component_add_usage	power/power_components.h	/^void power_component_add_usage(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, e_power_component_type component_idx)
power_component_get_usage	power/power_components.cpp	/^void power_component_get_usage(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, e_power_component_type component_idx)
power_component_get_usage	power/power_components.h	/^void power_component_get_usage(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, e_power_component_type component_idx)
power_component_get_usage_sum	power/power_components.cpp	/^float power_component_get_usage_sum(e_power_component_type component_idx) {$/;"	f	signature:(e_power_component_type component_idx)
power_component_get_usage_sum	power/power_components.h	/^float power_component_get_usage_sum(e_power_component_type component_idx);$/;"	p	signature:(e_power_component_type component_idx)
power_components_init	power/power_components.cpp	/^void power_components_init() {$/;"	f	signature:()
power_components_init	power/power_components.h	/^void power_components_init();$/;"	p	signature:()
power_components_uninit	power/power_components.cpp	/^void power_components_uninit() {$/;"	f	signature:()
power_components_uninit	power/power_components.h	/^void power_components_uninit();$/;"	p	signature:()
power_count_transistor_SRAM_bit	power/power_sizing.cpp	/^static double power_count_transistor_SRAM_bit() {$/;"	f	file:	signature:()
power_count_transistor_SRAM_bit	power/power_sizing.cpp	/^static double power_count_transistor_SRAM_bit();$/;"	p	file:	signature:()
power_count_transistors_FF	power/power_sizing.cpp	/^static double power_count_transistors_FF(float size) {$/;"	f	file:	signature:(float size)
power_count_transistors_FF	power/power_sizing.cpp	/^static double power_count_transistors_FF(float size);$/;"	p	file:	signature:(float size)
power_count_transistors_LUT	power/power_sizing.cpp	/^static double power_count_transistors_LUT(int LUT_inputs,$/;"	f	file:	signature:(int LUT_inputs, float transistor_size)
power_count_transistors_LUT	power/power_sizing.cpp	/^static double power_count_transistors_LUT(int LUT_inputs,$/;"	p	file:	signature:(int LUT_inputs, float transistor_size)
power_count_transistors_buffer	power/power_sizing.cpp	/^double power_count_transistors_buffer(float buffer_size) {$/;"	f	signature:(float buffer_size)
power_count_transistors_buffer	power/power_sizing.h	/^double power_count_transistors_buffer(float buffer_size);$/;"	p	signature:(float buffer_size)
power_count_transistors_connectionbox	power/power_sizing.cpp	/^static double power_count_transistors_connectionbox() {$/;"	f	file:	signature:()
power_count_transistors_connectionbox	power/power_sizing.cpp	/^static double power_count_transistors_connectionbox();$/;"	p	file:	signature:()
power_count_transistors_interc	power/power_sizing.cpp	/^static double power_count_transistors_interc(t_interconnect * interc) {$/;"	f	file:	signature:(t_interconnect * interc)
power_count_transistors_interc	power/power_sizing.cpp	/^static double power_count_transistors_interc(t_interconnect * interc);$/;"	p	file:	signature:(t_interconnect * interc)
power_count_transistors_inv	power/power_sizing.cpp	/^static double power_count_transistors_inv(float size) {$/;"	f	file:	signature:(float size)
power_count_transistors_inv	power/power_sizing.cpp	/^static double power_count_transistors_inv(float size);$/;"	p	file:	signature:(float size)
power_count_transistors_levr	power/power_sizing.cpp	/^static double power_count_transistors_levr() {$/;"	f	file:	signature:()
power_count_transistors_levr	power/power_sizing.cpp	/^static double power_count_transistors_levr();$/;"	p	file:	signature:()
power_count_transistors_mux	power/power_sizing.cpp	/^static double power_count_transistors_mux(t_mux_arch * mux_arch) {$/;"	f	file:	signature:(t_mux_arch * mux_arch)
power_count_transistors_mux	power/power_sizing.cpp	/^static double power_count_transistors_mux(t_mux_arch * mux_arch);$/;"	p	file:	signature:(t_mux_arch * mux_arch)
power_count_transistors_mux_node	power/power_sizing.cpp	/^static double power_count_transistors_mux_node(t_mux_node * mux_node,$/;"	f	file:	signature:(t_mux_node * mux_node, float transistor_size)
power_count_transistors_mux_node	power/power_sizing.cpp	/^static double power_count_transistors_mux_node(t_mux_node * mux_node,$/;"	p	file:	signature:(t_mux_node * mux_node, float transistor_size)
power_count_transistors_pb_node	power/power_sizing.cpp	/^static double power_count_transistors_pb_node(t_pb_graph_node * pb_node) {$/;"	f	file:	signature:(t_pb_graph_node * pb_node)
power_count_transistors_pb_node	power/power_sizing.cpp	/^static double power_count_transistors_pb_node(t_pb_graph_node * pb_node);$/;"	p	file:	signature:(t_pb_graph_node * pb_node)
power_count_transistors_primitive	power/power_sizing.cpp	/^static double power_count_transistors_primitive(t_pb_type * pb_type) {$/;"	f	file:	signature:(t_pb_type * pb_type)
power_count_transistors_primitive	power/power_sizing.cpp	/^static double power_count_transistors_primitive(t_pb_type * pb_type);$/;"	p	file:	signature:(t_pb_type * pb_type)
power_count_transistors_switchbox	power/power_sizing.cpp	/^static double power_count_transistors_switchbox(const t_arch * arch) {$/;"	f	file:	signature:(const t_arch * arch)
power_count_transistors_switchbox	power/power_sizing.cpp	/^static double power_count_transistors_switchbox(const t_arch * arch);$/;"	p	file:	signature:(const t_arch * arch)
power_count_transistors_trans_gate	power/power_sizing.cpp	/^static double power_count_transistors_trans_gate(float size) {$/;"	f	file:	signature:(float size)
power_count_transistors_trans_gate	power/power_sizing.cpp	/^static double power_count_transistors_trans_gate(float size);$/;"	p	file:	signature:(float size)
power_estimation_method_name	power/power.cpp	/^static const char * power_estimation_method_name($/;"	f	file:	signature:( e_power_estimation_method power_method)
power_estimation_method_name	power/power.cpp	/^static const char * power_estimation_method_name($/;"	p	file:	signature:( e_power_estimation_method power_method)
power_find_buffer_sc_levr	power/power_cmos_tech.cpp	/^void power_find_buffer_sc_levr(t_power_buffer_sc_levr_inf ** lower,$/;"	f	signature:(t_power_buffer_sc_levr_inf ** lower, t_power_buffer_sc_levr_inf ** upper, t_power_buffer_strength_inf * buffer_strength, int input_mux_size)
power_find_buffer_sc_levr	power/power_cmos_tech.h	/^void power_find_buffer_sc_levr(t_power_buffer_sc_levr_inf ** lower,$/;"	p	signature:(t_power_buffer_sc_levr_inf ** lower, t_power_buffer_sc_levr_inf ** upper, t_power_buffer_strength_inf * buffer_sc, int input_mux_size)
power_find_buffer_strength_inf	power/power_cmos_tech.cpp	/^void power_find_buffer_strength_inf(t_power_buffer_strength_inf ** lower,$/;"	f	signature:(t_power_buffer_strength_inf ** lower, t_power_buffer_strength_inf ** upper, t_power_buffer_size_inf * size_inf, float stage_gain)
power_find_buffer_strength_inf	power/power_cmos_tech.h	/^void power_find_buffer_strength_inf(t_power_buffer_strength_inf ** lower,$/;"	p	signature:(t_power_buffer_strength_inf ** lower, t_power_buffer_strength_inf ** upper, t_power_buffer_size_inf * size_inf, float stage_gain)
power_find_mux_volt_inf	power/power_cmos_tech.cpp	/^void power_find_mux_volt_inf(t_power_mux_volt_pair ** lower,$/;"	f	signature:(t_power_mux_volt_pair ** lower, t_power_mux_volt_pair ** upper, t_power_mux_volt_inf * volt_inf, float v_in)
power_find_mux_volt_inf	power/power_cmos_tech.h	/^void power_find_mux_volt_inf(t_power_mux_volt_pair ** lower,$/;"	p	signature:(t_power_mux_volt_pair ** lower, t_power_mux_volt_pair ** upper, t_power_mux_volt_inf * volt_inf, float v_in)
power_find_nmos_leakage	power/power_cmos_tech.cpp	/^void power_find_nmos_leakage(t_power_nmos_leakage_inf * nmos_leakage_info,$/;"	f	signature:(t_power_nmos_leakage_inf * nmos_leakage_info, t_power_nmos_leakage_pair ** lower, t_power_nmos_leakage_pair ** upper, float v_ds)
power_find_nmos_leakage	power/power_cmos_tech.h	/^void power_find_nmos_leakage(t_power_nmos_leakage_inf * nmos_leakage_info,$/;"	p	signature:(t_power_nmos_leakage_inf * nmos_leakage_info, t_power_nmos_leakage_pair ** lower, t_power_nmos_leakage_pair ** upper, float v_ds)
power_find_transistor_info	power/power_cmos_tech.cpp	/^bool power_find_transistor_info(t_transistor_size_inf ** lower,$/;"	f	signature:(t_transistor_size_inf ** lower, t_transistor_size_inf ** upper, e_tx_type type, float size)
power_find_transistor_info	power/power_cmos_tech.h	/^bool power_find_transistor_info(t_transistor_size_inf ** lower,$/;"	p	signature:(t_transistor_size_inf ** lower, t_transistor_size_inf ** upper, e_tx_type type, float size)
power_get_mux_arch	power/power_util.cpp	/^t_mux_arch * power_get_mux_arch(int num_mux_inputs, float transistor_size) {$/;"	f	signature:(int num_mux_inputs, float transistor_size)
power_get_mux_arch	power/power_util.h	/^t_mux_arch * power_get_mux_arch(int num_mux_inputs, float transistor_size);$/;"	p	signature:(int num_mux_inputs, float transistor_size)
power_init	power/power.cpp	/^bool power_init(const char * power_out_filepath,$/;"	f	signature:(const char * power_out_filepath, const char * cmos_tech_behavior_filepath, const t_arch * arch, const t_det_routing_arch * routing_arch)
power_init	power/power.h	/^bool power_init(const char * power_out_filepath,$/;"	p	signature:(const char * power_out_filepath, const char * cmos_tech_behavior_filepath, const t_arch * arch, const t_det_routing_arch * routing_arch)
power_init_pb_pins_rec	power/power.cpp	/^void power_init_pb_pins_rec(t_pb_graph_node * pb_node) {$/;"	f	signature:(t_pb_graph_node * pb_node)
power_init_pb_pins_rec	power/power.cpp	/^void power_init_pb_pins_rec(t_pb_graph_node * pb_node);$/;"	p	file:	signature:(t_pb_graph_node * pb_node)
power_log_msg	power/power_util.cpp	/^void power_log_msg(e_power_log_type log_type, const char * msg) {$/;"	f	signature:(e_power_log_type log_type, const char * msg)
power_log_msg	power/power_util.h	/^void power_log_msg(e_power_log_type log_type, const char * msg);$/;"	p	signature:(e_power_log_type log_type, const char * msg)
power_lowlevel_init	power/power_lowlevel.cpp	/^void power_lowlevel_init() {$/;"	f	signature:()
power_lowlevel_init	power/power_lowlevel.h	/^void power_lowlevel_init();$/;"	p	signature:()
power_method_inherited	../../libs/libarchfpga/src/arch_util.cpp	/^e_power_estimation_method power_method_inherited($/;"	f	signature:( e_power_estimation_method parent_power_method)
power_method_inherited	../../libs/libarchfpga/src/arch_util.h	/^e_power_estimation_method power_method_inherited($/;"	p	signature:( e_power_estimation_method parent_power_method)
power_method_is_recursive	power/power_util.cpp	/^bool power_method_is_recursive(e_power_estimation_method method) {$/;"	f	signature:(e_power_estimation_method method)
power_method_is_recursive	power/power_util.h	/^bool power_method_is_recursive($/;"	p	signature:( e_power_estimation_method method)
power_method_is_transistor_level	power/power_util.cpp	/^bool power_method_is_transistor_level($/;"	f	signature:( e_power_estimation_method estimation_method)
power_method_is_transistor_level	power/power_util.h	/^bool power_method_is_transistor_level($/;"	p	signature:( e_power_estimation_method estimation_method)
power_mux_node_max_inputs	power/power_sizing.cpp	/^static void power_mux_node_max_inputs(t_mux_node * mux_node,$/;"	f	file:	signature:(t_mux_node * mux_node, float * max_inputs)
power_mux_node_max_inputs	power/power_sizing.cpp	/^static void power_mux_node_max_inputs(t_mux_node * mux_node,$/;"	p	file:	signature:(t_mux_node * mux_node, float * max_inputs)
power_pb_pins_init	power/power.cpp	/^void power_pb_pins_init() {$/;"	f	signature:()
power_pb_pins_init	power/power.cpp	/^void power_pb_pins_init();$/;"	p	file:	signature:()
power_pb_pins_uninit	power/power.cpp	/^void power_pb_pins_uninit() {$/;"	f	signature:()
power_pb_pins_uninit	power/power.cpp	/^void power_pb_pins_uninit();$/;"	p	file:	signature:()
power_perc_dynamic	power/power_util.cpp	/^float power_perc_dynamic(t_power_usage * power_usage) {$/;"	f	signature:(t_power_usage * power_usage)
power_perc_dynamic	power/power_util.h	/^float power_perc_dynamic(t_power_usage * power_usage);$/;"	p	signature:(t_power_usage * power_usage)
power_print_breakdown_component	power/power.cpp	/^static void power_print_breakdown_component(FILE * fp, const char * name,$/;"	f	file:	signature:(FILE * fp, const char * name, e_power_component_type type, int indent_level)
power_print_breakdown_component	power/power.cpp	/^static void power_print_breakdown_component(FILE * fp, const char * name,$/;"	p	file:	signature:(FILE * fp, const char * name, e_power_component_type type, int indent_level)
power_print_breakdown_entry	power/power.cpp	/^static void power_print_breakdown_entry(FILE * fp, int indent,$/;"	f	file:	signature:(FILE * fp, int indent, e_power_breakdown_entry_type type, const char * name, float power, float total_power, float perc_dyn, const char * method)
power_print_breakdown_entry	power/power.cpp	/^static void power_print_breakdown_entry(FILE * fp, int indent,$/;"	p	file:	signature:(FILE * fp, int indent, e_power_breakdown_entry_type type, const char * name, float power, float total_power, float perc_dyn, const char * method)
power_print_breakdown_pb	power/power.cpp	/^static void power_print_breakdown_pb(FILE * fp) {$/;"	f	file:	signature:(FILE * fp)
power_print_breakdown_pb	power/power.cpp	/^static void power_print_breakdown_pb(FILE * fp);$/;"	p	file:	signature:(FILE * fp)
power_print_breakdown_pb_rec	power/power.cpp	/^static void power_print_breakdown_pb_rec(FILE * fp, t_pb_type * pb_type,$/;"	f	file:	signature:(FILE * fp, t_pb_type * pb_type, int indent)
power_print_breakdown_pb_rec	power/power.cpp	/^static void power_print_breakdown_pb_rec(FILE * fp, t_pb_type * pb_type,$/;"	p	file:	signature:(FILE * fp, t_pb_type * pb_type, int indent)
power_print_breakdown_summary	power/power.cpp	/^static void power_print_breakdown_summary(FILE * fp) {$/;"	f	file:	signature:(FILE * fp)
power_print_breakdown_summary	power/power.cpp	/^static void power_print_breakdown_summary(FILE * fp);$/;"	p	file:	signature:(FILE * fp)
power_print_callibration	power/power_callibrate.cpp	/^void power_print_callibration() {$/;"	f	signature:()
power_print_callibration	power/power_callibrate.h	/^void power_print_callibration();$/;"	p	signature:()
power_print_spice_comparison	power/power_callibrate.cpp	/^void power_print_spice_comparison() {$/;"	f	signature:()
power_print_spice_comparison	power/power_callibrate.h	/^void power_print_spice_comparison();$/;"	p	signature:()
power_print_summary	power/power.cpp	/^static void power_print_summary(FILE * fp, const t_vpr_setup& vpr_setup) {$/;"	f	file:	signature:(FILE * fp, const t_vpr_setup& vpr_setup)
power_print_summary	power/power.cpp	/^static void power_print_summary(FILE * fp, const t_vpr_setup& vpr_setup);$/;"	p	file:	signature:(FILE * fp, const t_vpr_setup& vpr_setup)
power_print_title	power/power_util.cpp	/^void power_print_title(FILE * fp, const char * title) {$/;"	f	signature:(FILE * fp, const char * title)
power_print_title	power/power_util.h	/^void power_print_title(FILE * fp, const char * title);$/;"	p	signature:(FILE * fp, const char * title)
power_reset_pb_type	power/power.cpp	/^static void power_reset_pb_type(t_pb_type * pb_type) {$/;"	f	file:	signature:(t_pb_type * pb_type)
power_reset_pb_type	power/power.cpp	/^static void power_reset_pb_type(t_pb_type * pb_type);$/;"	p	file:	signature:(t_pb_type * pb_type)
power_reset_tile_usage	power/power.cpp	/^static void power_reset_tile_usage() {$/;"	f	file:	signature:()
power_reset_tile_usage	power/power.cpp	/^static void power_reset_tile_usage();$/;"	p	file:	signature:()
power_routing_init	power/power.cpp	/^void power_routing_init(const t_det_routing_arch * routing_arch) {$/;"	f	signature:(const t_det_routing_arch * routing_arch)
power_routing_init	power/power.cpp	/^void power_routing_init(const t_det_routing_arch * routing_arch);$/;"	p	file:	signature:(const t_det_routing_arch * routing_arch)
power_scale_usage	power/power_util.cpp	/^void power_scale_usage(t_power_usage * power_usage, float scale_factor) {$/;"	f	signature:(t_power_usage * power_usage, float scale_factor)
power_scale_usage	power/power_util.h	/^void power_scale_usage(t_power_usage * power_usage, float scale_factor);$/;"	p	signature:(t_power_usage * power_usage, float scale_factor)
power_size_pb	power/power_sizing.cpp	/^static void power_size_pb() {$/;"	f	file:	signature:()
power_size_pb	power/power_sizing.cpp	/^static void power_size_pb();$/;"	p	file:	signature:()
power_size_pb_rec	power/power_sizing.cpp	/^static void power_size_pb_rec(t_pb_graph_node * pb_node) {$/;"	f	file:	signature:(t_pb_graph_node * pb_node)
power_size_pb_rec	power/power_sizing.cpp	/^static void power_size_pb_rec(t_pb_graph_node * pb_node);$/;"	p	file:	signature:(t_pb_graph_node * pb_node)
power_size_pin_buffers_and_wires	power/power_sizing.cpp	/^static void power_size_pin_buffers_and_wires(t_pb_graph_pin * pin,$/;"	f	file:	signature:(t_pb_graph_pin * pin, bool pin_is_an_input)
power_size_pin_buffers_and_wires	power/power_sizing.cpp	/^static void power_size_pin_buffers_and_wires(t_pb_graph_pin * pin,$/;"	p	file:	signature:(t_pb_graph_pin * pin, bool pin_is_an_input)
power_size_pin_to_interconnect	power/power_sizing.cpp	/^static void power_size_pin_to_interconnect(t_interconnect * interc,$/;"	f	file:	signature:(t_interconnect * interc, int * fanout, float * wirelength)
power_size_pin_to_interconnect	power/power_sizing.cpp	/^static void power_size_pin_to_interconnect(t_interconnect * interc,$/;"	p	file:	signature:(t_interconnect * interc, int * fanout, float * wirelength)
power_sizing_init	power/power_sizing.cpp	/^void power_sizing_init(const t_arch * arch) {$/;"	f	signature:(const t_arch * arch)
power_sizing_init	power/power_sizing.h	/^void power_sizing_init(const t_arch * arch);$/;"	p	signature:(const t_arch * arch)
power_sum_usage	power/power_util.cpp	/^float power_sum_usage(t_power_usage * power_usage) {$/;"	f	signature:(t_power_usage * power_usage)
power_sum_usage	power/power_util.h	/^float power_sum_usage(t_power_usage * power_usage);$/;"	p	signature:(t_power_usage * power_usage)
power_tech_init	power/power_cmos_tech.cpp	/^void power_tech_init(const char * cmos_tech_behavior_filepath) {$/;"	f	signature:(const char * cmos_tech_behavior_filepath)
power_tech_init	power/power_cmos_tech.h	/^void power_tech_init(const char * cmos_tech_behavior_filepath);$/;"	p	signature:(const char * cmos_tech_behavior_filepath)
power_tech_init	tags	/^power_tech_init	power\/power_cmos_tech.cpp	\/^void power_tech_init(const char * cmos_tech_behavior_filepath) {$\/;"	f	signature:(const char * cmos_tech_behavior_filepath)$/;"	f	signature:(const char * cmos_tech_behavior_filepath)
power_tech_load_xml_file	power/power_cmos_tech.cpp	/^static void power_tech_load_xml_file(const char * cmos_tech_behavior_filepath);$/;"	p	file:	signature:(const char * cmos_tech_behavior_filepath)
power_tech_load_xml_file	power/power_cmos_tech.cpp	/^void power_tech_load_xml_file(const char * cmos_tech_behavior_filepath) {$/;"	f	signature:(const char * cmos_tech_behavior_filepath)
power_tech_xml_load_component	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_component(pugi::xml_node parent, const pugiutil::loc_data& loc_data,$/;"	f	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data, PowerSpicedComponent ** component, const char * name, float (*usage_fn)(int num_inputs, float transistor_size))
power_tech_xml_load_component	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_component(pugi::xml_node parent, const pugiutil::loc_data& loc_data,$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data, PowerSpicedComponent ** component, const char * name, float (*usage_fn)(int num_inputs, float transistor_size))
power_tech_xml_load_components	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_components(pugi::xml_node parent, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_components	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_components(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_components	tags	/^power_tech_xml_load_components	power\/power_cmos_tech.cpp	\/^static void power_tech_xml_load_components(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$\/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_multiplexer_info	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_multiplexer_info(pugi::xml_node parent, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_multiplexer_info	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_multiplexer_info(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_nmos_st_leakages	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_nmos_st_leakages(pugi::xml_node parent, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_nmos_st_leakages	power/power_cmos_tech.cpp	/^static void power_tech_xml_load_nmos_st_leakages(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_tech_xml_load_nmos_st_leakages	tags	/^power_tech_xml_load_nmos_st_leakages	power\/power_cmos_tech.cpp	\/^static void power_tech_xml_load_nmos_st_leakages(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$\/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
power_total	power/power.cpp	/^e_power_ret_code power_total(float * run_time_s, const t_vpr_setup& vpr_setup,$/;"	f	signature:(float * run_time_s, const t_vpr_setup& vpr_setup, const t_arch * arch, const t_det_routing_arch * routing_arch)
power_total	power/power.h	/^e_power_ret_code power_total(float * run_time_s, const t_vpr_setup& vpr_setup,$/;"	p	signature:(float * run_time_s, const t_vpr_setup& vpr_setup, const t_arch * arch, const t_det_routing_arch * routing_arch)
power_transistor_area	power/power_sizing.cpp	/^double power_transistor_area(double num_MTAs) {$/;"	f	signature:(double num_MTAs)
power_transistor_area	power/power_sizing.h	/^double power_transistor_area(double num_transistors);$/;"	p	signature:(double num_transistors)
power_transistors_for_pb_node	power/power_sizing.cpp	/^static double power_transistors_for_pb_node(t_pb_graph_node * pb_node) {$/;"	f	file:	signature:(t_pb_graph_node * pb_node)
power_transistors_for_pb_node	power/power_sizing.cpp	/^static double power_transistors_for_pb_node(t_pb_graph_node * pb_node);$/;"	p	file:	signature:(t_pb_graph_node * pb_node)
power_transistors_per_tile	power/power_sizing.cpp	/^static double power_transistors_per_tile(const t_arch * arch) {$/;"	f	file:	signature:(const t_arch * arch)
power_transistors_per_tile	power/power_sizing.cpp	/^static double power_transistors_per_tile(const t_arch * arch);$/;"	p	file:	signature:(const t_arch * arch)
power_uninit	power/power.cpp	/^bool power_uninit() {$/;"	f	signature:()
power_uninit	power/power.h	/^bool power_uninit();$/;"	p	signature:()
power_uninit_pb_pin	power/power.cpp	/^void power_uninit_pb_pin(t_pb_graph_pin * pin) {$/;"	f	signature:(t_pb_graph_pin * pin)
power_uninit_pb_pin	power/power.cpp	/^void power_uninit_pb_pin(t_pb_graph_pin * pin);$/;"	p	file:	signature:(t_pb_graph_pin * pin)
power_uninit_pb_pins_rec	power/power.cpp	/^void power_uninit_pb_pins_rec(t_pb_graph_node * pb_node) {$/;"	f	signature:(t_pb_graph_node * pb_node)
power_uninit_pb_pins_rec	power/power.cpp	/^void power_uninit_pb_pins_rec(t_pb_graph_node * pb_node);$/;"	p	file:	signature:(t_pb_graph_node * pb_node)
power_usage	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage; \/* Power usage of this mode *\/$/;"	m	struct:t_mode_power	access:public
power_usage	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage; \/* Total power usage of this pb type *\/$/;"	m	struct:t_pb_type_power	access:public
power_usage	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage;$/;"	m	struct:t_interconnect_power	access:public
power_usage_MUX2_transmission	power/power_lowlevel.cpp	/^void power_usage_MUX2_transmission(t_power_usage * power_usage, float size,$/;"	f	signature:(t_power_usage * power_usage, float size, float * in_dens, float * in_prob, float sel_dens, float out_dens, float period)
power_usage_MUX2_transmission	power/power_lowlevel.h	/^void power_usage_MUX2_transmission(t_power_usage * power_usage, float size,$/;"	p	signature:(t_power_usage * power_usage, float size, float * in_dens, float * in_prob, float sel_dens, float out_dens, float period)
power_usage_blocks	power/power.cpp	/^static void power_usage_blocks(t_power_usage * power_usage) {$/;"	f	file:	signature:(t_power_usage * power_usage)
power_usage_blocks	power/power.cpp	/^static void power_usage_blocks(t_power_usage * power_usage);$/;"	p	file:	signature:(t_power_usage * power_usage)
power_usage_buf_for_callibration	power/power_callibrate.cpp	/^float power_usage_buf_for_callibration(int num_inputs, float transistor_size) {$/;"	f	signature:(int num_inputs, float transistor_size)
power_usage_buf_for_callibration	power/power_callibrate.h	/^float power_usage_buf_for_callibration(int num_inputs, float transistor_size);$/;"	p	signature:(int num_inputs, float transistor_size)
power_usage_buf_levr_for_callibration	power/power_callibrate.cpp	/^float power_usage_buf_levr_for_callibration(int num_inputs,$/;"	f	signature:(int num_inputs, float transistor_size)
power_usage_buf_levr_for_callibration	power/power_callibrate.h	/^float power_usage_buf_levr_for_callibration(int num_inputs,$/;"	p	signature:(int num_inputs, float transistor_size)
power_usage_buffer	power/power_components.cpp	/^void power_usage_buffer(t_power_usage * power_usage, float size, float in_prob,$/;"	f	signature:(t_power_usage * power_usage, float size, float in_prob, float in_dens, bool level_restorer, float period)
power_usage_buffer	power/power_components.h	/^void power_usage_buffer(t_power_usage * power_usage, float size, float in_prob,$/;"	p	signature:(t_power_usage * power_usage, float size, float in_prob, float in_dens, bool level_restored, float period)
power_usage_bufs_wires	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage_bufs_wires; \/* Power dissipated in local buffers and wire switching (Subset of total power) *\/$/;"	m	struct:t_pb_type_power	access:public
power_usage_clock	power/power.cpp	/^static void power_usage_clock(t_power_usage * power_usage,$/;"	f	file:	signature:(t_power_usage * power_usage, t_clock_arch * clock_arch)
power_usage_clock	power/power.cpp	/^static void power_usage_clock(t_power_usage * power_usage,$/;"	p	file:	signature:(t_power_usage * power_usage, t_clock_arch * clock_arch)
power_usage_clock_single	power/power.cpp	/^static void power_usage_clock_single(t_power_usage * power_usage,$/;"	f	file:	signature:(t_power_usage * power_usage, t_clock_network * single_clock)
power_usage_clock_single	power/power.cpp	/^static void power_usage_clock_single(t_power_usage * power_usage,$/;"	p	file:	signature:(t_power_usage * power_usage, t_clock_network * clock_inf)
power_usage_ff	power/power_components.cpp	/^void power_usage_ff(t_power_usage * power_usage, float size, float D_prob,$/;"	f	signature:(t_power_usage * power_usage, float size, float D_prob, float D_dens, float Q_prob, float Q_dens, float clk_prob, float clk_dens, float period)
power_usage_ff	power/power_components.h	/^void power_usage_ff(t_power_usage * power_usage, float size, float D_prob,$/;"	p	signature:(t_power_usage * power_usage, float size, float D_prob, float D_dens, float Q_prob, float Q_dens, float clk_prob, float clk_dens, float period)
power_usage_ff_for_callibration	power/power_callibrate.cpp	/^float power_usage_ff_for_callibration(int num_inputs, float transistor_size) {$/;"	f	signature:(int num_inputs, float transistor_size)
power_usage_ff_for_callibration	power/power_callibrate.h	/^float power_usage_ff_for_callibration(int num_inputs, float transistor_size);$/;"	p	signature:(int num_inputs, float transistor_size)
power_usage_inverter	power/power_lowlevel.cpp	/^void power_usage_inverter(t_power_usage * power_usage, float in_dens,$/;"	f	signature:(t_power_usage * power_usage, float in_dens, float in_prob, float size, float period)
power_usage_inverter	power/power_lowlevel.h	/^void power_usage_inverter(t_power_usage * power_usage, float in_dens,$/;"	p	signature:(t_power_usage * power_usage, float in_dens, float in_prob, float size, float period)
power_usage_inverter_irregular	power/power_lowlevel.cpp	/^void power_usage_inverter_irregular(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, float * dyn_power_input, float in_density, float in_probability, float PMOS_size, float NMOS_size, float period)
power_usage_inverter_irregular	power/power_lowlevel.h	/^void power_usage_inverter_irregular(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, float * dyn_power_input, float in_density, float in_probability, float PMOS_size, float NMOS_size, float period)
power_usage_level_restorer	power/power_lowlevel.cpp	/^void power_usage_level_restorer(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, float * dyn_power_in, float in_dens, float in_prob, float period)
power_usage_level_restorer	power/power_lowlevel.h	/^void power_usage_level_restorer(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, float * dyn_power_in, float in_density, float in_probability, float period)
power_usage_local_buffers_and_wires	power/power.cpp	/^static void power_usage_local_buffers_and_wires(t_power_usage * power_usage,$/;"	f	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_node * pb_node, ClusterBlockId iblk)
power_usage_local_buffers_and_wires	power/power.cpp	/^static void power_usage_local_buffers_and_wires(t_power_usage * power_usage,$/;"	p	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_node * pb_node, ClusterBlockId iblk)
power_usage_local_interc_mux	power/power_components.cpp	/^void power_usage_local_interc_mux(t_power_usage * power_usage, t_pb * pb,$/;"	f	signature:(t_power_usage * power_usage, t_pb * pb, t_interconnect_pins * interc_pins, ClusterBlockId iblk)
power_usage_local_interc_mux	power/power_components.h	/^void power_usage_local_interc_mux(t_power_usage * power_usage, t_pb * pb,$/;"	p	signature:(t_power_usage * power_usage, t_pb * pb, t_interconnect_pins * interc_pins, ClusterBlockId iblk)
power_usage_local_pin_buffer_and_wire	power/power.cpp	/^void power_usage_local_pin_buffer_and_wire(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
power_usage_local_pin_buffer_and_wire	power/power.cpp	/^void power_usage_local_pin_buffer_and_wire(t_power_usage * power_usage,$/;"	p	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
power_usage_local_pin_toggle	power/power.cpp	/^void power_usage_local_pin_toggle(t_power_usage * power_usage, t_pb * pb,$/;"	f	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
power_usage_local_pin_toggle	power/power.cpp	/^void power_usage_local_pin_toggle(t_power_usage * power_usage, t_pb * pb,$/;"	p	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_pin * pin, ClusterBlockId iblk)
power_usage_lut	power/power_components.cpp	/^void power_usage_lut(t_power_usage * power_usage, int lut_size,$/;"	f	signature:(t_power_usage * power_usage, int lut_size, float transistor_size, char * SRAM_values, float * input_prob, float * input_dens, float period)
power_usage_lut	power/power_components.h	/^void power_usage_lut(t_power_usage * power_usage, int LUT_size,$/;"	p	signature:(t_power_usage * power_usage, int LUT_size, float transistor_size, char * SRAM_values, float * input_densities, float * input_probabilities, float period)
power_usage_lut_for_callibration	power/power_callibrate.cpp	/^float power_usage_lut_for_callibration(int num_inputs, float transistor_size) {$/;"	f	signature:(int num_inputs, float transistor_size)
power_usage_lut_for_callibration	power/power_callibrate.h	/^float power_usage_lut_for_callibration(int num_inputs, float transistor_size);$/;"	p	signature:(int num_inputs, float transistor_size)
power_usage_mux_for_callibration	power/power_callibrate.cpp	/^float power_usage_mux_for_callibration(int num_inputs, float transistor_size) {$/;"	f	signature:(int num_inputs, float transistor_size)
power_usage_mux_for_callibration	power/power_callibrate.h	/^float power_usage_mux_for_callibration(int num_inputs, float transistor_size);$/;"	p	signature:(int num_inputs, float transistor_size)
power_usage_mux_multilevel	power/power_components.cpp	/^void power_usage_mux_multilevel(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, t_mux_arch * mux_arch, float * in_prob, float * in_dens, int selected_input, bool output_level_restored, float period)
power_usage_mux_multilevel	power/power_components.h	/^void power_usage_mux_multilevel(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, t_mux_arch * mux_arch, float * in_prob, float * in_dens, int selected_input, bool output_level_restored, float period)
power_usage_mux_rec	power/power_components.cpp	/^static void power_usage_mux_rec(t_power_usage * power_usage, float * out_prob,$/;"	f	file:	signature:(t_power_usage * power_usage, float * out_prob, float * out_dens, float * v_out, t_mux_node * mux_node, t_mux_arch * mux_arch, int * selector_values, float * primary_input_prob, float * primary_input_dens, bool v_out_restored, float period)
power_usage_mux_rec	power/power_components.cpp	/^static void power_usage_mux_rec(t_power_usage * power_usage, float * out_prob,$/;"	p	file:	signature:(t_power_usage * power_usage, float * out_prob, float * out_dens, float * v_out, t_mux_node * mux_node, t_mux_arch * mux_arch, int * selector_values, float * primary_input_prob, float * primary_input_dens, bool v_out_restored, float period)
power_usage_mux_singlelevel_dynamic	power/power_lowlevel.cpp	/^void power_usage_mux_singlelevel_dynamic(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, int num_inputs, float out_density, float v_out, float * in_prob, float * in_dens, float * v_in, float sel_dens, float sel_prob, float transistor_size, float period)
power_usage_mux_singlelevel_dynamic	power/power_lowlevel.h	/^void power_usage_mux_singlelevel_dynamic(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, int num_inputs, float out_density, float v_out, float * in_prob, float * in_density, float * v_in, float sel_dens, float sel_prob, float transistor_size, float period)
power_usage_mux_singlelevel_static	power/power_lowlevel.cpp	/^void power_usage_mux_singlelevel_static(t_power_usage * power_usage,$/;"	f	signature:(t_power_usage * power_usage, float * out_prob, float * out_dens, float * v_out, int num_inputs, int selected_idx, float * in_prob, float * in_dens, float * v_in, float transistor_size, bool v_out_restored, float period)
power_usage_mux_singlelevel_static	power/power_lowlevel.h	/^void power_usage_mux_singlelevel_static(t_power_usage * power_usage,$/;"	p	signature:(t_power_usage * power_usage, float * out_prob, float * out_dens, float * V_out, int num_inputs, int selected_idx, float * in_prob, float * in_dens, float * v_in, float transistor_size, bool v_out_restored, float period)
power_usage_pb	power/power.cpp	/^static void power_usage_pb(t_power_usage * power_usage, t_pb * pb,$/;"	f	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_node * pb_node, ClusterBlockId iblk)
power_usage_pb	power/power.cpp	/^static void power_usage_pb(t_power_usage * power_usage, t_pb * pb,$/;"	p	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_node * pb_node, ClusterBlockId iblk)
power_usage_primitive	power/power.cpp	/^static void power_usage_primitive(t_power_usage * power_usage, t_pb * pb,$/;"	f	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_node * pb_graph_node, ClusterBlockId iblk)
power_usage_primitive	power/power.cpp	/^static void power_usage_primitive(t_power_usage * power_usage, t_pb * pb,$/;"	p	file:	signature:(t_power_usage * power_usage, t_pb * pb, t_pb_graph_node * pb_graph_node, ClusterBlockId iblk)
power_usage_routing	power/power.cpp	/^static void power_usage_routing(t_power_usage * power_usage,$/;"	f	file:	signature:(t_power_usage * power_usage, const t_det_routing_arch * routing_arch, t_segment_inf * segment_inf)
power_usage_routing	power/power.cpp	/^static void power_usage_routing(t_power_usage * power_usage,$/;"	p	file:	signature:(t_power_usage * power_usage, const t_det_routing_arch * routing_arch, t_segment_inf * segment_inf)
power_usage_wire	power/power_lowlevel.cpp	/^void power_usage_wire(t_power_usage * power_usage, float capacitance,$/;"	f	signature:(t_power_usage * power_usage, float capacitance, float density, float period)
power_usage_wire	power/power_lowlevel.h	/^void power_usage_wire(t_power_usage * power_usage, float capacitance,$/;"	p	signature:(t_power_usage * power_usage, float capacitance, float density, float period)
power_zero_usage	power/power_util.cpp	/^void power_zero_usage(t_power_usage * power_usage) {$/;"	f	signature:(t_power_usage * power_usage)
power_zero_usage	power/power_util.h	/^void power_zero_usage(t_power_usage * power_usage);$/;"	p	signature:(t_power_usage * power_usage)
precedence	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			int precedence;$/;"	m	struct:xpath_parser::binary_op_t	file:	access:public
precision_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::streamsize precision_;$/;"	m	class:vtr::OsFormatGuard	access:private
predef_colors	../../libs/libeasygl/src/graphics_types.cpp	/^const std::array<t_color,NUM_COLOR> t_color::predef_colors = {$/;"	m	class:t_color	file:
predef_colors	../../libs/libeasygl/src/graphics_types.h	/^    static const std::array<t_color,NUM_COLOR> predef_colors;$/;"	m	class:t_color	access:public
predicate_constant	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		predicate_constant,$/;"	e	enum:predicate_t	file:
predicate_constant_one	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		predicate_constant_one$/;"	e	enum:predicate_t	file:
predicate_default	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		predicate_default,$/;"	e	enum:predicate_t	file:
predicate_posinv	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		predicate_posinv,$/;"	e	enum:predicate_t	file:
predicate_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	enum predicate_t$/;"	g	file:
prefix	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* prefix;$/;"	m	struct:namespace_uri_predicate	file:	access:public
prefix_length	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t prefix_length;$/;"	m	struct:namespace_uri_predicate	file:	access:public
prepacked_data	base/vpr_types.h	/^	t_prepacked_tnode_data * prepacked_data;$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
prepare_routing_for_net	route/connection_based_routing.h	/^	void prepare_routing_for_net(ClusterNetId inet) {$/;"	f	class:Connection_based_routing_resources	access:public	signature:(ClusterNetId inet)
prepend_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::prepend_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
prepend_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void prepend_attribute(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f	signature:(xml_attribute_struct* attr, xml_node_struct* node)
prepend_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute prepend_attribute(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_child(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_child(xml_node_type type_)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_)
prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_child(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_child(xml_node_type type = node_element);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type = node_element)
prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::prepend_copy(const xml_attribute& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto)
prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_copy(const xml_node& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto)
prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute prepend_copy(const xml_attribute& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto)
prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_copy(const xml_node& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto)
prepend_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_move(const xml_node& moved)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved)
prepend_move	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_move(const xml_node& moved);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved)
prepend_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void prepend_node(xml_node_struct* child, xml_node_struct* node)$/;"	f	signature:(xml_node_struct* child, xml_node_struct* node)
pres_con_fac	pack/pack_types.h	/^	float pres_con_fac;$/;"	m	struct:t_lb_router_data	access:public
pres_cost	base/vpr_types.h	/^	float pres_cost;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
pres_fac	pack/pack_types.h	/^	float pres_fac;$/;"	m	struct:t_lb_router_params	access:public
pres_fac_mult	base/read_options.h	/^    argparse::ArgValue<float> pres_fac_mult;$/;"	m	struct:t_options	access:public
pres_fac_mult	base/vpr_types.h	/^	float pres_fac_mult;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
pres_fac_mult	pack/pack_types.h	/^	float pres_fac_mult;$/;"	m	struct:t_lb_router_params	access:public
pretty_print_float	route/route_timing.cpp	/^static void pretty_print_float(const char* prefix, double value, int num_digits, int scientific_precision) {$/;"	f	file:	signature:(const char* prefix, double value, int num_digits, int scientific_precision)
pretty_print_float	route/route_timing.cpp	/^static void pretty_print_float(const char* prefix, double value, int num_digits, int scientific_precision);$/;"	p	file:	signature:(const char* prefix, double value, int num_digits, int scientific_precision)
pretty_print_uint	route/route_timing.cpp	/^static void pretty_print_uint(const char* prefix, size_t value, int num_digits, int scientific_precision) {$/;"	f	file:	signature:(const char* prefix, size_t value, int num_digits, int scientific_precision)
pretty_print_uint	route/route_timing.cpp	/^static void pretty_print_uint(const char* prefix, size_t value, int num_digits, int scientific_precision);$/;"	p	file:	signature:(const char* prefix, size_t value, int num_digits, int scientific_precision)
prev	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* prev;$/;"	m	struct:xml_memory_page	file:	access:public
prev_attribute_c	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_attribute_struct, 6> prev_attribute_c;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
prev_edge	base/vpr_types.h	/^	short prev_edge;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
prev_edge	pack/pack_types.h	/^	int prev_edge;			\/* index of previous edge that drives current node *\/$/;"	m	struct:t_lb_traceback	access:public
prev_index	pack/pack_types.h	/^	int prev_index;			\/* Prevous node that drives this one *\/$/;"	m	struct:t_explored_node_tb	access:public
prev_index	pack/pack_types.h	/^	int prev_index;		\/* Index of logic cluster_ctx.blocks rr node that drives this expansion node *\/$/;"	m	struct:t_expansion_node	access:public
prev_lb_rr_node	pack/pack_types.h	/^	int prev_lb_rr_node;	\/* index of previous node that drives current node *\/$/;"	m	struct:t_lb_traceback	access:public
prev_node	base/vpr_types.h	/^	int prev_node;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
prev_sibling_c	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_node_struct,  9>    prev_sibling_c;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
previous	route/route_common.h	/^    std::vector<t_heap_prev> previous;$/;"	m	struct:t_heap	access:public
previous_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_attribute::previous_attribute() const$/;"	f	class:pugi::xml_attribute	signature:() const
previous_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute previous_attribute() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::previous_sibling() const$/;"	f	class:pugi::xml_node	signature:() const
previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::previous_sibling(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node previous_sibling() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node previous_sibling(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
previous_x	../../libs/libeasygl/src/graphics.cpp	/^    int previous_x, previous_y;$/;"	m	struct:__anon21	file:	access:public
previous_y	../../libs/libeasygl/src/graphics.cpp	/^    int previous_x, previous_y;$/;"	m	struct:__anon21	file:	access:public
prim_comb_delay	timing/PreClusterDelayCalculator.h	/^    tatum::Time prim_comb_delay(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const
prim_tcq_delay	timing/PreClusterDelayCalculator.h	/^    tatum::Time prim_tcq_delay(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const {$/;"	f	class:PreClusterDelayCalculator	access:private	signature:(const tatum::TimingGraph& tg, tatum::NodeId src_node, tatum::NodeId sink_node) const
primitive_feasible	pack/cluster.cpp	/^static bool primitive_feasible(const AtomBlockId blk_id, t_pb *cur_pb) {$/;"	f	file:	signature:(const AtomBlockId blk_id, t_pb *cur_pb)
primitive_feasible	pack/cluster.cpp	/^static bool primitive_feasible(const AtomBlockId blk_id, t_pb *cur_pb);$/;"	p	file:	signature:(const AtomBlockId blk_id, t_pb *cur_pb)
primitive_memory_sibling_feasible	pack/cluster.cpp	/^static bool primitive_memory_sibling_feasible(const AtomBlockId blk_id, const t_pb_type *cur_pb_type, const AtomBlockId sibling_blk_id) {$/;"	f	file:	signature:(const AtomBlockId blk_id, const t_pb_type *cur_pb_type, const AtomBlockId sibling_blk_id)
primitive_memory_sibling_feasible	pack/cluster.cpp	/^static bool primitive_memory_sibling_feasible(const AtomBlockId blk_id, const t_pb_type *cur_pb_type, const AtomBlockId sibling_memory_blk);$/;"	p	file:	signature:(const AtomBlockId blk_id, const t_pb_type *cur_pb_type, const AtomBlockId sibling_memory_blk)
primitive_type_feasible	util/vpr_utils.cpp	/^bool primitive_type_feasible(const AtomBlockId blk_id, const t_pb_type *cur_pb_type) {$/;"	f	signature:(const AtomBlockId blk_id, const t_pb_type *cur_pb_type)
primitive_type_feasible	util/vpr_utils.h	/^bool primitive_type_feasible(AtomBlockId blk_id, const t_pb_type *cur_pb_type);$/;"	p	signature:(AtomBlockId blk_id, const t_pb_type *cur_pb_type)
primitives_annotation_clock_match	../../libs/libarchfpga/src/arch_util.cpp	/^void primitives_annotation_clock_match($/;"	f	signature:( t_pin_to_pin_annotation *annotation, t_pb_type * parent_pb_type)
primitives_annotation_clock_match	../../libs/libarchfpga/src/arch_util.h	/^void primitives_annotation_clock_match($/;"	p	signature:( t_pin_to_pin_annotation *annotation, t_pb_type * parent_pb_type)
print	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_node::print(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const$/;"	f	class:pugi::xml_node	signature:(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
print	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_node::print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const$/;"	f	class:pugi::xml_node	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const
print	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_node::print(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const$/;"	f	class:pugi::xml_node	signature:(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
print	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const
print	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, unsigned int depth = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, unsigned int depth = 0) const
print	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void print(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(xml_writer& writer, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const
print	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::print(FILE * fp) {$/;"	f	class:PowerSpicedComponent	signature:(FILE * fp)
print	power/PowerSpicedComponent.h	/^	void print(FILE * fp);$/;"	p	class:PowerSpicedComponent	access:public	signature:(FILE * fp)
printClusteredNetlistStats	base/ShowSetup.cpp	/^void printClusteredNetlistStats() {$/;"	f	signature:()
printClusteredNetlistStats	base/ShowSetup.h	/^void printClusteredNetlistStats();$/;"	p	signature:()
print_atom_block	pack/output_blif.cpp	/^void print_atom_block(FILE *fpout, AtomBlockId atom_blk) {$/;"	f	signature:(FILE *fpout, AtomBlockId atom_blk)
print_atom_block	pack/output_blif.cpp	/^void print_atom_block(FILE *fpout, AtomBlockId atom_blk);$/;"	p	file:	signature:(FILE *fpout, AtomBlockId atom_blk)
print_blif	base/netlist_writer.cpp	/^        virtual void print_blif(std::ostream& os, size_t& unconn_count, int depth=0) = 0;$/;"	p	class:Instance	file:	access:public	signature:(std::ostream& os, size_t& unconn_count, int depth=0)
print_blif	base/netlist_writer.cpp	/^        void print_blif(int depth=0) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(int depth=0)
print_blif	base/netlist_writer.cpp	/^        void print_blif(std::ostream& os, std::string indent) {$/;"	f	class:Assignment	access:public	signature:(std::ostream& os, std::string indent)
print_blif_port	base/netlist_writer.cpp	/^void print_blif_port(std::ostream& os, size_t& unconn_count, const std::string& port_name, const std::vector<std::string>& nets, int depth) {$/;"	f	signature:(std::ostream& os, size_t& unconn_count, const std::string& port_name, const std::vector<std::string>& nets, int depth)
print_blif_port	base/netlist_writer.cpp	/^void print_blif_port(std::ostream& os, size_t& unconn_count, const std::string& port_name, const std::vector<std::string>& nets, int depth);$/;"	p	file:	signature:(std::ostream& os, size_t& unconn_count, const std::string& port_name, const std::vector<std::string>& nets, int depth)
print_channel_stats	route/channel_stats.cpp	/^void print_channel_stats() {$/;"	f	signature:()
print_channel_stats	route/channel_stats.h	/^void print_channel_stats();$/;"	p	signature:()
print_classic_cpds	timing/path_delay.cpp	/^void print_classic_cpds() {$/;"	f	signature:()
print_classic_cpds	timing/path_delay.h	/^void print_classic_cpds();$/;"	p	signature:()
print_clb_placement	place/place.cpp	/^	static void print_clb_placement(const char *fname);$/;"	p	file:	signature:(const char *fname)
print_clb_placement	place/place.cpp	/^static void print_clb_placement(const char *fname) {$/;"	f	file:	signature:(const char *fname)
print_clustering_timing_info	timing/path_delay.cpp	/^void print_clustering_timing_info(const char *fname) {$/;"	f	signature:(const char *fname)
print_clustering_timing_info	timing/path_delay.h	/^void print_clustering_timing_info(const char *fname);$/;"	p	signature:(const char *fname)
print_comb_loop	timing/path_delay2.cpp	/^void print_comb_loop(std::vector<int>& loop_tnodes) {$/;"	f	signature:(std::vector<int>& loop_tnodes)
print_comb_loop	timing/path_delay2.cpp	/^void print_comb_loop(std::vector<int>& loop_tnodes);$/;"	p	file:	signature:(std::vector<int>& loop_tnodes)
print_cost_map	route/router_lookahead_map.cpp	/^static void print_cost_map() {$/;"	f	file:	signature:()
print_cost_map	route/router_lookahead_map.cpp	/^static void print_cost_map();$/;"	p	file:	signature:()
print_critical_path	timing/path_delay.cpp	/^void print_critical_path(const char *fname, const t_timing_inf &timing_inf) {$/;"	f	signature:(const char *fname, const t_timing_inf &timing_inf)
print_critical_path	timing/path_delay.h	/^void print_critical_path(const char *fname, const t_timing_inf &timing_inf);$/;"	p	signature:(const char *fname, const t_timing_inf &timing_inf)
print_critical_path_node	timing/path_delay2.cpp	/^float print_critical_path_node(FILE * fp, vtr::t_linked_int * critical_path_node, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping) {$/;"	f	signature:(FILE * fp, vtr::t_linked_int * critical_path_node, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
print_critical_path_node	timing/path_delay2.h	/^float print_critical_path_node(FILE * fp, vtr::t_linked_int * critical_path_node, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping);$/;"	p	signature:(FILE * fp, vtr::t_linked_int * critical_path_node, vtr::vector<ClusterBlockId, t_pb **> &pin_id_to_pb_mapping)
print_criticality	timing/path_delay.cpp	/^void print_criticality(t_slack * slacks, const char *fname) {$/;"	f	signature:(t_slack * slacks, const char *fname)
print_criticality	timing/path_delay.h	/^void print_criticality(t_slack * slacks, const char *fname);$/;"	p	signature:(t_slack * slacks, const char *fname)
print_edge	route/route_tree_timing.cpp	/^void print_edge(const t_linked_rt_edge* edge) {$/;"	f	signature:(const t_linked_rt_edge* edge)
print_edge	route/route_tree_timing.h	/^void print_edge(const t_linked_rt_edge* edge);$/;"	p	signature:(const t_linked_rt_edge* edge)
print_endpoint_timing	timing/endpoint_timing.cpp	/^void print_endpoint_timing(char* filename) {$/;"	f	signature:(char* filename)
print_endpoint_timing	timing/endpoint_timing.h	/^void print_endpoint_timing(char* filename);$/;"	p	signature:(char* filename)
print_global_criticality_stats	timing/path_delay.cpp	/^static void print_global_criticality_stats(FILE * fp, float ** criticality, const char * singular_name, const char * capitalized_plural_name) {$/;"	f	file:	signature:(FILE * fp, float ** criticality, const char * singular_name, const char * capitalized_plural_name)
print_global_criticality_stats	timing/path_delay.cpp	/^static void print_global_criticality_stats(FILE * fp, float ** criticality, const char * singular_name, const char * capitalized_plural_name);$/;"	p	file:	signature:(FILE * fp, float ** criticality, const char * singular_name, const char * capitalized_plural_name)
print_heap	route/route_common.cpp	/^	void print_heap() {$/;"	f	namespace:heap_	signature:()
print_heap	route/route_common.h	/^	void print_heap();$/;"	p	namespace:heap_	signature:()
print_help	../../libs/libarchfpga/src/main.cpp	/^void print_help() {$/;"	f	signature:()
print_help	../../libs/libarchfpga/src/main.cpp	/^void print_help();$/;"	p	file:	signature:()
print_histogram	util/histogram.cpp	/^void print_histogram(std::vector<HistogramBucket> histogram) {$/;"	f	signature:(std::vector<HistogramBucket> histogram)
print_histogram	util/histogram.h	/^void print_histogram(std::vector<HistogramBucket> histogram);$/;"	p	signature:(std::vector<HistogramBucket> histogram)
print_hold_timing_summary	timing/timing_util.cpp	/^void print_hold_timing_summary(const tatum::TimingConstraints& constraints, const tatum::HoldTimingAnalyzer& hold_analyzer) {$/;"	f	signature:(const tatum::TimingConstraints& constraints, const tatum::HoldTimingAnalyzer& hold_analyzer)
print_hold_timing_summary	timing/timing_util.h	/^void print_hold_timing_summary(const tatum::TimingConstraints& constraints, const tatum::HoldTimingAnalyzer& hold_analyzer);$/;"	p	signature:(const tatum::TimingConstraints& constraints, const tatum::HoldTimingAnalyzer& hold_analyzer)
print_invalid_routing_info	route/route_common.cpp	/^void print_invalid_routing_info() {$/;"	f	signature:()
print_invalid_routing_info	route/route_common.h	/^void print_invalid_routing_info();$/;"	p	signature:()
print_lambda	base/stats.cpp	/^void print_lambda() {$/;"	f	signature:()
print_lambda	base/stats.h	/^void print_lambda();$/;"	p	signature:()
print_lb_type_rr_graph	pack/lb_type_rr_graph.cpp	/^static void print_lb_type_rr_graph(FILE *fp, const std::vector<t_lb_type_rr_node> &lb_type_rr_graph) {$/;"	f	file:	signature:(FILE *fp, const std::vector<t_lb_type_rr_node> &lb_type_rr_graph)
print_lb_type_rr_graph	pack/lb_type_rr_graph.cpp	/^static void print_lb_type_rr_graph(FILE *fp, const std::vector<t_lb_type_rr_node> &lb_type_rr_graph);$/;"	p	file:	signature:(FILE *fp, const std::vector<t_lb_type_rr_node> &lb_type_rr_graph)
print_models	pack/output_blif.cpp	/^void print_models(FILE *fpout, t_model *user_models) {$/;"	f	signature:(FILE *fpout, t_model *user_models)
print_models	pack/output_blif.cpp	/^void print_models(FILE *fpout, t_model *user_models);$/;"	p	file:	signature:(FILE *fpout, t_model *user_models)
print_net_delay	timing/path_delay.cpp	/^void print_net_delay(vtr::vector<ClusterNetId, float *> &net_delay, const char *fname) {$/;"	f	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const char *fname)
print_net_delay	timing/path_delay.h	/^void print_net_delay(vtr::vector<ClusterNetId, float *> &net_delay, const char *fname);$/;"	p	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const char *fname)
print_net_name	pack/output_blif.cpp	/^static void print_net_name(AtomNetId net_id, int *column, FILE * fpout) {$/;"	f	file:	signature:(AtomNetId net_id, int *column, FILE * fpout)
print_netlist_as_blif	base/atom_netlist_utils.cpp	/^void print_netlist_as_blif(FILE* f, const AtomNetlist& netlist) {$/;"	f	signature:(FILE* f, const AtomNetlist& netlist)
print_netlist_as_blif	base/atom_netlist_utils.cpp	/^void print_netlist_as_blif(std::string filename, const AtomNetlist& netlist) {$/;"	f	signature:(std::string filename, const AtomNetlist& netlist)
print_netlist_as_blif	base/atom_netlist_utils.h	/^void print_netlist_as_blif(FILE* f, const AtomNetlist& netlist);$/;"	p	signature:(FILE* f, const AtomNetlist& netlist)
print_netlist_as_blif	base/atom_netlist_utils.h	/^void print_netlist_as_blif(std::string filename, const AtomNetlist& netlist);$/;"	p	signature:(std::string filename, const AtomNetlist& netlist)
print_netlist_clock_info	base/atom_netlist_utils.cpp	/^void print_netlist_clock_info(const AtomNetlist& netlist) {$/;"	f	signature:(const AtomNetlist& netlist)
print_netlist_clock_info	base/atom_netlist_utils.h	/^void print_netlist_clock_info(const AtomNetlist& netlist);$/;"	p	signature:(const AtomNetlist& netlist)
print_node	route/route_tree_timing.cpp	/^static void print_node(const t_rt_node* rt_node) {$/;"	f	file:	signature:(const t_rt_node* rt_node)
print_node_congestion	route/route_tree_timing.cpp	/^static void print_node_congestion(const t_rt_node* rt_node) {$/;"	f	file:	signature:(const t_rt_node* rt_node)
print_node_inf	route/route_tree_timing.cpp	/^static void print_node_inf(const t_rt_node* rt_node) {$/;"	f	file:	signature:(const t_rt_node* rt_node)
print_pack_molecules	pack/prepack.cpp	/^static void print_pack_molecules(const char *fname,$/;"	f	file:	signature:(const char *fname, const t_pack_patterns *list_of_pack_patterns, const int num_pack_patterns, const t_pack_molecule *list_of_molecules)
print_pack_molecules	pack/prepack.cpp	/^static void print_pack_molecules(const char *fname,$/;"	p	file:	signature:(const char *fname, const t_pack_patterns *list_of_pack_patterns, const int num_pack_patterns, const t_pack_molecule *list_of_molecules)
print_path_criticality	timing/path_delay.h	/^void print_path_criticality(float ** path_criticality, const char *fname);$/;"	p	signature:(float ** path_criticality, const char *fname)
print_place	base/read_place.cpp	/^void print_place(const char* net_file,$/;"	f	signature:(const char* net_file, const char* net_id, const char* place_file)
print_place	base/read_place.h	/^void print_place(const char* net_file,$/;"	p	signature:(const char* net_file, const char* net_id, const char* place_file)
print_route	pack/cluster_router.cpp	/^static void print_route(const char *filename, t_lb_router_data *router_data) {$/;"	f	file:	signature:(const char *filename, t_lb_router_data *router_data)
print_route	pack/cluster_router.cpp	/^static void print_route(const char *filename, t_lb_router_data *router_data);$/;"	p	file:	signature:(const char *filename, t_lb_router_data *router_data)
print_route	route/route_common.cpp	/^void print_route(FILE* fp, const vtr::vector<ClusterNetId,t_traceback>& tracebacks) {$/;"	f	signature:(FILE* fp, const vtr::vector<ClusterNetId,t_traceback>& tracebacks)
print_route	route/route_common.cpp	/^void print_route(const char* placement_file, const char* route_file) {$/;"	f	signature:(const char* placement_file, const char* route_file)
print_route	route/route_export.h	/^void print_route(FILE* fp, const vtr::vector<ClusterNetId,t_traceback>& tracebacks);$/;"	p	signature:(FILE* fp, const vtr::vector<ClusterNetId,t_traceback>& tracebacks)
print_route	route/route_export.h	/^void print_route(const char* place_file, const char* route_file);$/;"	p	signature:(const char* place_file, const char* route_file)
print_route_budget	route/route_budgets.cpp	/^void route_budgets::print_route_budget() {$/;"	f	class:route_budgets	signature:()
print_route_budget	route/route_budgets.h	/^    void print_route_budget();$/;"	p	class:route_budgets	access:public	signature:()
print_route_status	route/route_timing.cpp	/^static void print_route_status(int itry, double elapsed_sec, float pres_fac, int num_bb_updated, const RouterStats& router_stats,$/;"	f	file:	signature:(int itry, double elapsed_sec, float pres_fac, int num_bb_updated, const RouterStats& router_stats, const OveruseInfo& overuse_info, const WirelengthInfo& wirelength_info, std::shared_ptr<const SetupHoldTimingInfo> timing_info, float est_success_iteration)
print_route_status	route/route_timing.cpp	/^static void print_route_status(int itry, double elapsed_sec, float pres_fac, int num_bb_updated, const RouterStats& router_stats,$/;"	p	file:	signature:(int itry, double elapsed_sec, float pres_fac, int num_bb_updated, const RouterStats& router_stats, const OveruseInfo& overuse_info, const WirelengthInfo& wirelength_info, std::shared_ptr<const SetupHoldTimingInfo> timing_info, float est_success_iteration)
print_route_status_header	route/route_timing.cpp	/^static void print_route_status_header() {$/;"	f	file:	signature:()
print_route_status_header	route/route_timing.cpp	/^static void print_route_status_header();$/;"	p	file:	signature:()
print_route_tree	route/route_tree_timing.cpp	/^void print_route_tree(const t_rt_node* rt_node, int depth) {$/;"	f	signature:(const t_rt_node* rt_node, int depth)
print_route_tree	route/route_tree_timing.cpp	/^void print_route_tree(const t_rt_node* rt_root) {$/;"	f	signature:(const t_rt_node* rt_root)
print_route_tree	route/route_tree_timing.h	/^void print_route_tree(const t_rt_node* rt_node, int depth=0);$/;"	p	signature:(const t_rt_node* rt_node, int depth=0)
print_route_tree	route/route_tree_timing.h	/^void print_route_tree(const t_rt_node* rt_root);$/;"	p	signature:(const t_rt_node* rt_root)
print_route_tree_congestion	route/route_tree_timing.cpp	/^void print_route_tree_congestion(const t_rt_node* rt_root) {$/;"	f	signature:(const t_rt_node* rt_root)
print_route_tree_congestion	route/route_tree_timing.h	/^void print_route_tree_congestion(const t_rt_node* rt_root);$/;"	p	signature:(const t_rt_node* rt_root)
print_route_tree_inf	route/route_tree_timing.cpp	/^void print_route_tree_inf(const t_rt_node* rt_root) {$/;"	f	signature:(const t_rt_node* rt_root)
print_route_tree_inf	route/route_tree_timing.h	/^void print_route_tree_inf(const t_rt_node* rt_root);$/;"	p	signature:(const t_rt_node* rt_root)
print_routing_in_clusters	pack/output_blif.cpp	/^void print_routing_in_clusters(FILE *fpout, ClusterBlockId clb_index) {$/;"	f	signature:(FILE *fpout, ClusterBlockId clb_index)
print_routing_in_clusters	pack/output_blif.cpp	/^void print_routing_in_clusters(FILE *fpout, ClusterBlockId clb_index);$/;"	p	file:	signature:(FILE *fpout, ClusterBlockId clb_index)
print_rr_indexed_data	route/rr_graph.cpp	/^void print_rr_indexed_data(FILE * fp, int index) {$/;"	f	signature:(FILE * fp, int index)
print_rr_indexed_data	route/rr_graph.h	/^void print_rr_indexed_data(FILE * fp, int index); \/* For debugging only *\/$/;"	p	signature:(FILE * fp, int index)
print_rr_node	route/rr_graph.cpp	/^void print_rr_node(FILE * fp, const std::vector<t_rr_node> &L_rr_node, int inode) {$/;"	f	signature:(FILE * fp, const std::vector<t_rr_node> &L_rr_node, int inode)
print_rr_node	route/rr_graph.h	/^void print_rr_node(FILE *fp, const std::vector<t_rr_node> &L_rr_node, int inode);$/;"	p	signature:(FILE *fp, const std::vector<t_rr_node> &L_rr_node, int inode)
print_rr_node_route_inf	route/route_common.cpp	/^void print_rr_node_route_inf() {$/;"	f	signature:()
print_rr_node_route_inf	route/route_common.h	/^void print_rr_node_route_inf();$/;"	p	signature:()
print_rr_node_route_inf_dot	route/route_common.cpp	/^void print_rr_node_route_inf_dot() {$/;"	f	signature:()
print_rr_node_route_inf_dot	route/route_common.h	/^void print_rr_node_route_inf_dot();$/;"	p	signature:()
print_sdf	base/netlist_writer.cpp	/^        virtual void print_sdf(std::ostream& os, int depth=0) = 0;$/;"	p	class:Instance	file:	access:public	signature:(std::ostream& os, int depth=0)
print_sdf	base/netlist_writer.cpp	/^        void print_sdf(int depth=0) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(int depth=0)
print_seed_gains	pack/cluster.cpp	/^static void print_seed_gains(const char * fname, const std::vector<AtomBlockId>& seed_atoms, const vtr::vector<AtomBlockId,float>& atom_gain, const vtr::vector<AtomBlockId,float>& atom_criticality) {$/;"	f	file:	signature:(const char * fname, const std::vector<AtomBlockId>& seed_atoms, const vtr::vector<AtomBlockId,float>& atom_gain, const vtr::vector<AtomBlockId,float>& atom_criticality)
print_seed_gains	pack/cluster.cpp	/^static void print_seed_gains(const char * fname, const std::vector<AtomBlockId>& seed_atoms, const vtr::vector<AtomBlockId,float>& atom_gain, const vtr::vector<AtomBlockId,float>& atom_criticality);$/;"	p	file:	signature:(const char * fname, const std::vector<AtomBlockId>& seed_atoms, const vtr::vector<AtomBlockId,float>& atom_gain, const vtr::vector<AtomBlockId,float>& atom_criticality)
print_setup_timing_summary	timing/timing_util.cpp	/^void print_setup_timing_summary(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer) {$/;"	f	signature:(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer)
print_setup_timing_summary	timing/timing_util.h	/^void print_setup_timing_summary(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer);$/;"	p	signature:(const tatum::TimingConstraints& constraints, const tatum::SetupTimingAnalyzer& setup_analyzer)
print_slack	timing/path_delay.cpp	/^void print_slack(float ** slack, bool slack_is_normalized, const char *fname) {$/;"	f	signature:(float ** slack, bool slack_is_normalized, const char *fname)
print_slack	timing/path_delay.h	/^void print_slack(float ** slack, bool slack_is_normalized, const char *fname);$/;"	p	signature:(float ** slack, bool slack_is_normalized, const char *fname)
print_spaces	timing/path_delay.cpp	/^static void print_spaces(FILE * fp, int num_spaces) {$/;"	f	file:	signature:(FILE * fp, int num_spaces)
print_spaces	timing/path_delay.cpp	/^static void print_spaces(FILE * fp, int num_spaces);$/;"	p	file:	signature:(FILE * fp, int num_spaces)
print_stats	base/netlist.h	/^        void print_stats() const;$/;"	p	class:Netlist	access:public	signature:() const
print_stats	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::print_stats() const {$/;"	f	class:Netlist	signature:() const
print_stats	pack/output_clustering.cpp	/^static void print_stats() {$/;"	f	file:	signature:()
print_string	pack/output_blif.cpp	/^static void print_string(const char *str_ptr, int *column, FILE * fpout) {$/;"	f	file:	signature:(const char *str_ptr, int *column, FILE * fpout)
print_switch_histogram	route/cb_metrics.cpp	/^static void print_switch_histogram(const int nodes_per_chan, const Conn_Block_Metrics *cb_metrics);$/;"	p	file:	signature:(const int nodes_per_chan, const Conn_Block_Metrics *cb_metrics)
print_switch_histogram	route/cb_metrics.cpp	/^static void print_switch_histogram(const int nodes_per_chan, const Conn_Block_Metrics *cb_metrics){$/;"	f	file:	signature:(const int nodes_per_chan, const Conn_Block_Metrics *cb_metrics)
print_switch_usage	util/vpr_utils.cpp	/^void print_switch_usage() {$/;"	f	signature:()
print_switch_usage	util/vpr_utils.h	/^void print_switch_usage();$/;"	p	signature:()
print_tabs	util/vpr_utils.cpp	/^void print_tabs(FILE * fpout, int num_tab) {$/;"	f	signature:(FILE * fpout, int num_tab)
print_tabs	util/vpr_utils.h	/^void print_tabs(FILE * fpout, int num_tab);$/;"	p	signature:(FILE * fpout, int num_tab)
print_tatum_cpds	timing/timing_util.cpp	/^void print_tatum_cpds(std::vector<tatum::TimingPathInfo> cpds) {$/;"	f	signature:(std::vector<tatum::TimingPathInfo> cpds)
print_tatum_cpds	timing/timing_util.h	/^void print_tatum_cpds(std::vector<tatum::TimingPathInfo> cpds);$/;"	p	signature:(std::vector<tatum::TimingPathInfo> cpds)
print_temporary_budgets_to_file	route/route_budgets.cpp	/^void route_budgets::print_temporary_budgets_to_file(vtr::vector<ClusterNetId, float *> &temp_budgets) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
print_temporary_budgets_to_file	route/route_budgets.h	/^    void print_temporary_budgets_to_file(vtr::vector<ClusterNetId, float *> &temp_budgets);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
print_timing_constraint_info	timing/path_delay.cpp	/^static void print_timing_constraint_info(const char *fname) {$/;"	f	file:	signature:(const char *fname)
print_timing_constraint_info	timing/path_delay.cpp	/^static void print_timing_constraint_info(const char *fname);$/;"	p	file:	signature:(const char *fname)
print_timing_graph	timing/path_delay.cpp	/^void print_timing_graph(const char *fname) {$/;"	f	signature:(const char *fname)
print_timing_graph	timing/path_delay.h	/^void print_timing_graph(const char *fname);$/;"	p	signature:(const char *fname)
print_timing_stats	timing/path_delay.cpp	/^void print_timing_stats() {$/;"	f	signature:()
print_timing_stats	timing/path_delay.h	/^void print_timing_stats();$/;"	p	signature:()
print_tnode_info	timing/endpoint_timing.cpp	/^void print_tnode_info(FILE* fp, int inode, const char* identifier) {$/;"	f	signature:(FILE* fp, int inode, const char* identifier)
print_tnode_info	timing/endpoint_timing.cpp	/^void print_tnode_info(FILE* fp, int inode, const char* identifier);$/;"	p	file:	signature:(FILE* fp, int inode, const char* identifier)
print_trace	pack/cluster_router.cpp	/^static void print_trace(FILE *fp, t_lb_trace *trace) {$/;"	f	file:	signature:(FILE *fp, t_lb_trace *trace)
print_trace	pack/cluster_router.cpp	/^static void print_trace(FILE *fp, t_lb_trace *trace);$/;"	p	file:	signature:(FILE *fp, t_lb_trace *trace)
print_traceback	route/route_common.cpp	/^void print_traceback(ClusterNetId net_id) {$/;"	f	signature:(ClusterNetId net_id)
print_traceback	route/route_common.cpp	/^void print_traceback(const t_trace* trace) {$/;"	f	signature:(const t_trace* trace)
print_traceback	route/route_common.h	/^void print_traceback(ClusterNetId net_id);$/;"	p	signature:(ClusterNetId net_id)
print_traceback	route/route_common.h	/^void print_traceback(const t_trace* trace);$/;"	p	signature:(const t_trace* trace)
print_usage_by_wire_length	util/vpr_utils.h	/^void print_usage_by_wire_length();$/;"	p	signature:()
print_verilog	base/netlist_writer.cpp	/^        virtual void print_verilog(std::ostream& os, int depth=0) = 0;$/;"	p	class:Instance	file:	access:public	signature:(std::ostream& os, int depth=0)
print_verilog	base/netlist_writer.cpp	/^        void print_verilog(int depth=0) {$/;"	f	class:NetlistWriterVisitor	file:	access:private	signature:(int depth=0)
print_verilog	base/netlist_writer.cpp	/^        void print_verilog(std::ostream& os, std::string indent) {$/;"	f	class:Assignment	access:public	signature:(std::ostream& os, std::string indent)
print_verilog_port	base/netlist_writer.cpp	/^void print_verilog_port(std::ostream& os, const std::string& port_name, const std::vector<std::string>& nets, PortType type, int depth) {$/;"	f	signature:(std::ostream& os, const std::string& port_name, const std::vector<std::string>& nets, PortType type, int depth)
print_verilog_port	base/netlist_writer.cpp	/^void print_verilog_port(std::ostream& os, const std::string& port_name, const std::vector<std::string>& nets, PortType type, int depth);$/;"	p	file:	signature:(std::ostream& os, const std::string& port_name, const std::vector<std::string>& nets, PortType type, int depth)
print_wirelen_prob_dist	base/stats.cpp	/^void print_wirelen_prob_dist() {$/;"	f	signature:()
print_wirelen_prob_dist	base/stats.h	/^void print_wirelen_prob_dist();$/;"	p	signature:()
print_xbar	route/cb_metrics.cpp	/^static void print_xbar( t_xbar_matrix *xbar ){$/;"	f	file:	signature:( t_xbar_matrix *xbar )
printf	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerInfo printf = log_print_info;$/;"	m	namespace:vtr	file:
printf_direct	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerDirect printf_direct = log_print_direct;$/;"	m	namespace:vtr	file:
printf_error	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerError printf_error = log_print_error;$/;"	m	namespace:vtr	file:
printf_info	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerInfo printf_info = log_print_info;$/;"	m	namespace:vtr	file:
printf_warning	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerWarning printf_warning = log_print_warning;$/;"	m	namespace:vtr	file:
priority	../../libs/libarchfpga/src/physical_types.h	/^	int priority = 0;       \/\/Priority of the specification.$/;"	m	struct:t_grid_loc_def	access:public
prob	../../libs/libarchfpga/src/physical_types.h	/^	float prob; \/* Static probability of net assigned to this clock *\/$/;"	m	struct:t_clock_network	access:public
probabilistic_or	route/cb_metrics.cpp	/^static float probabilistic_or(const float a, const float b){$/;"	f	file:	signature:(const float a, const float b)
probability	base/vpr_types.h	/^	float probability;$/;"	m	struct:ScreenUpdatePriority::t_net_power	access:public
proc_time	base/place_and_route.h	/^	int proc_time;$/;"	m	struct:t_fmap_cell	access:public
proceed	../../libs/libeasygl/src/graphics.cpp	/^proceed(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
proceed	../../libs/libeasygl/src/graphics.cpp	/^static void proceed(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint16_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:utf16_decoder	access:public	signature:(const uint16_t* data, size_t size, typename Traits::value_type result, Traits)
process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint32_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:utf32_decoder	access:public	signature:(const uint32_t* data, size_t size, typename Traits::value_type result, Traits)
process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:latin1_decoder	access:public	signature:(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)
process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:utf8_decoder	access:public	signature:(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)
process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const wchar_t* data, size_t size, typename Traits::value_type result, Traits traits)$/;"	f	struct:wchar_decoder	access:public	signature:(const wchar_t* data, size_t size, typename Traits::value_type result, Traits traits)
process	../../libs/libvtrutil/src/picosha2.h	/^	void process(RaIter first, RaIter last){$/;"	f	class:picosha2::hash256_one_by_one	access:public	signature:(RaIter first, RaIter last)
processAttrsParams	base/read_netlist.cpp	/^template<typename T> void processAttrsParams(pugi::xml_node Parent, const char * child_name, T &atom_net_range,$/;"	f	signature:(pugi::xml_node Parent, const char * child_name, T &atom_net_range, const pugiutil::loc_data& loc_data)
processComplexBlock	base/read_netlist.cpp	/^static void processComplexBlock(pugi::xml_node Parent,$/;"	p	file:	signature:(pugi::xml_node Parent, const ClusterBlockId index, int *num_primitives, const pugiutil::loc_data& loc_data, ClusteredNetlist *clb_nlist)
processComplexBlock	base/read_netlist.cpp	/^static void processComplexBlock(pugi::xml_node clb_block,$/;"	f	file:	signature:(pugi::xml_node clb_block, const ClusterBlockId index, int *num_primitives, const pugiutil::loc_data& loc_data, ClusteredNetlist *clb_nlist)
processPb	base/read_netlist.cpp	/^static void processPb(pugi::xml_node Parent, const ClusterBlockId index,$/;"	f	file:	signature:(pugi::xml_node Parent, const ClusterBlockId index, t_pb* pb, t_pb_routes& pb_route, int *num_primitives, const pugiutil::loc_data& loc_data, ClusteredNetlist *clb_nlist)
processPb	base/read_netlist.cpp	/^static void processPb(pugi::xml_node Parent, const ClusterBlockId index,$/;"	p	file:	signature:(pugi::xml_node Parent, const ClusterBlockId index, t_pb* pb, t_pb_routes& pb_route, int *num_primitives, const pugiutil::loc_data& loc_data, ClusteredNetlist *clb_nlist)
processPorts	base/read_netlist.cpp	/^static int processPorts(pugi::xml_node Parent, t_pb* pb, t_pb_routes& pb_route,$/;"	f	file:	signature:(pugi::xml_node Parent, t_pb* pb, t_pb_routes& pb_route, const pugiutil::loc_data& loc_data)
processPorts	base/read_netlist.cpp	/^static int processPorts(pugi::xml_node Parent, t_pb* pb, t_pb_routes& pb_route,$/;"	p	file:	signature:(pugi::xml_node Parent, t_pb* pb, t_pb_routes& pb_route, const pugiutil::loc_data& loc_data)
process_blocks	route/rr_graph_reader.cpp	/^void process_blocks(pugi::xml_node parent, const pugiutil::loc_data & loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
process_channels	route/rr_graph_reader.cpp	/^void process_channels(t_chan_width& chan_width, pugi::xml_node parent, const pugiutil::loc_data & loc_data) {$/;"	f	signature:(t_chan_width& chan_width, pugi::xml_node parent, const pugiutil::loc_data & loc_data)
process_channels	route/rr_graph_reader.cpp	/^void process_channels(t_chan_width& chan_width, pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(t_chan_width& chan_width, pugi::xml_node parent, const pugiutil::loc_data& loc_data)
process_circuit	base/read_circuit.cpp	/^static void process_circuit(AtomNetlist& netlist,$/;"	f	file:	signature:(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, bool should_absorb_buffers, bool should_sweep_dangling_primary_ios, bool should_sweep_dangling_nets, bool should_sweep_dangling_blocks, bool should_sweep_constant_primary_outputs, int verbosity)
process_circuit	base/read_circuit.cpp	/^static void process_circuit(AtomNetlist& netlist,$/;"	p	file:	signature:(AtomNetlist& netlist, e_const_gen_inference const_gen_inference_method, bool should_absorb_buffers, bool should_sweep_dangling_primary_ios, bool should_sweep_dangling_nets, bool should_sweep_dangling_blocks, bool should_sweep_constant_primary_outputs, int verbosity)
process_constant_nets	base/constant_nets.cpp	/^void process_constant_nets(ClusteredNetlist& nlist, e_constant_net_method method) {$/;"	f	signature:(ClusteredNetlist& nlist, e_constant_net_method method)
process_constant_nets	base/constant_nets.h	/^void process_constant_nets(ClusteredNetlist& nlist, e_constant_net_method method);$/;"	p	signature:(ClusteredNetlist& nlist, e_constant_net_method method)
process_constraints	timing/path_delay.cpp	/^static void process_constraints() {$/;"	f	file:	signature:()
process_constraints	timing/path_delay.cpp	/^static void process_constraints();$/;"	p	file:	signature:()
process_edges	route/rr_graph_reader.cpp	/^void process_edges(pugi::xml_node parent, const pugiutil::loc_data & loc_data,$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data, int *wire_to_rr_ipin_switch, const int num_rr_switches)
process_edges	route/rr_graph_reader.cpp	/^void process_edges(pugi::xml_node parent, const pugiutil::loc_data& loc_data, int *wire_to_rr_ipin_switch, const int num_rr_switches);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data, int *wire_to_rr_ipin_switch, const int num_rr_switches)
process_global_blocks	base/read_route.cpp	/^static void process_global_blocks(ifstream &fp, ClusterNetId inet, const char* filename, int& lineno) {$/;"	f	file:	signature:(ifstream &fp, ClusterNetId inet, const char* filename, int& lineno)
process_global_blocks	base/read_route.cpp	/^static void process_global_blocks(ifstream &fp, ClusterNetId inet, const char* filename, int& lineno);$/;"	p	file:	signature:(ifstream &fp, ClusterNetId inet, const char* filename, int& lineno)
process_negative_slack_using_minimax	route/route_budgets.cpp	/^void route_budgets::process_negative_slack_using_minimax(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
process_negative_slack_using_minimax	route/route_budgets.h	/^    void process_negative_slack_using_minimax(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
process_nets	base/read_route.cpp	/^static void process_nets(ifstream &fp, ClusterNetId inet, string name, std::vector<std::string> input_tokens, const char* filename, int& lineno) {$/;"	f	file:	signature:(ifstream &fp, ClusterNetId inet, string name, std::vector<std::string> input_tokens, const char* filename, int& lineno)
process_nets	base/read_route.cpp	/^static void process_nets(ifstream &fp, ClusterNetId inet, string name, std::vector<std::string> input_tokens, const char* filename, int& lineno);$/;"	p	file:	signature:(ifstream &fp, ClusterNetId inet, string name, std::vector<std::string> input_tokens, const char* filename, int& lineno)
process_nodes	base/read_route.cpp	/^static void process_nodes(ifstream & fp, ClusterNetId inet, const char* filename, int& lineno) {$/;"	f	file:	signature:(ifstream & fp, ClusterNetId inet, const char* filename, int& lineno)
process_nodes	base/read_route.cpp	/^static void process_nodes(ifstream &fp, ClusterNetId inet, const char* filename, int& lineno);$/;"	p	file:	signature:(ifstream &fp, ClusterNetId inet, const char* filename, int& lineno)
process_nodes	route/rr_graph_reader.cpp	/^void process_nodes(pugi::xml_node parent, const pugiutil::loc_data & loc_data) {$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
process_nodes	route/rr_graph_reader.cpp	/^void process_nodes(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
process_route	base/read_route.cpp	/^static void process_route(ifstream &fp, const char* filename, int& lineno) {$/;"	f	file:	signature:(ifstream &fp, const char* filename, int& lineno)
process_route	base/read_route.cpp	/^static void process_route(ifstream &fp, const char* filename, int& lineno);$/;"	p	file:	signature:(ifstream &fp, const char* filename, int& lineno)
process_rr_node_indices	route/rr_graph_reader.cpp	/^void process_rr_node_indices(const DeviceGrid& grid) {$/;"	f	signature:(const DeviceGrid& grid)
process_rr_node_indices	route/rr_graph_reader.cpp	/^void process_rr_node_indices(const DeviceGrid& grid);$/;"	p	file:	signature:(const DeviceGrid& grid)
process_seg_id	route/rr_graph_reader.cpp	/^void process_seg_id(pugi::xml_node parent, const pugiutil::loc_data & loc_data) {$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
process_seg_id	route/rr_graph_reader.cpp	/^void process_seg_id(pugi::xml_node parent, const pugiutil::loc_data & loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
process_switches	route/rr_graph_reader.cpp	/^void process_switches(pugi::xml_node parent, const pugiutil::loc_data & loc_data) {$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
process_switches	route/rr_graph_reader.cpp	/^void process_switches(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
process_tech_xml_load_transistor_info	power/power_cmos_tech.cpp	/^static void process_tech_xml_load_transistor_info(pugi::xml_node parent, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
process_tech_xml_load_transistor_info	power/power_cmos_tech.cpp	/^static void process_tech_xml_load_transistor_info(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
process_tech_xml_load_transistor_info	tags	/^process_tech_xml_load_transistor_info	power\/power_cmos_tech.cpp	\/^static void process_tech_xml_load_transistor_info(pugi::xml_node parent, const pugiutil::loc_data& loc_data);$\/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data)
profiling	route/route_profiling.cpp	/^namespace profiling {$/;"	n	file:
profiling	route/route_profiling.h	/^namespace profiling {$/;"	n
profiling::congestion_analysis	route/route_profiling.cpp	/^void congestion_analysis() {}$/;"	f	namespace:profiling	signature:()
profiling::congestion_analysis	route/route_profiling.h	/^void congestion_analysis();$/;"	p	namespace:profiling	signature:()
profiling::mark_for_forced_reroute	route/route_profiling.cpp	/^void mark_for_forced_reroute() {}$/;"	f	namespace:profiling	signature:()
profiling::mark_for_forced_reroute	route/route_profiling.h	/^void mark_for_forced_reroute();$/;"	p	namespace:profiling	signature:()
profiling::net_fanout_end	route/route_profiling.cpp	/^void net_fanout_end(unsigned \/*net_fanout*\/) {}$/;"	f	namespace:profiling	signature:(unsigned )
profiling::net_fanout_end	route/route_profiling.h	/^void net_fanout_end(unsigned net_fanout);$/;"	p	namespace:profiling	signature:(unsigned net_fanout)
profiling::net_fanout_start	route/route_profiling.cpp	/^void net_fanout_start() {}$/;"	f	namespace:profiling	signature:()
profiling::net_fanout_start	route/route_profiling.h	/^void net_fanout_start();$/;"	p	namespace:profiling	signature:()
profiling::net_rebuild_end	route/route_profiling.cpp	/^void net_rebuild_end(unsigned \/*net_fanout*\/, unsigned \/*sinks_left_to_route*\/) {}$/;"	f	namespace:profiling	signature:(unsigned , unsigned )
profiling::net_rebuild_end	route/route_profiling.h	/^void net_rebuild_end(unsigned net_fanout, unsigned sinks_left_to_route);$/;"	p	namespace:profiling	signature:(unsigned net_fanout, unsigned sinks_left_to_route)
profiling::net_rebuild_start	route/route_profiling.cpp	/^void net_rebuild_start() {}$/;"	f	namespace:profiling	signature:()
profiling::net_rebuild_start	route/route_profiling.h	/^void net_rebuild_start();$/;"	p	namespace:profiling	signature:()
profiling::net_rerouted	route/route_profiling.cpp	/^void net_rerouted() {}$/;"	f	namespace:profiling	signature:()
profiling::net_rerouted	route/route_profiling.h	/^void net_rerouted();$/;"	p	namespace:profiling	signature:()
profiling::perform_forced_reroute	route/route_profiling.cpp	/^void perform_forced_reroute() {}$/;"	f	namespace:profiling	signature:()
profiling::perform_forced_reroute	route/route_profiling.h	/^void perform_forced_reroute();$/;"	p	namespace:profiling	signature:()
profiling::profiling_initialization	route/route_profiling.cpp	/^void profiling_initialization(unsigned \/*max_net_fanout*\/) {}$/;"	f	namespace:profiling	signature:(unsigned )
profiling::profiling_initialization	route/route_profiling.h	/^void profiling_initialization(unsigned max_net_fanout);$/;"	p	namespace:profiling	signature:(unsigned max_net_fanout)
profiling::route_tree_preserved	route/route_profiling.cpp	/^void route_tree_preserved() {}$/;"	f	namespace:profiling	signature:()
profiling::route_tree_preserved	route/route_profiling.h	/^void route_tree_preserved();$/;"	p	namespace:profiling	signature:()
profiling::route_tree_pruned	route/route_profiling.cpp	/^void route_tree_pruned() {}$/;"	f	namespace:profiling	signature:()
profiling::route_tree_pruned	route/route_profiling.h	/^void route_tree_pruned();$/;"	p	namespace:profiling	signature:()
profiling::sink_criticality_end	route/route_profiling.cpp	/^void sink_criticality_end(float \/*target_criticality*\/) {}$/;"	f	namespace:profiling	signature:(float )
profiling::sink_criticality_end	route/route_profiling.h	/^void sink_criticality_end(float target_criticality);$/;"	p	namespace:profiling	signature:(float target_criticality)
profiling::sink_criticality_start	route/route_profiling.cpp	/^void sink_criticality_start() {}$/;"	f	namespace:profiling	signature:()
profiling::sink_criticality_start	route/route_profiling.h	/^void sink_criticality_start();$/;"	p	namespace:profiling	signature:()
profiling::time_on_criticality_analysis	route/route_profiling.cpp	/^void time_on_criticality_analysis() {}$/;"	f	namespace:profiling	signature:()
profiling::time_on_criticality_analysis	route/route_profiling.h	/^void time_on_criticality_analysis();$/;"	p	namespace:profiling	signature:()
profiling::time_on_fanout_analysis	route/route_profiling.cpp	/^void time_on_fanout_analysis() {}$/;"	f	namespace:profiling	signature:()
profiling::time_on_fanout_analysis	route/route_profiling.h	/^void time_on_fanout_analysis();$/;"	p	namespace:profiling	signature:()
profiling_initialization	route/route_profiling.cpp	/^void profiling_initialization(unsigned \/*max_net_fanout*\/) {}$/;"	f	namespace:profiling	signature:(unsigned )
profiling_initialization	route/route_profiling.h	/^void profiling_initialization(unsigned max_net_fanout);$/;"	p	namespace:profiling	signature:(unsigned max_net_fanout)
prop	../../libs/libarchfpga/src/physical_types.h	/^	int *prop; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:t_pin_to_pin_annotation	access:public
propagate_clock_domain_and_skew	timing/path_delay.cpp	/^static void propagate_clock_domain_and_skew(int inode) {$/;"	f	file:	signature:(int inode)
propagate_clock_domain_and_skew	timing/path_delay.cpp	/^static void propagate_clock_domain_and_skew(int inode);$/;"	p	file:	signature:(int inode)
prune_route_tree	route/route_tree_timing.cpp	/^t_rt_node* prune_route_tree(t_rt_node* rt_root, CBRR& connections_inf) {$/;"	f	signature:(t_rt_node* rt_root, CBRR& connections_inf)
prune_route_tree	route/route_tree_timing.h	/^t_rt_node* prune_route_tree(t_rt_node* rt_root, CBRR& connections_inf);$/;"	p	signature:(t_rt_node* rt_root, CBRR& connections_inf)
prune_route_tree_recurr	route/route_tree_timing.cpp	/^t_rt_node* prune_route_tree_recurr(t_rt_node* node, CBRR& connections_inf, bool congested);$/;"	p	file:	signature:(t_rt_node* node, CBRR& connections_inf, bool congested)
prune_route_tree_recurr	route/route_tree_timing.cpp	/^t_rt_node* prune_route_tree_recurr(t_rt_node* node, CBRR& connections_inf, bool force_prune) {$/;"	f	signature:(t_rt_node* node, CBRR& connections_inf, bool force_prune)
ps	../../libs/libeasygl/src/graphics_state.h	/^    FILE *ps = nullptr;$/;"	m	struct:t_gl_state	access:public
ps_bot	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
ps_cnames	../../libs/libeasygl/src/graphics.cpp	/^static const char *ps_cnames[NUM_COLOR] = {$/;"	v	file:
ps_left	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
ps_right	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
ps_top	../../libs/libeasygl/src/graphics.cpp	/^    float ps_left, ps_right, ps_top, ps_bot;$/;"	m	struct:__anon20	file:	access:public
ps_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon20	file:	access:public
ps_xmult	../../libs/libeasygl/src/graphics.h	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon22	access:public
ps_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon20	file:	access:public
ps_ymult	../../libs/libeasygl/src/graphics.h	/^    float ps_xmult, ps_ymult;$/;"	m	struct:__anon22	access:public
ptc_	route/rr_node.h	/^        } ptc_;$/;"	m	class:t_rr_node	typeref:union:t_rr_node::__anon9	access:private
ptc_num	route/rr_node.cpp	/^short t_rr_node::ptc_num() const {$/;"	f	class:t_rr_node	signature:() const
ptc_num	route/rr_node.h	/^        short ptc_num() const;$/;"	p	class:t_rr_node	access:public	signature:() const
ptr	timing/slre.cpp	/^  const char *ptr;  \/\/ Pointer to the substring$/;"	m	struct:cap	file:	access:public
pugi	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^namespace pugi$/;"	n	file:
pugi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^namespace pugi$/;"	n
pugi::allocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef void* (*allocation_function)(size_t size);$/;"	t	namespace:pugi
pugi::as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t>& str)$/;"	f	namespace:pugi	signature:(const std::basic_string<wchar_t>& str)
pugi::as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const wchar_t* str)$/;"	f	namespace:pugi	signature:(const wchar_t* str)
pugi::as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str);$/;"	p	namespace:pugi	signature:(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str)
pugi::as_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const wchar_t* str);$/;"	p	namespace:pugi	signature:(const wchar_t* str)
pugi::as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const char* str)$/;"	f	namespace:pugi	signature:(const char* str)
pugi::as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const std::string& str)$/;"	f	namespace:pugi	signature:(const std::string& str)
pugi::as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const char* str);$/;"	p	namespace:pugi	signature:(const char* str)
pugi::as_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str);$/;"	p	namespace:pugi	signature:(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str)
pugi::char_t	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef PUGIXML_CHAR char_t;$/;"	t	namespace:pugi
pugi::deallocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef void (*deallocation_function)(void* ptr);$/;"	t	namespace:pugi
pugi::encoding_auto	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_auto,		\/\/ Auto-detect input encoding using BOM or < \/ <? detection; use UTF8 if BOM is not found$/;"	e	enum:pugi::xml_encoding
pugi::encoding_latin1	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_latin1$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf16	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf16,		\/\/ UTF16 with native endianness$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf16_be	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf16_be,	\/\/ Big-endian UTF16$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf16_le	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf16_le,	\/\/ Little-endian UTF16$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf32	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf32,		\/\/ UTF32 with native endianness$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf32_be	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf32_be,	\/\/ Big-endian UTF32$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf32_le	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf32_le,	\/\/ Little-endian UTF32$/;"	e	enum:pugi::xml_encoding
pugi::encoding_utf8	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_utf8,		\/\/ UTF8 encoding$/;"	e	enum:pugi::xml_encoding
pugi::encoding_wchar	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		encoding_wchar,		\/\/ The same encoding wchar_t has (either UTF16 or UTF32)$/;"	e	enum:pugi::xml_encoding
pugi::format_default	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_default = format_indent;$/;"	m	namespace:pugi
pugi::format_indent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_indent = 0x01;$/;"	m	namespace:pugi
pugi::format_indent_attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_indent_attributes = 0x40;$/;"	m	namespace:pugi
pugi::format_no_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_no_declaration = 0x08;$/;"	m	namespace:pugi
pugi::format_no_escapes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_no_escapes = 0x10;$/;"	m	namespace:pugi
pugi::format_raw	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_raw = 0x04;$/;"	m	namespace:pugi
pugi::format_save_file_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_save_file_text = 0x20;$/;"	m	namespace:pugi
pugi::format_write_bom	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int format_write_bom = 0x02;$/;"	m	namespace:pugi
pugi::get_memory_allocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN allocation_function PUGIXML_FUNCTION get_memory_allocation_function()$/;"	f	namespace:pugi	signature:()
pugi::get_memory_allocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	allocation_function PUGIXML_FUNCTION get_memory_allocation_function();$/;"	p	namespace:pugi	signature:()
pugi::get_memory_deallocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function()$/;"	f	namespace:pugi	signature:()
pugi::get_memory_deallocation_function	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function();$/;"	p	namespace:pugi	signature:()
pugi::node_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_cdata,			\/\/ Character data, i.e. '<![CDATA[text]]>'$/;"	e	enum:pugi::xml_node_type
pugi::node_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_comment,		\/\/ Comment tag, i.e. '<!-- text -->'$/;"	e	enum:pugi::xml_node_type
pugi::node_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_declaration,	\/\/ Document declaration, i.e. '<?xml version="1.0"?>'$/;"	e	enum:pugi::xml_node_type
pugi::node_doctype	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_doctype		\/\/ Document type declaration, i.e. '<!DOCTYPE doc>'$/;"	e	enum:pugi::xml_node_type
pugi::node_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_document,		\/\/ A document tree's absolute root$/;"	e	enum:pugi::xml_node_type
pugi::node_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_element,		\/\/ Element tag, i.e. '<node\/>'$/;"	e	enum:pugi::xml_node_type
pugi::node_null	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_null,			\/\/ Empty (null) node handle$/;"	e	enum:pugi::xml_node_type
pugi::node_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_pcdata,		\/\/ Plain character data, i.e. 'text'$/;"	e	enum:pugi::xml_node_type
pugi::node_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		node_pi,			\/\/ Processing instruction, i.e. '<?name?>'$/;"	e	enum:pugi::xml_node_type
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xml_attribute& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xml_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xml_text& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator&&(const xpath_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xml_attribute& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xml_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xml_text& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
pugi::operator &&	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator&&(const xpath_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xml_attribute& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xml_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xml_text& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool operator||(const xpath_node& lhs, bool rhs)$/;"	f	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xml_attribute& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_attribute& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xml_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_node& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xml_text& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xml_text& lhs, bool rhs)
pugi::operator ||	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	bool PUGIXML_FUNCTION operator||(const xpath_node& lhs, bool rhs);$/;"	p	namespace:pugi	signature:(const xpath_node& lhs, bool rhs)
pugi::parse_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_cdata = 0x0004;$/;"	m	namespace:pugi
pugi::parse_comments	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_comments = 0x0002;$/;"	m	namespace:pugi
pugi::parse_declaration	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_declaration = 0x0100;$/;"	m	namespace:pugi
pugi::parse_default	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_default = parse_cdata | parse_escapes | parse_wconv_attribute | parse_eol;$/;"	m	namespace:pugi
pugi::parse_doctype	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_doctype = 0x0200;$/;"	m	namespace:pugi
pugi::parse_eol	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_eol = 0x0020;$/;"	m	namespace:pugi
pugi::parse_escapes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_escapes = 0x0010;$/;"	m	namespace:pugi
pugi::parse_fragment	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_fragment = 0x1000;$/;"	m	namespace:pugi
pugi::parse_full	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_full = parse_default | parse_pi | parse_comments | parse_declaration | parse_doctype;$/;"	m	namespace:pugi
pugi::parse_minimal	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_minimal = 0x0000;$/;"	m	namespace:pugi
pugi::parse_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_pi = 0x0001;$/;"	m	namespace:pugi
pugi::parse_trim_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_trim_pcdata = 0x0800;$/;"	m	namespace:pugi
pugi::parse_wconv_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_wconv_attribute = 0x0040;$/;"	m	namespace:pugi
pugi::parse_wnorm_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_wnorm_attribute = 0x0080;$/;"	m	namespace:pugi
pugi::parse_ws_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_ws_pcdata = 0x0008;$/;"	m	namespace:pugi
pugi::parse_ws_pcdata_single	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	const unsigned int parse_ws_pcdata_single = 0x0400;$/;"	m	namespace:pugi
pugi::set_memory_management_functions	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate)$/;"	f	namespace:pugi	signature:(allocation_function allocate, deallocation_function deallocate)
pugi::set_memory_management_functions	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate);$/;"	p	namespace:pugi	signature:(allocation_function allocate, deallocation_function deallocate)
pugi::status_append_invalid_root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_append_invalid_root,	\/\/ Unable to append nodes since root type is not node_element or node_document (exclusive to xml_node::append_buffer)$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_attribute,		\/\/ Parsing error occurred while parsing element attribute$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_cdata,			\/\/ Parsing error occurred while parsing CDATA section$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_comment,			\/\/ Parsing error occurred while parsing comment$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_doctype	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_doctype,			\/\/ Parsing error occurred while parsing document type declaration$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_end_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_end_element,		\/\/ Parsing error occurred while parsing end element tag$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_pcdata,			\/\/ Parsing error occurred while parsing PCDATA section$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_pi,				\/\/ Parsing error occurred while parsing document declaration\/processing instruction$/;"	e	enum:pugi::xml_parse_status
pugi::status_bad_start_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_start_element,	\/\/ Parsing error occurred while parsing start element tag$/;"	e	enum:pugi::xml_parse_status
pugi::status_end_element_mismatch	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_end_element_mismatch,\/\/ There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)$/;"	e	enum:pugi::xml_parse_status
pugi::status_file_not_found	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_file_not_found,		\/\/ File was not found during load_file()$/;"	e	enum:pugi::xml_parse_status
pugi::status_internal_error	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_internal_error,		\/\/ Internal error occurred$/;"	e	enum:pugi::xml_parse_status
pugi::status_io_error	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_io_error,			\/\/ Error reading from file\/stream$/;"	e	enum:pugi::xml_parse_status
pugi::status_no_document_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_no_document_element	\/\/ Parsing resulted in a document without element nodes$/;"	e	enum:pugi::xml_parse_status
pugi::status_ok	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_ok = 0,				\/\/ No error$/;"	e	enum:pugi::xml_parse_status
pugi::status_out_of_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_out_of_memory,		\/\/ Could not allocate memory$/;"	e	enum:pugi::xml_parse_status
pugi::status_unrecognized_tag	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_unrecognized_tag,	\/\/ Parser could not determine tag type$/;"	e	enum:pugi::xml_parse_status
pugi::string_t	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef std::basic_string<PUGIXML_CHAR, std::char_traits<PUGIXML_CHAR>, std::allocator<PUGIXML_CHAR> > string_t;$/;"	t	namespace:pugi
pugi::unspecified_bool_xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xml_attribute(xml_attribute***)$/;"	f	namespace:pugi	signature:(xml_attribute***)
pugi::unspecified_bool_xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xml_node(xml_node***)$/;"	f	namespace:pugi	signature:(xml_node***)
pugi::unspecified_bool_xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xml_text(xml_text***)$/;"	f	namespace:pugi	signature:(xml_text***)
pugi::unspecified_bool_xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xpath_node(xpath_node***)$/;"	f	namespace:pugi	signature:(xpath_node***)
pugi::unspecified_bool_xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xpath_query(xpath_query***)$/;"	f	namespace:pugi	signature:(xpath_query***)
pugi::xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_attribute$/;"	c	namespace:pugi
pugi::xml_attribute::_attr	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_struct* _attr;$/;"	m	class:pugi::xml_attribute	access:private
pugi::xml_attribute::as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::as_bool(bool def) const$/;"	f	class:pugi::xml_attribute	signature:(bool def) const
pugi::xml_attribute::as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool as_bool(bool def = false) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(bool def = false) const
pugi::xml_attribute::as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xml_attribute::as_double(double def) const$/;"	f	class:pugi::xml_attribute	signature:(double def) const
pugi::xml_attribute::as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double as_double(double def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(double def = 0) const
pugi::xml_attribute::as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN float xml_attribute::as_float(float def) const$/;"	f	class:pugi::xml_attribute	signature:(float def) const
pugi::xml_attribute::as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		float as_float(float def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(float def = 0) const
pugi::xml_attribute::as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int xml_attribute::as_int(int def) const$/;"	f	class:pugi::xml_attribute	signature:(int def) const
pugi::xml_attribute::as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int as_int(int def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(int def = 0) const
pugi::xml_attribute::as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN long long xml_attribute::as_llong(long long def) const$/;"	f	class:pugi::xml_attribute	signature:(long long def) const
pugi::xml_attribute::as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		long long as_llong(long long def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(long long def = 0) const
pugi::xml_attribute::as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_attribute::as_string(const char_t* def) const$/;"	f	class:pugi::xml_attribute	signature:(const char_t* def) const
pugi::xml_attribute::as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* def = PUGIXML_TEXT(Ó)) const
pugi::xml_attribute::as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned int xml_attribute::as_uint(unsigned int def) const$/;"	f	class:pugi::xml_attribute	signature:(unsigned int def) const
pugi::xml_attribute::as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned int as_uint(unsigned int def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned int def = 0) const
pugi::xml_attribute::as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned long long xml_attribute::as_ullong(unsigned long long def) const$/;"	f	class:pugi::xml_attribute	signature:(unsigned long long def) const
pugi::xml_attribute::as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned long long as_ullong(unsigned long long def = 0) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned long long def = 0) const
pugi::xml_attribute::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::empty() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xml_attribute::hash_value() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t hash_value() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_struct* xml_attribute::internal_object() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_struct* internal_object() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_attribute::name() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* name() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::next_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_attribute::next_attribute() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::next_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute next_attribute() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator!() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator!=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator<(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator<=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<=(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(bool rhs)$/;"	f	class:pugi::xml_attribute	signature:(bool rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(const char_t* rhs)$/;"	f	class:pugi::xml_attribute	signature:(const char_t* rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(double rhs)$/;"	f	class:pugi::xml_attribute	signature:(double rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(float rhs)$/;"	f	class:pugi::xml_attribute	signature:(float rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(int rhs)$/;"	f	class:pugi::xml_attribute	signature:(int rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(long long rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned int rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned int rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned long long rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(bool rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(bool rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(const char_t* rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(double rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(double rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(float rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(float rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(int rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(long long rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(unsigned int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned int rhs)
pugi::xml_attribute::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator=(unsigned long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned long long rhs)
pugi::xml_attribute::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator==(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator>(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::operator>=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>=(const xml_attribute& r) const;$/;"	p	class:pugi::xml_attribute	access:public	signature:(const xml_attribute& r) const
pugi::xml_attribute::operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::operator xml_attribute::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute::operator xml_attribute::unspecified_bool_type() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::previous_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_attribute::previous_attribute() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::previous_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute previous_attribute() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_name(const char_t* rhs)$/;"	f	class:pugi::xml_attribute	signature:(const char_t* rhs)
pugi::xml_attribute::set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_name(const char_t* rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(bool rhs)$/;"	f	class:pugi::xml_attribute	signature:(bool rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(const char_t* rhs)$/;"	f	class:pugi::xml_attribute	signature:(const char_t* rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(double rhs)$/;"	f	class:pugi::xml_attribute	signature:(double rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(float rhs)$/;"	f	class:pugi::xml_attribute	signature:(float rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(int rhs)$/;"	f	class:pugi::xml_attribute	signature:(int rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(long long rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(unsigned int rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned int rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(unsigned long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned long long rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(bool rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(bool rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(const char_t* rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(double rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(double rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(float rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(float rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(int rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(long long rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(unsigned int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned int rhs)
pugi::xml_attribute::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(unsigned long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned long long rhs)
pugi::xml_attribute::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xml_attribute***);$/;"	t	class:pugi::xml_attribute	access:private
pugi::xml_attribute::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_attribute::value() const$/;"	f	class:pugi::xml_attribute	signature:() const
pugi::xml_attribute::value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* value() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
pugi::xml_attribute::xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute::xml_attribute(): _attr(0)$/;"	f	class:pugi::xml_attribute	signature:()
pugi::xml_attribute::xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute::xml_attribute(xml_attribute_struct* attr): _attr(attr)$/;"	f	class:pugi::xml_attribute	signature:(xml_attribute_struct* attr)
pugi::xml_attribute::xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xml_attribute(xml_attribute_struct* attr);$/;"	p	class:pugi::xml_attribute	access:public	signature:(xml_attribute_struct* attr)
pugi::xml_attribute::xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute();$/;"	p	class:pugi::xml_attribute	access:public	signature:()
pugi::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_attribute_iterator$/;"	c	namespace:pugi
pugi::xml_attribute_iterator::_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _parent;$/;"	m	class:pugi::xml_attribute_iterator	access:private
pugi::xml_attribute_iterator::_wrap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		mutable xml_attribute _wrap;$/;"	m	class:pugi::xml_attribute_iterator	access:private
pugi::xml_attribute_iterator::difference_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_attribute_iterator	access:public
pugi::xml_attribute_iterator::iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_attribute_iterator	access:public
pugi::xml_attribute_iterator::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute_iterator::operator!=(const xml_attribute_iterator& rhs) const$/;"	f	class:pugi::xml_attribute_iterator	signature:(const xml_attribute_iterator& rhs) const
pugi::xml_attribute_iterator::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_attribute_iterator& rhs) const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(const xml_attribute_iterator& rhs) const
pugi::xml_attribute_iterator::operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute& xml_attribute_iterator::operator*() const$/;"	f	class:pugi::xml_attribute_iterator	signature:() const
pugi::xml_attribute_iterator::operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute& operator*() const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:() const
pugi::xml_attribute_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator++()$/;"	f	class:pugi::xml_attribute_iterator	signature:()
pugi::xml_attribute_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator++(int)$/;"	f	class:pugi::xml_attribute_iterator	signature:(int)
pugi::xml_attribute_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_attribute_iterator& operator++();$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:()
pugi::xml_attribute_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator operator++(int);$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(int)
pugi::xml_attribute_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator--()$/;"	f	class:pugi::xml_attribute_iterator	signature:()
pugi::xml_attribute_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator--(int)$/;"	f	class:pugi::xml_attribute_iterator	signature:(int)
pugi::xml_attribute_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_attribute_iterator& operator--();$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:()
pugi::xml_attribute_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator operator--(int);$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(int)
pugi::xml_attribute_iterator::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute* xml_attribute_iterator::operator->() const$/;"	f	class:pugi::xml_attribute_iterator	signature:() const
pugi::xml_attribute_iterator::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute* operator->() const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:() const
pugi::xml_attribute_iterator::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute_iterator::operator==(const xml_attribute_iterator& rhs) const$/;"	f	class:pugi::xml_attribute_iterator	signature:(const xml_attribute_iterator& rhs) const
pugi::xml_attribute_iterator::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_attribute_iterator& rhs) const;$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(const xml_attribute_iterator& rhs) const
pugi::xml_attribute_iterator::pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute* pointer;$/;"	t	class:pugi::xml_attribute_iterator	access:public
pugi::xml_attribute_iterator::reference	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute& reference;$/;"	t	class:pugi::xml_attribute_iterator	access:public
pugi::xml_attribute_iterator::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute value_type;$/;"	t	class:pugi::xml_attribute_iterator	access:public
pugi::xml_attribute_iterator::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator()$/;"	f	class:pugi::xml_attribute_iterator	signature:()
pugi::xml_attribute_iterator::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent): _wrap(attr), _parent(parent)$/;"	f	class:pugi::xml_attribute_iterator	signature:(const xml_attribute& attr, const xml_node& parent)
pugi::xml_attribute_iterator::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)$/;"	f	class:pugi::xml_attribute_iterator	signature:(xml_attribute_struct* ref, xml_node_struct* parent)
pugi::xml_attribute_iterator::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator();$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:()
pugi::xml_attribute_iterator::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent);$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(const xml_attribute& attr, const xml_node& parent)
pugi::xml_attribute_iterator::xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent);$/;"	p	class:pugi::xml_attribute_iterator	access:private	signature:(xml_attribute_struct* ref, xml_node_struct* parent)
pugi::xml_attribute_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_attribute_struct$/;"	s	namespace:pugi	file:
pugi::xml_attribute_struct::header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_header header;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
pugi::xml_attribute_struct::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<4, 2> name;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
pugi::xml_attribute_struct::namevalue_base	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t namevalue_base;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
pugi::xml_attribute_struct::next_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_attribute_struct, 7, 0> next_attribute;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
pugi::xml_attribute_struct::prev_attribute_c	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_attribute_struct, 6> prev_attribute_c;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
pugi::xml_attribute_struct::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<5, 3> value;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
pugi::xml_attribute_struct::xml_attribute_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_attribute_struct(impl::xml_memory_page* page): header(page, 0), namevalue_base(0)$/;"	f	struct:pugi::xml_attribute_struct	access:public	signature:(impl::xml_memory_page* page)
pugi::xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_document: public xml_node$/;"	c	namespace:pugi	inherits:xml_node
pugi::xml_document::_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		char_t* _buffer;$/;"	m	class:pugi::xml_document	access:private
pugi::xml_document::_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		char _memory[192];$/;"	m	class:pugi::xml_document	access:private
pugi::xml_document::create	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::create()$/;"	f	class:pugi::xml_document	signature:()
pugi::xml_document::create	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void create();$/;"	p	class:pugi::xml_document	access:private	signature:()
pugi::xml_document::destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::destroy()$/;"	f	class:pugi::xml_document	signature:()
pugi::xml_document::destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void destroy();$/;"	p	class:pugi::xml_document	access:private	signature:()
pugi::xml_document::document_element	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_document::document_element() const$/;"	f	class:pugi::xml_document	signature:() const
pugi::xml_document::document_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node document_element() const;$/;"	p	class:pugi::xml_document	access:public	signature:() const
pugi::xml_document::load	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load(const char_t* contents, unsigned int options)$/;"	f	class:pugi::xml_document	signature:(const char_t* contents, unsigned int options)
pugi::xml_document::load	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)
pugi::xml_document::load	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)$/;"	f	class:pugi::xml_document	signature:(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)
pugi::xml_document::load	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load(const char_t* contents, unsigned int options = parse_default);$/;"	p	class:pugi::xml_document	access:public	signature:(const char_t* contents, unsigned int options = parse_default)
pugi::xml_document::load	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_document::load	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default);$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default)
pugi::xml_document::load_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
pugi::xml_document::load_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_document::load_buffer_inplace	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(void* contents, size_t size, unsigned int options, xml_encoding encoding)
pugi::xml_document::load_buffer_inplace	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_buffer_inplace(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_document::load_buffer_inplace_own	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(void* contents, size_t size, unsigned int options, xml_encoding encoding)
pugi::xml_document::load_buffer_inplace_own	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_buffer_inplace_own(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_document::load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_file(const char* path_, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(const char* path_, unsigned int options, xml_encoding encoding)
pugi::xml_document::load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_file(const wchar_t* path_, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document	signature:(const wchar_t* path_, unsigned int options, xml_encoding encoding)
pugi::xml_document::load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_file(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_document::load_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_file(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_document	access:public	signature:(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_document::load_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_document::load_string(const char_t* contents, unsigned int options)$/;"	f	class:pugi::xml_document	signature:(const char_t* contents, unsigned int options)
pugi::xml_document::load_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result load_string(const char_t* contents, unsigned int options = parse_default);$/;"	p	class:pugi::xml_document	access:public	signature:(const char_t* contents, unsigned int options = parse_default)
pugi::xml_document::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_document& operator=(const xml_document&);$/;"	p	class:pugi::xml_document	access:private	signature:(const xml_document&)
pugi::xml_document::reset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::reset()$/;"	f	class:pugi::xml_document	signature:()
pugi::xml_document::reset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::reset(const xml_document& proto)$/;"	f	class:pugi::xml_document	signature:(const xml_document& proto)
pugi::xml_document::reset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void reset();$/;"	p	class:pugi::xml_document	access:public	signature:()
pugi::xml_document::reset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void reset(const xml_document& proto);$/;"	p	class:pugi::xml_document	access:public	signature:(const xml_document& proto)
pugi::xml_document::save	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const
pugi::xml_document::save	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const$/;"	f	class:pugi::xml_document	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const
pugi::xml_document::save	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::save(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const
pugi::xml_document::save	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
pugi::xml_document::save	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default) const;$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default) const
pugi::xml_document::save	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void save(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(xml_writer& writer, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
pugi::xml_document::save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_document::save_file(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
pugi::xml_document::save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_document::save_file(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
pugi::xml_document::save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool save_file(const char* path, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(const char* path, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
pugi::xml_document::save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool save_file(const wchar_t* path, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(const wchar_t* path, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
pugi::xml_document::xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_document::xml_document(): _buffer(0)$/;"	f	class:pugi::xml_document	signature:()
pugi::xml_document::xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_document();$/;"	p	class:pugi::xml_document	access:public	signature:()
pugi::xml_document::xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_document(const xml_document&);$/;"	p	class:pugi::xml_document	access:private	signature:(const xml_document&)
pugi::xml_document::~xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_document::~xml_document()$/;"	f	class:pugi::xml_document	signature:()
pugi::xml_document::~xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xml_document();$/;"	p	class:pugi::xml_document	access:public	signature:()
pugi::xml_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xml_encoding$/;"	g	namespace:pugi
pugi::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_named_node_iterator$/;"	c	namespace:pugi
pugi::xml_named_node_iterator::_name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* _name;$/;"	m	class:pugi::xml_named_node_iterator	access:private
pugi::xml_named_node_iterator::_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _parent;$/;"	m	class:pugi::xml_named_node_iterator	access:private
pugi::xml_named_node_iterator::_wrap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		mutable xml_node _wrap;$/;"	m	class:pugi::xml_named_node_iterator	access:private
pugi::xml_named_node_iterator::difference_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_named_node_iterator	access:public
pugi::xml_named_node_iterator::iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_named_node_iterator	access:public
pugi::xml_named_node_iterator::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_named_node_iterator::operator!=(const xml_named_node_iterator& rhs) const$/;"	f	class:pugi::xml_named_node_iterator	signature:(const xml_named_node_iterator& rhs) const
pugi::xml_named_node_iterator::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_named_node_iterator& rhs) const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(const xml_named_node_iterator& rhs) const
pugi::xml_named_node_iterator::operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node& xml_named_node_iterator::operator*() const$/;"	f	class:pugi::xml_named_node_iterator	signature:() const
pugi::xml_named_node_iterator::operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node& operator*() const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:() const
pugi::xml_named_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator++()$/;"	f	class:pugi::xml_named_node_iterator	signature:()
pugi::xml_named_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator++(int)$/;"	f	class:pugi::xml_named_node_iterator	signature:(int)
pugi::xml_named_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_named_node_iterator& operator++();$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:()
pugi::xml_named_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator operator++(int);$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(int)
pugi::xml_named_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator--()$/;"	f	class:pugi::xml_named_node_iterator	signature:()
pugi::xml_named_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator--(int)$/;"	f	class:pugi::xml_named_node_iterator	signature:(int)
pugi::xml_named_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_named_node_iterator& operator--();$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:()
pugi::xml_named_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator operator--(int);$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(int)
pugi::xml_named_node_iterator::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node* xml_named_node_iterator::operator->() const$/;"	f	class:pugi::xml_named_node_iterator	signature:() const
pugi::xml_named_node_iterator::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node* operator->() const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:() const
pugi::xml_named_node_iterator::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_named_node_iterator::operator==(const xml_named_node_iterator& rhs) const$/;"	f	class:pugi::xml_named_node_iterator	signature:(const xml_named_node_iterator& rhs) const
pugi::xml_named_node_iterator::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_named_node_iterator& rhs) const;$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(const xml_named_node_iterator& rhs) const
pugi::xml_named_node_iterator::pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node* pointer;$/;"	t	class:pugi::xml_named_node_iterator	access:public
pugi::xml_named_node_iterator::reference	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node& reference;$/;"	t	class:pugi::xml_named_node_iterator	access:public
pugi::xml_named_node_iterator::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node value_type;$/;"	t	class:pugi::xml_named_node_iterator	access:public
pugi::xml_named_node_iterator::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(): _name(0)$/;"	f	class:pugi::xml_named_node_iterator	signature:()
pugi::xml_named_node_iterator::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(const xml_node& node, const char_t* name): _wrap(node), _parent(node.parent()), _name(name)$/;"	f	class:pugi::xml_named_node_iterator	signature:(const xml_node& node, const char_t* name)
pugi::xml_named_node_iterator::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name): _wrap(ref), _parent(parent), _name(name)$/;"	f	class:pugi::xml_named_node_iterator	signature:(xml_node_struct* ref, xml_node_struct* parent, const char_t* name)
pugi::xml_named_node_iterator::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator();$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:()
pugi::xml_named_node_iterator::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator(const xml_node& node, const char_t* name);$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(const xml_node& node, const char_t* name)
pugi::xml_named_node_iterator::xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name);$/;"	p	class:pugi::xml_named_node_iterator	access:private	signature:(xml_node_struct* ref, xml_node_struct* parent, const char_t* name)
pugi::xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_node$/;"	c	namespace:pugi
pugi::xml_node::_root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _root;$/;"	m	class:pugi::xml_node	access:protected
pugi::xml_node::append_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::append_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
pugi::xml_node::append_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute append_attribute(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
pugi::xml_node::append_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result xml_node::append_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_node	signature:(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
pugi::xml_node::append_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result append_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);$/;"	p	class:pugi::xml_node	access:public	signature:(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto)
pugi::xml_node::append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_child(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
pugi::xml_node::append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_child(xml_node_type type_)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_)
pugi::xml_node::append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_child(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
pugi::xml_node::append_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_child(xml_node_type type = node_element);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type = node_element)
pugi::xml_node::append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::append_copy(const xml_attribute& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto)
pugi::xml_node::append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_copy(const xml_node& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto)
pugi::xml_node::append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute append_copy(const xml_attribute& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto)
pugi::xml_node::append_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_copy(const xml_node& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto)
pugi::xml_node::append_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::append_move(const xml_node& moved)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved)
pugi::xml_node::append_move	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node append_move(const xml_node& moved);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved)
pugi::xml_node::attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
pugi::xml_node::attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_, xml_attribute& hint_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, xml_attribute& hint_) const
pugi::xml_node::attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute attribute(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
pugi::xml_node::attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute attribute(const char_t* name, xml_attribute& hint) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, xml_attribute& hint) const
pugi::xml_node::attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute_iterator attribute_iterator;$/;"	t	class:pugi::xml_node	access:public
pugi::xml_node::attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_object_range<xml_attribute_iterator> xml_node::attributes() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::attributes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range<xml_attribute_iterator> attributes() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::attributes_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::attribute_iterator xml_node::attributes_begin() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::attributes_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		attribute_iterator attributes_begin() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::attributes_end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::attribute_iterator xml_node::attributes_end() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::attributes_end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		attribute_iterator attributes_end() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::iterator xml_node::begin() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		iterator begin() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::child(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
pugi::xml_node::child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node child(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
pugi::xml_node::child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::child_value() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::child_value(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
pugi::xml_node::child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* child_value() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::child_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* child_value(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
pugi::xml_node::children	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_object_range<xml_named_node_iterator> xml_node::children(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
pugi::xml_node::children	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_object_range<xml_node_iterator> xml_node::children() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::children	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range<xml_named_node_iterator> children(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
pugi::xml_node::children	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range<xml_node_iterator> children() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::empty() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::iterator xml_node::end() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		iterator end() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::find_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		template <typename Predicate> xml_attribute find_attribute(Predicate pred) const$/;"	f	class:pugi::xml_node	access:public	signature:(Predicate pred) const
pugi::xml_node::find_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		template <typename Predicate> xml_node find_child(Predicate pred) const$/;"	f	class:pugi::xml_node	access:public	signature:(Predicate pred) const
pugi::xml_node::find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const$/;"	f	class:pugi::xml_node	signature:(const char_t* attr_name, const char_t* attr_value) const
pugi::xml_node::find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const
pugi::xml_node::find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* attr_name, const char_t* attr_value) const
pugi::xml_node::find_child_by_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node find_child_by_attribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const char_t* attr_name, const char_t* attr_value) const
pugi::xml_node::find_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		template <typename Predicate> xml_node find_node(Predicate pred) const$/;"	f	class:pugi::xml_node	access:public	signature:(Predicate pred) const
pugi::xml_node::first_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::first_attribute() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::first_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute first_attribute() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::first_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::first_child() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::first_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node first_child() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::first_element_by_path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::first_element_by_path(const char_t* path_, char_t delimiter) const$/;"	f	class:pugi::xml_node	signature:(const char_t* path_, char_t delimiter) const
pugi::xml_node::first_element_by_path	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node first_element_by_path(const char_t* path, char_t delimiter = '\/') const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* path, char_t delimiter = Ã) const
pugi::xml_node::hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xml_node::hash_value() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::hash_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t hash_value() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::insert_attribute_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_attribute_after(const char_t* name_, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_attribute& attr)
pugi::xml_node::insert_attribute_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_attribute_after(const char_t* name, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_attribute& attr)
pugi::xml_node::insert_attribute_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_attribute_before(const char_t* name_, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_attribute& attr)
pugi::xml_node::insert_attribute_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_attribute_before(const char_t* name, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_attribute& attr)
pugi::xml_node::insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_after(const char_t* name_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_node& node)
pugi::xml_node::insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_after(xml_node_type type_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_, const xml_node& node)
pugi::xml_node::insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_after(const char_t* name, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_node& node)
pugi::xml_node::insert_child_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_after(xml_node_type type, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type, const xml_node& node)
pugi::xml_node::insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_before(const char_t* name_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_, const xml_node& node)
pugi::xml_node::insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_child_before(xml_node_type type_, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_, const xml_node& node)
pugi::xml_node::insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_before(const char_t* name, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name, const xml_node& node)
pugi::xml_node::insert_child_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_child_before(xml_node_type type, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type, const xml_node& node)
pugi::xml_node::insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_copy_after(const xml_attribute& proto, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto, const xml_attribute& attr)
pugi::xml_node::insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_copy_after(const xml_node& proto, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto, const xml_node& node)
pugi::xml_node::insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_copy_after(const xml_attribute& proto, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto, const xml_attribute& attr)
pugi::xml_node::insert_copy_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_copy_after(const xml_node& proto, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto, const xml_node& node)
pugi::xml_node::insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::insert_copy_before(const xml_attribute& proto, const xml_attribute& attr)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto, const xml_attribute& attr)
pugi::xml_node::insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_copy_before(const xml_node& proto, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto, const xml_node& node)
pugi::xml_node::insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute insert_copy_before(const xml_attribute& proto, const xml_attribute& attr);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto, const xml_attribute& attr)
pugi::xml_node::insert_copy_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_copy_before(const xml_node& proto, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto, const xml_node& node)
pugi::xml_node::insert_move_after	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_move_after(const xml_node& moved, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved, const xml_node& node)
pugi::xml_node::insert_move_after	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_move_after(const xml_node& moved, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved, const xml_node& node)
pugi::xml_node::insert_move_before	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::insert_move_before(const xml_node& moved, const xml_node& node)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved, const xml_node& node)
pugi::xml_node::insert_move_before	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node insert_move_before(const xml_node& moved, const xml_node& node);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved, const xml_node& node)
pugi::xml_node::internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_struct* xml_node::internal_object() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::internal_object	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* internal_object() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node_iterator iterator;$/;"	t	class:pugi::xml_node	access:public
pugi::xml_node::last_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::last_attribute() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::last_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute last_attribute() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::last_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::last_child() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::last_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node last_child() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::name() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* name() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::next_sibling() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::next_sibling(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
pugi::xml_node::next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node next_sibling() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node next_sibling(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
pugi::xml_node::offset_debug	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN ptrdiff_t xml_node::offset_debug() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::offset_debug	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		ptrdiff_t offset_debug() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator!() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator!=(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
pugi::xml_node::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
pugi::xml_node::operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator<(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
pugi::xml_node::operator <	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
pugi::xml_node::operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator<=(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
pugi::xml_node::operator <=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator<=(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
pugi::xml_node::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator==(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
pugi::xml_node::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
pugi::xml_node::operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator>(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
pugi::xml_node::operator >	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
pugi::xml_node::operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::operator>=(const xml_node& r) const$/;"	f	class:pugi::xml_node	signature:(const xml_node& r) const
pugi::xml_node::operator >=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator>=(const xml_node& r) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& r) const
pugi::xml_node::operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::operator xml_node::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::operator xml_node::unspecified_bool_type() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::parent() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node parent() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN string_t xml_node::path(char_t delimiter) const$/;"	f	class:pugi::xml_node	signature:(char_t delimiter) const
pugi::xml_node::path	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		string_t path(char_t delimiter = '\/') const;$/;"	p	class:pugi::xml_node	access:public	signature:(char_t delimiter = Ã) const
pugi::xml_node::prepend_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::prepend_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
pugi::xml_node::prepend_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute prepend_attribute(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
pugi::xml_node::prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_child(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
pugi::xml_node::prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_child(xml_node_type type_)$/;"	f	class:pugi::xml_node	signature:(xml_node_type type_)
pugi::xml_node::prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_child(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
pugi::xml_node::prepend_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_child(xml_node_type type = node_element);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_type type = node_element)
pugi::xml_node::prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xml_node::prepend_copy(const xml_attribute& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& proto)
pugi::xml_node::prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_copy(const xml_node& proto)$/;"	f	class:pugi::xml_node	signature:(const xml_node& proto)
pugi::xml_node::prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute prepend_copy(const xml_attribute& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& proto)
pugi::xml_node::prepend_copy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_copy(const xml_node& proto);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& proto)
pugi::xml_node::prepend_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::prepend_move(const xml_node& moved)$/;"	f	class:pugi::xml_node	signature:(const xml_node& moved)
pugi::xml_node::prepend_move	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node prepend_move(const xml_node& moved);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& moved)
pugi::xml_node::previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::previous_sibling() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::previous_sibling(const char_t* name_) const$/;"	f	class:pugi::xml_node	signature:(const char_t* name_) const
pugi::xml_node::previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node previous_sibling() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::previous_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node previous_sibling(const char_t* name) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name) const
pugi::xml_node::print	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_node::print(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const$/;"	f	class:pugi::xml_node	signature:(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
pugi::xml_node::print	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_node::print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const$/;"	f	class:pugi::xml_node	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const
pugi::xml_node::print	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_node::print(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const$/;"	f	class:pugi::xml_node	signature:(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
pugi::xml_node::print	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const
pugi::xml_node::print	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, unsigned int depth = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, unsigned int depth = 0) const
pugi::xml_node::print	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void print(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(xml_writer& writer, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const
pugi::xml_node::remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
pugi::xml_node::remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_attribute(const xml_attribute& a)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& a)
pugi::xml_node::remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_attribute(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
pugi::xml_node::remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_attribute(const xml_attribute& a);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& a)
pugi::xml_node::remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_child(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
pugi::xml_node::remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_child(const xml_node& n)$/;"	f	class:pugi::xml_node	signature:(const xml_node& n)
pugi::xml_node::remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_child(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
pugi::xml_node::remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_child(const xml_node& n);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& n)
pugi::xml_node::root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::root() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node root() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_node(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node	signature:(const char_t* query, xpath_variable_set* variables) const
pugi::xml_node::select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_node(const xpath_query& query) const$/;"	f	class:pugi::xml_node	signature:(const xpath_query& query) const
pugi::xml_node::select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_node(const char_t* query, xpath_variable_set* variables = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0) const
pugi::xml_node::select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_node(const xpath_query& query) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xpath_query& query) const
pugi::xml_node::select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set xml_node::select_nodes(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node	signature:(const char_t* query, xpath_variable_set* variables) const
pugi::xml_node::select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set xml_node::select_nodes(const xpath_query& query) const$/;"	f	class:pugi::xml_node	signature:(const xpath_query& query) const
pugi::xml_node::select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set select_nodes(const char_t* query, xpath_variable_set* variables = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0) const
pugi::xml_node::select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set select_nodes(const xpath_query& query) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xpath_query& query) const
pugi::xml_node::select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_single_node(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node	signature:(const char_t* query, xpath_variable_set* variables) const
pugi::xml_node::select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_single_node(const xpath_query& query) const$/;"	f	class:pugi::xml_node	signature:(const xpath_query& query) const
pugi::xml_node::select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_single_node(const char_t* query, xpath_variable_set* variables = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0) const
pugi::xml_node::select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_single_node(const xpath_query& query) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xpath_query& query) const
pugi::xml_node::set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::set_name(const char_t* rhs)$/;"	f	class:pugi::xml_node	signature:(const char_t* rhs)
pugi::xml_node::set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_name(const char_t* rhs);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* rhs)
pugi::xml_node::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::set_value(const char_t* rhs)$/;"	f	class:pugi::xml_node	signature:(const char_t* rhs)
pugi::xml_node::set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(const char_t* rhs);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* rhs)
pugi::xml_node::text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text xml_node::text() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text text() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::traverse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::traverse(xml_tree_walker& walker)$/;"	f	class:pugi::xml_node	signature:(xml_tree_walker& walker)
pugi::xml_node::traverse	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool traverse(xml_tree_walker& walker);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_tree_walker& walker)
pugi::xml_node::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_type xml_node::type() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_type type() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xml_node***);$/;"	t	class:pugi::xml_node	access:protected
pugi::xml_node::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::value() const$/;"	f	class:pugi::xml_node	signature:() const
pugi::xml_node::value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* value() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
pugi::xml_node::xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::xml_node(): _root(0)$/;"	f	class:pugi::xml_node	signature:()
pugi::xml_node::xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::xml_node(xml_node_struct* p): _root(p)$/;"	f	class:pugi::xml_node	signature:(xml_node_struct* p)
pugi::xml_node::xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xml_node(xml_node_struct* p);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_struct* p)
pugi::xml_node::xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node();$/;"	p	class:pugi::xml_node	access:public	signature:()
pugi::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_node_iterator$/;"	c	namespace:pugi
pugi::xml_node_iterator::_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _parent;$/;"	m	class:pugi::xml_node_iterator	access:private
pugi::xml_node_iterator::_wrap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		mutable xml_node _wrap;$/;"	m	class:pugi::xml_node_iterator	access:private
pugi::xml_node_iterator::difference_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_node_iterator	access:public
pugi::xml_node_iterator::iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_node_iterator	access:public
pugi::xml_node_iterator::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node_iterator::operator!=(const xml_node_iterator& rhs) const$/;"	f	class:pugi::xml_node_iterator	signature:(const xml_node_iterator& rhs) const
pugi::xml_node_iterator::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xml_node_iterator& rhs) const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(const xml_node_iterator& rhs) const
pugi::xml_node_iterator::operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node& xml_node_iterator::operator*() const$/;"	f	class:pugi::xml_node_iterator	signature:() const
pugi::xml_node_iterator::operator *	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node& operator*() const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:() const
pugi::xml_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_node_iterator& xml_node_iterator::operator++()$/;"	f	class:pugi::xml_node_iterator	signature:()
pugi::xml_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator xml_node_iterator::operator++(int)$/;"	f	class:pugi::xml_node_iterator	signature:(int)
pugi::xml_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_node_iterator& operator++();$/;"	p	class:pugi::xml_node_iterator	access:public	signature:()
pugi::xml_node_iterator::operator ++	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator operator++(int);$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(int)
pugi::xml_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xml_node_iterator& xml_node_iterator::operator--()$/;"	f	class:pugi::xml_node_iterator	signature:()
pugi::xml_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator xml_node_iterator::operator--(int)$/;"	f	class:pugi::xml_node_iterator	signature:(int)
pugi::xml_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xml_node_iterator& operator--();$/;"	p	class:pugi::xml_node_iterator	access:public	signature:()
pugi::xml_node_iterator::operator --	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator operator--(int);$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(int)
pugi::xml_node_iterator::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node* xml_node_iterator::operator->() const$/;"	f	class:pugi::xml_node_iterator	signature:() const
pugi::xml_node_iterator::operator ->	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node* operator->() const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:() const
pugi::xml_node_iterator::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node_iterator::operator==(const xml_node_iterator& rhs) const$/;"	f	class:pugi::xml_node_iterator	signature:(const xml_node_iterator& rhs) const
pugi::xml_node_iterator::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xml_node_iterator& rhs) const;$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(const xml_node_iterator& rhs) const
pugi::xml_node_iterator::pointer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node* pointer;$/;"	t	class:pugi::xml_node_iterator	access:public
pugi::xml_node_iterator::reference	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node& reference;$/;"	t	class:pugi::xml_node_iterator	access:public
pugi::xml_node_iterator::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node value_type;$/;"	t	class:pugi::xml_node_iterator	access:public
pugi::xml_node_iterator::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator::xml_node_iterator()$/;"	f	class:pugi::xml_node_iterator	signature:()
pugi::xml_node_iterator::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator::xml_node_iterator(const xml_node& node): _wrap(node), _parent(node.parent())$/;"	f	class:pugi::xml_node_iterator	signature:(const xml_node& node)
pugi::xml_node_iterator::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator::xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)$/;"	f	class:pugi::xml_node_iterator	signature:(xml_node_struct* ref, xml_node_struct* parent)
pugi::xml_node_iterator::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator();$/;"	p	class:pugi::xml_node_iterator	access:public	signature:()
pugi::xml_node_iterator::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator(const xml_node& node);$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(const xml_node& node)
pugi::xml_node_iterator::xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent);$/;"	p	class:pugi::xml_node_iterator	access:private	signature:(xml_node_struct* ref, xml_node_struct* parent)
pugi::xml_node_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_node_struct$/;"	s	namespace:pugi	file:
pugi::xml_node_struct::first_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_attribute_struct, 11, 0> first_attribute;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::first_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_node_struct, 8, 0> first_child;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_header header;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<4, 2> name;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::namevalue_base	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t namevalue_base;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::next_sibling	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_node_struct, 10, 0> next_sibling;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer_parent<xml_node_struct, 6> parent;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::prev_sibling_c	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_pointer<xml_node_struct,  9>    prev_sibling_c;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<5, 3> value;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
pugi::xml_node_struct::xml_node_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): header(page, type - 1), namevalue_base(0)$/;"	f	struct:pugi::xml_node_struct	access:public	signature:(impl::xml_memory_page* page, xml_node_type type)
pugi::xml_node_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xml_node_type$/;"	g	namespace:pugi
pugi::xml_object_range	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	template <typename It> class xml_object_range$/;"	c	namespace:pugi
pugi::xml_object_range::_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It _begin, _end;$/;"	m	class:pugi::xml_object_range	access:private
pugi::xml_object_range::_end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It _begin, _end;$/;"	m	class:pugi::xml_object_range	access:private
pugi::xml_object_range::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It begin() const { return _begin; }$/;"	f	class:pugi::xml_object_range	access:public	signature:() const
pugi::xml_object_range::const_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef It const_iterator;$/;"	t	class:pugi::xml_object_range	access:public
pugi::xml_object_range::end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		It end() const { return _end; }$/;"	f	class:pugi::xml_object_range	access:public	signature:() const
pugi::xml_object_range::iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef It iterator;$/;"	t	class:pugi::xml_object_range	access:public
pugi::xml_object_range::xml_object_range	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range(It b, It e): _begin(b), _end(e)$/;"	f	class:pugi::xml_object_range	access:public	signature:(It b, It e)
pugi::xml_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	struct PUGIXML_CLASS xml_parse_result$/;"	s	namespace:pugi
pugi::xml_parse_result::description	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char* xml_parse_result::description() const$/;"	f	class:pugi::xml_parse_result	signature:() const
pugi::xml_parse_result::description	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char* description() const;$/;"	p	struct:pugi::xml_parse_result	access:public	signature:() const
pugi::xml_parse_result::encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_encoding encoding;$/;"	m	struct:pugi::xml_parse_result	access:public
pugi::xml_parse_result::offset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		ptrdiff_t offset;$/;"	m	struct:pugi::xml_parse_result	access:public
pugi::xml_parse_result::operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result::operator bool() const$/;"	f	class:pugi::xml_parse_result	signature:() const
pugi::xml_parse_result::operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator bool() const;$/;"	p	struct:pugi::xml_parse_result	access:public	signature:() const
pugi::xml_parse_result::status	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_status status;$/;"	m	struct:pugi::xml_parse_result	access:public
pugi::xml_parse_result::xml_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result::xml_parse_result(): status(status_internal_error), offset(0), encoding(encoding_auto)$/;"	f	class:pugi::xml_parse_result	signature:()
pugi::xml_parse_result::xml_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result();$/;"	p	struct:pugi::xml_parse_result	access:public	signature:()
pugi::xml_parse_status	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xml_parse_status$/;"	g	namespace:pugi
pugi::xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_text$/;"	c	namespace:pugi
pugi::xml_text::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_struct* xml_text::_data() const$/;"	f	class:pugi::xml_text	signature:() const
pugi::xml_text::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _data() const;$/;"	p	class:pugi::xml_text	access:private	signature:() const
pugi::xml_text::_data_new	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_struct* xml_text::_data_new()$/;"	f	class:pugi::xml_text	signature:()
pugi::xml_text::_data_new	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _data_new();$/;"	p	class:pugi::xml_text	access:private	signature:()
pugi::xml_text::_root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_struct* _root;$/;"	m	class:pugi::xml_text	access:private
pugi::xml_text::as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::as_bool(bool def) const$/;"	f	class:pugi::xml_text	signature:(bool def) const
pugi::xml_text::as_bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool as_bool(bool def = false) const;$/;"	p	class:pugi::xml_text	access:public	signature:(bool def = false) const
pugi::xml_text::as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xml_text::as_double(double def) const$/;"	f	class:pugi::xml_text	signature:(double def) const
pugi::xml_text::as_double	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double as_double(double def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(double def = 0) const
pugi::xml_text::as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN float xml_text::as_float(float def) const$/;"	f	class:pugi::xml_text	signature:(float def) const
pugi::xml_text::as_float	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		float as_float(float def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(float def = 0) const
pugi::xml_text::as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int xml_text::as_int(int def) const$/;"	f	class:pugi::xml_text	signature:(int def) const
pugi::xml_text::as_int	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int as_int(int def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(int def = 0) const
pugi::xml_text::as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN long long xml_text::as_llong(long long def) const$/;"	f	class:pugi::xml_text	signature:(long long def) const
pugi::xml_text::as_llong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		long long as_llong(long long def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(long long def = 0) const
pugi::xml_text::as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_text::as_string(const char_t* def) const$/;"	f	class:pugi::xml_text	signature:(const char_t* def) const
pugi::xml_text::as_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;$/;"	p	class:pugi::xml_text	access:public	signature:(const char_t* def = PUGIXML_TEXT(Ó)) const
pugi::xml_text::as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned int xml_text::as_uint(unsigned int def) const$/;"	f	class:pugi::xml_text	signature:(unsigned int def) const
pugi::xml_text::as_uint	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned int as_uint(unsigned int def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned int def = 0) const
pugi::xml_text::as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned long long xml_text::as_ullong(unsigned long long def) const$/;"	f	class:pugi::xml_text	signature:(unsigned long long def) const
pugi::xml_text::as_ullong	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		unsigned long long as_ullong(unsigned long long def = 0) const;$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned long long def = 0) const
pugi::xml_text::data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_text::data() const$/;"	f	class:pugi::xml_text	signature:() const
pugi::xml_text::data	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node data() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
pugi::xml_text::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::empty() const$/;"	f	class:pugi::xml_text	signature:() const
pugi::xml_text::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
pugi::xml_text::get	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_text::get() const$/;"	f	class:pugi::xml_text	signature:() const
pugi::xml_text::get	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* get() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
pugi::xml_text::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::operator!() const$/;"	f	class:pugi::xml_text	signature:() const
pugi::xml_text::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(bool rhs)$/;"	f	class:pugi::xml_text	signature:(bool rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(const char_t* rhs)$/;"	f	class:pugi::xml_text	signature:(const char_t* rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(double rhs)$/;"	f	class:pugi::xml_text	signature:(double rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(float rhs)$/;"	f	class:pugi::xml_text	signature:(float rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(int rhs)$/;"	f	class:pugi::xml_text	signature:(int rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(long long rhs)$/;"	f	class:pugi::xml_text	signature:(long long rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(unsigned int rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned int rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text& xml_text::operator=(unsigned long long rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned long long rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(bool rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(bool rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(const char_t* rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(const char_t* rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(double rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(double rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(float rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(float rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(int rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(long long rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(unsigned int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned int rhs)
pugi::xml_text::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text& operator=(unsigned long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned long long rhs)
pugi::xml_text::operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xml_text	access:public	signature:() const
pugi::xml_text::operator xml_text::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text::operator xml_text::unspecified_bool_type() const$/;"	f	class:pugi::xml_text	signature:() const
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(bool rhs)$/;"	f	class:pugi::xml_text	signature:(bool rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(const char_t* rhs)$/;"	f	class:pugi::xml_text	signature:(const char_t* rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(double rhs)$/;"	f	class:pugi::xml_text	signature:(double rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(float rhs)$/;"	f	class:pugi::xml_text	signature:(float rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(int rhs)$/;"	f	class:pugi::xml_text	signature:(int rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(long long rhs)$/;"	f	class:pugi::xml_text	signature:(long long rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(unsigned int rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned int rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(unsigned long long rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned long long rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(bool rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(bool rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(const char_t* rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(double rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(double rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(float rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(float rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(int rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(long long rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(unsigned int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned int rhs)
pugi::xml_text::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(unsigned long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned long long rhs)
pugi::xml_text::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xml_text***);$/;"	t	class:pugi::xml_text	access:private
pugi::xml_text::xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text::xml_text(): _root(0)$/;"	f	class:pugi::xml_text	signature:()
pugi::xml_text::xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text::xml_text(xml_node_struct* root): _root(root)$/;"	f	class:pugi::xml_text	signature:(xml_node_struct* root)
pugi::xml_text::xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xml_text(xml_node_struct* root);$/;"	p	class:pugi::xml_text	access:private	signature:(xml_node_struct* root)
pugi::xml_text::xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text();$/;"	p	class:pugi::xml_text	access:public	signature:()
pugi::xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_tree_walker$/;"	c	namespace:pugi
pugi::xml_tree_walker::_depth	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int _depth;$/;"	m	class:pugi::xml_tree_walker	access:private
pugi::xml_tree_walker::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_tree_walker::begin(xml_node&)$/;"	f	class:pugi::xml_tree_walker	signature:(xml_node&)
pugi::xml_tree_walker::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual bool begin(xml_node& node);$/;"	p	class:pugi::xml_tree_walker	access:public	signature:(xml_node& node)
pugi::xml_tree_walker::depth	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN int xml_tree_walker::depth() const$/;"	f	class:pugi::xml_tree_walker	signature:() const
pugi::xml_tree_walker::depth	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		int depth() const;$/;"	p	class:pugi::xml_tree_walker	access:protected	signature:() const
pugi::xml_tree_walker::end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_tree_walker::end(xml_node&)$/;"	f	class:pugi::xml_tree_walker	signature:(xml_node&)
pugi::xml_tree_walker::end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual bool end(xml_node& node);$/;"	p	class:pugi::xml_tree_walker	access:public	signature:(xml_node& node)
pugi::xml_tree_walker::for_each	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual bool for_each(xml_node& node) = 0;$/;"	p	class:pugi::xml_tree_walker	access:public	signature:(xml_node& node)
pugi::xml_tree_walker::xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_tree_walker::xml_tree_walker(): _depth(0)$/;"	f	class:pugi::xml_tree_walker	signature:()
pugi::xml_tree_walker::xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_tree_walker();$/;"	p	class:pugi::xml_tree_walker	access:public	signature:()
pugi::xml_tree_walker::~xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_tree_walker::~xml_tree_walker()$/;"	f	class:pugi::xml_tree_walker	signature:()
pugi::xml_tree_walker::~xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual ~xml_tree_walker();$/;"	p	class:pugi::xml_tree_walker	access:public	signature:()
pugi::xml_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_writer$/;"	c	namespace:pugi
pugi::xml_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual void write(const void* data, size_t size) = 0;$/;"	p	class:pugi::xml_writer	access:public	signature:(const void* data, size_t size)
pugi::xml_writer::~xml_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual ~xml_writer() {}$/;"	f	class:pugi::xml_writer	access:public	signature:()
pugi::xml_writer_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_writer_file: public xml_writer$/;"	c	namespace:pugi	inherits:xml_writer
pugi::xml_writer_file::file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void* file;$/;"	m	class:pugi::xml_writer_file	access:private
pugi::xml_writer_file::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_writer_file::write(const void* data, size_t size)$/;"	f	class:pugi::xml_writer_file	signature:(const void* data, size_t size)
pugi::xml_writer_file::write	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual void write(const void* data, size_t size);$/;"	p	class:pugi::xml_writer_file	access:public	signature:(const void* data, size_t size)
pugi::xml_writer_file::xml_writer_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_writer_file::xml_writer_file(void* file_): file(file_)$/;"	f	class:pugi::xml_writer_file	signature:(void* file_)
pugi::xml_writer_file::xml_writer_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_writer_file(void* file);$/;"	p	class:pugi::xml_writer_file	access:public	signature:(void* file)
pugi::xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_writer_stream: public xml_writer$/;"	c	namespace:pugi	inherits:xml_writer
pugi::xml_writer_stream::narrow_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		std::basic_ostream<char, std::char_traits<char> >* narrow_stream;$/;"	m	class:pugi::xml_writer_stream	access:private
pugi::xml_writer_stream::wide_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream;$/;"	m	class:pugi::xml_writer_stream	access:private
pugi::xml_writer_stream::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_writer_stream::write(const void* data, size_t size)$/;"	f	class:pugi::xml_writer_stream	signature:(const void* data, size_t size)
pugi::xml_writer_stream::write	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual void write(const void* data, size_t size);$/;"	p	class:pugi::xml_writer_stream	access:public	signature:(const void* data, size_t size)
pugi::xml_writer_stream::xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream): narrow_stream(&stream), wide_stream(0)$/;"	f	class:pugi::xml_writer_stream	signature:(std::basic_ostream<char, std::char_traits<char> >& stream)
pugi::xml_writer_stream::xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream): narrow_stream(0), wide_stream(&stream)$/;"	f	class:pugi::xml_writer_stream	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream)
pugi::xml_writer_stream::xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream);$/;"	p	class:pugi::xml_writer_stream	access:public	signature:(std::basic_ostream<char, std::char_traits<char> >& stream)
pugi::xml_writer_stream::xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);$/;"	p	class:pugi::xml_writer_stream	access:public	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream)
pugi::xpath_exception	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_exception: public std::exception$/;"	c	namespace:pugi	inherits:std::exception
pugi::xpath_exception::_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_parse_result _result;$/;"	m	class:pugi::xpath_exception	access:private
pugi::xpath_exception::result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_parse_result& xpath_exception::result() const$/;"	f	class:pugi::xpath_exception	signature:() const
pugi::xpath_exception::result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_parse_result& result() const;$/;"	p	class:pugi::xpath_exception	access:public	signature:() const
pugi::xpath_exception::what	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char* xpath_exception::what() const throw()$/;"	f	class:pugi::xpath_exception	signature:() const
pugi::xpath_exception::what	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual const char* what() const throw();$/;"	p	class:pugi::xpath_exception	access:public	signature:() const
pugi::xpath_exception::xpath_exception	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_exception::xpath_exception(const xpath_parse_result& result_): _result(result_)$/;"	f	class:pugi::xpath_exception	signature:(const xpath_parse_result& result_)
pugi::xpath_exception::xpath_exception	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xpath_exception(const xpath_parse_result& result);$/;"	p	class:pugi::xpath_exception	access:public	signature:(const xpath_parse_result& result)
pugi::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_node$/;"	c	namespace:pugi
pugi::xpath_node::_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute _attribute;$/;"	m	class:pugi::xpath_node	access:private
pugi::xpath_node::_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node _node;$/;"	m	class:pugi::xpath_node	access:private
pugi::xpath_node::attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute xpath_node::attribute() const$/;"	f	class:pugi::xpath_node	signature:() const
pugi::xpath_node::attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute attribute() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
pugi::xpath_node::node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xpath_node::node() const$/;"	f	class:pugi::xpath_node	signature:() const
pugi::xpath_node::node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node node() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
pugi::xpath_node::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node::operator!() const$/;"	f	class:pugi::xpath_node	signature:() const
pugi::xpath_node::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
pugi::xpath_node::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node::operator!=(const xpath_node& n) const$/;"	f	class:pugi::xpath_node	signature:(const xpath_node& n) const
pugi::xpath_node::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!=(const xpath_node& n) const;$/;"	p	class:pugi::xpath_node	access:public	signature:(const xpath_node& n) const
pugi::xpath_node::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node::operator==(const xpath_node& n) const$/;"	f	class:pugi::xpath_node	signature:(const xpath_node& n) const
pugi::xpath_node::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator==(const xpath_node& n) const;$/;"	p	class:pugi::xpath_node	access:public	signature:(const xpath_node& n) const
pugi::xpath_node::operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
pugi::xpath_node::operator xpath_node::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::operator xpath_node::unspecified_bool_type() const$/;"	f	class:pugi::xpath_node	signature:() const
pugi::xpath_node::parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xpath_node::parent() const$/;"	f	class:pugi::xpath_node	signature:() const
pugi::xpath_node::parent	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node parent() const;$/;"	p	class:pugi::xpath_node	access:public	signature:() const
pugi::xpath_node::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xpath_node***);$/;"	t	class:pugi::xpath_node	access:private
pugi::xpath_node::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::xpath_node()$/;"	f	class:pugi::xpath_node	signature:()
pugi::xpath_node::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::xpath_node(const xml_attribute& attribute_, const xml_node& parent_): _node(attribute_ ? parent_ : xml_node()), _attribute(attribute_)$/;"	f	class:pugi::xpath_node	signature:(const xml_attribute& attribute_, const xml_node& parent_)
pugi::xpath_node::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::xpath_node(const xml_node& node_): _node(node_)$/;"	f	class:pugi::xpath_node	signature:(const xml_node& node_)
pugi::xpath_node::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node();$/;"	p	class:pugi::xpath_node	access:public	signature:()
pugi::xpath_node::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node(const xml_attribute& attribute, const xml_node& parent);$/;"	p	class:pugi::xpath_node	access:public	signature:(const xml_attribute& attribute, const xml_node& parent)
pugi::xpath_node::xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node(const xml_node& node);$/;"	p	class:pugi::xpath_node	access:public	signature:(const xml_node& node)
pugi::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_node_set$/;"	c	namespace:pugi
pugi::xpath_node_set::_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_node_set::_assign(const_iterator begin_, const_iterator end_, type_t type_)$/;"	f	class:pugi::xpath_node_set	signature:(const_iterator begin_, const_iterator end_, type_t type_)
pugi::xpath_node_set::_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _assign(const_iterator begin, const_iterator end, type_t type);$/;"	p	class:pugi::xpath_node_set	access:private	signature:(const_iterator begin, const_iterator end, type_t type)
pugi::xpath_node_set::_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node* _begin;$/;"	m	class:pugi::xpath_node_set	access:private
pugi::xpath_node_set::_end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node* _end;$/;"	m	class:pugi::xpath_node_set	access:private
pugi::xpath_node_set::_move	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_node_set::_move(xpath_node_set& rhs)$/;"	f	class:pugi::xpath_node_set	signature:(xpath_node_set& rhs)
pugi::xpath_node_set::_move	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _move(xpath_node_set& rhs);$/;"	p	class:pugi::xpath_node_set	access:private	signature:(xpath_node_set& rhs)
pugi::xpath_node_set::_storage	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node _storage;$/;"	m	class:pugi::xpath_node_set	access:private
pugi::xpath_node_set::_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		type_t _type;$/;"	m	class:pugi::xpath_node_set	access:private
pugi::xpath_node_set::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::const_iterator xpath_node_set::begin() const$/;"	f	class:pugi::xpath_node_set	signature:() const
pugi::xpath_node_set::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const_iterator begin() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
pugi::xpath_node_set::const_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef const xpath_node* const_iterator;$/;"	t	class:pugi::xpath_node_set	access:public
pugi::xpath_node_set::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_node_set::empty() const$/;"	f	class:pugi::xpath_node_set	signature:() const
pugi::xpath_node_set::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool empty() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
pugi::xpath_node_set::end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::const_iterator xpath_node_set::end() const$/;"	f	class:pugi::xpath_node_set	signature:() const
pugi::xpath_node_set::end	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const_iterator end() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
pugi::xpath_node_set::first	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xpath_node_set::first() const$/;"	f	class:pugi::xpath_node_set	signature:() const
pugi::xpath_node_set::first	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node first() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
pugi::xpath_node_set::iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef const xpath_node* iterator;$/;"	t	class:pugi::xpath_node_set	access:public
pugi::xpath_node_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set& xpath_node_set::operator=(const xpath_node_set& ns)$/;"	f	class:pugi::xpath_node_set	signature:(const xpath_node_set& ns)
pugi::xpath_node_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set& xpath_node_set::operator=(xpath_node_set&& rhs)$/;"	f	class:pugi::xpath_node_set	signature:(xpath_node_set&& rhs)
pugi::xpath_node_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set& operator=(const xpath_node_set& ns);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(const xpath_node_set& ns)
pugi::xpath_node_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set& operator=(xpath_node_set&& rhs);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(xpath_node_set&& rhs)
pugi::xpath_node_set::operator []	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_node& xpath_node_set::operator[](size_t index) const$/;"	f	class:pugi::xpath_node_set	signature:(size_t index) const
pugi::xpath_node_set::operator []	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_node& operator[](size_t index) const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:(size_t index) const
pugi::xpath_node_set::size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xpath_node_set::size() const$/;"	f	class:pugi::xpath_node_set	signature:() const
pugi::xpath_node_set::size	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t size() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
pugi::xpath_node_set::sort	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_node_set::sort(bool reverse)$/;"	f	class:pugi::xpath_node_set	signature:(bool reverse)
pugi::xpath_node_set::sort	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void sort(bool reverse = false);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(bool reverse = false)
pugi::xpath_node_set::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::type_t xpath_node_set::type() const$/;"	f	class:pugi::xpath_node_set	signature:() const
pugi::xpath_node_set::type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		type_t type() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
pugi::xpath_node_set::type_sorted	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^			type_sorted,			\/\/ Sorted by document order (ascending)$/;"	e	enum:pugi::xpath_node_set::type_t
pugi::xpath_node_set::type_sorted_reverse	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^			type_sorted_reverse		\/\/ Sorted by document order (descending)$/;"	e	enum:pugi::xpath_node_set::type_t
pugi::xpath_node_set::type_t	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		enum type_t$/;"	g	class:pugi::xpath_node_set	access:public
pugi::xpath_node_set::type_unsorted	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^			type_unsorted,			\/\/ Not ordered$/;"	e	enum:pugi::xpath_node_set::type_t
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:()
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(const xpath_node_set& ns): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:(const xpath_node_set& ns)
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(const_iterator begin_, const_iterator end_, type_t type_): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:(const_iterator begin_, const_iterator end_, type_t type_)
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(xpath_node_set&& rhs): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:(xpath_node_set&& rhs)
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set();$/;"	p	class:pugi::xpath_node_set	access:public	signature:()
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set(const xpath_node_set& ns);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(const xpath_node_set& ns)
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set(const_iterator begin, const_iterator end, type_t type = type_unsorted);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(const_iterator begin, const_iterator end, type_t type = type_unsorted)
pugi::xpath_node_set::xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set(xpath_node_set&& rhs);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(xpath_node_set&& rhs)
pugi::xpath_node_set::~xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::~xpath_node_set()$/;"	f	class:pugi::xpath_node_set	signature:()
pugi::xpath_node_set::~xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xpath_node_set();$/;"	p	class:pugi::xpath_node_set	access:public	signature:()
pugi::xpath_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	struct PUGIXML_CLASS xpath_parse_result$/;"	s	namespace:pugi
pugi::xpath_parse_result::description	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char* xpath_parse_result::description() const$/;"	f	class:pugi::xpath_parse_result	signature:() const
pugi::xpath_parse_result::description	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char* description() const;$/;"	p	struct:pugi::xpath_parse_result	access:public	signature:() const
pugi::xpath_parse_result::error	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char* error;$/;"	m	struct:pugi::xpath_parse_result	access:public
pugi::xpath_parse_result::offset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		ptrdiff_t offset;$/;"	m	struct:pugi::xpath_parse_result	access:public
pugi::xpath_parse_result::operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_parse_result::operator bool() const$/;"	f	class:pugi::xpath_parse_result	signature:() const
pugi::xpath_parse_result::operator bool	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator bool() const;$/;"	p	struct:pugi::xpath_parse_result	access:public	signature:() const
pugi::xpath_parse_result::xpath_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_parse_result::xpath_parse_result(): error("Internal error"), offset(0)$/;"	f	class:pugi::xpath_parse_result	signature:()
pugi::xpath_parse_result::xpath_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_parse_result();$/;"	p	struct:pugi::xpath_parse_result	access:public	signature:()
pugi::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_query$/;"	c	namespace:pugi
pugi::xpath_query::_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void* _impl;$/;"	m	class:pugi::xpath_query	access:private
pugi::xpath_query::_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_parse_result _result;$/;"	m	class:pugi::xpath_query	access:private
pugi::xpath_query::evaluate_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_query::evaluate_boolean(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool evaluate_boolean(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xpath_query::evaluate_node(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node evaluate_node(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set xpath_query::evaluate_node_set(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set evaluate_node_set(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xpath_query::evaluate_number(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_number	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double evaluate_number(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xpath_query::evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(char_t* buffer, size_t capacity, const xpath_node& n) const
pugi::xpath_query::evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN string_t xpath_query::evaluate_string(const xpath_node& n) const$/;"	f	class:pugi::xpath_query	signature:(const xpath_node& n) const
pugi::xpath_query::evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(char_t* buffer, size_t capacity, const xpath_node& n) const
pugi::xpath_query::evaluate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		string_t evaluate_string(const xpath_node& n) const;$/;"	p	class:pugi::xpath_query	access:public	signature:(const xpath_node& n) const
pugi::xpath_query::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_query::operator!() const$/;"	f	class:pugi::xpath_query	signature:() const
pugi::xpath_query::operator !	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool operator!() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
pugi::xpath_query::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query& xpath_query::operator=(xpath_query&& rhs)$/;"	f	class:pugi::xpath_query	signature:(xpath_query&& rhs)
pugi::xpath_query::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query& operator=(const xpath_query&);$/;"	p	class:pugi::xpath_query	access:private	signature:(const xpath_query&)
pugi::xpath_query::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query& operator=(xpath_query&& rhs);$/;"	p	class:pugi::xpath_query	access:public	signature:(xpath_query&& rhs)
pugi::xpath_query::operator unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		operator unspecified_bool_type() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
pugi::xpath_query::operator xpath_query::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::operator xpath_query::unspecified_bool_type() const$/;"	f	class:pugi::xpath_query	signature:() const
pugi::xpath_query::result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_parse_result& xpath_query::result() const$/;"	f	class:pugi::xpath_query	signature:() const
pugi::xpath_query::result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_parse_result& result() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
pugi::xpath_query::return_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_value_type xpath_query::return_type() const$/;"	f	class:pugi::xpath_query	signature:() const
pugi::xpath_query::return_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_value_type return_type() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
pugi::xpath_query::unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xpath_query***);$/;"	t	class:pugi::xpath_query	access:private
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::xpath_query(): _impl(0)$/;"	f	class:pugi::xpath_query	signature:()
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::xpath_query(const char_t* query, xpath_variable_set* variables): _impl(0)$/;"	f	class:pugi::xpath_query	signature:(const char_t* query, xpath_variable_set* variables)
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::xpath_query(xpath_query&& rhs)$/;"	f	class:pugi::xpath_query	signature:(xpath_query&& rhs)
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xpath_query(const char_t* query, xpath_variable_set* variables = 0);$/;"	p	class:pugi::xpath_query	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0)
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query();$/;"	p	class:pugi::xpath_query	access:public	signature:()
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query(const xpath_query&);$/;"	p	class:pugi::xpath_query	access:private	signature:(const xpath_query&)
pugi::xpath_query::xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query(xpath_query&& rhs);$/;"	p	class:pugi::xpath_query	access:public	signature:(xpath_query&& rhs)
pugi::xpath_query::~xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::~xpath_query()$/;"	f	class:pugi::xpath_query	signature:()
pugi::xpath_query::~xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xpath_query();$/;"	p	class:pugi::xpath_query	access:public	signature:()
pugi::xpath_type_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_boolean	  \/\/ Boolean$/;"	e	enum:pugi::xpath_value_type
pugi::xpath_type_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_node_set,  \/\/ Node set (xpath_node_set)$/;"	e	enum:pugi::xpath_value_type
pugi::xpath_type_none	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_none,	  \/\/ Unknown type (query failed to compile)$/;"	e	enum:pugi::xpath_value_type
pugi::xpath_type_number	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_number,	  \/\/ Number$/;"	e	enum:pugi::xpath_value_type
pugi::xpath_type_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_string,	  \/\/ String$/;"	e	enum:pugi::xpath_value_type
pugi::xpath_value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xpath_value_type$/;"	g	namespace:pugi
pugi::xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_variable$/;"	c	namespace:pugi
pugi::xpath_variable::_next	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* _next;$/;"	m	class:pugi::xpath_variable	access:protected
pugi::xpath_variable::_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_value_type _type;$/;"	m	class:pugi::xpath_variable	access:protected
pugi::xpath_variable::get_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::get_boolean() const$/;"	f	class:pugi::xpath_variable	signature:() const
pugi::xpath_variable::get_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool get_boolean() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
pugi::xpath_variable::get_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_node_set& xpath_variable::get_node_set() const$/;"	f	class:pugi::xpath_variable	signature:() const
pugi::xpath_variable::get_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_node_set& get_node_set() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
pugi::xpath_variable::get_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double xpath_variable::get_number() const$/;"	f	class:pugi::xpath_variable	signature:() const
pugi::xpath_variable::get_number	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		double get_number() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
pugi::xpath_variable::get_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xpath_variable::get_string() const$/;"	f	class:pugi::xpath_variable	signature:() const
pugi::xpath_variable::get_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* get_string() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
pugi::xpath_variable::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xpath_variable::name() const$/;"	f	class:pugi::xpath_variable	signature:() const
pugi::xpath_variable::name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* name() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
pugi::xpath_variable::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable& operator=(const xpath_variable&);$/;"	p	class:pugi::xpath_variable	access:protected	signature:(const xpath_variable&)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(bool value)$/;"	f	class:pugi::xpath_variable	signature:(bool value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(const char_t* value)$/;"	f	class:pugi::xpath_variable	signature:(const char_t* value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(const xpath_node_set& value)$/;"	f	class:pugi::xpath_variable	signature:(const xpath_node_set& value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(double value)$/;"	f	class:pugi::xpath_variable	signature:(double value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(bool value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(bool value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(const char_t* value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const xpath_node_set& value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(const xpath_node_set& value)
pugi::xpath_variable::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(double value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(double value)
pugi::xpath_variable::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_value_type xpath_variable::type() const$/;"	f	class:pugi::xpath_variable	signature:() const
pugi::xpath_variable::type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_value_type type() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
pugi::xpath_variable::xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable::xpath_variable(xpath_value_type type_): _type(type_), _next(0)$/;"	f	class:pugi::xpath_variable	signature:(xpath_value_type type_)
pugi::xpath_variable::xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable(const xpath_variable&);$/;"	p	class:pugi::xpath_variable	access:protected	signature:(const xpath_variable&)
pugi::xpath_variable::xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable(xpath_value_type type);$/;"	p	class:pugi::xpath_variable	access:protected	signature:(xpath_value_type type)
pugi::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_variable_set$/;"	c	namespace:pugi
pugi::xpath_variable_set::_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_variable_set::_assign(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(const xpath_variable_set& rhs)
pugi::xpath_variable_set::_assign	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _assign(const xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(const xpath_variable_set& rhs)
pugi::xpath_variable_set::_clone	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::_clone(xpath_variable* var, xpath_variable** out_result)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable* var, xpath_variable** out_result)
pugi::xpath_variable_set::_clone	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		static bool _clone(xpath_variable* var, xpath_variable** out_result);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(xpath_variable* var, xpath_variable** out_result)
pugi::xpath_variable_set::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* _data[64];$/;"	m	class:pugi::xpath_variable_set	access:private
pugi::xpath_variable_set::_destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_variable_set::_destroy(xpath_variable* var)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable* var)
pugi::xpath_variable_set::_destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		static void _destroy(xpath_variable* var);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(xpath_variable* var)
pugi::xpath_variable_set::_find	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* xpath_variable_set::_find(const char_t* name) const$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name) const
pugi::xpath_variable_set::_find	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* _find(const char_t* name) const;$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(const char_t* name) const
pugi::xpath_variable_set::_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_variable_set::_swap(xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable_set& rhs)
pugi::xpath_variable_set::_swap	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void _swap(xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:private	signature:(xpath_variable_set& rhs)
pugi::xpath_variable_set::add	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* xpath_variable_set::add(const char_t* name, xpath_value_type type)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, xpath_value_type type)
pugi::xpath_variable_set::add	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* add(const char_t* name, xpath_value_type type);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, xpath_value_type type)
pugi::xpath_variable_set::get	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_variable* xpath_variable_set::get(const char_t* name) const$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name) const
pugi::xpath_variable_set::get	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable* xpath_variable_set::get(const char_t* name)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name)
pugi::xpath_variable_set::get	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_variable* get(const char_t* name) const;$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name) const
pugi::xpath_variable_set::get	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable* get(const char_t* name);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name)
pugi::xpath_variable_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set& xpath_variable_set::operator=(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(const xpath_variable_set& rhs)
pugi::xpath_variable_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set& xpath_variable_set::operator=(xpath_variable_set&& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable_set&& rhs)
pugi::xpath_variable_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set& operator=(const xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const xpath_variable_set& rhs)
pugi::xpath_variable_set::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set& operator=(xpath_variable_set&& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(xpath_variable_set&& rhs)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, bool value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, bool value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, const char_t* value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, const char_t* value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, const xpath_node_set& value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, const xpath_node_set& value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, double value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, double value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, bool value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, bool value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, const char_t* value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, const char_t* value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, const xpath_node_set& value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, const xpath_node_set& value)
pugi::xpath_variable_set::set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, double value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, double value)
pugi::xpath_variable_set::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::xpath_variable_set()$/;"	f	class:pugi::xpath_variable_set	signature:()
pugi::xpath_variable_set::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::xpath_variable_set(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(const xpath_variable_set& rhs)
pugi::xpath_variable_set::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::xpath_variable_set(xpath_variable_set&& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable_set&& rhs)
pugi::xpath_variable_set::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set();$/;"	p	class:pugi::xpath_variable_set	access:public	signature:()
pugi::xpath_variable_set::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set(const xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const xpath_variable_set& rhs)
pugi::xpath_variable_set::xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set(xpath_variable_set&& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(xpath_variable_set&& rhs)
pugi::xpath_variable_set::~xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::~xpath_variable_set()$/;"	f	class:pugi::xpath_variable_set	signature:()
pugi::xpath_variable_set::~xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xpath_variable_set();$/;"	p	class:pugi::xpath_variable_set	access:public	signature:()
pugiutil	../../libs/libpugiutil/src/pugixml_loc.cpp	/^namespace pugiutil {$/;"	n	file:
pugiutil	../../libs/libpugiutil/src/pugixml_loc.hpp	/^namespace pugiutil {$/;"	n
pugiutil	../../libs/libpugiutil/src/pugixml_util.cpp	/^namespace pugiutil {$/;"	n	file:
pugiutil	../../libs/libpugiutil/src/pugixml_util.hpp	/^namespace pugiutil {$/;"	n
pugiutil::OPTIONAL	../../libs/libpugiutil/src/pugixml_util.hpp	/^        OPTIONAL$/;"	e	enum:pugiutil::ReqOpt
pugiutil::REQUIRED	../../libs/libpugiutil/src/pugixml_util.hpp	/^        REQUIRED,$/;"	e	enum:pugiutil::ReqOpt
pugiutil::ReqOpt	../../libs/libpugiutil/src/pugixml_util.hpp	/^    enum ReqOpt {$/;"	g	namespace:pugiutil
pugiutil::XmlError	../../libs/libpugiutil/src/pugixml_util.hpp	/^    class XmlError : public std::runtime_error {$/;"	c	namespace:pugiutil	inherits:std::runtime_error
pugiutil::XmlError::XmlError	../../libs/libpugiutil/src/pugixml_util.hpp	/^            XmlError(std::string msg="", std::string new_filename="", size_t new_linenumber=-1)$/;"	f	class:pugiutil::XmlError	access:public	signature:(std::string msg=Ó, std::string new_filename=Ó, size_t new_linenumber=-1)
pugiutil::XmlError::filename	../../libs/libpugiutil/src/pugixml_util.hpp	/^            std::string filename() const { return filename_; }$/;"	f	class:pugiutil::XmlError	access:public	signature:() const
pugiutil::XmlError::filename_	../../libs/libpugiutil/src/pugixml_util.hpp	/^            std::string filename_;$/;"	m	class:pugiutil::XmlError	access:private
pugiutil::XmlError::filename_c_str	../../libs/libpugiutil/src/pugixml_util.hpp	/^            const char* filename_c_str() const { return filename_.c_str(); }$/;"	f	class:pugiutil::XmlError	access:public	signature:() const
pugiutil::XmlError::line	../../libs/libpugiutil/src/pugixml_util.hpp	/^            size_t line() const { return linenumber_; }$/;"	f	class:pugiutil::XmlError	access:public	signature:() const
pugiutil::XmlError::linenumber_	../../libs/libpugiutil/src/pugixml_util.hpp	/^            size_t linenumber_;$/;"	m	class:pugiutil::XmlError	access:private
pugiutil::check_node	../../libs/libpugiutil/src/pugixml_util.cpp	/^    bool check_node(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& tag_name, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::check_node	../../libs/libpugiutil/src/pugixml_util.hpp	/^    bool check_node(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& tag_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
pugiutil::count_attributes	../../libs/libpugiutil/src/pugixml_util.cpp	/^    size_t count_attributes(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::count_attributes	../../libs/libpugiutil/src/pugixml_util.hpp	/^    size_t count_attributes(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
pugiutil::count_children	../../libs/libpugiutil/src/pugixml_util.cpp	/^    size_t count_children(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::count_children	../../libs/libpugiutil/src/pugixml_util.cpp	/^    size_t count_children(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::count_children	../../libs/libpugiutil/src/pugixml_util.hpp	/^    size_t count_children(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::count_children	../../libs/libpugiutil/src/pugixml_util.hpp	/^    size_t count_children(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
pugiutil::expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, size_t expected_count, const loc_data& loc_data)
pugiutil::expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::string child_name, size_t expected_count, const loc_data& loc_data)
pugiutil::expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, size_t expected_count, const loc_data& loc_data)
pugiutil::expect_child_node_count	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_child_node_count(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::string child_name, size_t expected_count, const loc_data& loc_data)
pugiutil::expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, const loc_data& loc_data)
pugiutil::expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, std::string explanation, const loc_data& loc_data)
pugiutil::expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, const loc_data& loc_data)
pugiutil::expect_only_attributes	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_only_attributes(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> attribute_names, std::string explanation, const loc_data& loc_data)
pugiutil::expect_only_children	../../libs/libpugiutil/src/pugixml_util.cpp	/^    void expect_only_children(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> child_names, const loc_data& loc_data)
pugiutil::expect_only_children	../../libs/libpugiutil/src/pugixml_util.hpp	/^    void expect_only_children(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, std::vector<std::string> child_names, const loc_data& loc_data)
pugiutil::get_attribute	../../libs/libpugiutil/src/pugixml_util.cpp	/^    pugi::xml_attribute get_attribute(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& attr_name, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::get_attribute	../../libs/libpugiutil/src/pugixml_util.hpp	/^    pugi::xml_attribute get_attribute(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& attr_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
pugiutil::get_first_child	../../libs/libpugiutil/src/pugixml_util.cpp	/^    pugi::xml_node get_first_child(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::get_first_child	../../libs/libpugiutil/src/pugixml_util.hpp	/^    pugi::xml_node get_first_child(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
pugiutil::get_single_child	../../libs/libpugiutil/src/pugixml_util.cpp	/^    pugi::xml_node get_single_child(const pugi::xml_node node,$/;"	f	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt)
pugiutil::get_single_child	../../libs/libpugiutil/src/pugixml_util.hpp	/^    pugi::xml_node get_single_child(const pugi::xml_node node,$/;"	p	namespace:pugiutil	signature:(const pugi::xml_node node, const std::string& child_name, const loc_data& loc_data, const ReqOpt req_opt=REQUIRED)
pugiutil::load_xml	../../libs/libpugiutil/src/pugixml_util.cpp	/^    loc_data load_xml(pugi::xml_document& doc,  \/\/Document object to be loaded with file contents$/;"	f	namespace:pugiutil	signature:(pugi::xml_document& doc, const std::string filename)
pugiutil::load_xml	../../libs/libpugiutil/src/pugixml_util.hpp	/^    loc_data load_xml(pugi::xml_document& doc,  \/\/Document object to be loaded with file contents$/;"	p	namespace:pugiutil	signature:(pugi::xml_document& doc, const std::string filename)
pugiutil::loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^    class loc_data {$/;"	c	namespace:pugiutil
pugiutil::loc_data::build_loc_data	../../libs/libpugiutil/src/pugixml_loc.cpp	/^void loc_data::build_loc_data() {$/;"	f	class:pugiutil::loc_data	signature:()
pugiutil::loc_data::build_loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            void build_loc_data();$/;"	p	class:pugiutil::loc_data	access:private	signature:()
pugiutil::loc_data::col	../../libs/libpugiutil/src/pugixml_loc.cpp	/^std::size_t loc_data::col(std::ptrdiff_t offset) const {$/;"	f	class:pugiutil::loc_data	signature:(std::ptrdiff_t offset) const
pugiutil::loc_data::col	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t col(pugi::xml_node node) const {$/;"	f	class:pugiutil::loc_data	access:public	signature:(pugi::xml_node node) const
pugiutil::loc_data::col	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t col(std::ptrdiff_t offset) const;$/;"	p	class:pugiutil::loc_data	access:public	signature:(std::ptrdiff_t offset) const
pugiutil::loc_data::filename	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            const std::string& filename() const { return filename_; }$/;"	f	class:pugiutil::loc_data	access:public	signature:() const
pugiutil::loc_data::filename_	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::string filename_;$/;"	m	class:pugiutil::loc_data	access:private
pugiutil::loc_data::filename_c_str	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            const char* filename_c_str() const { return filename_.c_str(); }$/;"	f	class:pugiutil::loc_data	access:public	signature:() const
pugiutil::loc_data::line	../../libs/libpugiutil/src/pugixml_loc.cpp	/^std::size_t loc_data::line(std::ptrdiff_t offset) const {$/;"	f	class:pugiutil::loc_data	signature:(std::ptrdiff_t offset) const
pugiutil::loc_data::line	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t line(pugi::xml_node node) const {$/;"	f	class:pugiutil::loc_data	access:public	signature:(pugi::xml_node node) const
pugiutil::loc_data::line	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::size_t line(std::ptrdiff_t offset) const;$/;"	p	class:pugiutil::loc_data	access:public	signature:(std::ptrdiff_t offset) const
pugiutil::loc_data::loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            loc_data() = default;$/;"	p	class:pugiutil::loc_data	access:public	signature:()
pugiutil::loc_data::loc_data	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            loc_data(std::string filename_val)$/;"	f	class:pugiutil::loc_data	access:public	signature:(std::string filename_val)
pugiutil::loc_data::offsets_	../../libs/libpugiutil/src/pugixml_loc.hpp	/^            std::vector<std::ptrdiff_t> offsets_;$/;"	m	class:pugiutil::loc_data	access:private
push	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void push(char_t*& s, size_t count)$/;"	f	struct:gap	access:public	signature:(char_t*& s, size_t count)
push_back	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void push_back(const xpath_node& node, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw	access:public	signature:(const xpath_node& node, xpath_allocator* alloc)
push_back	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void push_back(Args&&... args) { vec_.push_back(std::forward<Args>(args)...); }$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
push_back	route/route_common.cpp	/^	void push_back(t_heap* const hptr) {$/;"	f	namespace:heap_	signature:(t_heap* const hptr)
push_back	route/route_common.h	/^	void push_back(t_heap* const hptr);$/;"	p	namespace:heap_	signature:(t_heap* const hptr)
push_back_grow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void push_back_grow(const xpath_node& node, xpath_allocator* alloc);$/;"	p	class:xpath_node_set_raw	file:	access:public	signature:(const xpath_node& node, xpath_allocator* alloc)
push_back_grow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE void xpath_node_set_raw::push_back_grow(const xpath_node& node, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw	signature:(const xpath_node& node, xpath_allocator* alloc)
push_back_node	route/route_common.cpp	/^	void push_back_node(int inode, float total_cost, int prev_node, int prev_edge,$/;"	f	namespace:heap_	signature:(int inode, float total_cost, int prev_node, int prev_edge, float backward_path_cost, float R_upstream)
push_back_node	route/route_common.h	/^	void push_back_node(int inode, float total_cost, int prev_node, int prev_edge,$/;"	p	namespace:heap_	signature:(int inode, float total_cost, int prev_node, int prev_edge, float backward_path_cost, float R_upstream)
put_sink_rt_nodes_in_net_pins_lookup	route/connection_based_routing.h	/^	void put_sink_rt_nodes_in_net_pins_lookup(const std::vector<t_rt_node*>& sink_rt_nodes,$/;"	p	class:Connection_based_routing_resources	access:public	signature:(const std::vector<t_rt_node*>& sink_rt_nodes, t_rt_node** rt_node_of_sink) const
put_sink_rt_nodes_in_net_pins_lookup	route/route_timing.cpp	/^void Connection_based_routing_resources::put_sink_rt_nodes_in_net_pins_lookup(const vector<t_rt_node*>& sink_rt_nodes,$/;"	f	class:Connection_based_routing_resources	signature:(const vector<t_rt_node*>& sink_rt_nodes, t_rt_node** rt_node_of_sink) const
qualified_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* qualified_name(const xpath_node& node)$/;"	f	signature:(const xpath_node& node)
quantifier	timing/slre.cpp	/^static void quantifier(struct slre *r, int prev, int op) {$/;"	f	file:	signature:(struct slre *r, int prev, int op)
quiet	../../libs/libvtrutil/src/vtr_time.cpp	/^bool ScopedActionTimer::quiet() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
quiet	../../libs/libvtrutil/src/vtr_time.cpp	/^void ScopedActionTimer::quiet(bool value) {$/;"	f	class:vtr::ScopedActionTimer	signature:(bool value)
quiet	../../libs/libvtrutil/src/vtr_time.h	/^            bool quiet() const;$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:() const
quiet	../../libs/libvtrutil/src/vtr_time.h	/^            void quiet(bool value);$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:(bool value)
quiet_	../../libs/libvtrutil/src/vtr_time.h	/^            bool quiet_ = false;$/;"	m	class:vtr::ScopedActionTimer	access:private
quit	../../libs/libeasygl/src/graphics.cpp	/^quit(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
quit	../../libs/libeasygl/src/graphics.cpp	/^static void quit(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
r	../../libs/libvtrutil/src/vtr_color_map.h	/^    T r;$/;"	m	struct:vtr::Color	access:public
radix_digit_to_bits	../../libs/librtlnumber/src/rtl_utils.cpp	/^#define radix_digit_to_bits(/;"	d	file:
random_state	../../libs/libvtrutil/src/vtr_random.cpp	/^static RandState random_state = 0;$/;"	m	namespace:vtr	file:
range	../../libs/libvtrutil/src/vtr_color_map.cpp	/^float ColorMap::range() const {$/;"	f	class:vtr::ColorMap	signature:() const
range	../../libs/libvtrutil/src/vtr_color_map.h	/^        float range() const;$/;"	p	class:vtr::ColorMap	access:public	signature:() const
rbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  rbegin()    const   { return vec_.rbegin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
rbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        reverse_iterator        rbegin()            { return vec_.rbegin(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
rbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  rbegin()    const   { return vec_.rbegin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
rbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        reverse_iterator        rbegin()            { return vec_.rbegin(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
rbegin	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_reverse_iterator rbegin() const { return vec_.rbegin(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
rc_index	route/rr_node.cpp	/^short t_rr_node::rc_index() const {$/;"	f	class:t_rr_node	signature:() const
rc_index	route/rr_node.h	/^        short rc_index() const;$/;"	p	class:t_rr_node	access:public	signature:() const
rc_index_	route/rr_node.h	/^        int16_t rc_index_ = -1;$/;"	m	class:t_rr_node	access:private
rc_node	timing/net_delay.cpp	/^	t_rc_node *rc_node;$/;"	m	struct:t_linked_rc_ptr	file:	access:public
re_expand	route/route_tree_type.h	/^	bool re_expand;$/;"	m	struct:t_rt_node	access:public
reached_rt_sink	route/connection_based_routing.h	/^	void reached_rt_sink(t_rt_node* rt_sink) {reached_rt_sinks.push_back(rt_sink);}$/;"	f	class:Connection_based_routing_resources	access:public	signature:(t_rt_node* rt_sink)
reached_rt_sinks	route/connection_based_routing.h	/^	std::vector<t_rt_node*> reached_rt_sinks;$/;"	m	class:Connection_based_routing_resources	access:private
read_activity	base/read_activity.cpp	/^std::unordered_map<AtomNetId,t_net_power> read_activity(const AtomNetlist& netlist, const char * activity_file) {$/;"	f	signature:(const AtomNetlist& netlist, const char * activity_file)
read_activity	base/read_activity.h	/^std::unordered_map<AtomNetId,t_net_power> read_activity(const AtomNetlist& netlist, const char * activity_file);$/;"	p	signature:(const AtomNetlist& netlist, const char * activity_file)
read_and_process_circuit	base/read_circuit.cpp	/^AtomNetlist read_and_process_circuit(e_circuit_format circuit_format,$/;"	f	signature:(e_circuit_format circuit_format, const char* circuit_file, const t_model* user_models, const t_model* library_models, e_const_gen_inference const_gen_inference, bool should_absorb_buffers, bool should_sweep_dangling_primary_ios, bool should_sweep_dangling_nets, bool should_sweep_dangling_blocks, bool should_sweep_constant_primary_outputs, int verbosity)
read_and_process_circuit	base/read_circuit.h	/^AtomNetlist read_and_process_circuit(const e_circuit_format circuit_format,$/;"	p	signature:(const e_circuit_format circuit_format, const char *circuit_file, const t_model *user_models, const t_model *library_models, e_const_gen_inference const_gen_inference, bool should_absorb_buffers, bool should_sweep_dangling_primary_ios, bool should_sweep_dangling_nets, bool should_sweep_dangling_blocks, bool should_sweep_constant_primary_outputs, int verbosity)
read_blif	base/read_blif.cpp	/^AtomNetlist read_blif(e_circuit_format circuit_format,$/;"	f	signature:(e_circuit_format circuit_format, const char *blif_file, const t_model *user_models, const t_model *library_models, const int verbosity)
read_blif	base/read_blif.h	/^AtomNetlist read_blif(e_circuit_format circuit_format,$/;"	p	signature:(e_circuit_format circuit_format, const char* blif_file, const t_model* user_models, const t_model* library_models, const int verbosity)
read_hmetis_graph	pack/pack.cpp	/^static vtr::vector<AtomBlockId, int> read_hmetis_graph(string &hmetis_output_file, const int num_parts) {$/;"	f	file:	signature:(string &hmetis_output_file, const int num_parts)
read_hmetis_graph	pack/pack.cpp	/^static vtr::vector<AtomBlockId, int> read_hmetis_graph(string &hmetis_output_file_name, const int num_parts);$/;"	p	file:	signature:(string &hmetis_output_file_name, const int num_parts)
read_netlist	base/read_netlist.cpp	/^ClusteredNetlist read_netlist(const char *net_file,$/;"	f	signature:(const char *net_file, const t_arch* arch, bool verify_file_digests)
read_netlist	base/read_netlist.h	/^ClusteredNetlist read_netlist(const char *net_file,$/;"	p	signature:(const char *net_file, const t_arch *arch, bool verify_file_digests)
read_options	base/read_options.cpp	/^t_options read_options(int argc, const char** argv) {$/;"	f	signature:(int argc, const char** argv)
read_options	base/read_options.h	/^t_options read_options(int argc, const char** argv);$/;"	p	signature:(int argc, const char** argv)
read_place	base/read_place.cpp	/^void read_place(const char* net_file,$/;"	f	signature:(const char* net_file, const char* place_file, bool verify_file_digests, const DeviceGrid& grid)
read_place	base/read_place.h	/^void read_place($/;"	p	signature:( const char *net_file, const char *place_file, bool verify_file_hashes, const DeviceGrid& grid)
read_route	base/read_route.cpp	/^bool read_route(const char* route_file, const t_router_opts& router_opts, bool verify_file_digests) {$/;"	f	signature:(const char* route_file, const t_router_opts& router_opts, bool verify_file_digests)
read_route	base/read_route.h	/^bool read_route(const char* route_file, const t_router_opts& RouterOpts, bool verify_file_digests);$/;"	p	signature:(const char* route_file, const t_router_opts& RouterOpts, bool verify_file_digests)
read_rr_graph_file	base/read_options.h	/^    argparse::ArgValue<std::string> read_rr_graph_file;$/;"	m	struct:t_options	access:public
read_rr_graph_filename	base/vpr_types.h	/^    std::string read_rr_graph_filename;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
read_sb_switchfuncs	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void read_sb_switchfuncs( pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data ){$/;"	f	signature:( pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data )
read_sb_switchfuncs	../../libs/libarchfpga/src/parse_switchblocks.h	/^void read_sb_switchfuncs( pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data );$/;"	p	signature:( pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data )
read_sb_wireconns	../../libs/libarchfpga/src/parse_switchblocks.cpp	/^void read_sb_wireconns(const t_arch_switch_inf * \/*switches*\/, int \/*num_switches*\/, pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data ){$/;"	f	signature:(const t_arch_switch_inf * , int , pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data )
read_sb_wireconns	../../libs/libarchfpga/src/parse_switchblocks.h	/^void read_sb_wireconns(const t_arch_switch_inf *switches, int num_switches, pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data );$/;"	p	signature:(const t_arch_switch_inf *switches, int num_switches, pugi::xml_node Node, t_switchblock_inf *sb, const pugiutil::loc_data& loc_data )
read_sdc	timing/read_sdc.cpp	/^void read_sdc(t_timing_inf timing_inf) {$/;"	f	signature:(t_timing_inf timing_inf)
read_sdc	timing/read_sdc.h	/^void read_sdc(t_timing_inf timing_inf);$/;"	p	signature:(t_timing_inf timing_inf)
read_sdc2	timing/read_sdc2.cpp	/^std::unique_ptr<tatum::TimingConstraints> read_sdc2(const t_timing_inf& timing_inf,$/;"	f	signature:(const t_timing_inf& timing_inf, const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingGraph& timing_graph)
read_sdc2	timing/read_sdc2.h	/^std::unique_ptr<tatum::TimingConstraints> read_sdc2(const t_timing_inf& timing_inf,$/;"	p	signature:(const t_timing_inf& timing_inf, const AtomNetlist& netlist, const AtomLookup& lookup, tatum::TimingGraph& timing_graph)
read_user_pad_loc	base/read_place.cpp	/^void read_user_pad_loc(const char *pad_loc_file) {$/;"	f	signature:(const char *pad_loc_file)
read_user_pad_loc	base/read_place.h	/^void read_user_pad_loc(const char *pad_loc_file);$/;"	p	signature:(const char *pad_loc_file)
realloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* realloc(void *ptr, size_t size) {$/;"	f	namespace:vtr	signature:(void *ptr, size_t size)
realloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* realloc(void *ptr, size_t size);$/;"	p	namespace:vtr	signature:(void *ptr, size_t size)
realloc_and_load_pb_graph_pin_ptrs_at_var	pack/pb_type_graph.cpp	/^static bool realloc_and_load_pb_graph_pin_ptrs_at_var(const int line_num,$/;"	f	file:	signature:(const int line_num, const t_pb_graph_node *pb_graph_parent_node, t_pb_graph_node **pb_graph_children_nodes, const bool interconnect_error_check, const bool is_input_to_interc, const t_token *tokens, int *token_index, int *num_pins, t_pb_graph_pin ***pb_graph_pins)
realloc_and_load_pb_graph_pin_ptrs_at_var	pack/pb_type_graph.cpp	/^static bool realloc_and_load_pb_graph_pin_ptrs_at_var(const int line_num,$/;"	p	file:	signature:(const int line_num, const t_pb_graph_node *pb_graph_parent_node, t_pb_graph_node **pb_graph_children_nodes, const bool interconnect_error_check, const bool is_input_to_interc, const t_token *tokens, int *token_index, int *num_pins, t_pb_graph_pin ***pb_graph_pins)
reallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* reallocate(void* ptr, size_t old_size, size_t new_size)$/;"	f	class:xpath_allocator	access:public	signature:(void* ptr, size_t old_size, size_t new_size)
rebuild_block_refs	base/netlist.h	/^        void rebuild_block_refs(const vtr::vector_map<PinId, PinId>& pin_id_map,$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map)
rebuild_block_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_block_refs(const vtr::vector_map<PinId, PinId>& pin_id_map,$/;"	f	class:Netlist	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map)
rebuild_block_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_block_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& \/*pin_id_map*\/,$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPinId, AtomPinId>& , const vtr::vector_map<AtomPortId, AtomPortId>& )
rebuild_block_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_block_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& \/*pin_id_map*\/,$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPinId, ClusterPinId>& , const vtr::vector_map<ClusterPortId, ClusterPortId>& )
rebuild_block_refs_impl	base/netlist.h	/^        virtual void rebuild_block_refs_impl(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map, const vtr::vector_map<PortId, PortId>& port_id_map)
rebuild_lookups	base/netlist.h	/^        void rebuild_lookups();$/;"	p	class:Netlist	access:protected	signature:()
rebuild_lookups	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_lookups() {$/;"	f	class:Netlist	signature:()
rebuild_net_refs	base/netlist.h	/^        void rebuild_net_refs(const vtr::vector_map<PinId, PinId>& pin_id_map);$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
rebuild_net_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_net_refs(const vtr::vector_map<PinId, PinId>& pin_id_map) {$/;"	f	class:Netlist	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
rebuild_net_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_net_refs_impl(const vtr::vector_map<AtomPinId, AtomPinId>& \/*pin_id_map*\/) {$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPinId, AtomPinId>& )
rebuild_net_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_net_refs_impl(const vtr::vector_map<ClusterPinId, ClusterPinId>& \/*pin_id_map*\/) {$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPinId, ClusterPinId>& )
rebuild_net_refs_impl	base/netlist.h	/^        virtual void rebuild_net_refs_impl(const vtr::vector_map<PinId, PinId>& pin_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PinId, PinId>& pin_id_map)
rebuild_pin_refs	base/netlist.h	/^        void rebuild_pin_refs(const vtr::vector_map<PortId, PortId>& port_id_map,$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map)
rebuild_pin_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_pin_refs(const vtr::vector_map<PortId, PortId>& port_id_map,$/;"	f	class:Netlist	signature:(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map)
rebuild_pin_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_pin_refs_impl(const vtr::vector_map<AtomPortId, AtomPortId>& \/*port_id_map*\/,$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomPortId, AtomPortId>& , const vtr::vector_map<AtomNetId, AtomNetId>& )
rebuild_pin_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_pin_refs_impl(const vtr::vector_map<ClusterPortId, ClusterPortId>& \/*port_id_map*\/,$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterPortId, ClusterPortId>& , const vtr::vector_map<ClusterNetId, ClusterNetId>& )
rebuild_pin_refs_impl	base/netlist.h	/^        virtual void rebuild_pin_refs_impl(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<PortId, PortId>& port_id_map, const vtr::vector_map<NetId, NetId>& net_id_map)
rebuild_port_refs	base/netlist.h	/^        void rebuild_port_refs(const vtr::vector_map<BlockId, BlockId>& block_id_map,$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map)
rebuild_port_refs	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::rebuild_port_refs(const vtr::vector_map<BlockId, BlockId>& block_id_map,$/;"	f	class:Netlist	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map)
rebuild_port_refs_impl	base/atom_netlist.cpp	/^void AtomNetlist::rebuild_port_refs_impl(const vtr::vector_map<AtomBlockId, AtomBlockId>& \/*block_id_map*\/,$/;"	f	class:AtomNetlist	signature:(const vtr::vector_map<AtomBlockId, AtomBlockId>& , const vtr::vector_map<AtomPinId, AtomPinId>& )
rebuild_port_refs_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::rebuild_port_refs_impl(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& \/*block_id_map*\/,$/;"	f	class:ClusteredNetlist	signature:(const vtr::vector_map<ClusterBlockId, ClusterBlockId>& , const vtr::vector_map<ClusterPinId, ClusterPinId>& )
rebuild_port_refs_impl	base/netlist.h	/^        virtual void rebuild_port_refs_impl(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map) = 0;$/;"	p	class:Netlist	access:protected	signature:(const vtr::vector_map<BlockId, BlockId>& block_id_map, const vtr::vector_map<PinId, PinId>& pin_id_map)
recompute_bb_cost	place/place.cpp	/^static float recompute_bb_cost() {$/;"	f	file:	signature:()
recompute_bb_cost	place/place.cpp	/^static float recompute_bb_cost();$/;"	p	file:	signature:()
recompute_costs_from_scratch	place/place.cpp	/^static void recompute_costs_from_scratch(const t_placer_opts& placer_opts, const PlaceDelayModel& delay_model, t_placer_costs* costs) {$/;"	f	file:	signature:(const t_placer_opts& placer_opts, const PlaceDelayModel& delay_model, t_placer_costs* costs)
recompute_costs_from_scratch	place/place.cpp	/^static void recompute_costs_from_scratch(const t_placer_opts& placer_opts, const PlaceDelayModel& delay_model, t_placer_costs* costs);$/;"	p	file:	signature:(const t_placer_opts& placer_opts, const PlaceDelayModel& delay_model, t_placer_costs* costs)
recompute_crit_iter	base/vpr_types.h	/^	int recompute_crit_iter;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
recompute_occupancy_from_scratch	route/check_route.cpp	/^void recompute_occupancy_from_scratch() {$/;"	f	signature:()
recompute_occupancy_from_scratch	route/check_route.h	/^void recompute_occupancy_from_scratch();$/;"	p	signature:()
reconvergence_cpd_threshold	base/vpr_types.h	/^    float reconvergence_cpd_threshold;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
record_affected_net	place/place.cpp	/^static void record_affected_net(const ClusterNetId net, int& num_affected_nets) {$/;"	f	file:	signature:(const ClusterNetId net, int& num_affected_nets)
record_affected_net	place/place.cpp	/^static void record_affected_net(const ClusterNetId net, int& num_affected_nets);$/;"	p	file:	signature:(const ClusterNetId net, int& num_affected_nets)
rect_iter	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef typename std::vector<Rect<T>>::const_iterator rect_iter;$/;"	t	class:vtr::RectUnion	access:public
rect_off_screen	../../libs/libeasygl/src/graphics.cpp	/^rect_off_screen(float x1, float y1, float x2, float y2) {$/;"	f	file:	signature:(float x1, float y1, float x2, float y2)
rect_off_screen	../../libs/libeasygl/src/graphics.cpp	/^static int rect_off_screen(const t_bound_box& bbox) {$/;"	f	file:	signature:(const t_bound_box& bbox)
rect_range	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef vtr::Range<rect_iter> rect_range;$/;"	t	class:vtr::RectUnion	access:public
rects	../../libs/libvtrutil/src/vtr_geometry.h	/^        rect_range rects() const;$/;"	p	class:vtr::RectUnion	access:public	signature:() const
rects	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    typename RectUnion<T>::rect_range RectUnion<T>::rects() const {$/;"	f	class:vtr::RectUnion	signature:() const
rects_	../../libs/libvtrutil/src/vtr_geometry.h	/^        std::vector<Rect<T>> rects_;$/;"	m	class:vtr::RectUnion	access:private
red	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t red = 0;   \/\/ 8-bits per colour component$/;"	m	class:t_color	access:public
redirect_to_postscript	../../libs/libeasygl/src/graphics_state.h	/^    bool redirect_to_postscript = false;$/;"	m	struct:t_gl_state	access:public
redraw_needed	../../libs/libeasygl/src/graphics_state.h	/^    bool redraw_needed = false;$/;"	m	struct:t_gl_state	access:public
redraw_screen	draw/draw.cpp	/^static void redraw_screen() {$/;"	f	file:	signature:()
redraw_screen	draw/draw.cpp	/^static void redraw_screen();$/;"	p	file:	signature:()
reduce_budgets_if_congested	route/route_timing.cpp	/^void reduce_budgets_if_congested(route_budgets &budgeting_inf,$/;"	f	signature:(route_budgets &budgeting_inf, CBRR& connections_inf, float slope, int itry)
reduce_budgets_if_congested	route/route_timing.cpp	/^void reduce_budgets_if_congested(route_budgets &budgeting_inf,$/;"	p	file:	signature:(route_budgets &budgeting_inf, CBRR& connections_inf, float slope, int itry)
reference	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute& reference;$/;"	t	class:pugi::xml_attribute_iterator	access:public
reference	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node& reference;$/;"	t	class:pugi::xml_named_node_iterator	access:public
reference	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node& reference;$/;"	t	class:pugi::xml_node_iterator	access:public
reference	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef value_type& reference;$/;"	t	class:vtr::flat_map	access:public
reference	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef value_type& reference;$/;"	t	class:vtr::linear_map	access:public
reference	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::reference reference;$/;"	t	class:vtr::vector_map	access:public
regex_match	timing/read_sdc.cpp	/^static bool regex_match (const char * string, const char * regular_expression) {$/;"	f	file:	signature:(const char * string, const char * regular_expression)
regex_match	timing/read_sdc.cpp	/^static bool regex_match (const char *string, const char *pattern);$/;"	p	file:	signature:(const char *string, const char *pattern)
rehash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool rehash();$/;"	p	class:compact_hash_table	file:	access:private	signature:()
rehash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE bool compact_hash_table::rehash()$/;"	f	class:compact_hash_table	signature:()
relative_length	../../libs/libarchfpga/src/physical_types.h	/^		float relative_length;$/;"	m	union:t_port_power::__anon13	access:public
release	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T* release()$/;"	f	struct:auto_deleter	access:public	signature:()
release	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void release()$/;"	f	class:xpath_allocator	access:public	signature:()
relocate	timing/slre.cpp	/^static void relocate(struct slre *r, int begin, int shift) {$/;"	f	file:	signature:(struct slre *r, int begin, int shift)
remaining_targets	route/connection_based_routing.h	/^	std::vector<int> remaining_targets;$/;"	m	class:Connection_based_routing_resources	access:private
remap_ids	timing/timing_graph_builder.cpp	/^void TimingGraphBuilder::remap_ids(const tatum::GraphIdMaps& id_mapping) {$/;"	f	class:TimingGraphBuilder	signature:(const tatum::GraphIdMaps& id_mapping)
remap_ids	timing/timing_graph_builder.h	/^        void remap_ids(const tatum::GraphIdMaps& id_mapping);$/;"	p	class:TimingGraphBuilder	access:private	signature:(const tatum::GraphIdMaps& id_mapping)
remap_rr_node_switch_indices	route/rr_graph.cpp	/^static void remap_rr_node_switch_indices(const t_arch_switch_fanin& switch_fanin) {$/;"	f	file:	signature:(const t_arch_switch_fanin& switch_fanin)
remap_rr_node_switch_indices	route/rr_graph.cpp	/^static void remap_rr_node_switch_indices(const t_arch_switch_fanin& switch_fanin);$/;"	p	file:	signature:(const t_arch_switch_fanin& switch_fanin)
remap_valid	timing/timing_graph_builder.cpp	/^tatum::util::linear_map<K,V> remap_valid(const tatum::util::linear_map<K,V>& data, const tatum::util::linear_map<K,K>& id_map) {$/;"	f	signature:(const tatum::util::linear_map<K,V>& data, const tatum::util::linear_map<K,K>& id_map)
remove_and_compress	base/netlist.h	/^        IdRemapper remove_and_compress();$/;"	p	class:Netlist	access:public	signature:()
remove_and_compress	base/netlist.tpp	/^typename Netlist<BlockId, PortId, PinId, NetId>::IdRemapper Netlist<BlockId, PortId, PinId, NetId>::remove_and_compress() {$/;"	f	class:Netlist	signature:()
remove_atom_from_target	pack/cluster_router.cpp	/^void remove_atom_from_target(t_lb_router_data *router_data, const AtomBlockId blk_id) {$/;"	f	signature:(t_lb_router_data *router_data, const AtomBlockId blk_id)
remove_atom_from_target	pack/cluster_router.h	/^void remove_atom_from_target(t_lb_router_data *router_data, const AtomBlockId blk_id);$/;"	p	signature:(t_lb_router_data *router_data, const AtomBlockId blk_id)
remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_attribute(const xml_attribute& a)$/;"	f	class:pugi::xml_node	signature:(const xml_attribute& a)
remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void remove_attribute(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f	signature:(xml_attribute_struct* attr, xml_node_struct* node)
remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_attribute(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
remove_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_attribute(const xml_attribute& a);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_attribute& a)
remove_block	base/netlist.h	/^        void remove_block(const BlockId blk_id);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id)
remove_block	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_block(const BlockId blk_id) {$/;"	f	class:Netlist	signature:(const BlockId blk_id)
remove_block_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_block_impl(const AtomBlockId \/*blk_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomBlockId )
remove_block_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_block_impl(const ClusterBlockId blk_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterBlockId blk_id)
remove_block_impl	base/netlist.h	/^        virtual void remove_block_impl(const BlockId blk_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const BlockId blk_id)
remove_buffer_lut	base/atom_netlist_utils.cpp	/^void remove_buffer_lut(AtomNetlist& netlist, AtomBlockId blk, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, AtomBlockId blk, int verbosity)
remove_buffer_lut	base/atom_netlist_utils.cpp	/^void remove_buffer_lut(AtomNetlist& netlist, AtomBlockId blk, int verbosity);$/;"	p	file:	signature:(AtomNetlist& netlist, AtomBlockId blk, int verbosity)
remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_child(const char_t* name_)$/;"	f	class:pugi::xml_node	signature:(const char_t* name_)
remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::remove_child(const xml_node& n)$/;"	f	class:pugi::xml_node	signature:(const xml_node& n)
remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_child(const char_t* name);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* name)
remove_child	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool remove_child(const xml_node& n);$/;"	p	class:pugi::xml_node	access:public	signature:(const xml_node& n)
remove_duplicates	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void remove_duplicates()$/;"	f	class:xpath_node_set_raw	access:public	signature:()
remove_net	base/netlist.h	/^        void remove_net(const NetId net_id);$/;"	p	class:Netlist	access:public	signature:(const NetId net_id)
remove_net	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_net(const NetId net_id) {$/;"	f	class:Netlist	signature:(const NetId net_id)
remove_net_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_net_impl(const AtomNetId \/*net_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomNetId )
remove_net_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_net_impl(const ClusterNetId net_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterNetId net_id)
remove_net_impl	base/netlist.h	/^        virtual void remove_net_impl(const NetId net_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const NetId net_id)
remove_net_pin	base/netlist.h	/^        void remove_net_pin(const NetId net_id, const PinId pin_id);$/;"	p	class:Netlist	access:public	signature:(const NetId net_id, const PinId pin_id)
remove_net_pin	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_net_pin(const NetId net_id, const PinId pin_id) {$/;"	f	class:Netlist	signature:(const NetId net_id, const PinId pin_id)
remove_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline void remove_node(xml_node_struct* node)$/;"	f	signature:(xml_node_struct* node)
remove_pin	base/netlist.h	/^        void remove_pin(const PinId pin_id);$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id)
remove_pin	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_pin(const PinId pin_id) {$/;"	f	class:Netlist	signature:(const PinId pin_id)
remove_pin_from_rt_terminals	pack/cluster_router.cpp	/^static void remove_pin_from_rt_terminals(t_lb_router_data *router_data, const AtomPinId pin_id) {$/;"	f	file:	signature:(t_lb_router_data *router_data, const AtomPinId pin_id)
remove_pin_from_rt_terminals	pack/cluster_router.cpp	/^static void remove_pin_from_rt_terminals(t_lb_router_data *router_data, const AtomPinId pin_id);$/;"	p	file:	signature:(t_lb_router_data *router_data, const AtomPinId pin_id)
remove_pin_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_pin_impl(const AtomPinId \/*pin_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomPinId )
remove_pin_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_pin_impl(const ClusterPinId pin_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPinId pin_id)
remove_pin_impl	base/netlist.h	/^        virtual void remove_pin_impl(const PinId pin_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const PinId pin_id)
remove_port	base/netlist.h	/^        void remove_port(const PortId port_id);$/;"	p	class:Netlist	access:public	signature:(const PortId port_id)
remove_port	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_port(const PortId port_id) {$/;"	f	class:Netlist	signature:(const PortId port_id)
remove_port_impl	base/atom_netlist.cpp	/^void AtomNetlist::remove_port_impl(const AtomPortId \/*port_id*\/) {$/;"	f	class:AtomNetlist	signature:(const AtomPortId )
remove_port_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::remove_port_impl(const ClusterPortId port_id) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPortId port_id)
remove_port_impl	base/netlist.h	/^        virtual void remove_port_impl(const PortId port_id) = 0;$/;"	p	class:Netlist	access:protected	signature:(const PortId port_id)
remove_unused	base/netlist.h	/^        void remove_unused();$/;"	p	class:Netlist	access:public	signature:()
remove_unused	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::remove_unused() {$/;"	f	class:Netlist	signature:()
rend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  rend()      const   { return vec_.rend(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
rend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        reverse_iterator        rend()              { return vec_.rend(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
rend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  rend()      const   { return vec_.rend(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
rend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        reverse_iterator        rend()              { return vec_.rend(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
rend	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_reverse_iterator rend() const { return vec_.rend(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
repeat_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string repeat_expr; \/\/Distance between repeated$/;"	m	struct:t_grid_loc_spec	access:public
replace_all	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string replace_all(const std::string& input, const std::string& search, const std::string& replace) {$/;"	f	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
replace_all	../../libs/libvtrutil/src/vtr_util.h	/^    std::string replace_all(const std::string& input, const std::string& search, const std::string& replace);$/;"	p	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
replace_first	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string replace_first(const std::string& input, const std::string& search, const std::string& replace) {$/;"	f	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
replace_first	../../libs/libvtrutil/src/vtr_util.h	/^    std::string replace_first(const std::string& input, const std::string& search, const std::string& replace);$/;"	p	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
report_packing_pin_usage	pack/pack_report.cpp	/^void report_packing_pin_usage(std::ostream& os, const VprContext& ctx) {$/;"	f	signature:(std::ostream& os, const VprContext& ctx)
report_packing_pin_usage	pack/pack_report.h	/^void report_packing_pin_usage(std::ostream& os, const VprContext& ctx);$/;"	p	signature:(std::ostream& os, const VprContext& ctx)
requeue_primitive	pack/cluster_placement.cpp	/^static void requeue_primitive($/;"	f	file:	signature:( t_cluster_placement_stats *cluster_placement_stats, t_cluster_placement_primitive *cluster_placement_primitive)
requeue_primitive	pack/cluster_placement.cpp	/^static void requeue_primitive($/;"	p	file:	signature:( t_cluster_placement_stats *cluster_placement_stats, t_cluster_placement_primitive *cluster_placement_primitive)
reservable_pq	pack/cluster_router.cpp	/^		reservable_pq(size_type capacity = 0) {$/;"	f	class:reservable_pq	access:public	signature:(size_type capacity = 0)
reservable_pq	pack/cluster_router.cpp	/^class reservable_pq: public priority_queue<T, U, V>$/;"	c	file:	inherits:priority_queue
reservable_pq::clear	pack/cluster_router.cpp	/^		void clear() {$/;"	f	class:reservable_pq	access:public	signature:()
reservable_pq::cur_cap	pack/cluster_router.cpp	/^		size_type cur_cap;$/;"	m	class:reservable_pq	file:	access:private
reservable_pq::reservable_pq	pack/cluster_router.cpp	/^		reservable_pq(size_type capacity = 0) {$/;"	f	class:reservable_pq	access:public	signature:(size_type capacity = 0)
reservable_pq::reserve	pack/cluster_router.cpp	/^		void reserve(size_type capacity) {$/;"	f	class:reservable_pq	access:public	signature:(size_type capacity)
reservable_pq::size_type	pack/cluster_router.cpp	/^		typedef typename priority_queue<T>::size_type size_type;$/;"	t	class:reservable_pq	file:	access:public
reserve	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool reserve()$/;"	f	class:compact_hash_table	access:public	signature:()
reserve	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool reserve()$/;"	f	struct:xml_allocator	access:public	signature:()
reserve	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void reserve(size_type n) { vec_.reserve(n); }$/;"	f	class:vtr::flat_map	access:public	signature:(size_type n)
reserve	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void reserve(size_type n) { vec_.reserve(n); }$/;"	f	class:vtr::linear_map	access:public	signature:(size_type n)
reserve	pack/cluster_router.cpp	/^		void reserve(size_type capacity) {$/;"	f	class:reservable_pq	access:public	signature:(size_type capacity)
reserve_locally_used_opins	route/route_common.cpp	/^void reserve_locally_used_opins(float pres_fac, float acc_fac, bool rip_up_local_opins) {$/;"	f	signature:(float pres_fac, float acc_fac, bool rip_up_local_opins)
reserve_locally_used_opins	route/route_common.h	/^void reserve_locally_used_opins(float pres_fac, float acc_fac, bool rip_up_local_opins);$/;"	p	signature:(float pres_fac, float acc_fac, bool rip_up_local_opins)
reset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::reset()$/;"	f	class:pugi::xml_document	signature:()
reset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::reset(const xml_document& proto)$/;"	f	class:pugi::xml_document	signature:(const xml_document& proto)
reset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void reset();$/;"	p	class:pugi::xml_document	access:public	signature:()
reset	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void reset(const xml_document& proto);$/;"	p	class:pugi::xml_document	access:public	signature:(const xml_document& proto)
reset_cluster_placement_stats	pack/cluster_placement.cpp	/^void reset_cluster_placement_stats($/;"	f	signature:( t_cluster_placement_stats *cluster_placement_stats)
reset_cluster_placement_stats	pack/cluster_placement.h	/^void reset_cluster_placement_stats($/;"	p	signature:( t_cluster_placement_stats *cluster_placement_stats)
reset_common_state	../../libs/libeasygl/src/graphics.cpp	/^static void reset_common_state() {$/;"	f	file:	signature:()
reset_common_state	../../libs/libeasygl/src/graphics.cpp	/^static void reset_common_state();$/;"	p	file:	signature:()
reset_explored_node_tb	pack/cluster_router.cpp	/^static void reset_explored_node_tb(t_lb_router_data *router_data) {$/;"	f	file:	signature:(t_lb_router_data *router_data)
reset_explored_node_tb	pack/cluster_router.cpp	/^static void reset_explored_node_tb(t_lb_router_data *router_data);$/;"	p	file:	signature:(t_lb_router_data *router_data)
reset_flags	route/check_route.cpp	/^static void reset_flags(ClusterNetId inet, bool * connected_to_route) {$/;"	f	file:	signature:(ClusterNetId inet, bool * connected_to_route)
reset_flags	route/check_route.cpp	/^static void reset_flags(ClusterNetId inet, bool * connected_to_route);$/;"	p	file:	signature:(ClusterNetId inet, bool * connected_to_route)
reset_lookahead_pins_used	pack/cluster.cpp	/^static void reset_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:	signature:(t_pb *cur_pb)
reset_lookahead_pins_used	pack/cluster.cpp	/^static void reset_lookahead_pins_used(t_pb *cur_pb);$/;"	p	file:	signature:(t_pb *cur_pb)
reset_nets_congestion_and_rr	draw/draw_types.cpp	/^void t_draw_state::reset_nets_congestion_and_rr() {$/;"	f	class:t_draw_state	signature:()
reset_nets_congestion_and_rr	draw/draw_types.h	/^	void reset_nets_congestion_and_rr();$/;"	p	struct:t_draw_state	access:public	signature:()
reset_path_costs	route/route_common.cpp	/^void reset_path_costs(const std::vector<int>& visited_rr_nodes) {$/;"	f	signature:(const std::vector<int>& visited_rr_nodes)
reset_path_costs	route/route_common.h	/^void reset_path_costs(const std::vector<int>& visited_rr_nodes);$/;"	p	signature:(const std::vector<int>& visited_rr_nodes)
reset_pin_class_scratch_pad_rec	pack/cluster_feasibility_filter.cpp	/^static void reset_pin_class_scratch_pad_rec($/;"	f	file:	signature:( t_pb_graph_node *pb_graph_node)
reset_pin_class_scratch_pad_rec	pack/cluster_feasibility_filter.cpp	/^static void reset_pin_class_scratch_pad_rec($/;"	p	file:	signature:( t_pb_graph_node *pb_graph_node)
reset_rr_node_route_structs	route/route_common.cpp	/^void reset_rr_node_route_structs() {$/;"	f	signature:()
reset_rr_node_route_structs	route/route_common.h	/^void reset_rr_node_route_structs();$/;"	p	signature:()
reset_rr_node_to_rc_node	timing/net_delay.cpp	/^static void reset_rr_node_to_rc_node(t_linked_rc_ptr * rr_node_to_rc_node, ClusterNetId net_id) {$/;"	f	file:	signature:(t_linked_rc_ptr * rr_node_to_rc_node, ClusterNetId net_id)
reset_rr_node_to_rc_node	timing/net_delay.cpp	/^static void reset_rr_node_to_rc_node(t_linked_rc_ptr * rr_node_to_rc_node,$/;"	p	file:	signature:(t_linked_rc_ptr * rr_node_to_rc_node, ClusterNetId net_id)
reset_tried_but_unused_cluster_placements	pack/cluster_placement.cpp	/^void reset_tried_but_unused_cluster_placements($/;"	f	signature:( t_cluster_placement_stats *cluster_placement_stats)
reset_tried_but_unused_cluster_placements	pack/cluster_placement.h	/^void reset_tried_but_unused_cluster_placements($/;"	p	signature:( t_cluster_placement_stats *cluster_placement_stats)
resize	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void resize(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
resize	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void resize(std::array<DimRange,N> dim_ranges, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<DimRange,N> dim_ranges, T value=T())
resize	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void resize(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
resize	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void resize(Args&&... args) { vec_.resize(std::forward<Args>(args)...); }$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
resolve_clock_constraints	timing/read_sdc2.cpp	/^        void resolve_clock_constraints() {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:()
restore_routing	route/route_common.cpp	/^void restore_routing(vtr::vector<ClusterNetId, t_trace *> &best_routing,$/;"	f	signature:(vtr::vector<ClusterNetId, t_trace *> &best_routing, t_clb_opins_used& clb_opins_used_locally, const t_clb_opins_used& saved_clb_opins_used_locally)
restore_routing	route/route_export.h	/^void restore_routing(vtr::vector<ClusterNetId, t_trace *> &best_routing,$/;"	p	signature:(vtr::vector<ClusterNetId, t_trace *> &best_routing, t_clb_opins_used& clb_opins_used_locally, const t_clb_opins_used& saved_clb_opins_used_locally)
result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator result;$/;"	m	struct:xpath_stack_data	file:	access:public
result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* result;$/;"	m	struct:xpath_stack	file:	access:public
result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_parse_result& xpath_exception::result() const$/;"	f	class:pugi::xpath_exception	signature:() const
result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const xpath_parse_result& xpath_query::result() const$/;"	f	class:pugi::xpath_query	signature:() const
result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_parse_result& result() const;$/;"	p	class:pugi::xpath_exception	access:public	signature:() const
result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const xpath_parse_result& result() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
result	../../libs/librtlnumber/src/rtl_int.cpp	/^	uint8_t result = 0x0;$/;"	m	class:compare_bit	file:	access:private
rettype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			xpath_value_type rettype;$/;"	m	struct:xpath_parser::binary_op_t	file:	access:public
rettype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_value_type rettype() const$/;"	f	class:xpath_ast_node	access:public	signature:() const
return_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_value_type xpath_query::return_type() const$/;"	f	class:pugi::xpath_query	signature:() const
return_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_value_type return_type() const;$/;"	p	class:pugi::xpath_query	access:public	signature:() const
revalid_molecules	util/vpr_utils.cpp	/^void revalid_molecules(const t_pb* pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules) {$/;"	f	signature:(const t_pb* pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules)
revalid_molecules	util/vpr_utils.h	/^void revalid_molecules(const t_pb* pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules);$/;"	p	signature:(const t_pb* pb, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules)
reverse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I> void reverse(I begin, I end)$/;"	f	signature:(I begin, I end)
reverse_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::reverse_iterator reverse_iterator;$/;"	t	class:vtr::flat_map	access:public
reverse_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::reverse_iterator reverse_iterator;$/;"	t	class:vtr::linear_map	access:public
reverse_scaled	../../libs/libarchfpga/src/physical_types.h	/^	bool reverse_scaled; \/* Scale by (1-prob) *\/$/;"	m	struct:t_port_power	access:public
revert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void revert(const xpath_allocator& state)$/;"	f	class:xpath_allocator	access:public	signature:(const xpath_allocator& state)
revert_place_atom_block	pack/cluster.cpp	/^static void revert_place_atom_block(const AtomBlockId blk_id, t_lb_router_data *router_data,$/;"	f	file:	signature:(const AtomBlockId blk_id, t_lb_router_data *router_data, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules)
revert_place_atom_block	pack/cluster.cpp	/^static void revert_place_atom_block(const AtomBlockId blk_id, t_lb_router_data *router_data,$/;"	p	file:	signature:(const AtomBlockId blk_id, t_lb_router_data *router_data, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules)
rhs	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl& operator=(const SurfaceImpl& rhs) = default; \/\/ assignment operator$/;"	m	class:SurfaceImpl	access:public
rhs	base/netlist_writer.cpp	/^        NetlistWriterVisitor& operator=(NetlistWriterVisitor& rhs) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
rhs	base/netlist_writer.cpp	/^        NetlistWriterVisitor& operator=(NetlistWriterVisitor&& rhs) = delete;$/;"	m	class:NetlistWriterVisitor	file:	access:public
right	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::right() const {$/;"	f	class:t_bound_box	signature:() const
right	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::right() {$/;"	f	class:t_bound_box	signature:()
right	../../libs/libeasygl/src/graphics_types.h	/^    const float& right() const;$/;"	p	class:t_bound_box	access:public	signature:() const
right	../../libs/libeasygl/src/graphics_types.h	/^    float& right();$/;"	p	class:t_bound_box	access:public	signature:()
right	route/route_common.cpp	/^	size_t right(size_t i) {return (i << 1) + 1;}$/;"	f	namespace:heap_	signature:(size_t i)
right	route/route_common.cpp	/^	size_t right(size_t i);$/;"	p	namespace:heap_	file:	signature:(size_t i)
rising_edge	timing/read_sdc.cpp	/^	float rising_edge;$/;"	m	struct:t_sdc_clock	file:	access:public
root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* root;$/;"	m	struct:xpath_query_impl	file:	access:public
root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node xml_node::root() const$/;"	f	class:pugi::xml_node	signature:() const
root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node root() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
root	base/vpr_types.h	/^	int root; \/* root index of molecule, atom_block_ids[root] is the root atom block *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
root	place/timing_place_lookup.cpp	/^    vtr::Point<int> root;$/;"	m	struct:t_profile_loc	file:	access:public
root_block	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_block *root_block; \/* root block used by this pattern *\/$/;"	m	struct:t_pack_patterns	access:public
root_pb	base/vpr_types.h	/^    const t_pb* root_pb() const {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:() const
rotr	../../libs/libvtrutil/src/picosha2.h	/^inline word_t rotr(word_t x, std::size_t n){$/;"	f	namespace:picosha2::detail	signature:(word_t x, std::size_t n)
round_nearest	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double round_nearest(double value)$/;"	f	signature:(double value)
round_nearest_nzero	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN double round_nearest_nzero(double value)$/;"	f	signature:(double value)
round_up	route/router_lookahead.cpp	/^static int round_up(float x) {$/;"	f	file:	signature:(float x)
round_up	route/router_lookahead.cpp	/^static int round_up(float x);$/;"	p	file:	signature:(float x)
route_bb	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_bb> route_bb; \/* [0..cluster_ctx.clb_nlist.nets().size()-1]*\/$/;"	m	struct:RoutingContext	access:public
route_bb_update	base/read_options.h	/^    argparse::ArgValue<e_route_bb_update> route_bb_update;$/;"	m	struct:t_options	access:public
route_bb_update	base/vpr_types.h	/^    e_route_bb_update route_bb_update;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
route_budgets	route/route_budgets.cpp	/^route_budgets::route_budgets() {$/;"	f	class:route_budgets	signature:()
route_budgets	route/route_budgets.h	/^    route_budgets();$/;"	p	class:route_budgets	access:public	signature:()
route_budgets	route/route_budgets.h	/^    route_budgets(vector<vector<float>> net_delay);$/;"	p	class:route_budgets	access:public	signature:(vector<vector<float>> net_delay)
route_budgets	route/route_budgets.h	/^class route_budgets {$/;"	c
route_budgets::alloc_budget_memory	route/route_budgets.cpp	/^void route_budgets::alloc_budget_memory() {$/;"	f	class:route_budgets	signature:()
route_budgets::alloc_budget_memory	route/route_budgets.h	/^    void alloc_budget_memory();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::allocate_slack_using_delays_and_criticalities	route/route_budgets.cpp	/^void route_budgets::allocate_slack_using_delays_and_criticalities(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
route_budgets::allocate_slack_using_delays_and_criticalities	route/route_budgets.h	/^    void allocate_slack_using_delays_and_criticalities(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
route_budgets::allocate_slack_using_weights	route/route_budgets.cpp	/^void route_budgets::allocate_slack_using_weights(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
route_budgets::allocate_slack_using_weights	route/route_budgets.h	/^    void allocate_slack_using_weights(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
route_budgets::calculate_clb_pin_slack	route/route_budgets.cpp	/^float route_budgets::calculate_clb_pin_slack(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info,$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type type, AtomPinId &atom_pin)
route_budgets::calculate_clb_pin_slack	route/route_budgets.h	/^    float calculate_clb_pin_slack(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info,$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, int ipin, std::shared_ptr<SetupHoldTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type type, AtomPinId &atom_pin)
route_budgets::calculate_delay_targets	route/route_budgets.cpp	/^void route_budgets::calculate_delay_targets() {$/;"	f	class:route_budgets	signature:()
route_budgets::calculate_delay_targets	route/route_budgets.cpp	/^void route_budgets::calculate_delay_targets(ClusterNetId net_id, ClusterPinId pin_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, ClusterPinId pin_id)
route_budgets::calculate_delay_targets	route/route_budgets.h	/^    void calculate_delay_targets();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::calculate_delay_targets	route/route_budgets.h	/^    void calculate_delay_targets(ClusterNetId net_id, ClusterPinId pin_id);$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, ClusterPinId pin_id)
route_budgets::check_if_budgets_in_bounds	route/route_budgets.cpp	/^void route_budgets::check_if_budgets_in_bounds() {$/;"	f	class:route_budgets	signature:()
route_budgets::check_if_budgets_in_bounds	route/route_budgets.cpp	/^void route_budgets::check_if_budgets_in_bounds(ClusterNetId net_id, ClusterPinId pin_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, ClusterPinId pin_id)
route_budgets::check_if_budgets_in_bounds	route/route_budgets.h	/^    void check_if_budgets_in_bounds();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::check_if_budgets_in_bounds	route/route_budgets.h	/^    void check_if_budgets_in_bounds(ClusterNetId net_id, ClusterPinId pin_id);$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, ClusterPinId pin_id)
route_budgets::delay_lower_bound	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_lower_bound; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
route_budgets::delay_max_budget	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_max_budget; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
route_budgets::delay_min_budget	route/route_budgets.h	/^    vtr::vector<ClusterNetId, float *> delay_min_budget; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
route_budgets::delay_target	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_target; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
route_budgets::delay_upper_bound	route/route_budgets.h	/^	vtr::vector<ClusterNetId, float *> delay_upper_bound; \/\/[0..num_nets][0..clb_net[inet].pins]$/;"	m	class:route_budgets	access:private
route_budgets::free_budgets	route/route_budgets.cpp	/^void route_budgets::free_budgets() {$/;"	f	class:route_budgets	signature:()
route_budgets::free_budgets	route/route_budgets.h	/^    void free_budgets();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::get_crit_short_path	route/route_budgets.cpp	/^float route_budgets::get_crit_short_path(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_crit_short_path	route/route_budgets.h	/^    float get_crit_short_path(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_delay_target	route/route_budgets.cpp	/^float route_budgets::get_delay_target(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_delay_target	route/route_budgets.h	/^    float get_delay_target(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_edge_from_nets	route/route_budgets.h	/^    tatum::EdgeId get_edge_from_nets(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:private	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_max_delay_budget	route/route_budgets.cpp	/^float route_budgets::get_max_delay_budget(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_max_delay_budget	route/route_budgets.h	/^    float get_max_delay_budget(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_min_delay_budget	route/route_budgets.cpp	/^float route_budgets::get_min_delay_budget(ClusterNetId net_id, int ipin) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_min_delay_budget	route/route_budgets.h	/^    float get_min_delay_budget(ClusterNetId net_id, int ipin);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id, int ipin)
route_budgets::get_routing_calc	route/route_budgets.h	/^    std::shared_ptr<RoutingDelayCalculator> get_routing_calc(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
route_budgets::get_total_path_delay	route/route_budgets.cpp	/^float route_budgets::get_total_path_delay(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer,$/;"	f	class:route_budgets	signature:(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer, analysis_type analysis_type, tatum::NodeId timing_node)
route_budgets::get_total_path_delay	route/route_budgets.h	/^    float get_total_path_delay(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer,$/;"	p	class:route_budgets	access:private	signature:(std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> timing_analyzer, analysis_type analysis_type, tatum::NodeId timing_node)
route_budgets::if_set	route/route_budgets.cpp	/^bool route_budgets::if_set() const {$/;"	f	class:route_budgets	signature:() const
route_budgets::if_set	route/route_budgets.h	/^    bool if_set() const;$/;"	p	class:route_budgets	access:public	signature:() const
route_budgets::keep_budget_above_value	route/route_budgets.cpp	/^void route_budgets::keep_budget_above_value(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range)
route_budgets::keep_budget_above_value	route/route_budgets.h	/^    void keep_budget_above_value(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, float bottom_range)
route_budgets::keep_budget_in_bounds	route/route_budgets.cpp	/^void route_budgets::keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
route_budgets::keep_budget_in_bounds	route/route_budgets.cpp	/^void route_budgets::keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId pin_id) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId pin_id)
route_budgets::keep_budget_in_bounds	route/route_budgets.h	/^    void keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
route_budgets::keep_budget_in_bounds	route/route_budgets.h	/^    void keep_budget_in_bounds(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId ipin);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets, ClusterNetId net_id, ClusterPinId ipin)
route_budgets::keep_min_below_max_budget	route/route_budgets.cpp	/^void route_budgets::keep_min_below_max_budget() {$/;"	f	class:route_budgets	signature:()
route_budgets::keep_min_below_max_budget	route/route_budgets.h	/^    void keep_min_below_max_budget();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::load_initial_budgets	route/route_budgets.cpp	/^void route_budgets::load_initial_budgets() {$/;"	f	class:route_budgets	signature:()
route_budgets::load_initial_budgets	route/route_budgets.h	/^    void load_initial_budgets();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::load_route_budgets	route/route_budgets.cpp	/^void route_budgets::load_route_budgets(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
route_budgets::load_route_budgets	route/route_budgets.h	/^    void load_route_budgets(vtr::vector<ClusterNetId, float *> &net_delay,$/;"	p	class:route_budgets	access:public	signature:(vtr::vector<ClusterNetId, float *> &net_delay, std::shared_ptr<SetupTimingInfo> timing_info, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, t_router_opts router_opts)
route_budgets::lower_bound_delay_ch	route/route_budgets.h	/^    vtr::t_chunk lower_bound_delay_ch;$/;"	m	class:route_budgets	access:private
route_budgets::lower_budgets	route/route_budgets.cpp	/^void route_budgets::lower_budgets(float delay_decrement) {$/;"	f	class:route_budgets	signature:(float delay_decrement)
route_budgets::lower_budgets	route/route_budgets.h	/^    void lower_budgets(float delay_decrement);$/;"	p	class:route_budgets	access:public	signature:(float delay_decrement)
route_budgets::max_budget_delay_ch	route/route_budgets.h	/^    vtr::t_chunk max_budget_delay_ch;$/;"	m	class:route_budgets	access:private
route_budgets::min_budget_delay_ch	route/route_budgets.h	/^    vtr::t_chunk min_budget_delay_ch;$/;"	m	class:route_budgets	access:private
route_budgets::minimax_PERT	route/route_budgets.cpp	/^float route_budgets::minimax_PERT(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets,$/;"	f	class:route_budgets	signature:(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets, vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type analysis_type, bool keep_in_bounds, slack_allocated_type slack_type)
route_budgets::minimax_PERT	route/route_budgets.h	/^    float minimax_PERT(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets,$/;"	p	class:route_budgets	access:private	signature:(std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *> &temp_budgets, vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, analysis_type analysis_type, bool keep_in_bounds, slack_allocated_type slack_type = BOTH)
route_budgets::not_congested_this_iteration	route/route_budgets.cpp	/^void route_budgets::not_congested_this_iteration(ClusterNetId net_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id)
route_budgets::not_congested_this_iteration	route/route_budgets.h	/^    void not_congested_this_iteration(ClusterNetId net_id);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id)
route_budgets::num_times_congested	route/route_budgets.h	/^    vtr::vector<ClusterNetId, int> num_times_congested; \/\/[0..num_nets]$/;"	m	class:route_budgets	access:private
route_budgets::perform_sta	route/route_budgets.cpp	/^std::shared_ptr<SetupHoldTimingInfo> route_budgets::perform_sta(vtr::vector<ClusterNetId, float *> &temp_budgets) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
route_budgets::perform_sta	route/route_budgets.h	/^    std::shared_ptr<SetupHoldTimingInfo> perform_sta(vtr::vector<ClusterNetId, float *> &temp_budgets);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
route_budgets::print_route_budget	route/route_budgets.cpp	/^void route_budgets::print_route_budget() {$/;"	f	class:route_budgets	signature:()
route_budgets::print_route_budget	route/route_budgets.h	/^    void print_route_budget();$/;"	p	class:route_budgets	access:public	signature:()
route_budgets::print_temporary_budgets_to_file	route/route_budgets.cpp	/^void route_budgets::print_temporary_budgets_to_file(vtr::vector<ClusterNetId, float *> &temp_budgets) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
route_budgets::print_temporary_budgets_to_file	route/route_budgets.h	/^    void print_temporary_budgets_to_file(vtr::vector<ClusterNetId, float *> &temp_budgets);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &temp_budgets)
route_budgets::process_negative_slack_using_minimax	route/route_budgets.cpp	/^void route_budgets::process_negative_slack_using_minimax(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup) {$/;"	f	class:route_budgets	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
route_budgets::process_negative_slack_using_minimax	route/route_budgets.h	/^    void process_negative_slack_using_minimax(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup);$/;"	p	class:route_budgets	access:private	signature:(vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup)
route_budgets::route_budgets	route/route_budgets.cpp	/^route_budgets::route_budgets() {$/;"	f	class:route_budgets	signature:()
route_budgets::route_budgets	route/route_budgets.h	/^    route_budgets();$/;"	p	class:route_budgets	access:public	signature:()
route_budgets::route_budgets	route/route_budgets.h	/^    route_budgets(vector<vector<float>> net_delay);$/;"	p	class:route_budgets	access:public	signature:(vector<vector<float>> net_delay)
route_budgets::set	route/route_budgets.h	/^    bool set;$/;"	m	class:route_budgets	access:private
route_budgets::set_min_max_budgets_equal	route/route_budgets.cpp	/^void route_budgets::set_min_max_budgets_equal() {$/;"	f	class:route_budgets	signature:()
route_budgets::set_min_max_budgets_equal	route/route_budgets.h	/^    void set_min_max_budgets_equal();$/;"	p	class:route_budgets	access:private	signature:()
route_budgets::target_budget_delay_ch	route/route_budgets.h	/^    vtr::t_chunk target_budget_delay_ch;$/;"	m	class:route_budgets	access:private
route_budgets::update_congestion_times	route/route_budgets.cpp	/^void route_budgets::update_congestion_times(ClusterNetId net_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id)
route_budgets::update_congestion_times	route/route_budgets.h	/^    void update_congestion_times(ClusterNetId net_id);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id)
route_budgets::upper_bound_delay_ch	route/route_budgets.h	/^    vtr::t_chunk upper_bound_delay_ch;$/;"	m	class:route_budgets	access:private
route_budgets::~route_budgets	route/route_budgets.cpp	/^route_budgets::~route_budgets() {$/;"	f	class:route_budgets	signature:()
route_budgets::~route_budgets	route/route_budgets.h	/^    virtual ~route_budgets();$/;"	p	class:route_budgets	access:public	signature:()
route_connection_delay	place/timing_place_lookup.cpp	/^static float route_connection_delay(int source_x, int source_y,$/;"	f	file:	signature:(int source_x, int source_y, int sink_x, int sink_y, t_router_opts router_opts)
route_connection_delay	place/timing_place_lookup.cpp	/^static float route_connection_delay(int source_x_loc, int source_y_loc,$/;"	p	file:	signature:(int source_x_loc, int source_y_loc, int sink_x_loc, int sink_y_loc, t_router_opts router_opts)
route_tree_preserved	route/route_profiling.cpp	/^void route_tree_preserved() {}$/;"	f	namespace:profiling	signature:()
route_tree_preserved	route/route_profiling.h	/^void route_tree_preserved();$/;"	p	namespace:profiling	signature:()
route_tree_pruned	route/route_profiling.cpp	/^void route_tree_pruned() {}$/;"	f	namespace:profiling	signature:()
route_tree_pruned	route/route_profiling.h	/^void route_tree_pruned();$/;"	p	namespace:profiling	signature:()
route_type	base/vpr_types.h	/^	enum e_route_type route_type;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_route_type	access:public
router_algorithm	base/vpr_types.h	/^	enum e_router_algorithm router_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_router_algorithm	access:public
router_debug_net	base/read_options.h	/^    argparse::ArgValue<int> router_debug_net;$/;"	m	struct:t_options	access:public
router_debug_net	base/vpr_types.h	/^    int router_debug_net;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
router_debug_sink_rr	base/read_options.h	/^    argparse::ArgValue<int> router_debug_sink_rr;$/;"	m	struct:t_options	access:public
router_debug_sink_rr	base/vpr_types.h	/^    int router_debug_sink_rr;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
router_first_iteration_timing_report_file	base/read_options.h	/^    argparse::ArgValue<std::string> router_first_iteration_timing_report_file;$/;"	m	struct:t_options	access:public
router_high_fanout_threshold	base/read_options.h	/^    argparse::ArgValue<int> router_high_fanout_threshold;$/;"	m	struct:t_options	access:public
router_lookahead_type	base/read_options.h	/^    argparse::ArgValue<e_router_lookahead> router_lookahead_type;$/;"	m	struct:t_options	access:public
router_max_convergence_count	base/read_options.h	/^    argparse::ArgValue<int> router_max_convergence_count;$/;"	m	struct:t_options	access:public
router_opts_	place/place_delay_model.h	/^        t_router_opts router_opts_;$/;"	m	class:DeltaDelayModel	access:private
router_opts_	place/place_delay_model.h	/^        t_router_opts router_opts_;$/;"	m	class:OverrideDelayModel	access:private
router_reconvergence_cpd_threshold	base/read_options.h	/^    argparse::ArgValue<float> router_reconvergence_cpd_threshold;$/;"	m	struct:t_options	access:public
routing	base/vpr_context.h	/^        const RoutingContext& routing() const { return routing_; }$/;"	f	class:VprContext	access:public	signature:() const
routing_	base/vpr_context.h	/^        RoutingContext routing_;$/;"	m	class:VprContext	access:private
routing_budgets_algorithm	base/read_options.h	/^    argparse::ArgValue<e_routing_budgets_algorithm> routing_budgets_algorithm;$/;"	m	struct:t_options	access:public
routing_budgets_algorithm	base/vpr_types.h	/^	enum e_routing_budgets_algorithm routing_budgets_algorithm;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_routing_budgets_algorithm	access:public
routing_failure_predictor	base/read_options.h	/^    argparse::ArgValue<e_routing_failure_predictor> routing_failure_predictor;$/;"	m	struct:t_options	access:public
routing_failure_predictor	base/vpr_types.h	/^	enum e_routing_failure_predictor routing_failure_predictor;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	typeref:enum:ScreenUpdatePriority::t_router_opts::e_routing_failure_predictor	access:public
routing_id	base/vpr_context.h	/^    std::string routing_id;$/;"	m	struct:RoutingContext	access:public
routing_stats	base/stats.cpp	/^void routing_stats(bool full_stats, enum e_route_type route_type,$/;"	f	signature:(bool full_stats, enum e_route_type route_type, int num_rr_switch, t_segment_inf * segment_inf, int num_segment, float R_minW_nmos, float R_minW_pmos, float grid_logic_tile_area, enum e_directionality directionality, int wire_to_ipin_switch, bool timing_analysis_enabled , vtr::vector<ClusterNetId, float *> &net_delay , t_slack * slacks, const t_timing_inf &timing_inf )
routing_stats	base/stats.h	/^void routing_stats(bool full_stats, enum e_route_type route_type,$/;"	p	signature:(bool full_stats, enum e_route_type route_type, int num_rr_switch, t_segment_inf * segment_inf, int num_segment, float R_minW_nmos, float R_minW_pmos, float grid_logic_tile_area, enum e_directionality directionality, int wire_to_ipin_switch, bool timing_analysis_enabled , vtr::vector<ClusterNetId, float *> &net_delay , t_slack * slacks, const t_timing_inf &timing_inf )
routing_util	route/route_util.cpp	/^float routing_util(float used, float avail) {$/;"	f	signature:(float used, float avail)
routing_util	route/route_util.h	/^float routing_util(float used, float avail);$/;"	p	signature:(float used, float avail)
rr_blk_source	base/vpr_context.h	/^    vtr::vector<ClusterBlockId, std::vector<int>> rr_blk_source; \/* [0..num_blocks-1][0..num_class-1] *\/$/;"	m	struct:RoutingContext	access:public
rr_graph_externals	route/rr_graph.cpp	/^static void rr_graph_externals($/;"	f	file:	signature:( const t_segment_inf * segment_inf, int num_seg_types, int max_chan_width, int wire_to_rr_ipin_switch, enum e_base_cost_type base_cost_type)
rr_graph_externals	route/rr_graph.cpp	/^static void rr_graph_externals($/;"	p	file:	signature:( const t_segment_inf * segment_inf, int num_seg_types, int max_chan_width, int wire_to_rr_ipin_switch, enum e_base_cost_type base_cost_type)
rr_highlight_message	draw/draw.cpp	/^std::string rr_highlight_message;$/;"	v
rr_indexed_data	base/vpr_context.h	/^    t_rr_indexed_data *rr_indexed_data; \/* [0 .. num_rr_indexed_data-1] *\/$/;"	m	struct:DeviceContext	access:public
rr_node_arch_name	util/vpr_utils.cpp	/^std::string rr_node_arch_name(int inode) {$/;"	f	signature:(int inode)
rr_node_arch_name	util/vpr_utils.h	/^std::string rr_node_arch_name(int inode);$/;"	p	signature:(int inode)
rr_node_ind	route/router_lookahead_map.cpp	/^	int rr_node_ind;     \/\/index in device_ctx.rr_nodes that this entry represents$/;"	m	class:PQ_Entry	file:	access:public
rr_node_indices	base/vpr_context.h	/^    t_rr_node_indices rr_node_indices; \/\/[0..NUM_RR_TYPES-1][0..grid.width()-1][0..grid.width()-1][0..size-1]$/;"	m	struct:DeviceContext	access:public
rr_node_is_global_clb_ipin	route/check_rr_graph.cpp	/^static bool rr_node_is_global_clb_ipin(int inode) {$/;"	f	file:	signature:(int inode)
rr_node_is_global_clb_ipin	route/check_rr_graph.cpp	/^static bool rr_node_is_global_clb_ipin(int inode);$/;"	p	file:	signature:(int inode)
rr_node_power	power/power.cpp	/^static t_rr_node_power * rr_node_power;$/;"	v	file:
rr_node_route_inf	base/vpr_context.h	/^    std::vector<t_rr_node_route_inf> rr_node_route_inf; \/* [0..device_ctx.num_rr_nodes-1] *\/$/;"	m	struct:RoutingContext	access:public
rr_node_to_rt_node	route/route_tree_timing.cpp	/^static std::vector<t_rt_node *> rr_node_to_rt_node; \/* [0..device_ctx.rr_nodes.size()-1] *\/$/;"	v	file:
rr_nodes	base/vpr_context.h	/^    std::vector<t_rr_node> rr_nodes; \/* autogenerated in build_rr_graph *\/$/;"	m	struct:DeviceContext	access:public
rr_rc_data	base/vpr_context.h	/^    std::vector<t_rr_rc_data> rr_rc_data;$/;"	m	struct:DeviceContext	access:public
rr_sink_node_to_pin	route/connection_based_routing.h	/^	vtr::vector<ClusterNetId, std::unordered_map<int,int>> rr_sink_node_to_pin;$/;"	m	class:Connection_based_routing_resources	access:private
rr_switch_inf	base/vpr_context.h	/^    t_rr_switch_inf *rr_switch_inf; \/* autogenerated in build_rr_graph based on switch fan-in. [0..(num_rr_switches-1)] *\/$/;"	m	struct:DeviceContext	access:public
rt_edge_free_list	route/route_tree_timing.cpp	/^static t_linked_rt_edge *rt_edge_free_list = nullptr;$/;"	v	file:
rt_node_free_list	route/route_tree_timing.cpp	/^static t_rt_node *rt_node_free_list = nullptr;$/;"	v	file:
rt_node_of_sink	route/route_timing.h	/^    t_rt_node** rt_node_of_sink; \/* [1..max_pins_per_net-1] *\/$/;"	m	struct:timing_driven_route_structs	access:public
rt_tree	pack/pack_types.h	/^	t_lb_trace *rt_tree;				\/* Route tree head *\/$/;"	m	struct:t_intra_lb_net	access:public
run_dijkstra	route/router_lookahead_map.cpp	/^static void run_dijkstra(int start_node_ind, int start_x, int start_y, t_routing_cost_map &routing_cost_map);$/;"	p	file:	signature:(int start_node_ind, int start_x, int start_y, t_routing_cost_map &routing_cost_map)
run_dijkstra	route/router_lookahead_map.cpp	/^static void run_dijkstra(int start_node_ind, int start_x, int start_y, t_routing_cost_map &routing_cost_map){$/;"	f	file:	signature:(int start_node_ind, int start_x, int start_y, t_routing_cost_map &routing_cost_map)
rval_	base/netlist_writer.cpp	/^        std::string rval_;$/;"	m	class:Assignment	file:	access:private
s	draw/hsl.h	/^    double s;       \/\/ a fraction between 0 and 1$/;"	m	struct:hsl	access:public
sTNS	route/route_timing.cpp	/^    float sTNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
sWNS	route/route_timing.cpp	/^    float sWNS = std::numeric_limits<float>::quiet_NaN();$/;"	m	struct:RoutingMetrics	file:	access:public
s_to_ps_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float s_to_ps_xmult, s_to_ps_ymult;$/;"	m	struct:__anon20	file:	access:public
s_to_ps_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float s_to_ps_xmult, s_to_ps_ymult;$/;"	m	struct:__anon20	file:	access:public
safe_ratio	../../libs/libvtrutil/src/vtr_math.h	/^    T safe_ratio(T numerator, T denominator) {$/;"	f	namespace:vtr	signature:(T numerator, T denominator)
sanity_check_lookup	route/connection_based_routing.h	/^	bool sanity_check_lookup() const;$/;"	p	class:Connection_based_routing_resources	access:public	signature:() const
sanity_check_lookup	route/route_timing.cpp	/^bool Connection_based_routing_resources::sanity_check_lookup() const {$/;"	f	class:Connection_based_routing_resources	signature:() const
save	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const
save	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const$/;"	f	class:pugi::xml_document	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const
save	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_document::save(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const
save	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
save	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default) const;$/;"	p	class:pugi::xml_document	access:public	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default) const
save	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void save(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(xml_writer& writer, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
save_and_reset_lb_route	pack/cluster_router.cpp	/^static void save_and_reset_lb_route(t_lb_router_data *router_data) {$/;"	f	file:	signature:(t_lb_router_data *router_data)
save_and_reset_lb_route	pack/cluster_router.cpp	/^static void save_and_reset_lb_route(t_lb_router_data *router_data);$/;"	p	file:	signature:(t_lb_router_data *router_data)
save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_document::save_file(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_document::save_file(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document	signature:(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool save_file(const char* path, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(const char* path, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
save_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool save_file(const wchar_t* path, const char_t* indent = PUGIXML_TEXT("\\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;$/;"	p	class:pugi::xml_document	access:public	signature:(const wchar_t* path, const char_t* indent = PUGIXML_TEXT(Ó), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const
save_file_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool save_file_impl(const xml_document& doc, FILE* file, const char_t* indent, unsigned int flags, xml_encoding encoding)$/;"	f	signature:(const xml_document& doc, FILE* file, const char_t* indent, unsigned int flags, xml_encoding encoding)
save_routing	route/route_common.cpp	/^void save_routing(vtr::vector<ClusterNetId, t_trace *> &best_routing,$/;"	f	signature:(vtr::vector<ClusterNetId, t_trace *> &best_routing, const t_clb_opins_used& clb_opins_used_locally, t_clb_opins_used& saved_clb_opins_used_locally)
save_routing	route/route_export.h	/^void save_routing(vtr::vector<ClusterNetId, t_trace *> &best_routing,$/;"	p	signature:(vtr::vector<ClusterNetId, t_trace *> &best_routing, const t_clb_opins_used& clb_opins_used_locally, t_clb_opins_used& saved_clb_opins_used_locally)
save_routing_per_iteration	base/read_options.h	/^    argparse::ArgValue<bool> save_routing_per_iteration;$/;"	m	struct:t_options	access:public
save_routing_per_iteration	base/vpr_types.h	/^    bool save_routing_per_iteration;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
saved_base_cost	route/rr_node.h	/^	float saved_base_cost;$/;"	m	struct:t_rr_indexed_data	access:public
saved_lb_nets	pack/pack_types.h	/^    std::vector<t_intra_lb_net> *saved_lb_nets;		\/* Save vector of intra logic cluster_ctx.blocks nets and their connections *\/$/;"	m	struct:t_lb_router_data	access:public
sb	../../libs/libarchfpga/src/physical_types.h	/^	bool *sb;$/;"	m	struct:t_segment_inf	access:public
sb	base/vpr_types.h	/^        bool sb(int pos) const { return seg_detail_->sb[pos]; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int pos) const
sb	base/vpr_types.h	/^    std::unique_ptr<bool[]> sb;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
sb_len	../../libs/libarchfpga/src/physical_types.h	/^	int sb_len;$/;"	m	struct:t_segment_inf	access:public
sb_not_here	route/build_switchblocks.cpp	/^static bool sb_not_here(const DeviceGrid& grid, int x, int y, e_sb_location location);$/;"	p	file:	signature:(const DeviceGrid& grid, int x, int y, e_sb_location location)
sb_not_here	route/build_switchblocks.cpp	/^static bool sb_not_here(const DeviceGrid& grid, int x, int y, e_sb_location location){$/;"	f	file:	signature:(const DeviceGrid& grid, int x, int y, e_sb_location location)
sc_levr	power/power.h	/^	float sc_levr;$/;"	m	struct:t_power_buffer_sc_levr_inf	access:public
sc_levr_inf	power/power.h	/^	t_power_buffer_sc_levr_inf * sc_levr_inf;$/;"	m	struct:t_power_buffer_strength_inf	access:public
sc_no_levr	power/power.h	/^	float sc_no_levr;$/;"	m	struct:t_power_buffer_strength_inf	access:public
scale_factor	power/PowerSpicedComponent.cpp	/^float PowerSpicedComponent::scale_factor(int num_inputs,$/;"	f	class:PowerSpicedComponent	signature:(int num_inputs, float transistor_size)
scale_factor	power/PowerSpicedComponent.h	/^	float scale_factor(int num_inputs, float transistor_size);$/;"	p	class:PowerSpicedComponent	access:public	signature:(int num_inputs, float transistor_size)
scaled_by_pin	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin *scaled_by_pin;$/;"	m	struct:t_pb_graph_pin_power	access:public
scaled_by_port	../../libs/libarchfpga/src/physical_types.h	/^	t_port * scaled_by_port;$/;"	m	struct:t_port_power	access:public
scaled_by_port_pin_idx	../../libs/libarchfpga/src/physical_types.h	/^	int scaled_by_port_pin_idx;$/;"	m	struct:t_port_power	access:public
sched_type	base/vpr_types.h	/^enum sched_type {$/;"	g	class:ScreenUpdatePriority	access:private
scratch	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		} scratch;$/;"	m	class:xml_buffered_writer	typeref:union:xml_buffered_writer::__anon28	file:	access:public
scratch_pad	../../libs/libarchfpga/src/physical_types.h	/^	int scratch_pad = 0; \/* temporary data structure useful to store traversal info *\/$/;"	m	struct:t_pb_graph_pin	access:public
screen_num	../../libs/libeasygl/src/graphics_state.h	/^    int screen_num;$/;"	m	class:t_x11_state	access:public
scrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^t_bound_box scrn_to_world(const t_bound_box& \/*box*\/) {$/;"	f	signature:(const t_bound_box& )
scrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^t_bound_box scrn_to_world(const t_bound_box& box) {$/;"	f	signature:(const t_bound_box& box)
scrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^t_point scrn_to_world(const t_point& \/*point*\/) {$/;"	f	signature:(const t_point& )
scrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^t_point scrn_to_world(const t_point& point) {$/;"	f	signature:(const t_point& point)
scrn_to_world	../../libs/libeasygl/src/graphics.h	/^t_bound_box scrn_to_world(const t_bound_box& box);$/;"	p	signature:(const t_bound_box& box)
scrn_to_world	../../libs/libeasygl/src/graphics.h	/^t_point scrn_to_world(const t_point& point);$/;"	p	signature:(const t_point& point)
sdc	base/vpr_context.h	/^    t_timing_constraints* sdc;$/;"	m	struct:TimingContext	access:public
sdc	timing/read_sdc.cpp	/^static FILE *sdc;$/;"	v	file:
sdc_clocks	timing/read_sdc.cpp	/^t_sdc_clock * sdc_clocks = nullptr; \/* List of clock periods and offsets from create_clock commands *\/$/;"	v
sdc_clocks_	timing/read_sdc2.cpp	/^        std::map<tatum::DomainId,sdcparse::CreateClock> sdc_clocks_;$/;"	m	class:SdcParseCallback2	file:	access:private
sdc_file_name	base/vpr_types.h	/^	std::string sdc_file_name;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
sdc_file_name	timing/read_sdc.cpp	/^static std::string sdc_file_name = "<default_SDC>.sdc"; \/* Name of SDC file *\/$/;"	v	file:
sdc_units_to_seconds	timing/read_sdc2.cpp	/^        float sdc_units_to_seconds(float val) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(float val) const
sdf_os_	base/netlist_writer.cpp	/^        std::ostream& sdf_os_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
sec_to_mhz	timing/timing_util.cpp	/^double sec_to_mhz(double seconds) {$/;"	f	signature:(double seconds)
sec_to_mhz	timing/timing_util.h	/^double sec_to_mhz(double seconds);$/;"	p	signature:(double seconds)
sec_to_nanosec	timing/timing_util.cpp	/^double sec_to_nanosec(double seconds) {$/;"	f	signature:(double seconds)
sec_to_nanosec	timing/timing_util.h	/^double sec_to_nanosec(double seconds);$/;"	p	signature:(double seconds)
seconds_to_sdc_units	timing/read_sdc2.cpp	/^        float seconds_to_sdc_units(float val) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(float val) const
secure_digest_file	../../libs/libvtrutil/src/vtr_digest.cpp	/^std::string secure_digest_file(const std::string& filepath) {$/;"	f	namespace:vtr	signature:(const std::string& filepath)
secure_digest_file	../../libs/libvtrutil/src/vtr_digest.h	/^std::string secure_digest_file(const std::string& filepath);$/;"	p	namespace:vtr	signature:(const std::string& filepath)
secure_digest_stream	../../libs/libvtrutil/src/vtr_digest.cpp	/^std::string secure_digest_stream(std::istream& is) {$/;"	f	namespace:vtr	signature:(std::istream& is)
secure_digest_stream	../../libs/libvtrutil/src/vtr_digest.h	/^std::string secure_digest_stream(std::istream& is);$/;"	p	namespace:vtr	signature:(std::istream& is)
seed	base/vpr_types.h	/^	int seed;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
seg_detail_	base/vpr_types.h	/^        const t_seg_details* seg_detail_ = nullptr;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
seg_end	base/vpr_types.h	/^	int seg_end = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
seg_end	base/vpr_types.h	/^        int seg_end() const { return seg_end_; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
seg_end_	base/vpr_types.h	/^        int seg_end_ = -1;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
seg_index	../../libs/libarchfpga/src/physical_types.h	/^    int seg_index;                  \/\/The target segment index$/;"	m	struct:t_fc_specification	access:public
seg_index	route/rr_node.h	/^	int seg_index;$/;"	m	struct:t_rr_indexed_data	access:public
seg_index_of_cblock	route/rr_graph_util.cpp	/^int seg_index_of_cblock(t_rr_type from_rr_type, int to_node) {$/;"	f	signature:(t_rr_type from_rr_type, int to_node)
seg_index_of_cblock	route/rr_graph_util.h	/^int seg_index_of_cblock(t_rr_type from_rr_type, int to_node);$/;"	p	signature:(t_rr_type from_rr_type, int to_node)
seg_index_of_sblock	route/rr_graph_util.cpp	/^int seg_index_of_sblock(int from_node, int to_node) {$/;"	f	signature:(int from_node, int to_node)
seg_index_of_sblock	route/rr_graph_util.h	/^int seg_index_of_sblock(int from_node, int to_node);$/;"	p	signature:(int from_node, int to_node)
seg_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    std::string seg_name;$/;"	m	struct:t_fc_override	file:	access:public
seg_start	base/vpr_types.h	/^	int seg_start = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
seg_start	base/vpr_types.h	/^        int seg_start() const { return seg_start_; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
seg_start_	base/vpr_types.h	/^        int seg_start_ = -1;$/;"	m	class:ScreenUpdatePriority::t_chan_seg_details	access:private
segment_exists	../../libs/libarchfpga/src/arch_util.cpp	/^bool segment_exists(const t_arch* arch, std::string name) {$/;"	f	signature:(const t_arch* arch, std::string name)
segment_exists	../../libs/libarchfpga/src/arch_util.h	/^bool segment_exists(const t_arch* arch, std::string name);$/;"	p	signature:(const t_arch* arch, std::string name)
segment_name	../../libs/libarchfpga/src/physical_types.h	/^    std::string segment_name; \/\/The type of segment$/;"	m	struct:t_wire_switchpoints	access:public
sel_subblk_hasher	draw/intra_logic_block.h	/^	struct sel_subblk_hasher {$/;"	s	struct:t_selected_sub_block_info	access:public
select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_node(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node	signature:(const char_t* query, xpath_variable_set* variables) const
select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_node(const xpath_query& query) const$/;"	f	class:pugi::xml_node	signature:(const xpath_query& query) const
select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_node(const char_t* query, xpath_variable_set* variables = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0) const
select_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_node(const xpath_query& query) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xpath_query& query) const
select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set xml_node::select_nodes(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node	signature:(const char_t* query, xpath_variable_set* variables) const
select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set xml_node::select_nodes(const xpath_query& query) const$/;"	f	class:pugi::xml_node	signature:(const xpath_query& query) const
select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set select_nodes(const char_t* query, xpath_variable_set* variables = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0) const
select_nodes	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set select_nodes(const xpath_query& query) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xpath_query& query) const
select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_single_node(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node	signature:(const char_t* query, xpath_variable_set* variables) const
select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xml_node::select_single_node(const xpath_query& query) const$/;"	f	class:pugi::xml_node	signature:(const xpath_query& query) const
select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_single_node(const char_t* query, xpath_variable_set* variables = 0) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0) const
select_single_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node select_single_node(const xpath_query& query) const;$/;"	p	class:pugi::xml_node	access:public	signature:(const xpath_query& query) const
selected_input	power/power.h	/^	short selected_input; \/* Input index that is selected *\/$/;"	m	struct:t_rr_node_power	access:public
selected_pb	draw/intra_logic_block.h	/^	t_pb* selected_pb;$/;"	m	struct:t_selected_sub_block_info	access:private
selected_pb_gnode	draw/intra_logic_block.h	/^	t_pb_graph_node* selected_pb_gnode;$/;"	m	struct:t_selected_sub_block_info	access:private
sentinel	../../libs/libvtrutil/src/vtr_linear_map.h	/^        constexpr K sentinel() const { return Sentinel::INVALID(); }$/;"	f	class:vtr::linear_map	access:private	signature:() const
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(bool rhs)$/;"	f	class:pugi::xml_text	signature:(bool rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(const char_t* rhs)$/;"	f	class:pugi::xml_text	signature:(const char_t* rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(double rhs)$/;"	f	class:pugi::xml_text	signature:(double rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(float rhs)$/;"	f	class:pugi::xml_text	signature:(float rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(int rhs)$/;"	f	class:pugi::xml_text	signature:(int rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(long long rhs)$/;"	f	class:pugi::xml_text	signature:(long long rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(unsigned int rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned int rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_text::set(unsigned long long rhs)$/;"	f	class:pugi::xml_text	signature:(unsigned long long rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(bool value)$/;"	f	class:pugi::xpath_variable	signature:(bool value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(const char_t* value)$/;"	f	class:pugi::xpath_variable	signature:(const char_t* value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(const xpath_node_set& value)$/;"	f	class:pugi::xpath_variable	signature:(const xpath_node_set& value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable::set(double value)$/;"	f	class:pugi::xpath_variable	signature:(double value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, bool value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, bool value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, const char_t* value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, const char_t* value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, const xpath_node_set& value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, const xpath_node_set& value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, double value)$/;"	f	class:pugi::xpath_variable_set	signature:(const char_t* name, double value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(bool rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(bool rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(bool value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(bool value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, bool value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, bool value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, const char_t* value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, const char_t* value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, const xpath_node_set& value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, const xpath_node_set& value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* name, double value);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const char_t* name, double value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(const char_t* rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const char_t* value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(const char_t* value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(const xpath_node_set& value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(const xpath_node_set& value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(double rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(double rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(double value);$/;"	p	class:pugi::xpath_variable	access:public	signature:(double value)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(float rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(float rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(int rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(long long rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(unsigned int rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned int rhs)
set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set(unsigned long long rhs);$/;"	p	class:pugi::xml_text	access:public	signature:(unsigned long long rhs)
set	draw/intra_logic_block.cpp	/^void t_selected_sub_block_info::set(t_pb* new_selected_sub_block, const ClusterBlockId new_containing_block_index) {$/;"	f	class:t_selected_sub_block_info	signature:(t_pb* new_selected_sub_block, const ClusterBlockId new_containing_block_index)
set	draw/intra_logic_block.h	/^	void set(t_pb* new_selected_sub_block, const ClusterBlockId containing_block_index);$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(t_pb* new_selected_sub_block, const ClusterBlockId containing_block_index)
set	route/build_switchblocks.cpp	/^	void set(int len, int wires, int st){$/;"	f	class:Wire_Info	access:public	signature:(int len, int wires, int st)
set	route/route_budgets.h	/^    bool set;$/;"	m	class:route_budgets	access:private
setAllEchoFileEnabled	base/echo_files.cpp	/^void setAllEchoFileEnabled(bool value) {$/;"	f	signature:(bool value)
setAllEchoFileEnabled	base/echo_files.h	/^void setAllEchoFileEnabled(bool value);$/;"	p	signature:(bool value)
setEchoEnabled	base/echo_files.cpp	/^void setEchoEnabled(bool echo_enabled) {$/;"	f	signature:(bool echo_enabled)
setEchoEnabled	base/echo_files.h	/^void setEchoEnabled(bool echo_enabled);$/;"	p	signature:(bool echo_enabled)
setEchoFileEnabled	base/echo_files.cpp	/^void setEchoFileEnabled(enum e_echo_files echo_option, bool value) {$/;"	f	signature:(enum e_echo_files echo_option, bool value)
setEchoFileEnabled	base/echo_files.h	/^void setEchoFileEnabled(enum e_echo_files echo_option, bool value);$/;"	p	signature:(enum e_echo_files echo_option, bool value)
setEchoFileName	base/echo_files.cpp	/^void setEchoFileName(enum e_echo_files echo_option, const char *name) {$/;"	f	signature:(enum e_echo_files echo_option, const char *name)
setEchoFileName	base/echo_files.h	/^void setEchoFileName(enum e_echo_files echo_option, const char *name);$/;"	p	signature:(enum e_echo_files echo_option, const char *name)
setOutputFileName	base/echo_files.cpp	/^void setOutputFileName(enum e_output_files ename, const char *name, const char *default_name) {$/;"	f	signature:(enum e_output_files ename, const char *name, const char *default_name)
setOutputFileName	base/echo_files.h	/^void setOutputFileName(enum e_output_files ename, const char *name, const char* default_name);$/;"	p	signature:(enum e_output_files ename, const char *name, const char* default_name)
setSurface	../../libs/libeasygl/src/Surface.cpp	/^void Surface::setSurface(const char* filePath) {$/;"	f	class:Surface	signature:(const char* filePath)
setSurface	../../libs/libeasygl/src/Surface.h	/^        void setSurface(const char* filePath);$/;"	p	class:Surface	access:public	signature:(const char* filePath)
setSurface	../../libs/libeasygl/src/SurfaceImpl.cpp	/^void SurfaceImpl::setSurface($/;"	f	class:SurfaceImpl	signature:( const char* filePath )
setSurface	../../libs/libeasygl/src/SurfaceImpl.h	/^        void setSurface(const char* filePath);$/;"	p	class:SurfaceImpl	access:public	signature:(const char* filePath)
set_Tdel	../../libs/libarchfpga/src/physical_types.cpp	/^void t_arch_switch_inf::set_Tdel(int fanin, float delay) {$/;"	f	class:t_arch_switch_inf	signature:(int fanin, float delay)
set_Tdel	../../libs/libarchfpga/src/physical_types.h	/^        void set_Tdel(int fanin, float delay);$/;"	p	struct:t_arch_switch_inf	access:public	signature:(int fanin, float delay)
set_atom_clb	base/atom_lookup.cpp	/^void AtomLookup::set_atom_clb(const AtomBlockId blk_id, const ClusterBlockId clb) {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id, const ClusterBlockId clb)
set_atom_clb	base/atom_lookup.h	/^        void set_atom_clb(const AtomBlockId blk_id, const ClusterBlockId clb);$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id, const ClusterBlockId clb)
set_atom_clb_net	base/atom_lookup.cpp	/^void AtomLookup::set_atom_clb_net(const AtomNetId net_id, const ClusterNetId clb_net_index) {$/;"	f	class:AtomLookup	signature:(const AtomNetId net_id, const ClusterNetId clb_net_index)
set_atom_clb_net	base/atom_lookup.h	/^        void set_atom_clb_net(const AtomNetId net_id, const ClusterNetId clb_net_index);$/;"	p	class:AtomLookup	access:public	signature:(const AtomNetId net_id, const ClusterNetId clb_net_index)
set_atom_pb	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pb(const AtomBlockId blk_id, const t_pb* pb) {$/;"	f	class:AtomLookup	signature:(const AtomBlockId blk_id, const t_pb* pb)
set_atom_pb	base/atom_lookup.h	/^        void set_atom_pb(const AtomBlockId blk_id, const t_pb* pb);$/;"	p	class:AtomLookup	access:public	signature:(const AtomBlockId blk_id, const t_pb* pb)
set_atom_pin_bit_index	base/vpr_types.h	/^    void set_atom_pin_bit_index(const t_pb_graph_pin* gpin, BitIndex atom_pin_bit_idx) {$/;"	f	struct:ScreenUpdatePriority::t_pb	access:public	signature:(const t_pb_graph_pin* gpin, BitIndex atom_pin_bit_idx)
set_atom_pin_classic_tnode	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pin_classic_tnode(const AtomPinId pin_id, const int tnode_index) {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin_id, const int tnode_index)
set_atom_pin_classic_tnode	base/atom_lookup.h	/^        void set_atom_pin_classic_tnode(const AtomPinId pin_id, const int tnode_index);$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin_id, const int tnode_index)
set_atom_pin_mapping	base/read_netlist.cpp	/^static void set_atom_pin_mapping(const ClusteredNetlist& clb_nlist, const AtomBlockId atom_blk, const AtomPortId atom_port, const t_pb_graph_pin* gpin) {$/;"	f	file:	signature:(const ClusteredNetlist& clb_nlist, const AtomBlockId atom_blk, const AtomPortId atom_port, const t_pb_graph_pin* gpin)
set_atom_pin_mapping	base/read_netlist.cpp	/^static void set_atom_pin_mapping(const ClusteredNetlist& clb_nlist, const AtomBlockId atom_blk, const AtomPortId atom_port, const t_pb_graph_pin* gpin);$/;"	p	file:	signature:(const ClusteredNetlist& clb_nlist, const AtomBlockId atom_blk, const AtomPortId atom_port, const t_pb_graph_pin* gpin)
set_atom_pin_pb_graph_pin	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pin_pb_graph_pin(AtomPinId atom_pin, const t_pb_graph_pin* gpin) {$/;"	f	class:AtomLookup	signature:(AtomPinId atom_pin, const t_pb_graph_pin* gpin)
set_atom_pin_pb_graph_pin	base/atom_lookup.h	/^        void set_atom_pin_pb_graph_pin(AtomPinId atom_pin, const t_pb_graph_pin* gpin);$/;"	p	class:AtomLookup	access:public	signature:(AtomPinId atom_pin, const t_pb_graph_pin* gpin)
set_atom_pin_tnode	base/atom_lookup.cpp	/^void AtomLookup::set_atom_pin_tnode(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type) {$/;"	f	class:AtomLookup	signature:(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type)
set_atom_pin_tnode	base/atom_lookup.h	/^        void set_atom_pin_tnode(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type=BlockTnode::EXTERNAL);$/;"	p	class:AtomLookup	access:public	signature:(const AtomPinId pin, const tatum::NodeId node, BlockTnode block_tnode_type=BlockTnode::EXTERNAL)
set_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        void set_bit(size_t address, bit_value_t value)$/;"	f	class:BitSpace::BitFields	access:public	signature:(size_t address, bit_value_t value)
set_bit	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        void set_bit(size_t address, bit_value_t value)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(size_t address, bit_value_t value)
set_bit_from_lsb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_bit_from_lsb(size_t index, BitSpace::bit_value_t val)$/;"	f	class:VNumber	access:public	signature:(size_t index, BitSpace::bit_value_t val)
set_bit_from_msb	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_bit_from_msb(size_t index, BitSpace::bit_value_t val)$/;"	f	class:VNumber	access:public	signature:(size_t index, BitSpace::bit_value_t val)
set_block_attr	base/netlist.h	/^        void set_block_attr(const BlockId blk_id, const std::string &name, const std::string &value);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
set_block_attr	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_block_attr(const BlockId blk_id, const std::string &name, const std::string &value) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
set_block_name	base/netlist.h	/^        void set_block_name(const BlockId blk_id, const std::string new_name);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string new_name)
set_block_name	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_block_name(const BlockId blk_id, const std::string new_name) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string new_name)
set_block_param	base/netlist.h	/^        void set_block_param(const BlockId blk_id, const std::string &name, const std::string &value);$/;"	p	class:Netlist	access:public	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
set_block_param	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_block_param(const BlockId blk_id, const std::string &name, const std::string &value) {$/;"	f	class:Netlist	signature:(const BlockId blk_id, const std::string &name, const std::string &value)
set_block_pin_util	base/vpr_types.cpp	/^void t_ext_pin_util_targets::set_block_pin_util(std::string block_type_name, t_ext_pin_util target) {$/;"	f	class:t_ext_pin_util_targets	signature:(std::string block_type_name, t_ext_pin_util target)
set_block_pin_util	base/vpr_types.h	/^    void set_block_pin_util(std::string block_type_name, t_ext_pin_util target);$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(std::string block_type_name, t_ext_pin_util target)
set_cached_delay	timing/PostClusterDelayCalculator.h	/^    void set_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
set_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
set_cached_hold_time	timing/PostClusterDelayCalculator.h	/^    void set_cached_hold_time(tatum::EdgeId edge, tatum::Time hold) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, tatum::Time hold) const
set_cached_hold_time	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_hold_time(tatum::EdgeId edge, tatum::Time hold) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, tatum::Time hold) const
set_cached_pins	timing/PostClusterDelayCalculator.h	/^    void set_cached_pins(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const
set_cached_pins	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_pins(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, ClusterPinId src_pin, ClusterPinId sink_pin) const
set_cached_setup_time	timing/PostClusterDelayCalculator.h	/^    void set_cached_setup_time(tatum::EdgeId edge, tatum::Time setup) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, tatum::Time setup) const
set_cached_setup_time	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_cached_setup_time(tatum::EdgeId edge, tatum::Time setup) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, tatum::Time setup) const
set_capacity	route/rr_node.cpp	/^void t_rr_node::set_capacity(short new_capacity) {$/;"	f	class:t_rr_node	signature:(short new_capacity)
set_capacity	route/rr_node.h	/^        void set_capacity(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
set_class_num	route/rr_node.cpp	/^void t_rr_node::set_class_num(short new_class_num) {$/;"	f	class:t_rr_node	signature:(short new_class_num)
set_class_num	route/rr_node.h	/^        void set_class_num(short); \/\/Same as set_ptc_num() by checks type() is consistent$/;"	p	class:t_rr_node	access:public	signature:(short)
set_conditional_defaults	base/read_options.cpp	/^static void set_conditional_defaults(t_options& args) {$/;"	f	file:	signature:(t_options& args)
set_conditional_defaults	base/read_options.cpp	/^static void set_conditional_defaults(t_options& args);$/;"	p	file:	signature:(t_options& args)
set_connection_criticality_tolerance	route/connection_based_routing.h	/^    void set_connection_criticality_tolerance(float val) { connection_criticality_tolerance = val; }$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float val)
set_connection_delay_tolerance	route/connection_based_routing.h	/^    void set_connection_delay_tolerance(float val) { connection_delay_optimality_tolerance = val; }$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float val)
set_coordinate_system	../../libs/libeasygl/src/graphics.cpp	/^set_coordinate_system(t_coordinate_system coord)$/;"	f	signature:(t_coordinate_system coord)
set_coordinate_system	../../libs/libeasygl/src/graphics.cpp	/^void set_coordinate_system(t_coordinate_system \/*coord*\/) { }$/;"	f	signature:(t_coordinate_system )
set_coordinate_system	../../libs/libeasygl/src/graphics.h	/^void set_coordinate_system(t_coordinate_system coord);$/;"	p	signature:(t_coordinate_system coord)
set_coordinates	route/rr_node.cpp	/^void t_rr_node::set_coordinates(short x1, short y1, short x2, short y2) {$/;"	f	class:t_rr_node	signature:(short x1, short y1, short x2, short y2)
set_coordinates	route/rr_node.h	/^        void set_coordinates(short x1, short y1, short x2, short y2);$/;"	p	class:t_rr_node	access:public	signature:(short x1, short y1, short x2, short y2)
set_coords	route/build_switchblocks.h	/^	void set_coords(int set_x, int set_y, e_side set_from, e_side set_to){$/;"	f	class:Switchblock_Lookup	access:public	signature:(int set_x, int set_y, e_side set_from, e_side set_to)
set_cost_index	route/rr_node.cpp	/^void t_rr_node::set_cost_index(short new_cost_index) {$/;"	f	class:t_rr_node	signature:(short new_cost_index)
set_cost_index	route/rr_node.h	/^        void set_cost_index(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
set_cost_indices	route/rr_graph_reader.cpp	/^void set_cost_indices(pugi::xml_node parent, const pugiutil::loc_data& loc_data,$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data, const bool is_global_graph, const int num_seg_types)
set_cost_indices	route/rr_graph_reader.cpp	/^void set_cost_indices(pugi::xml_node parent, const pugiutil::loc_data& loc_data,$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data, const bool is_global_graph, const int num_seg_types)
set_curr_block	base/read_blif.cpp	/^        void set_curr_block(AtomBlockId blk) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(AtomBlockId blk)
set_curr_model_blackbox	base/read_blif.cpp	/^        void set_curr_model_blackbox(bool val) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(bool val)
set_default_pin_util	base/vpr_types.cpp	/^void t_ext_pin_util_targets::set_default_pin_util(t_ext_pin_util default_target) {$/;"	f	class:t_ext_pin_util_targets	signature:(t_ext_pin_util default_target)
set_default_pin_util	base/vpr_types.h	/^    void set_default_pin_util(t_ext_pin_util target);$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(t_ext_pin_util target)
set_delay_override	place/place_delay_model.cpp	/^void OverrideDelayModel::set_delay_override(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay_val) {$/;"	f	class:OverrideDelayModel	signature:(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay_val)
set_delay_override	place/place_delay_model.h	/^        void set_delay_override(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay);$/;"	p	class:OverrideDelayModel	access:public	signature:(int from_type, int from_class, int to_type, int to_class, int delta_x, int delta_y, float delay)
set_detail_level	timing/VprTimingGraphResolver.cpp	/^void VprTimingGraphResolver::set_detail_level(e_timing_report_detail report_detail) {$/;"	f	class:VprTimingGraphResolver	signature:(e_timing_report_detail report_detail)
set_detail_level	timing/VprTimingGraphResolver.h	/^        void set_detail_level(e_timing_report_detail report_detail);$/;"	p	class:VprTimingGraphResolver	access:public	signature:(e_timing_report_detail report_detail)
set_direction	route/rr_node.cpp	/^void t_rr_node::set_direction(e_direction new_direction) {$/;"	f	class:t_rr_node	signature:(e_direction new_direction)
set_direction	route/rr_node.h	/^        void set_direction(e_direction);$/;"	p	class:t_rr_node	access:public	signature:(e_direction)
set_disable_event_loop	../../libs/libeasygl/src/graphics.cpp	/^void set_disable_event_loop (bool new_setting) {$/;"	f	signature:(bool new_setting)
set_disable_event_loop	../../libs/libeasygl/src/graphics_automark.h	/^void set_disable_event_loop (bool new_setting);$/;"	p	signature:(bool new_setting)
set_draw_mode	../../libs/libeasygl/src/graphics.cpp	/^void set_draw_mode(enum e_draw_mode \/*draw_mode*\/) { }$/;"	f	signature:(enum e_draw_mode )
set_draw_mode	../../libs/libeasygl/src/graphics.cpp	/^void set_draw_mode(enum e_draw_mode draw_mode) {$/;"	f	signature:(enum e_draw_mode draw_mode)
set_draw_mode	../../libs/libeasygl/src/graphics.h	/^void set_draw_mode(enum e_draw_mode draw_mode);$/;"	p	signature:(enum e_draw_mode draw_mode)
set_drawing_buffer	../../libs/libeasygl/src/graphics.cpp	/^void set_drawing_buffer(t_draw_to \/*draw_mode*\/) { }$/;"	f	signature:(t_draw_to )
set_drawing_buffer	../../libs/libeasygl/src/graphics.cpp	/^void set_drawing_buffer(t_draw_to draw_mode) {$/;"	f	signature:(t_draw_to draw_mode)
set_drawing_buffer	../../libs/libeasygl/src/graphics.h	/^void set_drawing_buffer(t_draw_to draw_mode);$/;"	p	signature:(t_draw_to draw_mode)
set_driver_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    void set_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
set_driver_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_driver_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
set_edge_sink_node	route/rr_node.cpp	/^void t_rr_node::set_edge_sink_node(short iedge, int sink_node) {$/;"	f	class:t_rr_node	signature:(short iedge, int sink_node)
set_edge_sink_node	route/rr_node.h	/^        void set_edge_sink_node(short iedge, int sink_node);$/;"	p	class:t_rr_node	access:public	signature:(short iedge, int sink_node)
set_edge_switch	route/rr_node.cpp	/^void t_rr_node::set_edge_switch(short iedge, short switch_index) {$/;"	f	class:t_rr_node	signature:(short iedge, short switch_index)
set_edge_switch	route/rr_node.h	/^        void set_edge_switch(short iedge, short switch_index);$/;"	p	class:t_rr_node	access:public	signature:(short iedge, short switch_index)
set_fan_in	route/rr_node.cpp	/^void t_rr_node::set_fan_in(short new_fan_in) {$/;"	f	class:t_rr_node	signature:(short new_fan_in)
set_fan_in	route/rr_node.h	/^        void set_fan_in(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
set_forced_pause	base/vpr_context.h	/^        void set_forced_pause(bool val) { force_pause_ = val; }$/;"	f	class:VprContext	access:public	signature:(bool val)
set_grid_block_type	base/SetupGrid.cpp	/^static void set_grid_block_type(int priority, const t_type_descriptor* type, size_t x_root, size_t y_root, vtr::Matrix<t_grid_tile>& grid, vtr::Matrix<int>& grid_priorities) {$/;"	f	file:	signature:(int priority, const t_type_descriptor* type, size_t x_root, size_t y_root, vtr::Matrix<t_grid_tile>& grid, vtr::Matrix<int>& grid_priorities)
set_grid_block_type	base/SetupGrid.cpp	/^static void set_grid_block_type(int priority, const t_type_descriptor* type, size_t x_root, size_t y_root, vtr::Matrix<t_grid_tile>& grid, vtr::Matrix<int>& grid_priorities);$/;"	p	file:	signature:(int priority, const t_type_descriptor* type, size_t x_root, size_t y_root, vtr::Matrix<t_grid_tile>& grid, vtr::Matrix<int>& grid_priorities)
set_has_element	route/cb_metrics.cpp	/^template< typename T > bool set_has_element( const T elem, const std::set< T > *my_set ){$/;"	f	signature:( const T elem, const std::set< T > *my_set )
set_jump_offset	timing/slre.cpp	/^static void set_jump_offset(struct slre *r, int pc, int offset) {$/;"	f	file:	signature:(struct slre *r, int pc, int offset)
set_keypress_input	../../libs/libeasygl/src/graphics.cpp	/^void set_keypress_input(bool enable) {$/;"	f	signature:(bool enable)
set_keypress_input	../../libs/libeasygl/src/graphics.cpp	/^void set_keypress_input(bool) { }$/;"	f	signature:(bool)
set_keypress_input	../../libs/libeasygl/src/graphics.h	/^void set_keypress_input(bool turn_on);$/;"	p	signature:(bool turn_on)
set_length	base/vpr_types.h	/^        void set_length(int new_len) { length_ = new_len; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int new_len)
set_log_file	../../libs/libvtrutil/src/vtr_log.cpp	/^void set_log_file(const char* filename) {$/;"	f	namespace:vtr	signature:(const char* filename)
set_log_file	../../libs/libvtrutil/src/vtr_log.h	/^void set_log_file(const char* filename);$/;"	p	namespace:vtr	signature:(const char* filename)
set_lookahead_map_costs	route/router_lookahead_map.cpp	/^static void set_lookahead_map_costs(int segment_index, e_rr_type chan_type, t_routing_cost_map &routing_cost_map);$/;"	p	file:	signature:(int segment_index, e_rr_type chan_type, t_routing_cost_map &routing_cost_map)
set_lookahead_map_costs	route/router_lookahead_map.cpp	/^static void set_lookahead_map_costs(int segment_index, e_rr_type chan_type, t_routing_cost_map &routing_cost_map){$/;"	f	file:	signature:(int segment_index, e_rr_type chan_type, t_routing_cost_map &routing_cost_map)
set_lower_bound_connection_delays	route/connection_based_routing.h	/^	void set_lower_bound_connection_delays(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	class:Connection_based_routing_resources	access:public	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
set_lower_bound_connection_delays	route/route_timing.cpp	/^void Connection_based_routing_resources::set_lower_bound_connection_delays(vtr::vector<ClusterNetId, float *> &net_delay) {$/;"	f	class:Connection_based_routing_resources	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
set_memory_management_functions	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate)$/;"	f	namespace:pugi	signature:(allocation_function allocate, deallocation_function deallocate)
set_memory_management_functions	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate);$/;"	p	namespace:pugi	signature:(allocation_function allocate, deallocation_function deallocate)
set_min_max_budgets_equal	route/route_budgets.cpp	/^void route_budgets::set_min_max_budgets_equal() {$/;"	f	class:route_budgets	signature:()
set_min_max_budgets_equal	route/route_budgets.h	/^    void set_min_max_budgets_equal();$/;"	p	class:route_budgets	access:private	signature:()
set_mode_cluster_placement_stats	pack/cluster_placement.cpp	/^void set_mode_cluster_placement_stats(const t_pb_graph_node *pb_graph_node,$/;"	f	signature:(const t_pb_graph_node *pb_graph_node, int mode)
set_mode_cluster_placement_stats	pack/cluster_placement.h	/^void set_mode_cluster_placement_stats(const t_pb_graph_node *complex_block,$/;"	p	signature:(const t_pb_graph_node *complex_block, int mode)
set_mouse_move_input	../../libs/libeasygl/src/graphics.cpp	/^void set_mouse_move_input(bool enable) {$/;"	f	signature:(bool enable)
set_mouse_move_input	../../libs/libeasygl/src/graphics.cpp	/^void set_mouse_move_input(bool) { }$/;"	f	signature:(bool)
set_mouse_move_input	../../libs/libeasygl/src/graphics.h	/^void set_mouse_move_input(bool turn_on);$/;"	p	signature:(bool turn_on)
set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_name(const char_t* rhs)$/;"	f	class:pugi::xml_attribute	signature:(const char_t* rhs)
set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::set_name(const char_t* rhs)$/;"	f	class:pugi::xml_node	signature:(const char_t* rhs)
set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_name(const char_t* rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* rhs)
set_name	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_name(const char_t* rhs);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* rhs)
set_net_is_global	base/clustered_netlist.cpp	/^void ClusteredNetlist::set_net_is_global(ClusterNetId net_id, bool state) {$/;"	f	class:ClusteredNetlist	signature:(ClusterNetId net_id, bool state)
set_net_is_global	base/clustered_netlist.h	/^        void set_net_is_global(ClusterNetId net_id, bool state);$/;"	p	class:ClusteredNetlist	access:public	signature:(ClusterNetId net_id, bool state)
set_next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void set_next(xpath_ast_node* value)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_ast_node* value)
set_num_edges	route/rr_node.cpp	/^void t_rr_node::set_num_edges(short new_num_edges) {$/;"	f	class:t_rr_node	signature:(short new_num_edges)
set_num_edges	route/rr_node.h	/^        void set_num_edges(short); \/\/Note will remove any previous edges$/;"	p	class:t_rr_node	access:public	signature:(short)
set_occ	base/vpr_types.h	/^        void set_occ(int new_occ) { occ_ = new_occ; }$/;"	f	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public	signature:(int new_occ)
set_pin_is_constant	base/netlist.h	/^        void set_pin_is_constant(const PinId pin_id, const bool value);$/;"	p	class:Netlist	access:public	signature:(const PinId pin_id, const bool value)
set_pin_is_constant	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_pin_is_constant(const PinId pin_id, const bool value) {$/;"	f	class:Netlist	signature:(const PinId pin_id, const bool value)
set_pin_net	base/netlist.h	/^        void set_pin_net(const PinId pin, PinType pin_type, const NetId net);$/;"	p	class:Netlist	access:public	signature:(const PinId pin, PinType pin_type, const NetId net)
set_pin_net	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::set_pin_net(const PinId pin, PinType type, const NetId net) {$/;"	f	class:Netlist	signature:(const PinId pin, PinType type, const NetId net)
set_pin_num	route/rr_node.cpp	/^void t_rr_node::set_pin_num(short new_pin_num) {$/;"	f	class:t_rr_node	signature:(short new_pin_num)
set_pin_num	route/rr_node.h	/^        void set_pin_num(short); \/\/Same as set_ptc_num() by checks type() is consistent$/;"	p	class:t_rr_node	access:public	signature:(short)
set_pin_physical_index	base/clustered_netlist.cpp	/^void ClusteredNetlist::set_pin_physical_index(const ClusterPinId pin, const int phys_pin_index) {$/;"	f	class:ClusteredNetlist	signature:(const ClusterPinId pin, const int phys_pin_index)
set_pin_physical_index	base/clustered_netlist.h	/^        void    set_pin_physical_index(const ClusterPinId pin_id, const int index);$/;"	p	class:ClusteredNetlist	access:public	signature:(const ClusterPinId pin_id, const int index)
set_ptc_num	route/rr_node.cpp	/^void t_rr_node::set_ptc_num(short new_ptc_num) {$/;"	f	class:t_rr_node	signature:(short new_ptc_num)
set_ptc_num	route/rr_node.h	/^        void set_ptc_num(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
set_rc_index	route/rr_node.cpp	/^void t_rr_node::set_rc_index(short new_rc_index) {$/;"	f	class:t_rr_node	signature:(short new_rc_index)
set_rc_index	route/rr_node.h	/^        void set_rc_index(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
set_redirect_to_postscript	../../libs/libeasygl/src/graphics.cpp	/^void set_redirect_to_postscript (bool new_setting) {$/;"	f	signature:(bool new_setting)
set_redirect_to_postscript	../../libs/libeasygl/src/graphics_automark.h	/^void set_redirect_to_postscript (bool new_setting);$/;"	p	signature:(bool new_setting)
set_reset_pb_modes	pack/cluster_router.cpp	/^void set_reset_pb_modes(t_lb_router_data *router_data, const t_pb *pb, const bool set) {$/;"	f	signature:(t_lb_router_data *router_data, const t_pb *pb, const bool set)
set_reset_pb_modes	pack/cluster_router.h	/^void set_reset_pb_modes(t_lb_router_data *router_data, const t_pb *pb, const bool set);$/;"	p	signature:(t_lb_router_data *router_data, const t_pb *pb, const bool set)
set_right	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void set_right(xpath_ast_node* value)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_ast_node* value)
set_seg_end	base/vpr_types.h	/^        void set_seg_end(int new_end) { seg_end_ = new_end; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int new_end)
set_seg_start	base/vpr_types.h	/^        void set_seg_start(int new_start) { seg_start_ = new_start; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(int new_start)
set_side	route/rr_node.cpp	/^void t_rr_node::set_side(e_side new_side) {$/;"	f	class:t_rr_node	signature:(e_side new_side)
set_side	route/rr_node.h	/^        void set_side(e_side);$/;"	p	class:t_rr_node	access:public	signature:(e_side)
set_sides	../../libs/libarchfpga/src/physical_types.h	/^	void set_sides( enum e_side from, enum e_side to ){$/;"	f	class:SB_Side_Connection	access:public	signature:( enum e_side from, enum e_side to )
set_sink_clb_cached_delay	timing/PostClusterDelayCalculator.h	/^    void set_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const;$/;"	p	class:PostClusterDelayCalculator	access:private	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
set_sink_clb_cached_delay	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_sink_clb_cached_delay(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const {$/;"	f	class:PostClusterDelayCalculator	signature:(tatum::EdgeId edge, DelayType delay_type, tatum::Time delay) const
set_stable_critical_path_delay	route/connection_based_routing.h	/^	void set_stable_critical_path_delay(float stable_critical_path_delay) {last_stable_critical_path_delay = stable_critical_path_delay;}$/;"	f	class:Connection_based_routing_resources	access:public	signature:(float stable_critical_path_delay)
set_timing_place_crit	place/timing_place.cpp	/^void set_timing_place_crit(ClusterNetId net_id, int ipin, float val) {$/;"	f	signature:(ClusterNetId net_id, int ipin, float val)
set_timing_place_crit	place/timing_place.h	/^void set_timing_place_crit(ClusterNetId net_id, int ipin, float val);$/;"	p	signature:(ClusterNetId net_id, int ipin, float val)
set_track_num	route/rr_node.cpp	/^void t_rr_node::set_track_num(short new_track_num) {$/;"	f	class:t_rr_node	signature:(short new_track_num)
set_track_num	route/rr_node.h	/^        void set_track_num(short); \/\/Same as set_ptc_num() by checks type() is consistent$/;"	p	class:t_rr_node	access:public	signature:(short)
set_tsu_margin_absolute	timing/PostClusterDelayCalculator.h	/^    void set_tsu_margin_absolute(float val);$/;"	p	class:PostClusterDelayCalculator	access:public	signature:(float val)
set_tsu_margin_absolute	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_tsu_margin_absolute(float new_margin) {$/;"	f	class:PostClusterDelayCalculator	signature:(float new_margin)
set_tsu_margin_relative	timing/PostClusterDelayCalculator.h	/^    void set_tsu_margin_relative(float val);$/;"	p	class:PostClusterDelayCalculator	access:public	signature:(float val)
set_tsu_margin_relative	timing/PostClusterDelayCalculator.tpp	/^inline void PostClusterDelayCalculator::set_tsu_margin_relative(float new_margin) {$/;"	f	class:PostClusterDelayCalculator	signature:(float new_margin)
set_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void set_type(xpath_node_set::type_t value)$/;"	f	class:xpath_node_set_raw	access:public	signature:(xpath_node_set::type_t value)
set_type	../../libs/libarchfpga/src/physical_types.cpp	/^void t_arch_switch_inf::set_type(SwitchType type_val) {$/;"	f	class:t_arch_switch_inf	signature:(SwitchType type_val)
set_type	../../libs/libarchfpga/src/physical_types.cpp	/^void t_rr_switch_inf::set_type(SwitchType type_val) {$/;"	f	class:t_rr_switch_inf	signature:(SwitchType type_val)
set_type	../../libs/libarchfpga/src/physical_types.h	/^        void set_type(SwitchType type_val);$/;"	p	struct:t_arch_switch_inf	access:public	signature:(SwitchType type_val)
set_type	../../libs/libarchfpga/src/physical_types.h	/^        void set_type(SwitchType type_val);$/;"	p	struct:t_rr_switch_inf	access:public	signature:(SwitchType type_val)
set_type	route/rr_node.cpp	/^void t_rr_node::set_type(t_rr_type new_type) {$/;"	f	class:t_rr_node	signature:(t_rr_type new_type)
set_type	route/rr_node.h	/^        void set_type(t_rr_type new_type);$/;"	p	class:t_rr_node	access:public	signature:(t_rr_type new_type)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(bool rhs)$/;"	f	class:pugi::xml_attribute	signature:(bool rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(const char_t* rhs)$/;"	f	class:pugi::xml_attribute	signature:(const char_t* rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(double rhs)$/;"	f	class:pugi::xml_attribute	signature:(double rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(float rhs)$/;"	f	class:pugi::xml_attribute	signature:(float rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(int rhs)$/;"	f	class:pugi::xml_attribute	signature:(int rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(long long rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(unsigned int rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned int rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_attribute::set_value(unsigned long long rhs)$/;"	f	class:pugi::xml_attribute	signature:(unsigned long long rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::set_value(const char_t* rhs)$/;"	f	class:pugi::xml_node	signature:(const char_t* rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(bool rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(bool rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(const char_t* rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(const char_t* rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(const char_t* rhs);$/;"	p	class:pugi::xml_node	access:public	signature:(const char_t* rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(double rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(double rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(float rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(float rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(int rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(long long rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(unsigned int rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned int rhs)
set_value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool set_value(unsigned long long rhs);$/;"	p	class:pugi::xml_attribute	access:public	signature:(unsigned long long rhs)
set_value	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_value(const std::string& input)$/;"	f	class:VNumber	access:public	signature:(const std::string& input)
set_value	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    void set_value(int64_t in)$/;"	f	class:VNumber	access:public	signature:(int64_t in)
set_value_ascii	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_ascii(String& dest, Header& header, uintptr_t header_mask, char* buf)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, char* buf)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, bool value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, bool value)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, double value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, double value)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, float value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, float value)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, int value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, int value)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, long long value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, long long value)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, unsigned int value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, unsigned int value)
set_value_convert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, unsigned long long value)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, unsigned long long value)
set_var_value	../../libs/libarchfpga/src/expr_eval.h	/^        void set_var_value(std::string var, int value) { vars_[var] = value; }$/;"	f	class:t_formula_data	access:public	signature:(std::string var, int value)
set_visible_world	../../libs/libeasygl/src/graphics.cpp	/^void set_visible_world(const t_bound_box& \/*bounds*\/) { }$/;"	f	signature:(const t_bound_box& )
set_visible_world	../../libs/libeasygl/src/graphics.cpp	/^void set_visible_world(const t_bound_box& bounds) {$/;"	f	signature:(const t_bound_box& bounds)
set_visible_world	../../libs/libeasygl/src/graphics.cpp	/^void set_visible_world(float \/*xl*\/, float \/*yt*\/, float \/*xr*\/, float \/*yb*\/) { }$/;"	f	signature:(float , float , float , float )
set_visible_world	../../libs/libeasygl/src/graphics.cpp	/^void set_visible_world(float left, float bottom, float right, float top) {$/;"	f	signature:(float left, float bottom, float right, float top)
set_visible_world	../../libs/libeasygl/src/graphics.h	/^void set_visible_world(const t_bound_box& bounds);$/;"	p	signature:(const t_bound_box& bounds)
set_visible_world	../../libs/libeasygl/src/graphics.h	/^void set_visible_world(float xl, float yb, float xr, float yt);$/;"	p	signature:(float xl, float yb, float xr, float yt)
set_warn_unconstrained	timing/timing_info.h	/^        virtual void set_warn_unconstrained(bool val) = 0;$/;"	p	class:TimingInfo	access:public	signature:(bool val)
set_zoom_factor	../../libs/libeasygl/src/graphics.cpp	/^void set_zoom_factor(float \/*new_zoom_factor*\/) { }$/;"	f	signature:(float )
set_zoom_factor	../../libs/libeasygl/src/graphics.cpp	/^void set_zoom_factor(float new_zoom_factor) {$/;"	f	signature:(float new_zoom_factor)
set_zoom_factor	../../libs/libeasygl/src/graphics.h	/^void set_zoom_factor(float new_zoom_factor);$/;"	p	signature:(float new_zoom_factor)
setcolor	../../libs/libeasygl/src/graphics.cpp	/^void setcolor(const t_color& \/*c*\/) { }$/;"	f	signature:(const t_color& )
setcolor	../../libs/libeasygl/src/graphics.cpp	/^void setcolor(const t_color& color) {$/;"	f	signature:(const t_color& color)
setcolor	../../libs/libeasygl/src/graphics.cpp	/^void setcolor(int \/*cindex*\/) { }$/;"	f	signature:(int )
setcolor	../../libs/libeasygl/src/graphics.cpp	/^void setcolor(int cindex) {$/;"	f	signature:(int cindex)
setcolor	../../libs/libeasygl/src/graphics.cpp	/^void setcolor(uint_fast8_t \/*r*\/, uint_fast8_t \/*g*\/, uint_fast8_t \/*b*\/, uint_fast8_t \/*a*\/) { }$/;"	f	signature:(uint_fast8_t , uint_fast8_t , uint_fast8_t , uint_fast8_t )
setcolor	../../libs/libeasygl/src/graphics.cpp	/^void setcolor(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a) {$/;"	f	signature:(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a)
setcolor	../../libs/libeasygl/src/graphics.h	/^void setcolor(const t_color& new_color);$/;"	p	signature:(const t_color& new_color)
setcolor	../../libs/libeasygl/src/graphics.h	/^void setcolor(int cindex);$/;"	p	signature:(int cindex)
setcolor	../../libs/libeasygl/src/graphics.h	/^void setcolor(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a = 255);$/;"	p	signature:(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a = 255)
setcolor_by_name	../../libs/libeasygl/src/graphics.cpp	/^void setcolor_by_name(std::string \/*cname*\/) { }$/;"	f	signature:(std::string )
setcolor_by_name	../../libs/libeasygl/src/graphics.cpp	/^void setcolor_by_name(string cname) {$/;"	f	signature:(string cname)
setcolor_by_name	../../libs/libeasygl/src/graphics.h	/^void setcolor_by_name(std::string cname);$/;"	p	signature:(std::string cname)
setfontsize	../../libs/libeasygl/src/graphics.cpp	/^void setfontsize(int \/*pointsize*\/) { }$/;"	f	signature:(int )
setfontsize	../../libs/libeasygl/src/graphics.cpp	/^void setfontsize(int pointsize) {$/;"	f	signature:(int pointsize)
setfontsize	../../libs/libeasygl/src/graphics.h	/^void setfontsize(int pointsize);$/;"	p	signature:(int pointsize)
setlinestyle	../../libs/libeasygl/src/graphics.cpp	/^void setlinestyle(int \/*linestyle*\/, int \/*capstyle*\/) { }$/;"	f	signature:(int , int )
setlinestyle	../../libs/libeasygl/src/graphics.cpp	/^void setlinestyle(int linestyle, int capstyle) {$/;"	f	signature:(int linestyle, int capstyle)
setlinestyle	../../libs/libeasygl/src/graphics.h	/^void setlinestyle(int linestyle, int capstyle = BUTT);$/;"	p	signature:(int linestyle, int capstyle = BUTT)
setlinewidth	../../libs/libeasygl/src/graphics.cpp	/^void setlinewidth(int \/*linewidth*\/) { }$/;"	f	signature:(int )
setlinewidth	../../libs/libeasygl/src/graphics.cpp	/^void setlinewidth(int linewidth) {$/;"	f	signature:(int linewidth)
setlinewidth	../../libs/libeasygl/src/graphics.h	/^void setlinewidth(int linewidth);$/;"	p	signature:(int linewidth)
setpoly	../../libs/libeasygl/src/graphics.cpp	/^static void setpoly(int bnum, int xc, int yc, int r, float theta) {$/;"	f	file:	signature:(int bnum, int xc, int yc, int r, float theta)
settextattrs	../../libs/libeasygl/src/graphics.cpp	/^void settextattrs(int \/*pointsize*\/, int \/*degrees*\/) { }$/;"	f	signature:(int , int )
settextattrs	../../libs/libeasygl/src/graphics.cpp	/^void settextattrs(int pointsize, int degrees) {$/;"	f	signature:(int pointsize, int degrees)
settextattrs	../../libs/libeasygl/src/graphics.h	/^void settextattrs(int pointsize, int degrees);$/;"	p	signature:(int pointsize, int degrees)
settextrotation	../../libs/libeasygl/src/graphics.cpp	/^void settextrotation(int \/*degrees*\/) { }$/;"	f	signature:(int )
settextrotation	../../libs/libeasygl/src/graphics.cpp	/^void settextrotation(int degrees) {$/;"	f	signature:(int degrees)
settextrotation	../../libs/libeasygl/src/graphics.h	/^void settextrotation(int degrees);$/;"	p	signature:(int degrees)
setup_analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::SetupTimingAnalyzer> setup_analyzer() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
setup_analyzer_	timing/concrete_timing_info.h	/^        std::shared_ptr<tatum::SetupTimingAnalyzer> setup_analyzer_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
setup_blocks_affected	place/place.cpp	/^static int setup_blocks_affected(ClusterBlockId b_from, int x_to, int y_to, int z_to) {$/;"	f	file:	signature:(ClusterBlockId b_from, int x_to, int y_to, int z_to)
setup_blocks_affected	place/place.cpp	/^static int setup_blocks_affected(ClusterBlockId b_from, int x_to, int y_to, int z_to);$/;"	p	file:	signature:(ClusterBlockId b_from, int x_to, int y_to, int z_to)
setup_capture_cycle	timing/read_sdc2.cpp	/^        int setup_capture_cycle(tatum::DomainId from, tatum::DomainId to) const {$/;"	f	class:SdcParseCallback2	file:	access:private	signature:(tatum::DomainId from, tatum::DomainId to) const
setup_chan_width	place/timing_place_lookup.cpp	/^static t_chan_width setup_chan_width(t_router_opts router_opts,$/;"	f	file:	signature:(t_router_opts router_opts, t_chan_width_dist chan_width_dist)
setup_chan_width	place/timing_place_lookup.cpp	/^static t_chan_width setup_chan_width(t_router_opts router_opts,$/;"	p	file:	signature:(t_router_opts router_opts, t_chan_width_dist chan_width_dist)
setup_hold_analyzer	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::SetupHoldTimingAnalyzer> setup_hold_analyzer() const = 0;$/;"	p	class:SetupHoldTimingInfo	access:public	signature:() const
setup_hold_analyzer_	timing/concrete_timing_info.h	/^        std::shared_ptr<tatum::SetupHoldTimingAnalyzer> setup_hold_analyzer_;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
setup_mcp_overrides_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>,int> setup_mcp_overrides_;$/;"	m	class:SdcParseCallback2	file:	access:private
setup_override_constraints_	timing/read_sdc2.cpp	/^        std::map<std::pair<tatum::DomainId,tatum::DomainId>, float> setup_override_constraints_;$/;"	m	class:SdcParseCallback2	file:	access:private
setup_pin_criticality	timing/slack_evaluation.cpp	/^float SetupSlackCrit::setup_pin_criticality(AtomPinId pin) const { return pin_criticalities_[pin]; }$/;"	f	class:SetupSlackCrit	signature:(AtomPinId pin) const
setup_pin_criticality	timing/slack_evaluation.h	/^        float setup_pin_criticality(AtomPinId pin) const;$/;"	p	class:SetupSlackCrit	access:public	signature:(AtomPinId pin) const
setup_pin_criticality	timing/timing_info.h	/^        virtual float setup_pin_criticality(AtomPinId pin) const  = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:(AtomPinId pin) const
setup_pin_slack	timing/slack_evaluation.cpp	/^float SetupSlackCrit::setup_pin_slack(AtomPinId pin) const { return pin_slacks_[pin]; }$/;"	f	class:SetupSlackCrit	signature:(AtomPinId pin) const
setup_pin_slack	timing/slack_evaluation.h	/^        float setup_pin_slack(AtomPinId pin) const;$/;"	p	class:SetupSlackCrit	access:public	signature:(AtomPinId pin) const
setup_pin_slack	timing/timing_info.h	/^        virtual float setup_pin_slack(AtomPinId pin) const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:(AtomPinId pin) const
setup_routing_resources	route/route_timing.cpp	/^static t_rt_node* setup_routing_resources(int itry, ClusterNetId net_id, unsigned num_sinks, float pres_fac, int min_incremental_reroute_fanout,$/;"	p	file:	signature:(int itry, ClusterNetId net_id, unsigned num_sinks, float pres_fac, int min_incremental_reroute_fanout, CBRR& incremental_rerouting_res, t_rt_node** rt_node_of_sink)
setup_routing_resources	route/route_timing.cpp	/^static t_rt_node* setup_routing_resources(int itry, ClusterNetId net_id, unsigned num_sinks, float pres_fac,$/;"	f	file:	signature:(int itry, ClusterNetId net_id, unsigned num_sinks, float pres_fac, int min_incremental_reroute_fanout, CBRR& connections_inf, t_rt_node** rt_node_of_sink)
setup_routing_resources_no_net	route/router_delay_profiling.cpp	/^static t_rt_node* setup_routing_resources_no_net(int source_node) {$/;"	f	file:	signature:(int source_node)
setup_routing_resources_no_net	route/router_delay_profiling.cpp	/^static t_rt_node* setup_routing_resources_no_net(int source_node);$/;"	p	file:	signature:(int source_node)
setup_time	timing/PostClusterDelayCalculator.tpp	/^inline tatum::Time PostClusterDelayCalculator::setup_time(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const { $/;"	f	class:PostClusterDelayCalculator	signature:(const tatum::TimingGraph& tg, tatum::EdgeId edge_id) const
setup_timing_	timing/concrete_timing_info.h	/^        ConcreteSetupTimingInfo<DelayCalc> setup_timing_;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
setup_timing_info	draw/draw_types.h	/^    std::shared_ptr<const SetupTimingInfo> setup_timing_info;$/;"	m	struct:t_draw_state	access:public
setup_total_negative_slack	timing/timing_info.h	/^        virtual float setup_total_negative_slack() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
setup_worst_negative_slack	timing/timing_info.h	/^        virtual float setup_worst_negative_slack() const = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:() const
sharinggain	pack/pack_types.h	/^	std::map<AtomBlockId, float> sharinggain; \/* How many nets on an atom cluster_ctx.blocks are already in the pb under consideration *\/$/;"	m	struct:t_pb_stats	access:public
shift_merge_based_on_mask	../../libs/libeasygl/src/graphics.cpp	/^static unsigned long shift_merge_based_on_mask(unsigned long orig_value, unsigned long new_value, unsigned long new_mask) {$/;"	f	file:	signature:(unsigned long orig_value, unsigned long new_value, unsigned long new_mask)
shift_merge_based_on_mask	../../libs/libeasygl/src/graphics.cpp	/^static unsigned long shift_merge_based_on_mask(unsigned long orig_value, unsigned long new_value, unsigned long new_mask);$/;"	p	file:	signature:(unsigned long orig_value, unsigned long new_value, unsigned long new_mask)
shift_op	../../libs/librtlnumber/src/rtl_int.cpp	/^static VNumber shift_op(VNumber& a, int64_t b, bool sign_shift)$/;"	f	file:	signature:(VNumber& a, int64_t b, bool sign_shift)
shift_pressed	../../libs/libeasygl/src/easygl_constants.h	/^    bool shift_pressed; \/* indicates whether a Shift key was pressed when a mouse button is pressed *\/$/;"	m	struct:__anon16	access:public
short_path_criticality	route/route_timing.h	/^    float short_path_criticality; \/\/Hold criticality$/;"	m	struct:t_conn_delay_budget	access:public
should_apply_switch_override	route/rr_graph2.cpp	/^static bool should_apply_switch_override(int switch_override) {$/;"	f	file:	signature:(int switch_override)
should_apply_switch_override	route/rr_graph2.cpp	/^static bool should_apply_switch_override(int switch_override);$/;"	p	file:	signature:(int switch_override)
should_create_switchblock	route/rr_graph2.cpp	/^static int should_create_switchblock(const DeviceGrid& grid, int from_chan_coord, int from_seg_coord, t_rr_type from_chan_type, t_rr_type to_chan_type) {$/;"	f	file:	signature:(const DeviceGrid& grid, int from_chan_coord, int from_seg_coord, t_rr_type from_chan_type, t_rr_type to_chan_type)
should_create_switchblock	route/rr_graph2.cpp	/^static int should_create_switchblock(const DeviceGrid& grid, int from_chan_coord, int from_seg_coord, t_rr_type from_chan_type, t_rr_type to_chan_type);$/;"	p	file:	signature:(const DeviceGrid& grid, int from_chan_coord, int from_seg_coord, t_rr_type from_chan_type, t_rr_type to_chan_type)
should_force_reroute_connection	route/connection_based_routing.h	/^	bool should_force_reroute_connection(int rr_sink_node) const {$/;"	f	class:Connection_based_routing_resources	access:public	signature:(int rr_sink_node) const
should_route_net	route/route_timing.cpp	/^static bool should_route_net(ClusterNetId net_id, const CBRR& connections_inf, bool if_force_reroute) {$/;"	f	file:	signature:(ClusterNetId net_id, const CBRR& connections_inf, bool if_force_reroute)
should_route_net	route/route_timing.cpp	/^static bool should_route_net(ClusterNetId net_id, const CBRR& connections_inf, bool if_force_reroute);$/;"	p	file:	signature:(ClusterNetId net_id, const CBRR& connections_inf, bool if_force_reroute)
show_blk_internal	draw/draw_types.h	/^	int show_blk_internal = 0;$/;"	m	struct:t_draw_state	access:public
show_blk_pin_util	draw/draw_types.h	/^    e_draw_block_pin_util show_blk_pin_util = DRAW_NO_BLOCK_PIN_UTIL;$/;"	m	struct:t_draw_state	access:public
show_circuit_stats	base/read_circuit.cpp	/^static void show_circuit_stats(const AtomNetlist& netlist) {$/;"	f	file:	signature:(const AtomNetlist& netlist)
show_circuit_stats	base/read_circuit.cpp	/^static void show_circuit_stats(const AtomNetlist& netlist);$/;"	p	file:	signature:(const AtomNetlist& netlist)
show_congestion	draw/draw_types.h	/^	e_draw_congestion show_congestion = DRAW_NO_CONGEST;$/;"	m	struct:t_draw_state	access:public
show_crit_path	draw/draw_types.h	/^    e_draw_crit_path show_crit_path = DRAW_NO_CRIT_PATH;$/;"	m	struct:t_draw_state	access:public
show_graphics	base/read_options.h	/^    argparse::ArgValue<bool> show_graphics; \/\/Enable argparse::ArgValue<int>eractive graphics?$/;"	m	struct:t_options	access:public
show_graphics	draw/draw_types.h	/^	bool show_graphics = false;$/;"	m	struct:t_draw_state	access:public
show_help	base/read_options.h	/^    argparse::ArgValue<bool> show_help;$/;"	m	struct:t_options	access:public
show_nets	draw/draw_types.h	/^	e_draw_nets show_nets = DRAW_NO_NETS;$/;"	m	struct:t_draw_state	access:public
show_router_rr_cost	draw/draw_types.h	/^    e_draw_router_rr_cost show_router_rr_cost = DRAW_NO_ROUTER_RR_COST;$/;"	m	struct:t_draw_state	access:public
show_routing_bb	draw/draw_types.h	/^    int show_routing_bb = OPEN;$/;"	m	struct:t_draw_state	access:public
show_routing_costs	draw/draw_types.h	/^	e_draw_routing_costs show_routing_costs;$/;"	m	struct:t_draw_state	access:public
show_routing_util	draw/draw_types.h	/^    e_draw_routing_util show_routing_util = DRAW_NO_ROUTING_UTIL;$/;"	m	struct:t_draw_state	access:public
show_version	base/read_options.h	/^    argparse::ArgValue<bool> show_version;$/;"	m	struct:t_options	access:public
showing_sub_blocks	draw/draw_types.cpp	/^bool t_draw_state::showing_sub_blocks() {$/;"	f	class:t_draw_state	signature:()
showing_sub_blocks	draw/draw_types.h	/^	bool showing_sub_blocks();$/;"	p	struct:t_draw_state	access:public	signature:()
shr	../../libs/libvtrutil/src/picosha2.h	/^inline word_t shr(word_t x, std::size_t n){$/;"	f	namespace:picosha2::detail	signature:(word_t x, std::size_t n)
shrink_to_fit	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void shrink_to_fit() { vec_.shrink_to_fit(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
shrink_to_fit	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void shrink_to_fit() { vec_.shrink_to_fit(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
shrink_to_fit	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void shrink_to_fit() { vec_.shrink_to_fit(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
shrink_to_fit	base/netlist.h	/^        void shrink_to_fit();$/;"	p	class:Netlist	access:protected	signature:()
shrink_to_fit	base/netlist.tpp	/^void Netlist<BlockId, PortId, PinId, NetId>::shrink_to_fit() {$/;"	f	class:Netlist	signature:()
shrink_to_fit	route/rr_node.cpp	/^void t_rr_node::shrink_to_fit() {$/;"	f	class:t_rr_node	signature:()
shrink_to_fit	route/rr_node.h	/^        void shrink_to_fit();$/;"	p	class:t_rr_node	access:public	signature:()
shrink_to_fit_impl	base/atom_netlist.cpp	/^void AtomNetlist::shrink_to_fit_impl() {$/;"	f	class:AtomNetlist	signature:()
shrink_to_fit_impl	base/clustered_netlist.cpp	/^void ClusteredNetlist::shrink_to_fit_impl() {$/;"	f	class:ClusteredNetlist	signature:()
shrink_to_fit_impl	base/netlist.h	/^        virtual void shrink_to_fit_impl() = 0;$/;"	p	class:Netlist	access:protected	signature:()
shuffle	../../libs/libvtrutil/src/vtr_random.h	/^    void shuffle(Iter first, Iter last, RandState& rand_state) {$/;"	f	namespace:vtr	signature:(Iter first, Iter last, RandState& rand_state)
side	route/rr_graph.cpp	/^    e_side side;$/;"	m	struct:t_pin_loc	file:	access:public
side	route/rr_node.cpp	/^e_side t_rr_node::side() const {$/;"	f	class:t_rr_node	signature:() const
side	route/rr_node.h	/^            e_side side; \/\/Valid only for IPINs\/OPINs$/;"	m	union:t_rr_node::__anon8	access:public
side	route/rr_node.h	/^        e_side side() const;$/;"	p	class:t_rr_node	access:public	signature:() const
side_string	route/rr_node.cpp	/^const char* t_rr_node::side_string() const {$/;"	f	class:t_rr_node	signature:() const
side_string	route/rr_node.h	/^        const char *side_string() const;$/;"	p	class:t_rr_node	access:public	signature:() const
sift_down	route/route_common.cpp	/^	void sift_down(size_t hole) {$/;"	f	namespace:heap_	signature:(size_t hole)
sift_down	route/route_common.h	/^	void sift_down(size_t hole);$/;"	p	namespace:heap_	signature:(size_t hole)
sift_up	route/route_common.cpp	/^	void sift_up(size_t leaf, t_heap* const node) {$/;"	f	namespace:heap_	signature:(size_t leaf, t_heap* const node)
sift_up	route/route_common.h	/^	void sift_up(size_t tail, t_heap* const hptr);$/;"	p	namespace:heap_	signature:(size_t tail, t_heap* const hptr)
sign	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    bool sign;$/;"	m	class:VNumber	access:private
simple_linear_regression	route/routing_predictor.cpp	/^LinearModel simple_linear_regression(std::vector<size_t> x_values, std::vector<float> y_values) {$/;"	f	signature:(std::vector<size_t> x_values, std::vector<float> y_values)
simple_linear_regression	route/routing_predictor.cpp	/^LinearModel simple_linear_regression(std::vector<size_t> x_values, std::vector<float> y_values);$/;"	p	file:	signature:(std::vector<size_t> x_values, std::vector<float> y_values)
sink_clb_max_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> sink_clb_max_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
sink_clb_min_delay_cache_	timing/PostClusterDelayCalculator.h	/^    mutable vtr::vector<tatum::EdgeId,tatum::Time> sink_clb_min_delay_cache_;$/;"	m	class:PostClusterDelayCalculator	access:private
sink_criticality_end	route/route_profiling.cpp	/^void sink_criticality_end(float \/*target_criticality*\/) {}$/;"	f	namespace:profiling	signature:(float )
sink_criticality_end	route/route_profiling.h	/^void sink_criticality_end(float target_criticality);$/;"	p	namespace:profiling	signature:(float target_criticality)
sink_criticality_start	route/route_profiling.cpp	/^void sink_criticality_start() {}$/;"	f	namespace:profiling	signature:()
sink_criticality_start	route/route_profiling.h	/^void sink_criticality_start();$/;"	p	namespace:profiling	signature:()
sink_ipin	base/netlist_writer.cpp	/^        int sink_ipin() const { return sink_ipin_; }$/;"	f	class:Arc	access:public	signature:() const
sink_ipin_	base/netlist_writer.cpp	/^        int sink_ipin_;$/;"	m	class:Arc	file:	access:private
sink_list	base/vpr_types.h	/^	char ** sink_list;$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
sink_name	base/netlist_writer.cpp	/^        std::string sink_name() const { return sink_name_; }$/;"	f	class:Arc	access:public	signature:() const
sink_name_	base/netlist_writer.cpp	/^        std::string sink_name_;$/;"	m	class:Arc	file:	access:private
sink_node	route/rr_node.h	/^            int sink_node = -1; \/\/The ID of the sink RR node associated with this edge$/;"	m	struct:t_rr_node::t_rr_edge	access:public
sink_order	route/route_timing.h	/^    int* sink_order; \/* [1..max_pins_per_net-1] *\/$/;"	m	struct:timing_driven_route_structs	access:public
sink_pb_pin_ids	base/vpr_types.h	/^    std::vector<int> sink_pb_pin_ids; \/* The pb_pin id's of the pb_pins driven by this node *\/$/;"	m	struct:ScreenUpdatePriority::t_pb_route	access:public
sinks	draw/intra_logic_block.h	/^	std::unordered_set< gnode_clb_pair, sel_subblk_hasher > sinks;$/;"	m	struct:t_selected_sub_block_info	access:private
size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t position, size;$/;"	m	struct:xpath_context	file:	access:public
size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t size() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t size;$/;"	m	struct:gap	file:	access:public
size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t size;$/;"	m	struct:xml_stream_chunk	file:	access:public
size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t xpath_node_set::size() const$/;"	f	class:pugi::xpath_node_set	signature:() const
size	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		size_t size() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
size	../../libs/libarchfpga/src/logic_types.h	/^	int size = 0; \/* maximum number of pins *\/$/;"	m	struct:t_model_ports	access:public
size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t size()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        static size_t size()$/;"	f	class:BitSpace::BitFields	access:public	signature:()
size	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    size_t size()$/;"	f	class:VNumber	access:public	signature:()
size	../../libs/libvtrutil/src/vtr_bimap.h	/^        std::size_t size() const { VTR_ASSERT(map_.size() == inverse_map_.size()); return map_.size(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
size	../../libs/libvtrutil/src/vtr_flat_map.h	/^        size_type size() const { return vec_.size(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
size	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type size() const { return vec_.size(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
size	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t size() const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:() const
size	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t size() const { return end_index_ - begin_index_; }$/;"	f	class:vtr::DimRange	access:public	signature:() const
size	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t size() const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:() const
size	../../libs/libvtrutil/src/vtr_range.h	/^        size_t size() { return std::distance(begin_, end_); }$/;"	f	class:vtr::Range	access:public	signature:()
size	../../libs/libvtrutil/src/vtr_vector_map.h	/^        std::size_t size() const { return vec_.size(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
size	base/netlist_writer.cpp	/^        size_t size() { return values_.size(); }$/;"	f	class:LogicVec	access:public	signature:()
size	power/power.h	/^	float size;$/;"	m	struct:t_transistor_size_inf	access:public
size	route/route_common.cpp	/^	size_t size() {return static_cast<size_t>(heap_tail - 1);}	\/\/ heap[0] is not valid element$/;"	f	namespace:heap_	signature:()
size	route/route_common.cpp	/^	size_t size();$/;"	p	namespace:heap_	file:	signature:()
size	route/rr_graph.cpp	/^    int size;$/;"	m	struct:t_mux	file:	access:public
size_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t size_ = 0;$/;"	m	class:vtr::NdMatrixBase	access:protected
size_inf	power/power.h	/^	t_transistor_size_inf * size_inf; \/* Array of transistor sizes *\/$/;"	m	struct:t_transistor_inf	access:public
size_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::size_type size_type;$/;"	t	class:vtr::flat_map	access:public
size_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::size_type size_type;$/;"	t	class:vtr::linear_map	access:public
size_type	pack/cluster_router.cpp	/^		typedef typename priority_queue<T>::size_type size_type;$/;"	t	class:reservable_pq	file:	access:public
slack	base/vpr_types.h	/^	float ** slack;$/;"	m	struct:ScreenUpdatePriority::t_slack	access:public
slack_allocated_type	route/route_budgets.h	/^enum slack_allocated_type {$/;"	g
slack_crit_	timing/concrete_timing_info.h	/^        HoldSlackCrit slack_crit_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
slack_crit_	timing/concrete_timing_info.h	/^        SetupSlackCrit slack_crit_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
slack_definition	base/vpr_types.h	/^    std::string slack_definition;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
slack_wallclock_time	base/vpr_context.h	/^        double slack_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
slope_	route/routing_predictor.cpp	/^    float slope_;$/;"	m	class:LinearModel	file:	access:private
slre	timing/slre.cpp	/^struct slre {$/;"	s	file:
slre::anchored	timing/slre.cpp	/^  int anchored;   \/\/ Must match from string start$/;"	m	struct:slre	file:	access:public
slre::code	timing/slre.cpp	/^  unsigned char code[256];$/;"	m	struct:slre	file:	access:public
slre::code_size	timing/slre.cpp	/^  int code_size;$/;"	m	struct:slre	file:	access:public
slre::data	timing/slre.cpp	/^  unsigned char data[256];$/;"	m	struct:slre	file:	access:public
slre::data_size	timing/slre.cpp	/^  int data_size;$/;"	m	struct:slre	file:	access:public
slre::error_string	timing/slre.cpp	/^  const char *error_string;   \/\/ Error string$/;"	m	struct:slre	file:	access:public
slre::num_caps	timing/slre.cpp	/^  int num_caps;   \/\/ Number of bracket pairs$/;"	m	struct:slre	file:	access:public
slre::options	timing/slre.cpp	/^  enum slre_option options;$/;"	m	struct:slre	typeref:enum:slre::slre_option	file:	access:public
slre_capture	timing/slre.h	/^enum slre_capture {SLRE_STRING, SLRE_INT, SLRE_FLOAT};$/;"	g
slre_match	timing/slre.cpp	/^const char *slre_match(enum slre_option options, const char *re,$/;"	f	signature:(enum slre_option options, const char *re, const char *buf, int buf_len, ...)
slre_match	timing/slre.h	/^const char *slre_match(enum slre_option options, const char *regexp,$/;"	p	signature:(enum slre_option options, const char *regexp, const char *buf, int buf_len, ...)
slre_option	timing/slre.h	/^enum slre_option {SLRE_CASE_INSENSITIVE = 1};$/;"	g
solution_inf	base/vpr_context.h	/^    t_solution_inf solution_inf;$/;"	m	struct:PowerContext	access:public
sort	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xpath_node_set::sort(bool reverse)$/;"	f	class:pugi::xpath_node_set	signature:(bool reverse)
sort	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I, typename Pred> void sort(I begin, I end, const Pred& pred)$/;"	f	signature:(I begin, I end, const Pred& pred)
sort	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		void sort(bool reverse = false);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(bool reverse = false)
sort	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void sort() {$/;"	f	class:vtr::flat_map	access:private	signature:()
sort_do	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void sort_do()$/;"	f	class:xpath_node_set_raw	access:public	signature:()
sort_me	power/PowerSpicedComponent.cpp	/^void PowerCallibInputs::sort_me() {$/;"	f	class:PowerCallibInputs	signature:()
sort_me	power/PowerSpicedComponent.cpp	/^void PowerSpicedComponent::sort_me() {$/;"	f	class:PowerSpicedComponent	signature:()
sort_me	power/PowerSpicedComponent.h	/^	void sort_me();$/;"	p	class:PowerCallibInputs	access:public	signature:()
sort_me	power/PowerSpicedComponent.h	/^	void sort_me();$/;"	p	class:PowerSpicedComponent	access:public	signature:()
sorted	power/PowerSpicedComponent.h	/^	bool sorted;$/;"	m	class:PowerCallibInputs	access:public
sorted	power/PowerSpicedComponent.h	/^	bool sorted;$/;"	m	class:PowerSpicedComponent	access:public
sorter_PowerCallibInputs	power/PowerSpicedComponent.cpp	/^bool sorter_PowerCallibInputs(PowerCallibInputs * a, PowerCallibInputs * b) {$/;"	f	signature:(PowerCallibInputs * a, PowerCallibInputs * b)
sorter_PowerCallibInputs	power/PowerSpicedComponent.cpp	/^bool sorter_PowerCallibInputs(PowerCallibInputs * a, PowerCallibInputs * b);$/;"	p	file:	signature:(PowerCallibInputs * a, PowerCallibInputs * b)
sorter_PowerCallibSize	power/PowerSpicedComponent.cpp	/^bool sorter_PowerCallibSize(PowerCallibSize * a, PowerCallibSize * b) {$/;"	f	signature:(PowerCallibSize * a, PowerCallibSize * b)
source_ipin	base/netlist_writer.cpp	/^        int source_ipin() const { return source_ipin_; }$/;"	f	class:Arc	access:public	signature:() const
source_ipin_	base/netlist_writer.cpp	/^        int source_ipin_;$/;"	m	class:Arc	file:	access:private
source_list	base/vpr_types.h	/^	char ** source_list; \/* Array of net names of flip-flops or clocks *\/$/;"	m	struct:ScreenUpdatePriority::t_override_constraint	access:public
source_name	base/netlist_writer.cpp	/^        std::string source_name() const { return source_name_; }$/;"	f	class:Arc	access:public	signature:() const
source_name_	base/netlist_writer.cpp	/^        std::string source_name_;$/;"	m	class:Arc	file:	access:private
sources	draw/intra_logic_block.h	/^	std::unordered_set< gnode_clb_pair, sel_subblk_hasher > sources;$/;"	m	struct:t_selected_sub_block_info	access:private
specified	../../libs/libarchfpga/src/physical_types.h	/^    bool specified = false; 		\/\/Whether or not a default specification exists$/;"	m	struct:t_default_fc_spec	access:public
split	../../libs/libvtrutil/src/vtr_util.cpp	/^std::vector<std::string> split(const char* text, const std::string delims) {$/;"	f	namespace:vtr	signature:(const char* text, const std::string delims)
split	../../libs/libvtrutil/src/vtr_util.cpp	/^std::vector<std::string> split(const std::string& text, const std::string delims) {$/;"	f	namespace:vtr	signature:(const std::string& text, const std::string delims)
split	../../libs/libvtrutil/src/vtr_util.h	/^    std::vector<std::string> split(const char* text, const std::string delims=" \\t\\n");$/;"	p	namespace:vtr	signature:(const char* text, const std::string delims=Ó)
split	../../libs/libvtrutil/src/vtr_util.h	/^    std::vector<std::string> split(const std::string& text, const std::string delims=" \\t\\n");$/;"	p	namespace:vtr	signature:(const std::string& text, const std::string delims=Ó)
split_ext	../../libs/libvtrutil/src/vtr_path.cpp	/^std::array<std::string,2> split_ext(const std::string& filename) {$/;"	f	namespace:vtr	signature:(const std::string& filename)
split_ext	../../libs/libvtrutil/src/vtr_path.h	/^    std::array<std::string,2> split_ext(const std::string& filename);$/;"	p	namespace:vtr	signature:(const std::string& filename)
split_index	base/read_blif.cpp	/^        std::pair<std::string, int> split_index(const std::string& signal_name) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(const std::string& signal_name)
srandom	../../libs/libvtrutil/src/vtr_random.cpp	/^void srandom(int seed) {$/;"	f	namespace:vtr	signature:(int seed)
srandom	../../libs/libvtrutil/src/vtr_random.h	/^    void srandom(int seed);$/;"	p	namespace:vtr	signature:(int seed)
ssig0	../../libs/libvtrutil/src/picosha2.h	/^inline word_t ssig0(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
ssig1	../../libs/libvtrutil/src/picosha2.h	/^inline word_t ssig1(word_t x){$/;"	f	namespace:picosha2::detail	signature:(word_t x)
sta_wallclock_time	base/vpr_context.h	/^        double sta_wallclock_time = 0.;$/;"	m	struct:TimingContext::timing_analysis_profile_info	access:public
stack	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_stack stack;$/;"	m	struct:xpath_stack_data	file:	access:public
stage_gain	power/power.h	/^	float stage_gain;$/;"	m	struct:t_power_buffer_strength_inf	access:public
stampout_switchblocks_from_row	route/build_switchblocks.cpp	/^static void stampout_switchblocks_from_row( int sb_row_size,$/;"	f	file:	signature:( int sb_row_size, int nodes_per_chan, const DeviceGrid& grid, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_row, t_sb_connection_map *sb_conns )
stampout_switchblocks_from_row	route/build_switchblocks.cpp	/^static void stampout_switchblocks_from_row( int sb_row_size,$/;"	p	file:	signature:( int sb_row_size, int nodes_per_chan, const DeviceGrid& grid, t_wire_type_sizes *wire_type_sizes, e_directionality directionality, t_sb_connection_map *sb_row, t_sb_connection_map *sb_conns )
start	base/netlist_walker.h	/^        void start() { start_impl(); }$/;"	f	class:NetlistVisitor	access:public	signature:()
start	base/vpr_types.h	/^	int start = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
start	base/vpr_types.h	/^        int start() const { return seg_detail_->start; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
start	route/build_switchblocks.cpp	/^	int start;		\/* the wire index at which this type starts in the channel segment (0..W-1) *\/$/;"	m	class:Wire_Info	file:	access:public
start_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T* start_;$/;"	m	class:vtr::NdMatrixProxy	access:private
start_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        T* start_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
start_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string start_expr;  \/\/Starting position (inclusive)$/;"	m	struct:t_grid_loc_spec	access:public
start_hash_table_iterator	util/hash.cpp	/^t_hash_iterator start_hash_table_iterator() {$/;"	f	signature:()
start_hash_table_iterator	util/hash.h	/^t_hash_iterator start_hash_table_iterator();$/;"	p	signature:()
start_impl	base/netlist_walker.cpp	/^void NetlistVisitor::start_impl() {$/;"	f	class:NetlistVisitor	signature:()
start_impl	base/netlist_walker.h	/^        virtual void start_impl();$/;"	p	class:NetlistVisitor	access:protected	signature:()
start_new_cluster	pack/cluster.cpp	/^static void start_new_cluster($/;"	f	file:	signature:( t_cluster_placement_stats *cluster_placement_stats, t_pb_graph_node **primitives_list, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, ClusterBlockId clb_index, const t_pack_molecule *molecule, std::map<t_type_ptr, size_t>& num_used_type_instances, const float target_device_utilization, const int num_models, const int max_cluster_size, const t_arch* arch, std::string device_layout_name, vector<t_lb_type_rr_node> *lb_type_rr_graphs, t_lb_router_data **router_data, const int detailed_routing_stage, ClusteredNetlist *clb_nlist, const std::map<const t_model*,std::vector<t_type_ptr>>& primitive_candidate_block_types, int verbosity, bool enable_pin_feasibility_filter)
start_new_cluster	pack/cluster.cpp	/^static void start_new_cluster($/;"	p	file:	signature:( t_cluster_placement_stats *cluster_placement_stats, t_pb_graph_node **primitives_list, const std::multimap<AtomBlockId, t_pack_molecule*>& atom_molecules, ClusterBlockId clb_index, const t_pack_molecule *molecule, std::map<t_type_ptr, size_t>& num_used_type_instances, const float target_device_utilization, const int num_models, const int max_cluster_size, const t_arch* arch, std::string device_layout_name, vector<t_lb_type_rr_node> *lb_type_rr_graphs, t_lb_router_data **router_data, const int detailed_routing_stage, ClusteredNetlist *clb_nlist, const std::map<const t_model*,std::vector<t_type_ptr>>& primitive_candidate_block_types, int verbosity, bool enable_pin_feasibility_filter)
starting_pin_idx	power/power.h	/^	int starting_pin_idx; \/* Applicable to level 0 only, the overall mux primary input index *\/$/;"	m	struct:t_mux_node	access:public
starting_t	place/place.cpp	/^static float starting_t(t_placer_costs* costs,$/;"	f	file:	signature:(t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, t_annealing_sched annealing_sched, int max_moves, float rlim, const PlaceDelayModel& delay_model, enum e_place_algorithm place_algorithm, float timing_tradeoff)
starting_t	place/place.cpp	/^static float starting_t(t_placer_costs* costs,$/;"	p	file:	signature:(t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, t_annealing_sched annealing_sched, int max_moves, float rlim, const PlaceDelayModel& delay_model, enum e_place_algorithm place_algorithm, float timing_tradeoff)
starts_with	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool starts_with(const char_t* string, const char_t* pattern)$/;"	f	signature:(const char_t* string, const char_t* pattern)
starts_with	../../libs/libvtrutil/src/vtr_util.cpp	/^bool starts_with(std::string str, std::string prefix) {$/;"	f	namespace:vtr	signature:(std::string str, std::string prefix)
starts_with	../../libs/libvtrutil/src/vtr_util.h	/^    bool starts_with(std::string str, std::string prefix);$/;"	p	namespace:vtr	signature:(std::string str, std::string prefix)
state	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* state() const$/;"	f	class:xpath_lexer	access:public	signature:() const
static_assert	../../libs/libvtrutil/src/vtr_strong_id.h	/^    static_assert(std::is_integral<T>::value, "T must be integral");$/;"	p	class:vtr::StrongId	access:private	signature:(std::is_integral<T>::value, Ó)
stats	base/vpr_context.h	/^    timing_analysis_profile_info stats;$/;"	m	struct:TimingContext	access:public
status	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_status status;$/;"	m	struct:pugi::xml_parse_result	access:public
statusMessage	../../libs/libeasygl/src/graphics_state.h	/^    char statusMessage[BUFSIZE] = "";$/;"	m	struct:t_gl_state	access:public
status_append_invalid_root	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_append_invalid_root,	\/\/ Unable to append nodes since root type is not node_element or node_document (exclusive to xml_node::append_buffer)$/;"	e	enum:pugi::xml_parse_status
status_bad_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_attribute,		\/\/ Parsing error occurred while parsing element attribute$/;"	e	enum:pugi::xml_parse_status
status_bad_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_cdata,			\/\/ Parsing error occurred while parsing CDATA section$/;"	e	enum:pugi::xml_parse_status
status_bad_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_comment,			\/\/ Parsing error occurred while parsing comment$/;"	e	enum:pugi::xml_parse_status
status_bad_doctype	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_doctype,			\/\/ Parsing error occurred while parsing document type declaration$/;"	e	enum:pugi::xml_parse_status
status_bad_end_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_end_element,		\/\/ Parsing error occurred while parsing end element tag$/;"	e	enum:pugi::xml_parse_status
status_bad_pcdata	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_pcdata,			\/\/ Parsing error occurred while parsing PCDATA section$/;"	e	enum:pugi::xml_parse_status
status_bad_pi	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_pi,				\/\/ Parsing error occurred while parsing document declaration\/processing instruction$/;"	e	enum:pugi::xml_parse_status
status_bad_start_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_bad_start_element,	\/\/ Parsing error occurred while parsing start element tag$/;"	e	enum:pugi::xml_parse_status
status_end_element_mismatch	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_end_element_mismatch,\/\/ There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)$/;"	e	enum:pugi::xml_parse_status
status_file_not_found	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_file_not_found,		\/\/ File was not found during load_file()$/;"	e	enum:pugi::xml_parse_status
status_internal_error	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_internal_error,		\/\/ Internal error occurred$/;"	e	enum:pugi::xml_parse_status
status_io_error	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_io_error,			\/\/ Error reading from file\/stream$/;"	e	enum:pugi::xml_parse_status
status_no_document_element	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_no_document_element	\/\/ Parsing resulted in a document without element nodes$/;"	e	enum:pugi::xml_parse_status
status_ok	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_ok = 0,				\/\/ No error$/;"	e	enum:pugi::xml_parse_status
status_out_of_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_out_of_memory,		\/\/ Could not allocate memory$/;"	e	enum:pugi::xml_parse_status
status_unrecognized_tag	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		status_unrecognized_tag,	\/\/ Parser could not determine tag type$/;"	e	enum:pugi::xml_parse_status
std	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^namespace std$/;"	n	file:
std	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^namespace std$/;"	n
std	../../libs/libvtrutil/src/vtr_strong_id.h	/^namespace std {$/;"	n
std::_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_attribute_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_attribute_iterator&)
std::_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_named_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_named_node_iterator&)
std::_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_node_iterator&)
std::_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_attribute_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_attribute_iterator&)
std::_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_named_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_named_node_iterator&)
std::_Iter_cat	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_node_iterator&)
std::__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_attribute_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_attribute_iterator&)
std::__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_named_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_named_node_iterator&)
std::__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_node_iterator&)$/;"	f	namespace:std	signature:(const pugi::xml_node_iterator&)
std::__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_attribute_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_attribute_iterator&)
std::__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_named_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_named_node_iterator&)
std::__iterator_category	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_node_iterator&);$/;"	p	namespace:std	signature:(const pugi::xml_node_iterator&)
std::hash	../../libs/libvtrutil/src/vtr_strong_id.h	/^    struct hash<vtr::StrongId<tag,T,sentinel>> {$/;"	s	namespace:std
std::hash::operator ()	../../libs/libvtrutil/src/vtr_strong_id.h	/^        std::size_t operator()(const vtr::StrongId<tag,T,sentinel> k) const {$/;"	f	struct:std::hash	access:public	signature:(const vtr::StrongId<tag,T,sentinel> k) const
step_do	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> xpath_node_set_raw step_do(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval, T v)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval, T v)
step_fill	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> void step_fill(xpath_node_set_raw& ns, const xpath_node& xn, xpath_allocator* alloc, bool once, T v)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, const xpath_node& xn, xpath_allocator* alloc, bool once, T v)
step_fill	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> void step_fill(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* p, xpath_allocator* alloc, bool once, T v)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* p, xpath_allocator* alloc, bool once, T v)
step_fill	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> void step_fill(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc, bool once, T)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc, bool once, T)
step_push	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool step_push(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* parent, xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* parent, xpath_allocator* alloc)
step_push	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool step_push(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc)
store_char_in_data	timing/slre.cpp	/^static void store_char_in_data(struct slre *r, int ch) {$/;"	f	file:	signature:(struct slre *r, int ch)
stow_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float stow_xmult, stow_ymult;$/;"	m	struct:__anon20	file:	access:public
stow_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float stow_xmult, stow_ymult;$/;"	m	struct:__anon20	file:	access:public
strconv_attribute_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename opt_escape> struct strconv_attribute_impl$/;"	s	file:
strconv_attribute_impl::parse_eol	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_eol(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
strconv_attribute_impl::parse_simple	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_simple(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
strconv_attribute_impl::parse_wconv	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_wconv(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
strconv_attribute_impl::parse_wnorm	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_wnorm(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl	access:public	signature:(char_t* s, char_t end_quote)
strconv_attribute_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	typedef char_t* (*strconv_attribute_t)(char_t*, char_t);$/;"	t	file:
strconv_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* strconv_cdata(char_t* s, char_t endch)$/;"	f	signature:(char_t* s, char_t endch)
strconv_comment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* strconv_comment(char_t* s, char_t endch)$/;"	f	signature:(char_t* s, char_t endch)
strconv_escape	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* strconv_escape(char_t* s, gap& g)$/;"	f	signature:(char_t* s, gap& g)
strconv_pcdata_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename opt_trim, typename opt_eol, typename opt_escape> struct strconv_pcdata_impl$/;"	s	file:
strconv_pcdata_impl::parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse(char_t* s)$/;"	f	struct:strconv_pcdata_impl	access:public	signature:(char_t* s)
strconv_pcdata_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	typedef char_t* (*strconv_pcdata_t)(char_t*);$/;"	t	file:
strcpy_insitu	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool strcpy_insitu(String& dest, Header& header, uintptr_t header_mask, const char_t* source, size_t source_length)$/;"	f	signature:(String& dest, Header& header, uintptr_t header_mask, const char_t* source, size_t source_length)
strcpy_insitu_allow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	inline bool strcpy_insitu_allow(size_t length, const Header& header, uintptr_t header_mask, char_t* target)$/;"	f	signature:(size_t length, const Header& header, uintptr_t header_mask, char_t* target)
strdup	../../libs/libvtrutil/src/vtr_util.cpp	/^char* strdup(const char *str) {$/;"	f	namespace:vtr	signature:(const char *str)
strdup	../../libs/libvtrutil/src/vtr_util.h	/^    char* strdup(const char *str);$/;"	p	namespace:vtr	signature:(const char *str)
strength_inf	power/power.h	/^	t_power_buffer_strength_inf * strength_inf;$/;"	m	struct:t_power_buffer_size_inf	access:public
strequal	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool strequal(const char_t* src, const char_t* dst)$/;"	f	signature:(const char_t* src, const char_t* dst)
strequalrange	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool strequalrange(const char_t* lhs, const char_t* rhs, size_t count)$/;"	f	signature:(const char_t* lhs, const char_t* rhs, size_t count)
strictly_contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool strictly_contains(Point<T> point) const;$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> point) const
strictly_contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool strictly_contains(Point<T> point) const;$/;"	p	class:vtr::RectUnion	access:public	signature:(Point<T> point) const
strictly_contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool Rect<T>::strictly_contains(Point<T> point) const {$/;"	f	class:vtr::Rect	signature:(Point<T> point) const
strictly_contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool RectUnion<T>::strictly_contains(Point<T> point) const {$/;"	f	class:vtr::RectUnion	signature:(Point<T> point) const
string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const char_t* string;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
string_fmt	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string string_fmt(const char* fmt, ...) {$/;"	f	namespace:vtr	signature:(const char* fmt, ...)
string_fmt	../../libs/libvtrutil/src/vtr_util.h	/^    std::string string_fmt(const char* fmt, ...);$/;"	p	namespace:vtr	signature:(const char* fmt, ...)
string_ids_	base/netlist.h	/^        vtr::vector_map<StringId,StringId>      string_ids_;    \/\/Valid string ids$/;"	m	class:Netlist	access:private
string_of_radix_to_bitstring	../../libs/librtlnumber/src/include/rtl_utils.hpp	/^std::string string_of_radix_to_bitstring(std::string orig_string, short radix);$/;"	p	signature:(std::string orig_string, short radix)
string_of_radix_to_bitstring	../../libs/librtlnumber/src/rtl_utils.cpp	/^std::string string_of_radix_to_bitstring(std::string orig_string, short radix)$/;"	f	signature:(std::string orig_string, short radix)
string_t	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	typedef std::basic_string<PUGIXML_CHAR, std::char_traits<PUGIXML_CHAR>, std::allocator<PUGIXML_CHAR> > string_t;$/;"	t	namespace:pugi
string_to_fc_value_type	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static e_fc_value_type string_to_fc_value_type(const std::string& str, pugi::xml_node node, const pugiutil::loc_data& loc_data) {$/;"	f	file:	signature:(const std::string& str, pugi::xml_node node, const pugiutil::loc_data& loc_data)
string_to_fc_value_type	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^static e_fc_value_type string_to_fc_value_type(const std::string& str, pugi::xml_node node, const pugiutil::loc_data& loc_data);$/;"	p	file:	signature:(const std::string& str, pugi::xml_node node, const pugiutil::loc_data& loc_data)
string_to_integer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename U> U string_to_integer(const char_t* value, U minneg, U maxpos)$/;"	f	signature:(const char_t* value, U minneg, U maxpos)
string_to_side	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^e_side string_to_side(std::string side_str) {$/;"	f	signature:(std::string side_str)
string_to_side	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^e_side string_to_side(std::string side_str);$/;"	p	file:	signature:(std::string side_str)
string_to_string_id_	base/netlist.h	/^        std::unordered_map<std::string, StringId>       string_to_string_id_;$/;"	m	class:Netlist	access:private
string_value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_string string_value(const xpath_node& na, xpath_allocator* alloc)$/;"	f	signature:(const xpath_node& na, xpath_allocator* alloc)
strings_	base/netlist.h	/^        vtr::vector_map<StringId,std::string>   strings_;       \/\/Strings$/;"	m	class:Netlist	access:private
strlength	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t strlength(const char_t* s)$/;"	f	signature:(const char_t* s)
strlength_wide	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t strlength_wide(const wchar_t* s)$/;"	f	signature:(const wchar_t* s)
strncpy	../../libs/libvtrutil/src/vtr_util.cpp	/^char* strncpy(char *dest, const char *src, size_t size) {$/;"	f	namespace:vtr	signature:(char *dest, const char *src, size_t size)
strncpy	../../libs/libvtrutil/src/vtr_util.h	/^    char* strncpy(char *dest, const char *src, size_t size);$/;"	p	namespace:vtr	signature:(char *dest, const char *src, size_t size)
strongconnect	timing/path_delay2.cpp	/^void strongconnect(int& index, int* tnode_indexes, int* tnode_lowlinks, bool* tnode_instack,$/;"	f	signature:(int& index, int* tnode_indexes, int* tnode_lowlinks, bool* tnode_instack, std::stack<int>& tnode_stack, std::vector<std::vector<int> >& tnode_sccs, size_t min_size, int inode)
strongconnect	timing/path_delay2.cpp	/^void strongconnect(int& index, int* tnode_indexes, int* tnode_lowlinks, bool* tnode_instack,$/;"	p	file:	signature:(int& index, int* tnode_indexes, int* tnode_lowlinks, bool* tnode_instack, std::stack<int>& tnode_stack, std::vector<std::vector<int> >& tnode_sccs, size_t min_size, int inode)
strtok	../../libs/libvtrutil/src/vtr_util.cpp	/^char* strtok(char *ptr, const char *tokens, FILE * fp, char *buf) {$/;"	f	namespace:vtr	signature:(char *ptr, const char *tokens, FILE * fp, char *buf)
strtok	../../libs/libvtrutil/src/vtr_util.h	/^    char* strtok(char *ptr, const char *tokens, FILE * fp, char *buf);$/;"	p	namespace:vtr	signature:(char *ptr, const char *tokens, FILE * fp, char *buf)
subblk_array	draw/draw_types.h	/^    std::vector<t_bound_box> subblk_array;$/;"	m	struct:t_draw_pb_type_info	access:public
success	base/vpr_types.h	/^        bool success() const { return success_; }$/;"	f	class:ScreenUpdatePriority::RouteStatus	access:public	signature:() const
success_	base/vpr_types.h	/^        bool success_ = false;$/;"	m	class:ScreenUpdatePriority::RouteStatus	access:private
success_sum	place/place.cpp	/^	int success_sum;$/;"	m	struct:t_placer_statistics	file:	access:public
sum_of_squares	place/place.cpp	/^	       sum_of_squares, av_delay_cost;$/;"	m	struct:t_placer_statistics	file:	access:public
sum_op	../../libs/librtlnumber/src/rtl_int.cpp	/^static VNumber sum_op(VNumber& a, VNumber& b, const bit_value_t& initial_carry)$/;"	f	file:	signature:(VNumber& a, VNumber& b, const bit_value_t& initial_carry)
sum_pin_class	pack/cluster_feasibility_filter.cpp	/^static void sum_pin_class(t_pb_graph_node *pb_graph_node) {$/;"	f	file:	signature:(t_pb_graph_node *pb_graph_node)
sum_pin_class	pack/cluster_feasibility_filter.cpp	/^static void sum_pin_class(t_pb_graph_node *pb_graph_node);$/;"	p	file:	signature:(t_pb_graph_node *pb_graph_node)
surface	../../libs/libeasygl/src/SurfaceImpl.h	/^        SurfaceImpl(const SurfaceImpl& surface) = default; \/\/ cctor$/;"	m	class:SurfaceImpl	access:public
swap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> void swap(T& lhs, T& rhs)$/;"	f	signature:(T& lhs, T& rhs)
swap	../../libs/libeasygl/src/Surface.cpp	/^void swap(Surface& lhs, Surface& rhs) {$/;"	f	signature:(Surface& lhs, Surface& rhs)
swap	../../libs/libeasygl/src/Surface.h	/^        friend void swap(Surface& lhs, Surface& rhs);$/;"	p	class:Surface	access:friend	signature:(Surface& lhs, Surface& rhs)
swap	../../libs/libvtrutil/src/vtr_bimap.h	/^        friend void swap(bimap<K,V,Map,InvMap>& x, bimap<K,V,Map,InvMap>& y) {$/;"	f	class:vtr::bimap	access:friend	signature:(bimap<K,V,Map,InvMap>& x, bimap<K,V,Map,InvMap>& y)
swap	../../libs/libvtrutil/src/vtr_flat_map.h	/^        friend void swap(flat_map& lhs, flat_map& rhs) { std::swap(lhs.vec_, rhs.vec_); }$/;"	f	class:vtr::flat_map	access:friend	signature:(flat_map& lhs, flat_map& rhs)
swap	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void swap(flat_map& other) { std::swap(*this, other); }$/;"	f	class:vtr::flat_map	access:public	signature:(flat_map& other)
swap	../../libs/libvtrutil/src/vtr_linear_map.h	/^        friend void swap(linear_map& lhs, linear_map& rhs) {$/;"	f	class:vtr::linear_map	access:friend	signature:(linear_map& lhs, linear_map& rhs)
swap	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void swap(linear_map& other) { std::swap(vec_, other.vec_); }$/;"	f	class:vtr::linear_map	access:public	signature:(linear_map& other)
swap	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        friend void swap(NdMatrixBase<T,N>& m1, NdMatrixBase<T,N>& m2) {$/;"	f	class:vtr::NdMatrixBase	access:friend	signature:(NdMatrixBase<T,N>& m1, NdMatrixBase<T,N>& m2)
swap	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        friend void swap(NdOffsetMatrixBase<T,N>& m1, NdOffsetMatrixBase<T,N>& m2) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:friend	signature:(NdOffsetMatrixBase<T,N>& m1, NdOffsetMatrixBase<T,N>& m2)
swap	../../libs/libvtrutil/src/vtr_vector_map.h	/^        friend void swap(vector_map<K,V>& x, vector_map<K,V>& y) {$/;"	f	class:vtr::vector_map	access:friend	signature:(vector_map<K,V>& x, vector_map<K,V>& y)
swap	route/route_traceback.cpp	/^void swap(t_traceback& first, t_traceback& second) {$/;"	f	signature:(t_traceback& first, t_traceback& second)
swap	route/route_traceback.h	/^    friend void swap(t_traceback& first, t_traceback& second);$/;"	p	struct:t_traceback	access:friend	signature:(t_traceback& first, t_traceback& second)
swap	util/vpr_utils.cpp	/^void swap(IntraLbPbPinLookup& lhs, IntraLbPbPinLookup& rhs) {$/;"	f	signature:(IntraLbPbPinLookup& lhs, IntraLbPbPinLookup& rhs)
swap	util/vpr_utils.h	/^        friend void swap(IntraLbPbPinLookup& lhs, IntraLbPbPinLookup& rhs);$/;"	p	class:IntraLbPbPinLookup	access:friend	signature:(IntraLbPbPinLookup& lhs, IntraLbPbPinLookup& rhs)
swapped_from_is_empty	base/vpr_types.h	/^	int swapped_from_is_empty;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
swapped_to_was_empty	base/vpr_types.h	/^	int swapped_to_was_empty;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
sweep_blocks	base/atom_netlist_utils.cpp	/^size_t sweep_blocks(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
sweep_blocks	base/atom_netlist_utils.h	/^size_t sweep_blocks(AtomNetlist& netlist, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, int verbosity)
sweep_constant_primary_outputs	base/atom_netlist_utils.cpp	/^size_t sweep_constant_primary_outputs(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
sweep_constant_primary_outputs	base/atom_netlist_utils.h	/^size_t sweep_constant_primary_outputs(AtomNetlist& netlist, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, int verbosity)
sweep_constant_primary_outputs	base/read_options.h	/^    argparse::ArgValue<bool> sweep_constant_primary_outputs;$/;"	m	struct:t_options	access:public
sweep_constant_primary_outputs	base/vpr_types.h	/^    bool sweep_constant_primary_outputs = false;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
sweep_dangling_blocks	base/read_options.h	/^    argparse::ArgValue<bool> sweep_dangling_blocks;$/;"	m	struct:t_options	access:public
sweep_dangling_blocks	base/vpr_types.h	/^    bool sweep_dangling_blocks = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
sweep_dangling_nets	base/read_options.h	/^    argparse::ArgValue<bool> sweep_dangling_nets;$/;"	m	struct:t_options	access:public
sweep_dangling_nets	base/vpr_types.h	/^    bool sweep_dangling_nets = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
sweep_dangling_primary_ios	base/read_options.h	/^    argparse::ArgValue<bool> sweep_dangling_primary_ios;$/;"	m	struct:t_options	access:public
sweep_dangling_primary_ios	base/vpr_types.h	/^    bool sweep_dangling_primary_ios = true;$/;"	m	struct:ScreenUpdatePriority::t_netlist_opts	access:public
sweep_inputs	base/atom_netlist_utils.cpp	/^size_t sweep_inputs(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
sweep_inputs	base/atom_netlist_utils.h	/^size_t sweep_inputs(AtomNetlist& netlist, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, int verbosity)
sweep_iterative	base/atom_netlist_utils.cpp	/^size_t sweep_iterative(AtomNetlist& netlist,$/;"	f	signature:(AtomNetlist& netlist, bool should_sweep_ios, bool should_sweep_nets, bool should_sweep_blocks, bool should_sweep_constant_primary_outputs, int verbosity)
sweep_iterative	base/atom_netlist_utils.h	/^size_t sweep_iterative(AtomNetlist& netlist,$/;"	p	signature:(AtomNetlist& netlist, bool should_sweep_dangling_ios, bool should_sweep_dangling_blocks, bool should_sweep_dangling_nets, bool should_sweep_constant_primary_outputs, int verbosity)
sweep_nets	base/atom_netlist_utils.cpp	/^size_t sweep_nets(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
sweep_nets	base/atom_netlist_utils.h	/^size_t sweep_nets(AtomNetlist& netlist, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, int verbosity)
sweep_outputs	base/atom_netlist_utils.cpp	/^size_t sweep_outputs(AtomNetlist& netlist, int verbosity) {$/;"	f	signature:(AtomNetlist& netlist, int verbosity)
sweep_outputs	base/atom_netlist_utils.h	/^size_t sweep_outputs(AtomNetlist& netlist, int verbosity);$/;"	p	signature:(AtomNetlist& netlist, int verbosity)
switch_block_type	base/vpr_types.h	/^	enum e_switch_block_type switch_block_type;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	typeref:enum:ScreenUpdatePriority::t_det_routing_arch::e_switch_block_type	access:public
switch_fanin_remap	base/vpr_context.h	/^    std::vector<std::map<int, int>> switch_fanin_remap;$/;"	m	struct:DeviceContext	access:public
switch_id	route/rr_node.h	/^            short switch_id = -1; \/\/The ID of the switch type this edge represents$/;"	m	struct:t_rr_node::t_rr_edge	access:public
switch_ind	route/build_switchblocks.h	/^	short switch_ind;$/;"	m	struct:t_switchblock_edge	access:public
switch_index	route/rr_graph.cpp	/^    int switch_index; \/\/The switch type used by this direct connection$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
switch_type	../../libs/libarchfpga/src/physical_types.h	/^	int switch_type;$/;"	m	struct:t_direct_inf	access:public
switch_type	route/rr_graph2.h	/^    short switch_type = OPEN;$/;"	m	struct:t_rr_edge_info	access:public
switch_type_directionaity	../../libs/libarchfpga/src/physical_types.cpp	/^static e_directionality switch_type_directionaity(SwitchType type) {$/;"	f	file:	signature:(SwitchType type)
switch_type_directionaity	../../libs/libarchfpga/src/physical_types.cpp	/^static e_directionality switch_type_directionaity(SwitchType type);$/;"	p	file:	signature:(SwitchType type)
switch_type_is_buffered	../../libs/libarchfpga/src/physical_types.cpp	/^static bool switch_type_is_buffered(SwitchType type) {$/;"	f	file:	signature:(SwitchType type)
switch_type_is_buffered	../../libs/libarchfpga/src/physical_types.cpp	/^static bool switch_type_is_buffered(SwitchType type);$/;"	p	file:	signature:(SwitchType type)
switch_type_is_configurable	../../libs/libarchfpga/src/physical_types.cpp	/^static bool switch_type_is_configurable(SwitchType type) {$/;"	f	file:	signature:(SwitchType type)
switch_type_is_configurable	../../libs/libarchfpga/src/physical_types.cpp	/^static bool switch_type_is_configurable(SwitchType type);$/;"	p	file:	signature:(SwitchType type)
switch_usage_analysis	base/vpr_types.h	/^    bool switch_usage_analysis;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
switchblock_locations	../../libs/libarchfpga/src/physical_types.h	/^    vtr::Matrix<e_sb_type> switchblock_locations;$/;"	m	struct:t_type_descriptor	access:public
switchblock_switch_overrides	../../libs/libarchfpga/src/physical_types.h	/^    vtr::Matrix<int> switchblock_switch_overrides;$/;"	m	struct:t_type_descriptor	access:public
switchblocks	../../libs/libarchfpga/src/physical_types.h	/^	std::vector<t_switchblock_inf> switchblocks;$/;"	m	struct:t_arch	access:public
switchblocks	base/vpr_types.h	/^	std::vector<t_switchblock_inf> switchblocks;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
switchpoint	route/build_switchblocks.cpp	/^    int switchpoint;    \/\/Switchpoint of the wire$/;"	m	struct:t_wire_switchpoint	file:	access:public
switchpoints	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> switchpoints; \/\/The indices of wire points along the segment$/;"	m	struct:t_wire_switchpoints	access:public
sync_grid_to_blocks	util/vpr_utils.cpp	/^void sync_grid_to_blocks() {$/;"	f	signature:()
sync_grid_to_blocks	util/vpr_utils.h	/^void sync_grid_to_blocks();$/;"	p	signature:()
szAppName	../../libs/libeasygl/src/graphics.cpp	/^static wchar_t szAppName[256], szGraphicsName[] = L"VPR Graphics",$/;"	v	file:
szButtonsName	../../libs/libeasygl/src/graphics.cpp	/^    szStatusName[] = L"VPR Status", szButtonsName[] = L"VPR Buttons";$/;"	v	file:
szGraphicsName	../../libs/libeasygl/src/graphics.cpp	/^static wchar_t szAppName[256], szGraphicsName[] = L"VPR Graphics",$/;"	v	file:
szStatusName	../../libs/libeasygl/src/graphics.cpp	/^    szStatusName[] = L"VPR Status", szButtonsName[] = L"VPR Buttons";$/;"	v	file:
t_2d_int_vec	route/cb_metrics.h	/^typedef std::vector< std::vector<int> > t_2d_int_vec;$/;"	t
t_3d_int_vec	route/cb_metrics.h	/^typedef std::vector< std::vector< std::vector<int> > > t_3d_int_vec;$/;"	t
t_TokenPair	base/vpr_types.h	/^struct t_TokenPair {$/;"	s	class:ScreenUpdatePriority	access:private
t_analysis_opts	base/vpr_types.h	/^struct t_analysis_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_annealing_sched	base/vpr_types.h	/^struct t_annealing_sched {$/;"	s	class:ScreenUpdatePriority	access:private
t_arch	../../libs/libarchfpga/src/physical_types.h	/^struct t_arch {$/;"	s
t_arch::Chans	../../libs/libarchfpga/src/physical_types.h	/^	t_chan_width_dist Chans;$/;"	m	struct:t_arch	access:public
t_arch::Directs	../../libs/libarchfpga/src/physical_types.h	/^	t_direct_inf *Directs;$/;"	m	struct:t_arch	access:public
t_arch::Fs	../../libs/libarchfpga/src/physical_types.h	/^	int Fs;$/;"	m	struct:t_arch	access:public
t_arch::R_minW_nmos	../../libs/libarchfpga/src/physical_types.h	/^	float R_minW_nmos;$/;"	m	struct:t_arch	access:public
t_arch::R_minW_pmos	../../libs/libarchfpga/src/physical_types.h	/^	float R_minW_pmos;$/;"	m	struct:t_arch	access:public
t_arch::SBType	../../libs/libarchfpga/src/physical_types.h	/^	enum e_switch_block_type SBType;$/;"	m	struct:t_arch	typeref:enum:t_arch::e_switch_block_type	access:public
t_arch::Segments	../../libs/libarchfpga/src/physical_types.h	/^	t_segment_inf * Segments;$/;"	m	struct:t_arch	access:public
t_arch::Switches	../../libs/libarchfpga/src/physical_types.h	/^	t_arch_switch_inf *Switches;$/;"	m	struct:t_arch	access:public
t_arch::architecture_id	../../libs/libarchfpga/src/physical_types.h	/^    char* architecture_id; \/\/Secure hash digest of the architecture file to uniquely identify this architecture$/;"	m	struct:t_arch	access:public
t_arch::clocks	../../libs/libarchfpga/src/physical_types.h	/^	t_clock_arch * clocks;$/;"	m	struct:t_arch	access:public
t_arch::grid_layouts	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_grid_def> grid_layouts; \/\/Set of potential device layouts$/;"	m	struct:t_arch	access:public
t_arch::grid_logic_tile_area	../../libs/libarchfpga/src/physical_types.h	/^	float grid_logic_tile_area;$/;"	m	struct:t_arch	access:public
t_arch::ipin_cblock_switch_name	../../libs/libarchfpga/src/physical_types.h	/^    std::string ipin_cblock_switch_name;$/;"	m	struct:t_arch	access:public
t_arch::model_library	../../libs/libarchfpga/src/physical_types.h	/^	t_model *model_library;$/;"	m	struct:t_arch	access:public
t_arch::models	../../libs/libarchfpga/src/physical_types.h	/^	t_model *models;$/;"	m	struct:t_arch	access:public
t_arch::num_directs	../../libs/libarchfpga/src/physical_types.h	/^	int num_directs;$/;"	m	struct:t_arch	access:public
t_arch::num_segments	../../libs/libarchfpga/src/physical_types.h	/^	int num_segments;$/;"	m	struct:t_arch	access:public
t_arch::num_switches	../../libs/libarchfpga/src/physical_types.h	/^	int num_switches;$/;"	m	struct:t_arch	access:public
t_arch::power	../../libs/libarchfpga/src/physical_types.h	/^	t_power_arch * power;$/;"	m	struct:t_arch	access:public
t_arch::switchblocks	../../libs/libarchfpga/src/physical_types.h	/^	std::vector<t_switchblock_inf> switchblocks;$/;"	m	struct:t_arch	access:public
t_arch_switch_fanin	route/rr_graph.cpp	/^typedef std::vector<std::map<int,int>> t_arch_switch_fanin;$/;"	t	file:
t_arch_switch_inf	../../libs/libarchfpga/src/physical_types.h	/^struct t_arch_switch_inf {$/;"	s
t_arch_switch_inf::Cin	../../libs/libarchfpga/src/physical_types.h	/^        float Cin = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::Cout	../../libs/libarchfpga/src/physical_types.h	/^        float Cout = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::PrintArchInfo	../../libs/libarchfpga/src/physical_types.h	/^        friend void PrintArchInfo(FILE*, const t_arch*);$/;"	p	struct:t_arch_switch_inf	access:friend	signature:(FILE*, const t_arch*)
t_arch_switch_inf::R	../../libs/libarchfpga/src/physical_types.h	/^        float R = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::Tdel	../../libs/libarchfpga/src/physical_types.cpp	/^float t_arch_switch_inf::Tdel(int fanin) const {$/;"	f	class:t_arch_switch_inf	signature:(int fanin) const
t_arch_switch_inf::Tdel	../../libs/libarchfpga/src/physical_types.h	/^        float Tdel(int fanin=UNDEFINED_FANIN) const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:(int fanin=UNDEFINED_FANIN) const
t_arch_switch_inf::Tdel_map_	../../libs/libarchfpga/src/physical_types.h	/^        std::map<int, double> Tdel_map_;$/;"	m	struct:t_arch_switch_inf	access:private
t_arch_switch_inf::UNDEFINED_FANIN	../../libs/libarchfpga/src/physical_types.cpp	/^constexpr int t_arch_switch_inf::UNDEFINED_FANIN;$/;"	m	class:t_arch_switch_inf	file:
t_arch_switch_inf::UNDEFINED_FANIN	../../libs/libarchfpga/src/physical_types.h	/^        static constexpr int UNDEFINED_FANIN = -1;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::buf_size	../../libs/libarchfpga/src/physical_types.h	/^        float buf_size = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::buf_size_type	../../libs/libarchfpga/src/physical_types.h	/^        BufferSize buf_size_type = BufferSize::AUTO;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::buffered	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_arch_switch_inf::buffered() const {$/;"	f	class:t_arch_switch_inf	signature:() const
t_arch_switch_inf::buffered	../../libs/libarchfpga/src/physical_types.h	/^        bool buffered() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
t_arch_switch_inf::configurable	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_arch_switch_inf::configurable() const {$/;"	f	class:t_arch_switch_inf	signature:() const
t_arch_switch_inf::configurable	../../libs/libarchfpga/src/physical_types.h	/^        bool configurable() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
t_arch_switch_inf::directionality	../../libs/libarchfpga/src/physical_types.cpp	/^e_directionality t_arch_switch_inf::directionality() const {$/;"	f	class:t_arch_switch_inf	signature:() const
t_arch_switch_inf::directionality	../../libs/libarchfpga/src/physical_types.h	/^        e_directionality directionality() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
t_arch_switch_inf::fixed_Tdel	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_arch_switch_inf::fixed_Tdel() const {$/;"	f	class:t_arch_switch_inf	signature:() const
t_arch_switch_inf::fixed_Tdel	../../libs/libarchfpga/src/physical_types.h	/^        bool fixed_Tdel() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
t_arch_switch_inf::mux_trans_size	../../libs/libarchfpga/src/physical_types.h	/^        float mux_trans_size = 1.;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::name	../../libs/libarchfpga/src/physical_types.h	/^        char *name = nullptr;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::power_buffer_size	../../libs/libarchfpga/src/physical_types.h	/^        float power_buffer_size = 0.;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::power_buffer_type	../../libs/libarchfpga/src/physical_types.h	/^        e_power_buffer_type power_buffer_type = POWER_BUFFER_TYPE_AUTO;$/;"	m	struct:t_arch_switch_inf	access:public
t_arch_switch_inf::set_Tdel	../../libs/libarchfpga/src/physical_types.cpp	/^void t_arch_switch_inf::set_Tdel(int fanin, float delay) {$/;"	f	class:t_arch_switch_inf	signature:(int fanin, float delay)
t_arch_switch_inf::set_Tdel	../../libs/libarchfpga/src/physical_types.h	/^        void set_Tdel(int fanin, float delay);$/;"	p	struct:t_arch_switch_inf	access:public	signature:(int fanin, float delay)
t_arch_switch_inf::set_type	../../libs/libarchfpga/src/physical_types.cpp	/^void t_arch_switch_inf::set_type(SwitchType type_val) {$/;"	f	class:t_arch_switch_inf	signature:(SwitchType type_val)
t_arch_switch_inf::set_type	../../libs/libarchfpga/src/physical_types.h	/^        void set_type(SwitchType type_val);$/;"	p	struct:t_arch_switch_inf	access:public	signature:(SwitchType type_val)
t_arch_switch_inf::type	../../libs/libarchfpga/src/physical_types.cpp	/^SwitchType t_arch_switch_inf::type() const {$/;"	f	class:t_arch_switch_inf	signature:() const
t_arch_switch_inf::type	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
t_arch_switch_inf::type_	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type_ = SwitchType::INVALID;$/;"	m	struct:t_arch_switch_inf	access:private
t_bb	base/vpr_types.h	/^struct t_bb {$/;"	s	class:ScreenUpdatePriority	access:private
t_block_loc	base/vpr_types.h	/^struct t_block_loc {$/;"	s	class:ScreenUpdatePriority	access:private
t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box() :$/;"	f	class:t_bound_box	signature:()
t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(const t_bound_box& src) :$/;"	f	class:t_bound_box	signature:(const t_bound_box& src)
t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(const t_point& _bottomleft, const t_point& _topright) :$/;"	f	class:t_bound_box	signature:(const t_point& _bottomleft, const t_point& _topright)
t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(const t_point& _bottomleft, float width, float height) :$/;"	f	class:t_bound_box	signature:(const t_point& _bottomleft, float width, float height)
t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(float _left, float _bottom, float _right, float _top) :$/;"	f	class:t_bound_box	signature:(float _left, float _bottom, float _right, float _top)
t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(const t_bound_box& src);$/;"	p	class:t_bound_box	access:public	signature:(const t_bound_box& src)
t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(const t_point& bottomleft, const t_point& topright);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& bottomleft, const t_point& topright)
t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(const t_point& bottomleft, float width, float height);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& bottomleft, float width, float height)
t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(float left, float bottom, float right, float top);$/;"	p	class:t_bound_box	access:public	signature:(float left, float bottom, float right, float top)
t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^class t_bound_box {$/;"	c
t_bound_box::area	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::area() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::area	../../libs/libeasygl/src/graphics_types.h	/^    float area() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::bottom	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::bottom() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::bottom	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::bottom() {$/;"	f	class:t_bound_box	signature:()
t_bound_box::bottom	../../libs/libeasygl/src/graphics_types.h	/^    const float& bottom() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::bottom	../../libs/libeasygl/src/graphics_types.h	/^    float& bottom();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::bottom_left	../../libs/libeasygl/src/graphics_types.cpp	/^const t_point& t_bound_box::bottom_left() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::bottom_left	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_bound_box::bottom_left() {$/;"	f	class:t_bound_box	signature:()
t_bound_box::bottom_left	../../libs/libeasygl/src/graphics_types.h	/^    const t_point& bottom_left() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::bottom_left	../../libs/libeasygl/src/graphics_types.h	/^    t_point& bottom_left();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::bottomleft	../../libs/libeasygl/src/graphics_types.h	/^    t_point bottomleft;$/;"	m	class:t_bound_box	access:private
t_bound_box::get_center	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_bound_box::get_center() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::get_center	../../libs/libeasygl/src/graphics_types.h	/^    t_point get_center() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::get_height	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_height() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::get_height	../../libs/libeasygl/src/graphics_types.h	/^    float get_height() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::get_width	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_width() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::get_width	../../libs/libeasygl/src/graphics_types.h	/^    float get_width() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::get_xcenter	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_xcenter() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::get_xcenter	../../libs/libeasygl/src/graphics_types.h	/^    float get_xcenter() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::get_ycenter	../../libs/libeasygl/src/graphics_types.cpp	/^float t_bound_box::get_ycenter() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::get_ycenter	../../libs/libeasygl/src/graphics_types.h	/^    float get_ycenter() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::intersects	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_bound_box::intersects(const t_point& test_pt) const {$/;"	f	class:t_bound_box	signature:(const t_point& test_pt) const
t_bound_box::intersects	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_bound_box::intersects(float x, float y) const {$/;"	f	class:t_bound_box	signature:(float x, float y) const
t_bound_box::intersects	../../libs/libeasygl/src/graphics_types.h	/^    bool intersects(const t_point& test_pt) const;$/;"	p	class:t_bound_box	access:public	signature:(const t_point& test_pt) const
t_bound_box::intersects	../../libs/libeasygl/src/graphics_types.h	/^    bool intersects(float x, float y) const;$/;"	p	class:t_bound_box	access:public	signature:(float x, float y) const
t_bound_box::left	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::left() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::left	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::left() {$/;"	f	class:t_bound_box	signature:()
t_bound_box::left	../../libs/libeasygl/src/graphics_types.h	/^    const float& left() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::left	../../libs/libeasygl/src/graphics_types.h	/^    float& left();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::offset	../../libs/libeasygl/src/graphics_types.cpp	/^void t_bound_box::offset(const t_point& relative_to) {$/;"	f	class:t_bound_box	signature:(const t_point& relative_to)
t_bound_box::offset	../../libs/libeasygl/src/graphics_types.cpp	/^void t_bound_box::offset(float by_x, float by_y) {$/;"	f	class:t_bound_box	signature:(float by_x, float by_y)
t_bound_box::offset	../../libs/libeasygl/src/graphics_types.h	/^    void offset(const t_point& make_relative_to);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& make_relative_to)
t_bound_box::offset	../../libs/libeasygl/src/graphics_types.h	/^    void offset(float by_x, float by_y);$/;"	p	class:t_bound_box	access:public	signature:(float by_x, float by_y)
t_bound_box::operator +	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box t_bound_box::operator+(const t_point& rhs) const {$/;"	f	class:t_bound_box	signature:(const t_point& rhs) const
t_bound_box::operator +	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box operator+(const t_point& rhs) const;$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs) const
t_bound_box::operator +=	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box& t_bound_box::operator+=(const t_point& rhs) {$/;"	f	class:t_bound_box	signature:(const t_point& rhs)
t_bound_box::operator +=	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box& operator+=(const t_point& rhs);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs)
t_bound_box::operator -	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box t_bound_box::operator-(const t_point& rhs) const {$/;"	f	class:t_bound_box	signature:(const t_point& rhs) const
t_bound_box::operator -	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box operator-(const t_point& rhs) const;$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs) const
t_bound_box::operator -=	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box& t_bound_box::operator-=(const t_point& rhs) {$/;"	f	class:t_bound_box	signature:(const t_point& rhs)
t_bound_box::operator -=	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box& operator-=(const t_point& rhs);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& rhs)
t_bound_box::operator =	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box& t_bound_box::operator=(const t_bound_box& src) {$/;"	f	class:t_bound_box	signature:(const t_bound_box& src)
t_bound_box::operator =	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box& operator=(const t_bound_box& src);$/;"	p	class:t_bound_box	access:public	signature:(const t_bound_box& src)
t_bound_box::right	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::right() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::right	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::right() {$/;"	f	class:t_bound_box	signature:()
t_bound_box::right	../../libs/libeasygl/src/graphics_types.h	/^    const float& right() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::right	../../libs/libeasygl/src/graphics_types.h	/^    float& right();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box() :$/;"	f	class:t_bound_box	signature:()
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(const t_bound_box& src) :$/;"	f	class:t_bound_box	signature:(const t_bound_box& src)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(const t_point& _bottomleft, const t_point& _topright) :$/;"	f	class:t_bound_box	signature:(const t_point& _bottomleft, const t_point& _topright)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(const t_point& _bottomleft, float width, float height) :$/;"	f	class:t_bound_box	signature:(const t_point& _bottomleft, float width, float height)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.cpp	/^t_bound_box::t_bound_box(float _left, float _bottom, float _right, float _top) :$/;"	f	class:t_bound_box	signature:(float _left, float _bottom, float _right, float _top)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(const t_bound_box& src);$/;"	p	class:t_bound_box	access:public	signature:(const t_bound_box& src)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(const t_point& bottomleft, const t_point& topright);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& bottomleft, const t_point& topright)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(const t_point& bottomleft, float width, float height);$/;"	p	class:t_bound_box	access:public	signature:(const t_point& bottomleft, float width, float height)
t_bound_box::t_bound_box	../../libs/libeasygl/src/graphics_types.h	/^    t_bound_box(float left, float bottom, float right, float top);$/;"	p	class:t_bound_box	access:public	signature:(float left, float bottom, float right, float top)
t_bound_box::top	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::top() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::top	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::top() {$/;"	f	class:t_bound_box	signature:()
t_bound_box::top	../../libs/libeasygl/src/graphics_types.h	/^    const float& top() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::top	../../libs/libeasygl/src/graphics_types.h	/^    float& top();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::top_right	../../libs/libeasygl/src/graphics_types.cpp	/^const t_point& t_bound_box::top_right() const {$/;"	f	class:t_bound_box	signature:() const
t_bound_box::top_right	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_bound_box::top_right() {$/;"	f	class:t_bound_box	signature:()
t_bound_box::top_right	../../libs/libeasygl/src/graphics_types.h	/^    const t_point& top_right() const;$/;"	p	class:t_bound_box	access:public	signature:() const
t_bound_box::top_right	../../libs/libeasygl/src/graphics_types.h	/^    t_point& top_right();$/;"	p	class:t_bound_box	access:public	signature:()
t_bound_box::topright	../../libs/libeasygl/src/graphics_types.h	/^    t_point topright;$/;"	m	class:t_bound_box	access:private
t_button	../../libs/libeasygl/src/graphics.cpp	/^} t_button;$/;"	t	typeref:struct:__anon18	file:
t_button_state	../../libs/libeasygl/src/graphics.cpp	/^} t_button_state;$/;"	t	typeref:struct:__anon19	file:
t_button_type	../../libs/libeasygl/src/graphics.cpp	/^} t_button_type;$/;"	t	typeref:enum:__anon17	file:
t_chan	../../libs/libarchfpga/src/physical_types.h	/^struct t_chan {$/;"	s
t_chan::dc	../../libs/libarchfpga/src/physical_types.h	/^	float dc;$/;"	m	struct:t_chan	access:public
t_chan::peak	../../libs/libarchfpga/src/physical_types.h	/^	float peak;$/;"	m	struct:t_chan	access:public
t_chan::type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_stat type;$/;"	m	struct:t_chan	typeref:enum:t_chan::e_stat	access:public
t_chan::width	../../libs/libarchfpga/src/physical_types.h	/^	float width;$/;"	m	struct:t_chan	access:public
t_chan::xpeak	../../libs/libarchfpga/src/physical_types.h	/^	float xpeak;$/;"	m	struct:t_chan	access:public
t_chan_details	base/vpr_types.h	/^typedef vtr::NdMatrix<t_chan_seg_details,3> t_chan_details;$/;"	t	class:ScreenUpdatePriority	access:private
t_chan_seg_details	base/vpr_types.h	/^        t_chan_seg_details() = default;$/;"	p	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:()
t_chan_seg_details	base/vpr_types.h	/^        t_chan_seg_details(const t_seg_details* init_seg_details)$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:(const t_seg_details* init_seg_details)
t_chan_seg_details	base/vpr_types.h	/^class t_chan_seg_details {$/;"	c	class:ScreenUpdatePriority	access:private
t_chan_width	base/vpr_types.h	/^struct t_chan_width {$/;"	s	class:ScreenUpdatePriority	access:private
t_chan_width_dist	../../libs/libarchfpga/src/physical_types.h	/^struct t_chan_width_dist {$/;"	s
t_chan_width_dist::chan_x_dist	../../libs/libarchfpga/src/physical_types.h	/^	t_chan chan_x_dist;$/;"	m	struct:t_chan_width_dist	access:public
t_chan_width_dist::chan_y_dist	../../libs/libarchfpga/src/physical_types.h	/^	t_chan chan_y_dist;$/;"	m	struct:t_chan_width_dist	access:public
t_chunk	../../libs/libvtrutil/src/vtr_memory.h	/^    struct t_chunk {$/;"	s	namespace:vtr
t_class	../../libs/libarchfpga/src/physical_types.h	/^struct t_class {$/;"	s
t_class::equivalence	../../libs/libarchfpga/src/physical_types.h	/^    PortEquivalence equivalence;$/;"	m	struct:t_class	access:public
t_class::num_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins;$/;"	m	struct:t_class	access:public
t_class::pinlist	../../libs/libarchfpga/src/physical_types.h	/^	int *pinlist; \/* [0..num_pins - 1] *\/$/;"	m	struct:t_class	access:public
t_class::type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_type type;$/;"	m	struct:t_class	typeref:enum:t_class::e_pin_type	access:public
t_clb_opins_used	base/vpr_types.h	/^typedef vtr::vector<ClusterBlockId, std::vector<std::vector<int>>> t_clb_opins_used; \/\/[0..num_blocks-1][0..class-1][0..used_pins-1]$/;"	t	class:ScreenUpdatePriority	access:private
t_clb_to_clb_directs	route/rr_graph.cpp	/^struct t_clb_to_clb_directs {$/;"	s	file:
t_clb_to_clb_directs::from_clb_pin_end_index	route/rr_graph.cpp	/^    int from_clb_pin_end_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clb_to_clb_directs::from_clb_pin_start_index	route/rr_graph.cpp	/^    int from_clb_pin_start_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clb_to_clb_directs::from_clb_type	route/rr_graph.cpp	/^    t_type_descriptor *from_clb_type;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clb_to_clb_directs::switch_index	route/rr_graph.cpp	/^    int switch_index; \/\/The switch type used by this direct connection$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clb_to_clb_directs::to_clb_pin_end_index	route/rr_graph.cpp	/^    int to_clb_pin_end_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clb_to_clb_directs::to_clb_pin_start_index	route/rr_graph.cpp	/^    int to_clb_pin_start_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clb_to_clb_directs::to_clb_type	route/rr_graph.cpp	/^    t_type_descriptor *to_clb_type;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
t_clock	base/vpr_types.h	/^struct t_clock {$/;"	s	class:ScreenUpdatePriority	access:private
t_clock_arch	../../libs/libarchfpga/src/physical_types.h	/^struct t_clock_arch {$/;"	s
t_clock_arch::clock_inf	../../libs/libarchfpga/src/physical_types.h	/^	t_clock_network *clock_inf; \/* Details about each clock *\/$/;"	m	struct:t_clock_arch	access:public
t_clock_arch::num_global_clocks	../../libs/libarchfpga/src/physical_types.h	/^	int num_global_clocks;$/;"	m	struct:t_clock_arch	access:public
t_clock_network	../../libs/libarchfpga/src/physical_types.h	/^struct t_clock_network {$/;"	s
t_clock_network::C_wire	../../libs/libarchfpga/src/physical_types.h	/^	float C_wire; \/* Wire capacitance (per meter) *\/$/;"	m	struct:t_clock_network	access:public
t_clock_network::autosize_buffer	../../libs/libarchfpga/src/physical_types.h	/^	bool autosize_buffer; \/* autosize clock buffers *\/$/;"	m	struct:t_clock_network	access:public
t_clock_network::buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float buffer_size; \/* if not autosized, the clock buffer size *\/$/;"	m	struct:t_clock_network	access:public
t_clock_network::dens	../../libs/libarchfpga/src/physical_types.h	/^	float dens; \/* Switching density of net assigned to this clock *\/$/;"	m	struct:t_clock_network	access:public
t_clock_network::period	../../libs/libarchfpga/src/physical_types.h	/^	float period; \/* Period of clock *\/$/;"	m	struct:t_clock_network	access:public
t_clock_network::prob	../../libs/libarchfpga/src/physical_types.h	/^	float prob; \/* Static probability of net assigned to this clock *\/$/;"	m	struct:t_clock_network	access:public
t_cluster_placement_primitive	../../libs/libarchfpga/src/cad_types.h	/^struct t_cluster_placement_primitive {$/;"	s
t_cluster_placement_primitive::base_cost	../../libs/libarchfpga/src/cad_types.h	/^	float base_cost; \/* cost independant of current status of packing *\/$/;"	m	struct:t_cluster_placement_primitive	access:public
t_cluster_placement_primitive::incremental_cost	../../libs/libarchfpga/src/cad_types.h	/^	float incremental_cost; \/* cost dependant on current status of packing *\/$/;"	m	struct:t_cluster_placement_primitive	access:public
t_cluster_placement_primitive::next_primitive	../../libs/libarchfpga/src/cad_types.h	/^	t_cluster_placement_primitive *next_primitive;$/;"	m	struct:t_cluster_placement_primitive	access:public
t_cluster_placement_primitive::pb_graph_node	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_node *pb_graph_node;$/;"	m	struct:t_cluster_placement_primitive	access:public
t_cluster_placement_primitive::valid	../../libs/libarchfpga/src/cad_types.h	/^	bool valid;$/;"	m	struct:t_cluster_placement_primitive	access:public
t_cluster_placement_stats	base/vpr_types.h	/^struct t_cluster_placement_stats {$/;"	s	class:ScreenUpdatePriority	access:private
t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color() = default;$/;"	p	class:t_color	file:	signature:()
t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color(color_types src) {$/;"	f	class:t_color	signature:(color_types src)
t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color(const t_color&) = default;$/;"	p	class:t_color	file:	signature:(const t_color&)
t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a) :$/;"	f	class:t_color	signature:(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a)
t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color();$/;"	p	class:t_color	access:public	signature:()
t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color(color_types src);$/;"	p	class:t_color	access:public	signature:(color_types src)
t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color(const t_color& src);$/;"	p	class:t_color	access:public	signature:(const t_color& src)
t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a = 255);$/;"	p	class:t_color	access:public	signature:(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a = 255)
t_color	../../libs/libeasygl/src/graphics_types.h	/^class t_color {$/;"	c
t_color::alpha	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t alpha = 255;$/;"	m	class:t_color	access:public
t_color::blue	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t blue = 0;$/;"	m	class:t_color	access:public
t_color::green	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t green = 0;$/;"	m	class:t_color	access:public
t_color::operator !=	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator!=(color_types rhs) const {$/;"	f	class:t_color	signature:(color_types rhs) const
t_color::operator !=	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator!=(const t_color& rhs) const {$/;"	f	class:t_color	signature:(const t_color& rhs) const
t_color::operator !=	../../libs/libeasygl/src/graphics_types.h	/^    bool operator!=(color_types rhs) const;$/;"	p	class:t_color	access:public	signature:(color_types rhs) const
t_color::operator !=	../../libs/libeasygl/src/graphics_types.h	/^    bool operator!=(const t_color& rhs) const;$/;"	p	class:t_color	access:public	signature:(const t_color& rhs) const
t_color::operator =	../../libs/libeasygl/src/graphics_types.cpp	/^color_types t_color::operator=(color_types \/*color_enum*\/) {$/;"	f	class:t_color	signature:(color_types )
t_color::operator =	../../libs/libeasygl/src/graphics_types.cpp	/^color_types t_color::operator=(color_types color_enum) {$/;"	f	class:t_color	signature:(color_types color_enum)
t_color::operator =	../../libs/libeasygl/src/graphics_types.h	/^    color_types operator=(color_types color_enum);$/;"	p	class:t_color	access:public	signature:(color_types color_enum)
t_color::operator ==	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator==(color_types \/*rhs*\/) const {$/;"	f	class:t_color	signature:(color_types ) const
t_color::operator ==	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator==(color_types rhs) const {$/;"	f	class:t_color	signature:(color_types rhs) const
t_color::operator ==	../../libs/libeasygl/src/graphics_types.cpp	/^bool t_color::operator==(const t_color& rhs) const {$/;"	f	class:t_color	signature:(const t_color& rhs) const
t_color::operator ==	../../libs/libeasygl/src/graphics_types.h	/^    bool operator==(color_types rhs) const;$/;"	p	class:t_color	access:public	signature:(color_types rhs) const
t_color::operator ==	../../libs/libeasygl/src/graphics_types.h	/^    bool operator==(const t_color& rhs) const;$/;"	p	class:t_color	access:public	signature:(const t_color& rhs) const
t_color::predef_colors	../../libs/libeasygl/src/graphics_types.cpp	/^const std::array<t_color,NUM_COLOR> t_color::predef_colors = {$/;"	m	class:t_color	file:
t_color::predef_colors	../../libs/libeasygl/src/graphics_types.h	/^    static const std::array<t_color,NUM_COLOR> predef_colors;$/;"	m	class:t_color	access:public
t_color::red	../../libs/libeasygl/src/graphics_types.h	/^    uint_fast8_t red = 0;   \/\/ 8-bits per colour component$/;"	m	class:t_color	access:public
t_color::t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color() = default;$/;"	p	class:t_color	file:	signature:()
t_color::t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color(color_types src) {$/;"	f	class:t_color	signature:(color_types src)
t_color::t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color(const t_color&) = default;$/;"	p	class:t_color	file:	signature:(const t_color&)
t_color::t_color	../../libs/libeasygl/src/graphics_types.cpp	/^t_color::t_color(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a) :$/;"	f	class:t_color	signature:(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a)
t_color::t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color();$/;"	p	class:t_color	access:public	signature:()
t_color::t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color(color_types src);$/;"	p	class:t_color	access:public	signature:(color_types src)
t_color::t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color(const t_color& src);$/;"	p	class:t_color	access:public	signature:(const t_color& src)
t_color::t_color	../../libs/libeasygl/src/graphics_types.h	/^    t_color(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a = 255);$/;"	p	class:t_color	access:public	signature:(uint_fast8_t r, uint_fast8_t g, uint_fast8_t b, uint_fast8_t a = 255)
t_conn_cost_params	route/route_timing.h	/^struct t_conn_cost_params {$/;"	s
t_conn_cost_params::astar_fac	route/route_timing.h	/^    float astar_fac = 1.2;$/;"	m	struct:t_conn_cost_params	access:public
t_conn_cost_params::bend_cost	route/route_timing.h	/^    float bend_cost = 1.;$/;"	m	struct:t_conn_cost_params	access:public
t_conn_cost_params::criticality	route/route_timing.h	/^    float criticality = 1.;$/;"	m	struct:t_conn_cost_params	access:public
t_conn_cost_params::delay_budget	route/route_timing.h	/^    const t_conn_delay_budget* delay_budget = nullptr;$/;"	m	struct:t_conn_cost_params	access:public
t_conn_delay_budget	route/route_timing.h	/^struct t_conn_delay_budget {$/;"	s
t_conn_delay_budget::max_delay	route/route_timing.h	/^    float max_delay; \/\/Maximum legal connection delay$/;"	m	struct:t_conn_delay_budget	access:public
t_conn_delay_budget::min_delay	route/route_timing.h	/^    float min_delay; \/\/Minimum legal connection delay$/;"	m	struct:t_conn_delay_budget	access:public
t_conn_delay_budget::short_path_criticality	route/route_timing.h	/^    float short_path_criticality; \/\/Hold criticality$/;"	m	struct:t_conn_delay_budget	access:public
t_conn_delay_budget::target_delay	route/route_timing.h	/^    float target_delay; \/\/Target\/goal connection delay$/;"	m	struct:t_conn_delay_budget	access:public
t_coordinate_system	../../libs/libeasygl/src/easygl_constants.h	/^} t_coordinate_system;$/;"	t	typeref:enum:__anon14
t_cost_map	route/router_lookahead_map.cpp	/^typedef vtr::NdMatrix<Cost_Entry,4> t_cost_map; \/\/[0..1][[0..num_seg_types-1]0..device_ctx.grid.width()-1][0..device_ctx.grid.height()-1]$/;"	t	file:
t_default_fc_spec	../../libs/libarchfpga/src/physical_types.h	/^struct t_default_fc_spec {$/;"	s
t_default_fc_spec::in_value	../../libs/libarchfpga/src/physical_types.h	/^    float in_value;					\/\/Input Fc value$/;"	m	struct:t_default_fc_spec	access:public
t_default_fc_spec::in_value_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_value_type in_value_type;	\/\/Type of the input value (frac or abs)$/;"	m	struct:t_default_fc_spec	access:public
t_default_fc_spec::out_value	../../libs/libarchfpga/src/physical_types.h	/^    float out_value;				\/\/Output Fc value$/;"	m	struct:t_default_fc_spec	access:public
t_default_fc_spec::out_value_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_value_type out_value_type; \/\/Type of the output value (frac or abs)$/;"	m	struct:t_default_fc_spec	access:public
t_default_fc_spec::specified	../../libs/libarchfpga/src/physical_types.h	/^    bool specified = false; 		\/\/Whether or not a default specification exists$/;"	m	struct:t_default_fc_spec	access:public
t_det_routing_arch	base/vpr_types.h	/^struct t_det_routing_arch {$/;"	s	class:ScreenUpdatePriority	access:private
t_direct_inf	../../libs/libarchfpga/src/physical_types.h	/^struct t_direct_inf {$/;"	s
t_direct_inf::from_pin	../../libs/libarchfpga/src/physical_types.h	/^	char *from_pin;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::from_side	../../libs/libarchfpga/src/physical_types.h	/^    e_side from_side;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::line	../../libs/libarchfpga/src/physical_types.h	/^	int line;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::name	../../libs/libarchfpga/src/physical_types.h	/^	char *name;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::switch_type	../../libs/libarchfpga/src/physical_types.h	/^	int switch_type;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::to_pin	../../libs/libarchfpga/src/physical_types.h	/^	char *to_pin;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::to_side	../../libs/libarchfpga/src/physical_types.h	/^    e_side to_side;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::x_offset	../../libs/libarchfpga/src/physical_types.h	/^	int x_offset;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::y_offset	../../libs/libarchfpga/src/physical_types.h	/^	int y_offset;$/;"	m	struct:t_direct_inf	access:public
t_direct_inf::z_offset	../../libs/libarchfpga/src/physical_types.h	/^	int z_offset;$/;"	m	struct:t_direct_inf	access:public
t_display_type	../../libs/libeasygl/src/graphics_state.h	/^} t_display_type;$/;"	t	typeref:enum:__anon24
t_draw_coords	draw/draw_types.cpp	/^t_draw_coords::t_draw_coords() {$/;"	f	class:t_draw_coords	signature:()
t_draw_coords	draw/draw_types.h	/^	t_draw_coords();$/;"	p	struct:t_draw_coords	access:public	signature:()
t_draw_coords	draw/draw_types.h	/^struct t_draw_coords {$/;"	s
t_draw_coords::blk_info	draw/draw_types.h	/^    std::vector<t_draw_pb_type_info> blk_info;$/;"	m	struct:t_draw_coords	access:public
t_draw_coords::get_absolute_clb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_absolute_clb_bbox(const ClusterBlockId clb_index, const t_type_ptr type) {$/;"	f	class:t_draw_coords	signature:(const ClusterBlockId clb_index, const t_type_ptr type)
t_draw_coords::get_absolute_clb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_absolute_clb_bbox(int grid_x, int grid_y, int sub_block_index) {$/;"	f	class:t_draw_coords	signature:(int grid_x, int grid_y, int sub_block_index)
t_draw_coords::get_absolute_clb_bbox	draw/draw_types.h	/^	t_bound_box get_absolute_clb_bbox(const ClusterBlockId clb_index, const t_type_ptr type);$/;"	p	struct:t_draw_coords	access:public	signature:(const ClusterBlockId clb_index, const t_type_ptr type)
t_draw_coords::get_absolute_clb_bbox	draw/draw_types.h	/^	t_bound_box get_absolute_clb_bbox(int grid_x, int grid_y, int sub_block_index);$/;"	p	struct:t_draw_coords	access:public	signature:(int grid_x, int grid_y, int sub_block_index)
t_draw_coords::get_absolute_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_absolute_pb_bbox(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode) {$/;"	f	class:t_draw_coords	signature:(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode)
t_draw_coords::get_absolute_pb_bbox	draw/draw_types.h	/^	t_bound_box get_absolute_pb_bbox(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode);$/;"	p	struct:t_draw_coords	access:public	signature:(const ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode)
t_draw_coords::get_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_pb_bbox(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode) {$/;"	f	class:t_draw_coords	signature:(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode)
t_draw_coords::get_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_coords::get_pb_bbox(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode) {$/;"	f	class:t_draw_coords	signature:(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode)
t_draw_coords::get_pb_bbox	draw/draw_types.h	/^	t_bound_box get_pb_bbox(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_coords	access:public	signature:(ClusterBlockId clb_index, const t_pb_graph_node& pb_gnode)
t_draw_coords::get_pb_bbox	draw/draw_types.h	/^	t_bound_box get_pb_bbox(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_coords	access:public	signature:(int grid_x, int grid_y, int sub_block_index, const t_pb_graph_node& pb_gnode)
t_draw_coords::get_tile_height	draw/draw_types.cpp	/^float t_draw_coords::get_tile_height() {$/;"	f	class:t_draw_coords	signature:()
t_draw_coords::get_tile_height	draw/draw_types.h	/^	float get_tile_height();$/;"	p	struct:t_draw_coords	access:public	signature:()
t_draw_coords::get_tile_width	draw/draw_types.cpp	/^float t_draw_coords::get_tile_width() {$/;"	f	class:t_draw_coords	signature:()
t_draw_coords::get_tile_width	draw/draw_types.h	/^	float get_tile_width();$/;"	p	struct:t_draw_coords	access:public	signature:()
t_draw_coords::init_draw_coords	draw/draw_types.h	/^	friend void init_draw_coords(float);$/;"	p	struct:t_draw_coords	access:friend	signature:(float)
t_draw_coords::pin_size	draw/draw_types.h	/^	float pin_size;$/;"	m	struct:t_draw_coords	access:public
t_draw_coords::t_draw_coords	draw/draw_types.cpp	/^t_draw_coords::t_draw_coords() {$/;"	f	class:t_draw_coords	signature:()
t_draw_coords::t_draw_coords	draw/draw_types.h	/^	t_draw_coords();$/;"	p	struct:t_draw_coords	access:public	signature:()
t_draw_coords::tile_width	draw/draw_types.h	/^	float tile_width;$/;"	m	struct:t_draw_coords	access:private
t_draw_coords::tile_x	draw/draw_types.h	/^	float *tile_x, *tile_y;$/;"	m	struct:t_draw_coords	access:public
t_draw_coords::tile_y	draw/draw_types.h	/^	float *tile_x, *tile_y;$/;"	m	struct:t_draw_coords	access:public
t_draw_pb_type_info	draw/draw_types.h	/^struct t_draw_pb_type_info {$/;"	s
t_draw_pb_type_info::get_pb_bbox	draw/draw_types.cpp	/^t_bound_box t_draw_pb_type_info::get_pb_bbox(const t_pb_graph_node& pb_graph_node) {$/;"	f	class:t_draw_pb_type_info	signature:(const t_pb_graph_node& pb_graph_node)
t_draw_pb_type_info::get_pb_bbox	draw/draw_types.h	/^	t_bound_box get_pb_bbox(const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_pb_type_info	access:public	signature:(const t_pb_graph_node& pb_gnode)
t_draw_pb_type_info::get_pb_bbox_ref	draw/draw_types.cpp	/^t_bound_box& t_draw_pb_type_info::get_pb_bbox_ref(const t_pb_graph_node& pb_graph_node) {$/;"	f	class:t_draw_pb_type_info	signature:(const t_pb_graph_node& pb_graph_node)
t_draw_pb_type_info::get_pb_bbox_ref	draw/draw_types.h	/^	t_bound_box& get_pb_bbox_ref(const t_pb_graph_node& pb_gnode);$/;"	p	struct:t_draw_pb_type_info	access:public	signature:(const t_pb_graph_node& pb_gnode)
t_draw_pb_type_info::subblk_array	draw/draw_types.h	/^    std::vector<t_bound_box> subblk_array;$/;"	m	struct:t_draw_pb_type_info	access:public
t_draw_rr_node	draw/draw_types.h	/^} t_draw_rr_node;$/;"	t	typeref:struct:__anon12
t_draw_state	draw/draw_types.h	/^	t_draw_state() = default;$/;"	p	struct:t_draw_state	access:public	signature:()
t_draw_state	draw/draw_types.h	/^struct t_draw_state {$/;"	s
t_draw_state::arch_info	draw/draw_types.h	/^    const t_arch* arch_info = nullptr;$/;"	m	struct:t_draw_state	access:public
t_draw_state::block_color	draw/draw_types.h	/^	vtr::vector<ClusterBlockId, t_color> block_color;$/;"	m	struct:t_draw_state	access:public
t_draw_state::color_map	draw/draw_types.h	/^    std::unique_ptr<const vtr::ColorMap> color_map = nullptr;$/;"	m	struct:t_draw_state	access:public
t_draw_state::default_message	draw/draw_types.h	/^	char default_message[vtr::bufsize];$/;"	m	struct:t_draw_state	access:public
t_draw_state::draw_route_type	draw/draw_types.h	/^	e_route_type draw_route_type = GLOBAL;$/;"	m	struct:t_draw_state	access:public
t_draw_state::draw_rr_node	draw/draw_types.h	/^	t_draw_rr_node *draw_rr_node = nullptr;$/;"	m	struct:t_draw_state	access:public
t_draw_state::draw_rr_toggle	draw/draw_types.h	/^	e_draw_rr_toggle draw_rr_toggle = DRAW_NO_RR;$/;"	m	struct:t_draw_state	access:public
t_draw_state::gr_automode	draw/draw_types.h	/^	int gr_automode = 0;$/;"	m	struct:t_draw_state	access:public
t_draw_state::max_sub_blk_lvl	draw/draw_types.h	/^	int max_sub_blk_lvl = 0;$/;"	m	struct:t_draw_state	access:public
t_draw_state::net_color	draw/draw_types.h	/^	vtr::vector<ClusterNetId, t_color> net_color;$/;"	m	struct:t_draw_state	access:public
t_draw_state::pic_on_screen	draw/draw_types.h	/^	pic_type pic_on_screen = NO_PICTURE;$/;"	m	struct:t_draw_state	access:public
t_draw_state::reset_nets_congestion_and_rr	draw/draw_types.cpp	/^void t_draw_state::reset_nets_congestion_and_rr() {$/;"	f	class:t_draw_state	signature:()
t_draw_state::reset_nets_congestion_and_rr	draw/draw_types.h	/^	void reset_nets_congestion_and_rr();$/;"	p	struct:t_draw_state	access:public	signature:()
t_draw_state::setup_timing_info	draw/draw_types.h	/^    std::shared_ptr<const SetupTimingInfo> setup_timing_info;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_blk_internal	draw/draw_types.h	/^	int show_blk_internal = 0;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_blk_pin_util	draw/draw_types.h	/^    e_draw_block_pin_util show_blk_pin_util = DRAW_NO_BLOCK_PIN_UTIL;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_congestion	draw/draw_types.h	/^	e_draw_congestion show_congestion = DRAW_NO_CONGEST;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_crit_path	draw/draw_types.h	/^    e_draw_crit_path show_crit_path = DRAW_NO_CRIT_PATH;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_graphics	draw/draw_types.h	/^	bool show_graphics = false;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_nets	draw/draw_types.h	/^	e_draw_nets show_nets = DRAW_NO_NETS;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_router_rr_cost	draw/draw_types.h	/^    e_draw_router_rr_cost show_router_rr_cost = DRAW_NO_ROUTER_RR_COST;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_routing_bb	draw/draw_types.h	/^    int show_routing_bb = OPEN;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_routing_costs	draw/draw_types.h	/^	e_draw_routing_costs show_routing_costs;$/;"	m	struct:t_draw_state	access:public
t_draw_state::show_routing_util	draw/draw_types.h	/^    e_draw_routing_util show_routing_util = DRAW_NO_ROUTING_UTIL;$/;"	m	struct:t_draw_state	access:public
t_draw_state::showing_sub_blocks	draw/draw_types.cpp	/^bool t_draw_state::showing_sub_blocks() {$/;"	f	class:t_draw_state	signature:()
t_draw_state::showing_sub_blocks	draw/draw_types.h	/^	bool showing_sub_blocks();$/;"	p	struct:t_draw_state	access:public	signature:()
t_draw_state::t_draw_state	draw/draw_types.h	/^	t_draw_state() = default;$/;"	p	struct:t_draw_state	access:public	signature:()
t_draw_to	../../libs/libeasygl/src/easygl_constants.h	/^} t_draw_to;$/;"	t	typeref:enum:__anon15
t_event_buttonPressed	../../libs/libeasygl/src/easygl_constants.h	/^} t_event_buttonPressed;$/;"	t	typeref:struct:__anon16
t_expansion_node	pack/pack_types.h	/^	t_expansion_node() {$/;"	f	struct:t_expansion_node	access:public	signature:()
t_expansion_node	pack/pack_types.h	/^struct t_expansion_node {$/;"	s
t_expansion_node::cost	pack/pack_types.h	/^	float cost;$/;"	m	struct:t_expansion_node	access:public
t_expansion_node::node_index	pack/pack_types.h	/^	int node_index;		\/* Index of logic cluster_ctx.blocks rr node this expansion node represents *\/$/;"	m	struct:t_expansion_node	access:public
t_expansion_node::prev_index	pack/pack_types.h	/^	int prev_index;		\/* Index of logic cluster_ctx.blocks rr node that drives this expansion node *\/$/;"	m	struct:t_expansion_node	access:public
t_expansion_node::t_expansion_node	pack/pack_types.h	/^	t_expansion_node() {$/;"	f	struct:t_expansion_node	access:public	signature:()
t_explored_node_tb	pack/pack_types.h	/^	t_explored_node_tb() {$/;"	f	struct:t_explored_node_tb	access:public	signature:()
t_explored_node_tb	pack/pack_types.h	/^struct t_explored_node_tb {$/;"	s
t_explored_node_tb::enqueue_cost	pack/pack_types.h	/^	float enqueue_cost;		\/* cost of node pused on exploration priority queue *\/$/;"	m	struct:t_explored_node_tb	access:public
t_explored_node_tb::enqueue_id	pack/pack_types.h	/^	int enqueue_id;			\/* ID used ot determine if this node has been pushed on exploration priority queue *\/$/;"	m	struct:t_explored_node_tb	access:public
t_explored_node_tb::explored_id	pack/pack_types.h	/^	int explored_id;		\/* ID used to determine if this node has been explored *\/$/;"	m	struct:t_explored_node_tb	access:public
t_explored_node_tb::inet	pack/pack_types.h	/^	int inet;				\/* net index of route tree *\/$/;"	m	struct:t_explored_node_tb	access:public
t_explored_node_tb::prev_index	pack/pack_types.h	/^	int prev_index;			\/* Prevous node that drives this one *\/$/;"	m	struct:t_explored_node_tb	access:public
t_explored_node_tb::t_explored_node_tb	pack/pack_types.h	/^	t_explored_node_tb() {$/;"	f	struct:t_explored_node_tb	access:public	signature:()
t_ext_pin_util	base/vpr_types.h	/^    t_ext_pin_util() = default;$/;"	p	struct:ScreenUpdatePriority::t_ext_pin_util	access:public	signature:()
t_ext_pin_util	base/vpr_types.h	/^    t_ext_pin_util(float in, float out)$/;"	f	struct:ScreenUpdatePriority::t_ext_pin_util	access:public	signature:(float in, float out)
t_ext_pin_util	base/vpr_types.h	/^struct t_ext_pin_util {$/;"	s	class:ScreenUpdatePriority	access:private
t_ext_pin_util_targets	base/vpr_types.cpp	/^t_ext_pin_util_targets::t_ext_pin_util_targets(float default_in_util, float default_out_util) {$/;"	f	class:t_ext_pin_util_targets	signature:(float default_in_util, float default_out_util)
t_ext_pin_util_targets	base/vpr_types.h	/^    t_ext_pin_util_targets() = default;$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:()
t_ext_pin_util_targets	base/vpr_types.h	/^    t_ext_pin_util_targets(float default_in_util, float default_out_util);$/;"	p	class:ScreenUpdatePriority::t_ext_pin_util_targets	access:public	signature:(float default_in_util, float default_out_util)
t_ext_pin_util_targets	base/vpr_types.h	/^class t_ext_pin_util_targets {$/;"	c	class:ScreenUpdatePriority	access:private
t_ext_pin_util_targets::get_pin_util	base/vpr_types.cpp	/^t_ext_pin_util t_ext_pin_util_targets::get_pin_util(std::string block_type_name) const {$/;"	f	class:t_ext_pin_util_targets	signature:(std::string block_type_name) const
t_ext_pin_util_targets::set_block_pin_util	base/vpr_types.cpp	/^void t_ext_pin_util_targets::set_block_pin_util(std::string block_type_name, t_ext_pin_util target) {$/;"	f	class:t_ext_pin_util_targets	signature:(std::string block_type_name, t_ext_pin_util target)
t_ext_pin_util_targets::set_default_pin_util	base/vpr_types.cpp	/^void t_ext_pin_util_targets::set_default_pin_util(t_ext_pin_util default_target) {$/;"	f	class:t_ext_pin_util_targets	signature:(t_ext_pin_util default_target)
t_ext_pin_util_targets::t_ext_pin_util_targets	base/vpr_types.cpp	/^t_ext_pin_util_targets::t_ext_pin_util_targets(float default_in_util, float default_out_util) {$/;"	f	class:t_ext_pin_util_targets	signature:(float default_in_util, float default_out_util)
t_fc_override	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^struct t_fc_override {$/;"	s	file:
t_fc_override::fc_value	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    float fc_value;$/;"	m	struct:t_fc_override	file:	access:public
t_fc_override::fc_value_type	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    e_fc_value_type fc_value_type;$/;"	m	struct:t_fc_override	file:	access:public
t_fc_override::port_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    std::string port_name;$/;"	m	struct:t_fc_override	file:	access:public
t_fc_override::seg_name	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^    std::string seg_name;$/;"	m	struct:t_fc_override	file:	access:public
t_fc_specification	../../libs/libarchfpga/src/physical_types.h	/^struct t_fc_specification {$/;"	s
t_fc_specification::fc_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_type fc_type;              \/\/What type of Fc$/;"	m	struct:t_fc_specification	access:public
t_fc_specification::fc_value	../../libs/libarchfpga/src/physical_types.h	/^    float fc_value;                 \/\/The Fc value$/;"	m	struct:t_fc_specification	access:public
t_fc_specification::fc_value_type	../../libs/libarchfpga/src/physical_types.h	/^    e_fc_value_type fc_value_type;  \/\/How to interpret the Fc value$/;"	m	struct:t_fc_specification	access:public
t_fc_specification::pins	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> pins;          \/\/The block pins collectively effected by this Fc$/;"	m	struct:t_fc_specification	access:public
t_fc_specification::seg_index	../../libs/libarchfpga/src/physical_types.h	/^    int seg_index;                  \/\/The target segment index$/;"	m	struct:t_fc_specification	access:public
t_file_name_opts	base/vpr_types.h	/^struct t_file_name_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_fmap_cell	base/place_and_route.h	/^struct t_fmap_cell {$/;"	s
t_fmap_cell::fc	base/place_and_route.h	/^	int fc; \/* at this fc *\/$/;"	m	struct:t_fmap_cell	access:public
t_fmap_cell::fs	base/place_and_route.h	/^	int fs; \/* at this fs *\/$/;"	m	struct:t_fmap_cell	access:public
t_fmap_cell::next	base/place_and_route.h	/^	t_fmap_cell *next;$/;"	m	struct:t_fmap_cell	access:public
t_fmap_cell::proc_time	base/place_and_route.h	/^	int proc_time;$/;"	m	struct:t_fmap_cell	access:public
t_fmap_cell::wirelength	base/place_and_route.h	/^	int wirelength; \/* corresponding wirelength of successful routing at wneed *\/$/;"	m	struct:t_fmap_cell	access:public
t_fmap_cell::wneed	base/place_and_route.h	/^	int wneed; \/* need wneed to route *\/$/;"	m	struct:t_fmap_cell	access:public
t_formula_data	../../libs/libarchfpga/src/expr_eval.h	/^class t_formula_data {$/;"	c
t_formula_data::get_var_value	../../libs/libarchfpga/src/expr_eval.h	/^        int get_var_value(std::string var) const {$/;"	f	class:t_formula_data	access:public	signature:(std::string var) const
t_formula_data::set_var_value	../../libs/libarchfpga/src/expr_eval.h	/^        void set_var_value(std::string var, int value) { vars_[var] = value; }$/;"	f	class:t_formula_data	access:public	signature:(std::string var, int value)
t_formula_data::vars_	../../libs/libarchfpga/src/expr_eval.h	/^        std::map<std::string,int> vars_;$/;"	m	class:t_formula_data	access:private
t_formula_obj	../../libs/libarchfpga/src/expr_eval.cpp	/^} t_formula_obj;$/;"	t	typeref:enum:e_formula_obj	file:
t_gl_state	../../libs/libeasygl/src/graphics_state.h	/^struct t_gl_state {$/;"	s
t_gl_state::ProceedPressed	../../libs/libeasygl/src/graphics_state.h	/^    bool ProceedPressed = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::background_color	../../libs/libeasygl/src/graphics_state.h	/^    t_color background_color = t_color(0xFF, 0xFF, 0xCC);$/;"	m	struct:t_gl_state	access:public
t_gl_state::current_draw_mode	../../libs/libeasygl/src/graphics_state.h	/^    e_draw_mode current_draw_mode = DRAW_NORMAL;$/;"	m	struct:t_gl_state	access:public
t_gl_state::current_draw_to	../../libs/libeasygl/src/graphics_state.h	/^    t_draw_to current_draw_to = ON_SCREEN;$/;"	m	struct:t_gl_state	access:public
t_gl_state::currentcoordinatesystem	../../libs/libeasygl/src/graphics_state.h	/^    t_coordinate_system currentcoordinatesystem = GL_WORLD;$/;"	m	struct:t_gl_state	access:public
t_gl_state::currentfontrotation	../../libs/libeasygl/src/graphics_state.h	/^    int currentfontrotation = 0;$/;"	m	struct:t_gl_state	access:public
t_gl_state::currentfontsize	../../libs/libeasygl/src/graphics_state.h	/^    int currentfontsize = 12;$/;"	m	struct:t_gl_state	access:public
t_gl_state::currentlinecap	../../libs/libeasygl/src/graphics_state.h	/^    int currentlinecap = 0;$/;"	m	struct:t_gl_state	access:public
t_gl_state::currentlinestyle	../../libs/libeasygl/src/graphics_state.h	/^    int currentlinestyle = SOLID;$/;"	m	struct:t_gl_state	access:public
t_gl_state::currentlinewidth	../../libs/libeasygl/src/graphics_state.h	/^    int currentlinewidth = 0;$/;"	m	struct:t_gl_state	access:public
t_gl_state::disable_event_loop	../../libs/libeasygl/src/graphics_state.h	/^    bool disable_event_loop = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::disp_type	../../libs/libeasygl/src/graphics_state.h	/^    t_display_type disp_type = SCREEN;$/;"	m	struct:t_gl_state	access:public
t_gl_state::font_info	../../libs/libeasygl/src/graphics_state.h	/^    FontCache font_info;$/;"	m	struct:t_gl_state	access:public
t_gl_state::foreground_color	../../libs/libeasygl/src/graphics_state.h	/^    t_color foreground_color = BLACK;$/;"	m	struct:t_gl_state	access:public
t_gl_state::get_keypress_input	../../libs/libeasygl/src/graphics_state.h	/^    bool get_keypress_input = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::get_mouse_move_input	../../libs/libeasygl/src/graphics_state.h	/^    bool get_mouse_move_input = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::initialized	../../libs/libeasygl/src/graphics_state.h	/^    bool initialized = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::ps	../../libs/libeasygl/src/graphics_state.h	/^    FILE *ps = nullptr;$/;"	m	struct:t_gl_state	access:public
t_gl_state::redirect_to_postscript	../../libs/libeasygl/src/graphics_state.h	/^    bool redirect_to_postscript = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::redraw_needed	../../libs/libeasygl/src/graphics_state.h	/^    bool redraw_needed = false;$/;"	m	struct:t_gl_state	access:public
t_gl_state::statusMessage	../../libs/libeasygl/src/graphics_state.h	/^    char statusMessage[BUFSIZE] = "";$/;"	m	struct:t_gl_state	access:public
t_gl_state::zoom_factor	../../libs/libeasygl/src/graphics_state.h	/^    float zoom_factor = 1.6667;$/;"	m	struct:t_gl_state	access:public
t_graph_type	route/rr_graph.h	/^typedef enum e_graph_type t_graph_type;$/;"	t	typeref:enum:e_graph_type
t_grid_blocks	base/vpr_types.h	/^struct t_grid_blocks {$/;"	s	class:ScreenUpdatePriority	access:private
t_grid_def	../../libs/libarchfpga/src/physical_types.h	/^struct t_grid_def {$/;"	s
t_grid_def::aspect_ratio	../../libs/libarchfpga/src/physical_types.h	/^    float aspect_ratio = 1.;                    \/\/Aspect ratio for auto-sized devices (only valid for$/;"	m	struct:t_grid_def	access:public
t_grid_def::grid_type	../../libs/libarchfpga/src/physical_types.h	/^    GridDefType grid_type = GridDefType::AUTO;  \/\/The type of this grid specification$/;"	m	struct:t_grid_def	access:public
t_grid_def::height	../../libs/libarchfpga/src/physical_types.h	/^    int height = -1;                            \/\/Fixed device height (only valid for grid_type == FIXED)$/;"	m	struct:t_grid_def	access:public
t_grid_def::loc_defs	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_grid_loc_def> loc_defs;       \/\/The list of grid location definitions for this grid specification$/;"	m	struct:t_grid_def	access:public
t_grid_def::name	../../libs/libarchfpga/src/physical_types.h	/^    std::string name = "";                      \/\/The name of this device$/;"	m	struct:t_grid_def	access:public
t_grid_def::width	../../libs/libarchfpga/src/physical_types.h	/^    int width = -1;                             \/\/Fixed device width (only valid for grid_type == FIXED)$/;"	m	struct:t_grid_def	access:public
t_grid_loc_def	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_def(std::string block_type_val, int priority_val)$/;"	f	struct:t_grid_loc_def	access:public	signature:(std::string block_type_val, int priority_val)
t_grid_loc_def	../../libs/libarchfpga/src/physical_types.h	/^struct t_grid_loc_def {$/;"	s
t_grid_loc_def::block_type	../../libs/libarchfpga/src/physical_types.h	/^    std::string block_type; \/\/The block type name$/;"	m	struct:t_grid_loc_def	access:public
t_grid_loc_def::priority	../../libs/libarchfpga/src/physical_types.h	/^	int priority = 0;       \/\/Priority of the specification.$/;"	m	struct:t_grid_loc_def	access:public
t_grid_loc_def::t_grid_loc_def	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_def(std::string block_type_val, int priority_val)$/;"	f	struct:t_grid_loc_def	access:public	signature:(std::string block_type_val, int priority_val)
t_grid_loc_def::x	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_spec x;      \/\/Horizontal location specification$/;"	m	struct:t_grid_loc_def	access:public
t_grid_loc_def::y	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_spec y;      \/\/Veritcal location specification$/;"	m	struct:t_grid_loc_def	access:public
t_grid_loc_spec	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_spec(std::string start, std::string end, std::string repeat, std::string incr)$/;"	f	struct:t_grid_loc_spec	access:public	signature:(std::string start, std::string end, std::string repeat, std::string incr)
t_grid_loc_spec	../../libs/libarchfpga/src/physical_types.h	/^struct t_grid_loc_spec {$/;"	s
t_grid_loc_spec::end_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string end_expr;    \/\/Ending position (inclusive)$/;"	m	struct:t_grid_loc_spec	access:public
t_grid_loc_spec::incr_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string incr_expr;   \/\/Distance between block instantiations$/;"	m	struct:t_grid_loc_spec	access:public
t_grid_loc_spec::repeat_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string repeat_expr; \/\/Distance between repeated$/;"	m	struct:t_grid_loc_spec	access:public
t_grid_loc_spec::start_expr	../../libs/libarchfpga/src/physical_types.h	/^    std::string start_expr;  \/\/Starting position (inclusive)$/;"	m	struct:t_grid_loc_spec	access:public
t_grid_loc_spec::t_grid_loc_spec	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_spec(std::string start, std::string end, std::string repeat, std::string incr)$/;"	f	struct:t_grid_loc_spec	access:public	signature:(std::string start, std::string end, std::string repeat, std::string incr)
t_grid_tile	base/vpr_types.h	/^struct t_grid_tile {$/;"	s	class:ScreenUpdatePriority	access:private
t_hash	util/hash.h	/^struct t_hash {$/;"	s
t_hash::count	util/hash.h	/^	int count;$/;"	m	struct:t_hash	access:public
t_hash::index	util/hash.h	/^	int index;$/;"	m	struct:t_hash	access:public
t_hash::name	util/hash.h	/^	char *name;$/;"	m	struct:t_hash	access:public
t_hash::next	util/hash.h	/^	t_hash *next;$/;"	m	struct:t_hash	access:public
t_hash_Switchblock_Lookup	route/build_switchblocks.h	/^struct t_hash_Switchblock_Lookup{$/;"	s
t_hash_Switchblock_Lookup::operator ()	route/build_switchblocks.h	/^	size_t operator()(const Switchblock_Lookup &obj) const{$/;"	f	struct:t_hash_Switchblock_Lookup	access:public	signature:(const Switchblock_Lookup &obj) const
t_hash_iterator	util/hash.h	/^struct t_hash_iterator {$/;"	s
t_hash_iterator::h_ptr	util/hash.h	/^	t_hash *h_ptr;$/;"	m	struct:t_hash_iterator	access:public
t_hash_iterator::i	util/hash.h	/^	int i;$/;"	m	struct:t_hash_iterator	access:public
t_heap	route/route_common.h	/^struct t_heap {$/;"	s
t_heap::R_upstream	route/route_common.h	/^	float R_upstream = 0.;$/;"	m	struct:t_heap	access:public
t_heap::backward_path_cost	route/route_common.h	/^	float backward_path_cost = 0.;$/;"	m	struct:t_heap	access:public
t_heap::cost	route/route_common.h	/^	float cost = 0.;$/;"	m	struct:t_heap	access:public
t_heap::index	route/route_common.h	/^	int index = OPEN;$/;"	m	struct:t_heap	access:public
t_heap::next	route/route_common.h	/^    t_heap *next = nullptr;$/;"	m	struct:t_heap	access:public
t_heap::previous	route/route_common.h	/^    std::vector<t_heap_prev> previous;$/;"	m	struct:t_heap	access:public
t_heap_prev	route/route_common.h	/^    t_heap_prev(int to, int from, short edge)$/;"	f	struct:t_heap_prev	access:public	signature:(int to, int from, short edge)
t_heap_prev	route/route_common.h	/^struct t_heap_prev {$/;"	s
t_heap_prev::from_edge	route/route_common.h	/^    short from_edge = NO_PREVIOUS; \/\/The edge used to connect from 'from_node' to 'to_node'$/;"	m	struct:t_heap_prev	access:public
t_heap_prev::from_node	route/route_common.h	/^    int from_node = NO_PREVIOUS; \/\/The previous node used to connect to 'to_node'$/;"	m	struct:t_heap_prev	access:public
t_heap_prev::t_heap_prev	route/route_common.h	/^    t_heap_prev(int to, int from, short edge)$/;"	f	struct:t_heap_prev	access:public	signature:(int to, int from, short edge)
t_heap_prev::to_node	route/route_common.h	/^    int to_node = NO_PREVIOUS; \/\/The target node$/;"	m	struct:t_heap_prev	access:public
t_interconnect	../../libs/libarchfpga/src/physical_types.h	/^struct t_interconnect {$/;"	s
t_interconnect::annotations	../../libs/libarchfpga/src/physical_types.h	/^	t_pin_to_pin_annotation *annotations; \/* [0..num_annotations-1] *\/$/;"	m	struct:t_interconnect	access:public
t_interconnect::infer_annotations	../../libs/libarchfpga/src/physical_types.h	/^	bool infer_annotations;$/;"	m	struct:t_interconnect	access:public
t_interconnect::input_string	../../libs/libarchfpga/src/physical_types.h	/^	char *input_string;$/;"	m	struct:t_interconnect	access:public
t_interconnect::interconnect_power	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect_power *interconnect_power;$/;"	m	struct:t_interconnect	access:public
t_interconnect::line_num	../../libs/libarchfpga/src/physical_types.h	/^	int line_num; \/* Interconnect is processed later, need to know what line number it messed up on to give proper error message *\/$/;"	m	struct:t_interconnect	access:public
t_interconnect::name	../../libs/libarchfpga/src/physical_types.h	/^	char *name;$/;"	m	struct:t_interconnect	access:public
t_interconnect::num_annotations	../../libs/libarchfpga/src/physical_types.h	/^	int num_annotations;$/;"	m	struct:t_interconnect	access:public
t_interconnect::output_string	../../libs/libarchfpga/src/physical_types.h	/^	char *output_string;$/;"	m	struct:t_interconnect	access:public
t_interconnect::parent_mode	../../libs/libarchfpga/src/physical_types.h	/^	t_mode *parent_mode;$/;"	m	struct:t_interconnect	access:public
t_interconnect::parent_mode_index	../../libs/libarchfpga/src/physical_types.h	/^	int parent_mode_index;$/;"	m	struct:t_interconnect	access:public
t_interconnect::type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_interconnect type;$/;"	m	struct:t_interconnect	typeref:enum:t_interconnect::e_interconnect	access:public
t_interconnect_pins	../../libs/libarchfpga/src/physical_types.h	/^struct t_interconnect_pins {$/;"	s
t_interconnect_pins::input_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin ***input_pins; \/\/ [0..num_input_ports-1][0..num_pins_per_port-1]$/;"	m	struct:t_interconnect_pins	access:public
t_interconnect_pins::interconnect	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:t_interconnect_pins	access:public
t_interconnect_pins::output_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin ***output_pins; \/\/ [0..num_output_ports-1][0..num_pins_per_port-1]$/;"	m	struct:t_interconnect_pins	access:public
t_interconnect_power	../../libs/libarchfpga/src/physical_types.h	/^struct t_interconnect_power {$/;"	s
t_interconnect_power::num_input_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_ports;$/;"	m	struct:t_interconnect_power	access:public
t_interconnect_power::num_output_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_ports;$/;"	m	struct:t_interconnect_power	access:public
t_interconnect_power::num_pins_per_port	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins_per_port;$/;"	m	struct:t_interconnect_power	access:public
t_interconnect_power::port_info_initialized	../../libs/libarchfpga/src/physical_types.h	/^	bool port_info_initialized;$/;"	m	struct:t_interconnect_power	access:public
t_interconnect_power::power_usage	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage;$/;"	m	struct:t_interconnect_power	access:public
t_interconnect_power::transistor_cnt	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt;$/;"	m	struct:t_interconnect_power	access:public
t_intra_lb_net	pack/pack_types.h	/^	t_intra_lb_net() {$/;"	f	struct:t_intra_lb_net	access:public	signature:()
t_intra_lb_net	pack/pack_types.h	/^struct t_intra_lb_net {$/;"	s
t_intra_lb_net::atom_net_id	pack/pack_types.h	/^    AtomNetId atom_net_id;              \/* index of atom net this intra_lb_net represents *\/$/;"	m	struct:t_intra_lb_net	access:public
t_intra_lb_net::atom_pins	pack/pack_types.h	/^    std::vector<AtomPinId> atom_pins;	\/* AtomPin's associated with each terminal *\/$/;"	m	struct:t_intra_lb_net	access:public
t_intra_lb_net::fixed_terminals	pack/pack_types.h	/^    std::vector<bool> fixed_terminals;  \/* Marks a terminal as having a fixed target (i.e. a pin not a sink) *\/$/;"	m	struct:t_intra_lb_net	access:public
t_intra_lb_net::rt_tree	pack/pack_types.h	/^	t_lb_trace *rt_tree;				\/* Route tree head *\/$/;"	m	struct:t_intra_lb_net	access:public
t_intra_lb_net::t_intra_lb_net	pack/pack_types.h	/^	t_intra_lb_net() {$/;"	f	struct:t_intra_lb_net	access:public	signature:()
t_intra_lb_net::terminals	pack/pack_types.h	/^    std::vector<int> terminals;			\/* endpoints of the intra_lb_net, 0th position is the source, all others are sinks *\/$/;"	m	struct:t_intra_lb_net	access:public
t_io	base/vpr_types.h	/^struct t_io {$/;"	s	class:ScreenUpdatePriority	access:private
t_lb_router_data	pack/pack_types.h	/^	t_lb_router_data() {$/;"	f	struct:t_lb_router_data	access:public	signature:()
t_lb_router_data	pack/pack_types.h	/^struct t_lb_router_data {$/;"	s
t_lb_router_data::atoms_added	pack/pack_types.h	/^    std::map<AtomBlockId, bool> *atoms_added;		\/* map that records which atoms are added to cluster router *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::explore_id_index	pack/pack_types.h	/^	int explore_id_index; \/* used in conjunction with node_traceback to determine whether or not a location has been explored.  By using a unique identifier every route, I don't have to clear the previous route exploration *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::explored_node_tb	pack/pack_types.h	/^	t_explored_node_tb *explored_node_tb; \/* [0..lb_type_graph->size()-1] Stores mode exploration and traceback info for nodes *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::intra_lb_nets	pack/pack_types.h	/^    std::vector<t_intra_lb_net> *intra_lb_nets;		\/* Pointer to vector of intra logic cluster_ctx.blocks nets and their connections *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::is_routed	pack/pack_types.h	/^	bool is_routed;							\/* Stores whether or not the current logical-to-physical mapping has a routed solution *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::lb_rr_node_stats	pack/pack_types.h	/^	t_lb_rr_node_stats *lb_rr_node_stats;		\/* [0..lb_type_graph->size()-1] Stats for each logic cluster_ctx.blocks rr node instance *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::lb_type	pack/pack_types.h	/^	t_type_ptr lb_type;$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::lb_type_graph	pack/pack_types.h	/^    std::vector<t_lb_type_rr_node> *lb_type_graph;	\/* Pointer to physical intra-logic cluster_ctx.blocks type rr graph *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::params	pack/pack_types.h	/^	t_lb_router_params params;$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::pres_con_fac	pack/pack_types.h	/^	float pres_con_fac;$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::saved_lb_nets	pack/pack_types.h	/^    std::vector<t_intra_lb_net> *saved_lb_nets;		\/* Save vector of intra logic cluster_ctx.blocks nets and their connections *\/$/;"	m	struct:t_lb_router_data	access:public
t_lb_router_data::t_lb_router_data	pack/pack_types.h	/^	t_lb_router_data() {$/;"	f	struct:t_lb_router_data	access:public	signature:()
t_lb_router_params	pack/pack_types.h	/^struct t_lb_router_params {$/;"	s
t_lb_router_params::hist_fac	pack/pack_types.h	/^	float hist_fac;$/;"	m	struct:t_lb_router_params	access:public
t_lb_router_params::max_iterations	pack/pack_types.h	/^	int max_iterations;$/;"	m	struct:t_lb_router_params	access:public
t_lb_router_params::pres_fac	pack/pack_types.h	/^	float pres_fac;$/;"	m	struct:t_lb_router_params	access:public
t_lb_router_params::pres_fac_mult	pack/pack_types.h	/^	float pres_fac_mult;$/;"	m	struct:t_lb_router_params	access:public
t_lb_rr_node_stats	pack/pack_types.h	/^	t_lb_rr_node_stats() {$/;"	f	struct:t_lb_rr_node_stats	access:public	signature:()
t_lb_rr_node_stats	pack/pack_types.h	/^struct t_lb_rr_node_stats {$/;"	s
t_lb_rr_node_stats::historical_usage	pack/pack_types.h	/^	int historical_usage;					\/* Historical usage of using this node *\/$/;"	m	struct:t_lb_rr_node_stats	access:public
t_lb_rr_node_stats::mode	pack/pack_types.h	/^	int mode;								\/* Mode that this rr_node is set to *\/$/;"	m	struct:t_lb_rr_node_stats	access:public
t_lb_rr_node_stats::occ	pack/pack_types.h	/^	int occ;								\/* Number of nets currently using this lb_rr_node *\/$/;"	m	struct:t_lb_rr_node_stats	access:public
t_lb_rr_node_stats::t_lb_rr_node_stats	pack/pack_types.h	/^	t_lb_rr_node_stats() {$/;"	f	struct:t_lb_rr_node_stats	access:public	signature:()
t_lb_trace	pack/pack_types.h	/^struct t_lb_trace {$/;"	s
t_lb_trace::current_node	pack/pack_types.h	/^	int	current_node;					\/* current t_lb_type_rr_node used by net *\/$/;"	m	struct:t_lb_trace	access:public
t_lb_trace::next_nodes	pack/pack_types.h	/^    std::vector<t_lb_trace> next_nodes;		\/* index of previous edge that drives current node *\/$/;"	m	struct:t_lb_trace	access:public
t_lb_traceback	pack/pack_types.h	/^struct t_lb_traceback {$/;"	s
t_lb_traceback::net	pack/pack_types.h	/^	int	net;				\/* net of flat, technology-mapped, netlist using this node *\/$/;"	m	struct:t_lb_traceback	access:public
t_lb_traceback::prev_edge	pack/pack_types.h	/^	int prev_edge;			\/* index of previous edge that drives current node *\/$/;"	m	struct:t_lb_traceback	access:public
t_lb_traceback::prev_lb_rr_node	pack/pack_types.h	/^	int prev_lb_rr_node;	\/* index of previous node that drives current node *\/$/;"	m	struct:t_lb_traceback	access:public
t_lb_type_rr_node	pack/pack_types.h	/^	t_lb_type_rr_node() {$/;"	f	struct:t_lb_type_rr_node	access:public	signature:()
t_lb_type_rr_node	pack/pack_types.h	/^struct t_lb_type_rr_node {$/;"	s
t_lb_type_rr_node::capacity	pack/pack_types.h	/^	short capacity;			\/* Number of nets that can simultaneously use this node *\/$/;"	m	struct:t_lb_type_rr_node	access:public
t_lb_type_rr_node::intrinsic_cost	pack/pack_types.h	/^	float intrinsic_cost;					\/* cost of this node *\/$/;"	m	struct:t_lb_type_rr_node	access:public
t_lb_type_rr_node::num_fanout	pack/pack_types.h	/^	short *num_fanout;		\/* [0..num_modes - 1] Mode dependant fanout *\/$/;"	m	struct:t_lb_type_rr_node	access:public
t_lb_type_rr_node::outedges	pack/pack_types.h	/^	t_lb_type_rr_node_edge **outedges;						\/* [0..num_modes - 1][0..num_fanout-1] index and cost of out edges *\/$/;"	m	struct:t_lb_type_rr_node	access:public
t_lb_type_rr_node::pb_graph_pin	pack/pack_types.h	/^	t_pb_graph_pin *pb_graph_pin;	\/* pb_graph_pin associated with this lb_rr_node if exists, NULL otherwise *\/$/;"	m	struct:t_lb_type_rr_node	access:public
t_lb_type_rr_node::t_lb_type_rr_node	pack/pack_types.h	/^	t_lb_type_rr_node() {$/;"	f	struct:t_lb_type_rr_node	access:public	signature:()
t_lb_type_rr_node::type	pack/pack_types.h	/^	enum e_lb_rr_type type;	\/* Type of logic cluster_ctx.blocks resource node *\/$/;"	m	struct:t_lb_type_rr_node	typeref:enum:t_lb_type_rr_node::e_lb_rr_type	access:public
t_lb_type_rr_node_edge	pack/pack_types.h	/^struct t_lb_type_rr_node_edge {$/;"	s
t_lb_type_rr_node_edge::intrinsic_cost	pack/pack_types.h	/^	float intrinsic_cost;$/;"	m	struct:t_lb_type_rr_node_edge	access:public
t_lb_type_rr_node_edge::node_index	pack/pack_types.h	/^	int node_index;$/;"	m	struct:t_lb_type_rr_node_edge	access:public
t_legal_pos	base/vpr_types.h	/^struct t_legal_pos {$/;"	s	class:ScreenUpdatePriority	access:private
t_linked_f_pointer	base/vpr_types.h	/^struct t_linked_f_pointer {$/;"	s	class:ScreenUpdatePriority	access:private
t_linked_int	../../libs/libvtrutil/src/vtr_list.h	/^    struct t_linked_int {$/;"	s	namespace:vtr
t_linked_rc_edge	timing/net_delay.cpp	/^struct t_linked_rc_edge {$/;"	s	file:
t_linked_rc_edge::child	timing/net_delay.cpp	/^	t_rc_node *child;$/;"	m	struct:t_linked_rc_edge	file:	access:public
t_linked_rc_edge::iswitch	timing/net_delay.cpp	/^	short iswitch;$/;"	m	struct:t_linked_rc_edge	file:	access:public
t_linked_rc_edge::next	timing/net_delay.cpp	/^	t_linked_rc_edge *next;$/;"	m	struct:t_linked_rc_edge	file:	access:public
t_linked_rc_ptr	timing/net_delay.cpp	/^struct t_linked_rc_ptr {$/;"	s	file:
t_linked_rc_ptr::next	timing/net_delay.cpp	/^	t_linked_rc_ptr *next;$/;"	m	struct:t_linked_rc_ptr	file:	access:public
t_linked_rc_ptr::rc_node	timing/net_delay.cpp	/^	t_rc_node *rc_node;$/;"	m	struct:t_linked_rc_ptr	file:	access:public
t_linked_rt_edge	route/route_tree_type.h	/^struct t_linked_rt_edge {$/;"	s
t_linked_rt_edge::child	route/route_tree_type.h	/^	t_rt_node *child;$/;"	m	struct:t_linked_rt_edge	access:public
t_linked_rt_edge::iswitch	route/route_tree_type.h	/^	short iswitch;$/;"	m	struct:t_linked_rt_edge	access:public
t_linked_rt_edge::next	route/route_tree_type.h	/^	t_linked_rt_edge *next;$/;"	m	struct:t_linked_rt_edge	access:public
t_linked_vptr	../../libs/libvtrutil/src/vtr_list.h	/^    struct t_linked_vptr {$/;"	s	namespace:vtr
t_log	power/power.h	/^struct t_log {$/;"	s
t_log::messages	power/power.h	/^	char ** messages;$/;"	m	struct:t_log	access:public
t_log::name	power/power.h	/^	char * name;$/;"	m	struct:t_log	access:public
t_log::num_messages	power/power.h	/^	int num_messages;$/;"	m	struct:t_log	access:public
t_mode	../../libs/libarchfpga/src/physical_types.h	/^struct t_mode {$/;"	s
t_mode::index	../../libs/libarchfpga/src/physical_types.h	/^	int index;$/;"	m	struct:t_mode	access:public
t_mode::interconnect	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:t_mode	access:public
t_mode::mode_power	../../libs/libarchfpga/src/physical_types.h	/^	t_mode_power * mode_power;$/;"	m	struct:t_mode	access:public
t_mode::name	../../libs/libarchfpga/src/physical_types.h	/^	char* name;$/;"	m	struct:t_mode	access:public
t_mode::num_interconnect	../../libs/libarchfpga/src/physical_types.h	/^	int num_interconnect;$/;"	m	struct:t_mode	access:public
t_mode::num_pb_type_children	../../libs/libarchfpga/src/physical_types.h	/^	int num_pb_type_children;$/;"	m	struct:t_mode	access:public
t_mode::parent_pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *parent_pb_type;$/;"	m	struct:t_mode	access:public
t_mode::pb_type_children	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *pb_type_children; \/* [0..num_child_pb_types] *\/$/;"	m	struct:t_mode	access:public
t_mode_power	../../libs/libarchfpga/src/physical_types.h	/^struct t_mode_power {$/;"	s
t_mode_power::power_usage	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage; \/* Power usage of this mode *\/$/;"	m	struct:t_mode_power	access:public
t_model	../../libs/libarchfpga/src/logic_types.h	/^struct t_model {$/;"	s
t_model::index	../../libs/libarchfpga/src/logic_types.h	/^	int index = -1;$/;"	m	struct:t_model	access:public
t_model::inputs	../../libs/libarchfpga/src/logic_types.h	/^	t_model_ports *inputs = nullptr; \/* linked list of input\/clock ports *\/$/;"	m	struct:t_model	access:public
t_model::instances	../../libs/libarchfpga/src/logic_types.h	/^	void *instances = nullptr;$/;"	m	struct:t_model	access:public
t_model::name	../../libs/libarchfpga/src/logic_types.h	/^	char *name = nullptr; \/* name of this logic model *\/$/;"	m	struct:t_model	access:public
t_model::next	../../libs/libarchfpga/src/logic_types.h	/^	t_model *next = nullptr; \/* next model (linked list) *\/$/;"	m	struct:t_model	access:public
t_model::outputs	../../libs/libarchfpga/src/logic_types.h	/^	t_model_ports *outputs = nullptr; \/* linked list of output ports *\/$/;"	m	struct:t_model	access:public
t_model::pb_types	../../libs/libarchfpga/src/logic_types.h	/^    vtr::t_linked_vptr *pb_types = nullptr; \/* Physical block types that implement this model *\/$/;"	m	struct:t_model	access:public
t_model::used	../../libs/libarchfpga/src/logic_types.h	/^	int used = 0;$/;"	m	struct:t_model	access:public
t_model_chain_pattern	../../libs/libarchfpga/src/cad_types.h	/^struct t_model_chain_pattern {$/;"	s
t_model_chain_pattern::inport_link_pin	../../libs/libarchfpga/src/cad_types.h	/^	int inport_link_pin; \/* applicable pin of chain input port *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_chain_pattern::input_link_port	../../libs/libarchfpga/src/cad_types.h	/^	t_model_ports *input_link_port; \/* pointer to port of chain input *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_chain_pattern::model	../../libs/libarchfpga/src/cad_types.h	/^	t_model *model; \/* block associated with chain *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_chain_pattern::name	../../libs/libarchfpga/src/cad_types.h	/^	char *name; \/* name of this chain of logic *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_chain_pattern::next	../../libs/libarchfpga/src/cad_types.h	/^	t_model_chain_pattern *next; \/* next chain (linked list) *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_chain_pattern::outport_link_pin	../../libs/libarchfpga/src/cad_types.h	/^	int outport_link_pin; \/* applicable pin of chain output port *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_chain_pattern::output_link_port	../../libs/libarchfpga/src/cad_types.h	/^	t_model_ports *output_link_port; \/* pointer to port of chain output *\/$/;"	m	struct:t_model_chain_pattern	access:public
t_model_ports	../../libs/libarchfpga/src/logic_types.h	/^struct t_model_ports {$/;"	s
t_model_ports::clock	../../libs/libarchfpga/src/logic_types.h	/^    std::string clock; \/* The clock associated with this pin (if the pin is sequential) *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::combinational_sink_ports	../../libs/libarchfpga/src/logic_types.h	/^    std::vector<std::string> combinational_sink_ports; \/* The other ports on this model which are combinationally driven by this port *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::dir	../../libs/libarchfpga/src/logic_types.h	/^	enum PORTS dir = ERR_PORT; \/* port direction *\/$/;"	m	struct:t_model_ports	typeref:enum:t_model_ports::PORTS	access:public
t_model_ports::index	../../libs/libarchfpga/src/logic_types.h	/^	int index = -1; \/* indexing for array look-up *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::is_clock	../../libs/libarchfpga/src/logic_types.h	/^	bool is_clock = false; \/* clock? *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::is_non_clock_global	../../libs/libarchfpga/src/logic_types.h	/^	bool is_non_clock_global = false; \/* not a clock but is a special, global, control signal (eg global asynchronous reset, etc) *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::min_size	../../libs/libarchfpga/src/logic_types.h	/^	int min_size = 0; \/* minimum number of pins *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::name	../../libs/libarchfpga/src/logic_types.h	/^	char *name = nullptr; \/* name of this port *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::next	../../libs/libarchfpga/src/logic_types.h	/^	t_model_ports *next = nullptr; \/* next port *\/$/;"	m	struct:t_model_ports	access:public
t_model_ports::size	../../libs/libarchfpga/src/logic_types.h	/^	int size = 0; \/* maximum number of pins *\/$/;"	m	struct:t_model_ports	access:public
t_molecule_link	pack/cluster.cpp	/^struct t_molecule_link {$/;"	s	file:
t_molecule_link::moleculeptr	pack/cluster.cpp	/^	t_pack_molecule *moleculeptr;$/;"	m	struct:t_molecule_link	file:	access:public
t_molecule_link::next	pack/cluster.cpp	/^	t_molecule_link *next;$/;"	m	struct:t_molecule_link	file:	access:public
t_molecule_stats	pack/cluster.cpp	/^struct t_molecule_stats {$/;"	s	file:
t_molecule_stats::num_blocks	pack/cluster.cpp	/^    int num_blocks = 0;        \/\/Number of blocks across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_molecule_stats::num_input_pins	pack/cluster.cpp	/^    int num_input_pins = 0;    \/\/Number of input pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_molecule_stats::num_output_pins	pack/cluster.cpp	/^    int num_output_pins = 0;   \/\/Number of output pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_molecule_stats::num_pins	pack/cluster.cpp	/^    int num_pins = 0;          \/\/Number of pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_molecule_stats::num_used_ext_inputs	pack/cluster.cpp	/^    int num_used_ext_inputs = 0;   \/\/Number of *used external* input pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_molecule_stats::num_used_ext_outputs	pack/cluster.cpp	/^    int num_used_ext_outputs = 0;  \/\/Number of *used external* output pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_molecule_stats::num_used_ext_pins	pack/cluster.cpp	/^    int num_used_ext_pins = 0;     \/\/Number of *used external* pins across all primitives in molecule$/;"	m	struct:t_molecule_stats	file:	access:public
t_mux	route/rr_graph.cpp	/^struct t_mux {$/;"	s	file:
t_mux::next	route/rr_graph.cpp	/^    t_mux *next;$/;"	m	struct:t_mux	file:	access:public
t_mux::size	route/rr_graph.cpp	/^    int size;$/;"	m	struct:t_mux	file:	access:public
t_mux_arch	power/power.h	/^struct t_mux_arch {$/;"	s
t_mux_arch::levels	power/power.h	/^	int levels;$/;"	m	struct:t_mux_arch	access:public
t_mux_arch::mux_graph_head	power/power.h	/^	t_mux_node * mux_graph_head;$/;"	m	struct:t_mux_arch	access:public
t_mux_arch::num_inputs	power/power.h	/^	int num_inputs;$/;"	m	struct:t_mux_arch	access:public
t_mux_arch::transistor_size	power/power.h	/^	float transistor_size;$/;"	m	struct:t_mux_arch	access:public
t_mux_node	power/power.h	/^struct t_mux_node {$/;"	s
t_mux_node::children	power/power.h	/^	t_mux_node * children; \/* Multiplexers that drive the inputs [0..num_inputs-1] *\/$/;"	m	struct:t_mux_node	access:public
t_mux_node::level	power/power.h	/^	int level; \/* Level in the full multilevel mux - 0 = primary inputs to mux *\/$/;"	m	struct:t_mux_node	access:public
t_mux_node::level_restorer	power/power.h	/^	bool level_restorer; \/* Whether the output of this mux is level restored *\/$/;"	m	struct:t_mux_node	access:public
t_mux_node::num_inputs	power/power.h	/^	int num_inputs; \/* Number of inputs *\/$/;"	m	struct:t_mux_node	access:public
t_mux_node::starting_pin_idx	power/power.h	/^	int starting_pin_idx; \/* Applicable to level 0 only, the overall mux primary input index *\/$/;"	m	struct:t_mux_node	access:public
t_mux_size_distribution	route/rr_graph.cpp	/^struct t_mux_size_distribution {$/;"	s	file:
t_mux_size_distribution::distr	route/rr_graph.cpp	/^    int *distr;$/;"	m	struct:t_mux_size_distribution	file:	access:public
t_mux_size_distribution::max_index	route/rr_graph.cpp	/^    int max_index;$/;"	m	struct:t_mux_size_distribution	file:	access:public
t_mux_size_distribution::mux_count	route/rr_graph.cpp	/^    int mux_count;$/;"	m	struct:t_mux_size_distribution	file:	access:public
t_mux_size_distribution::next	route/rr_graph.cpp	/^    t_mux_size_distribution *next;$/;"	m	struct:t_mux_size_distribution	file:	access:public
t_net_power	base/vpr_types.h	/^struct t_net_power {$/;"	s	class:ScreenUpdatePriority	access:private
t_net_routing_status	base/vpr_types.h	/^struct t_net_routing_status {$/;"	s	class:ScreenUpdatePriority	access:private
t_netlist_opts	base/vpr_types.h	/^struct t_netlist_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_node_edge	route/check_route.cpp	/^    t_node_edge(int fnode, int tnode) {$/;"	f	struct:t_node_edge	access:public	signature:(int fnode, int tnode)
t_node_edge	route/check_route.cpp	/^struct t_node_edge {$/;"	s	file:
t_node_edge::from_node	route/check_route.cpp	/^    int from_node;$/;"	m	struct:t_node_edge	file:	access:public
t_node_edge::operator <	route/check_route.cpp	/^    friend bool operator<(const t_node_edge& lhs, const t_node_edge& rhs) {$/;"	f	struct:t_node_edge	access:friend	signature:(const t_node_edge& lhs, const t_node_edge& rhs)
t_node_edge::t_node_edge	route/check_route.cpp	/^    t_node_edge(int fnode, int tnode) {$/;"	f	struct:t_node_edge	access:public	signature:(int fnode, int tnode)
t_node_edge::to_node	route/check_route.cpp	/^    int to_node;$/;"	m	struct:t_node_edge	file:	access:public
t_non_configurable_rr_sets	route/check_route.cpp	/^struct t_non_configurable_rr_sets {$/;"	s	file:
t_non_configurable_rr_sets::edge_sets	route/check_route.cpp	/^    std::set<std::set<t_node_edge>> edge_sets;$/;"	m	struct:t_non_configurable_rr_sets	file:	access:public
t_non_configurable_rr_sets::node_sets	route/check_route.cpp	/^    std::set<std::set<int>> node_sets;$/;"	m	struct:t_non_configurable_rr_sets	file:	access:public
t_operator	../../libs/libarchfpga/src/expr_eval.cpp	/^} t_operator;$/;"	t	typeref:enum:e_operator	file:
t_options	base/read_options.h	/^struct t_options {$/;"	s
t_options::ActFile	base/read_options.h	/^    argparse::ArgValue<std::string> ActFile;$/;"	m	struct:t_options	access:public
t_options::ArchFile	base/read_options.h	/^    argparse::ArgValue<std::string> ArchFile;$/;"	m	struct:t_options	access:public
t_options::BlifFile	base/read_options.h	/^    argparse::ArgValue<std::string> BlifFile;$/;"	m	struct:t_options	access:public
t_options::CircuitName	base/read_options.h	/^    argparse::ArgValue<std::string> CircuitName;$/;"	m	struct:t_options	access:public
t_options::CmosTechFile	base/read_options.h	/^    argparse::ArgValue<std::string> CmosTechFile;$/;"	m	struct:t_options	access:public
t_options::CreateEchoFile	base/read_options.h	/^    argparse::ArgValue<bool> CreateEchoFile;$/;"	m	struct:t_options	access:public
t_options::Generate_Post_Synthesis_Netlist	base/read_options.h	/^    argparse::ArgValue<bool> Generate_Post_Synthesis_Netlist;$/;"	m	struct:t_options	access:public
t_options::GraphPause	base/read_options.h	/^    argparse::ArgValue<int> GraphPause;$/;"	m	struct:t_options	access:public
t_options::NetFile	base/read_options.h	/^    argparse::ArgValue<std::string> NetFile;$/;"	m	struct:t_options	access:public
t_options::PlaceAlgorithm	base/read_options.h	/^    argparse::ArgValue<e_place_algorithm> PlaceAlgorithm;$/;"	m	struct:t_options	access:public
t_options::PlaceAlphaT	base/read_options.h	/^    argparse::ArgValue<float> PlaceAlphaT;$/;"	m	struct:t_options	access:public
t_options::PlaceChanWidth	base/read_options.h	/^    argparse::ArgValue<int> PlaceChanWidth;$/;"	m	struct:t_options	access:public
t_options::PlaceExitT	base/read_options.h	/^    argparse::ArgValue<float> PlaceExitT;$/;"	m	struct:t_options	access:public
t_options::PlaceFile	base/read_options.h	/^    argparse::ArgValue<std::string> PlaceFile;$/;"	m	struct:t_options	access:public
t_options::PlaceInitT	base/read_options.h	/^    argparse::ArgValue<float> PlaceInitT;$/;"	m	struct:t_options	access:public
t_options::PlaceInnerNum	base/read_options.h	/^    argparse::ArgValue<float> PlaceInnerNum;$/;"	m	struct:t_options	access:public
t_options::PlaceTimingTradeoff	base/read_options.h	/^    argparse::ArgValue<float> PlaceTimingTradeoff;$/;"	m	struct:t_options	access:public
t_options::PowerFile	base/read_options.h	/^    argparse::ArgValue<std::string> PowerFile;$/;"	m	struct:t_options	access:public
t_options::RecomputeCritIter	base/read_options.h	/^    argparse::ArgValue<int> RecomputeCritIter;$/;"	m	struct:t_options	access:public
t_options::RouteChanWidth	base/read_options.h	/^    argparse::ArgValue<int> RouteChanWidth;$/;"	m	struct:t_options	access:public
t_options::RouteFile	base/read_options.h	/^    argparse::ArgValue<std::string> RouteFile;$/;"	m	struct:t_options	access:public
t_options::RouteType	base/read_options.h	/^    argparse::ArgValue<e_route_type> RouteType;$/;"	m	struct:t_options	access:public
t_options::RouterAlgorithm	base/read_options.h	/^    argparse::ArgValue<e_router_algorithm> RouterAlgorithm;$/;"	m	struct:t_options	access:public
t_options::SDCFile	base/read_options.h	/^    argparse::ArgValue<std::string> SDCFile;$/;"	m	struct:t_options	access:public
t_options::Seed	base/read_options.h	/^    argparse::ArgValue<int> Seed;$/;"	m	struct:t_options	access:public
t_options::ShowPlaceTiming	base/read_options.h	/^    argparse::ArgValue<bool> ShowPlaceTiming;$/;"	m	struct:t_options	access:public
t_options::SlackDefinition	base/read_options.h	/^    argparse::ArgValue<std::string> SlackDefinition; \/\/TODO: eventually remove$/;"	m	struct:t_options	access:public
t_options::absorb_buffer_luts	base/read_options.h	/^    argparse::ArgValue<bool> absorb_buffer_luts;$/;"	m	struct:t_options	access:public
t_options::acc_fac	base/read_options.h	/^    argparse::ArgValue<float> acc_fac;$/;"	m	struct:t_options	access:public
t_options::allow_unrelated_clustering	base/read_options.h	/^    argparse::ArgValue<e_unrelated_clustering> allow_unrelated_clustering;$/;"	m	struct:t_options	access:public
t_options::alpha_clustering	base/read_options.h	/^    argparse::ArgValue<float> alpha_clustering;$/;"	m	struct:t_options	access:public
t_options::anneal_sched_type	base/read_options.h	/^    argparse::ArgValue<sched_type> anneal_sched_type;$/;"	m	struct:t_options	access:public
t_options::astar_fac	base/read_options.h	/^    argparse::ArgValue<float> astar_fac;$/;"	m	struct:t_options	access:public
t_options::base_cost_type	base/read_options.h	/^    argparse::ArgValue<e_base_cost_type> base_cost_type;$/;"	m	struct:t_options	access:public
t_options::bb_factor	base/read_options.h	/^    argparse::ArgValue<int> bb_factor;$/;"	m	struct:t_options	access:public
t_options::bend_cost	base/read_options.h	/^    argparse::ArgValue<float> bend_cost;$/;"	m	struct:t_options	access:public
t_options::beta_clustering	base/read_options.h	/^    argparse::ArgValue<float> beta_clustering;$/;"	m	struct:t_options	access:public
t_options::circuit_format	base/read_options.h	/^    argparse::ArgValue<e_circuit_format> circuit_format;$/;"	m	struct:t_options	access:public
t_options::clock_modeling	base/read_options.h	/^    argparse::ArgValue<e_clock_modeling> clock_modeling;$/;"	m	struct:t_options	access:public
t_options::cluster_seed_type	base/read_options.h	/^    argparse::ArgValue<e_cluster_seed> cluster_seed_type;$/;"	m	struct:t_options	access:public
t_options::congested_routing_iteration_threshold_frac	base/read_options.h	/^    argparse::ArgValue<float> congested_routing_iteration_threshold_frac;$/;"	m	struct:t_options	access:public
t_options::connection_driven_clustering	base/read_options.h	/^    argparse::ArgValue<bool> connection_driven_clustering;$/;"	m	struct:t_options	access:public
t_options::const_gen_inference	base/read_options.h	/^    argparse::ArgValue<e_const_gen_inference> const_gen_inference;$/;"	m	struct:t_options	access:public
t_options::constant_net_method	base/read_options.h	/^    argparse::ArgValue<e_constant_net_method> constant_net_method;$/;"	m	struct:t_options	access:public
t_options::criticality_exp	base/read_options.h	/^    argparse::ArgValue<float> criticality_exp;$/;"	m	struct:t_options	access:public
t_options::device_layout	base/read_options.h	/^    argparse::ArgValue<std::string> device_layout;$/;"	m	struct:t_options	access:public
t_options::do_analysis	base/read_options.h	/^    argparse::ArgValue<bool> do_analysis;$/;"	m	struct:t_options	access:public
t_options::do_packing	base/read_options.h	/^    argparse::ArgValue<bool> do_packing;$/;"	m	struct:t_options	access:public
t_options::do_placement	base/read_options.h	/^    argparse::ArgValue<bool> do_placement;$/;"	m	struct:t_options	access:public
t_options::do_power	base/read_options.h	/^    argparse::ArgValue<bool> do_power;$/;"	m	struct:t_options	access:public
t_options::do_routing	base/read_options.h	/^    argparse::ArgValue<bool> do_routing;$/;"	m	struct:t_options	access:public
t_options::enable_clustering_pin_feasibility_filter	base/read_options.h	/^    argparse::ArgValue<bool> enable_clustering_pin_feasibility_filter;$/;"	m	struct:t_options	access:public
t_options::exit_before_pack	base/read_options.h	/^    argparse::ArgValue<bool> exit_before_pack;$/;"	m	struct:t_options	access:public
t_options::first_iter_pres_fac	base/read_options.h	/^    argparse::ArgValue<float> first_iter_pres_fac;$/;"	m	struct:t_options	access:public
t_options::full_stats	base/read_options.h	/^    argparse::ArgValue<bool> full_stats;$/;"	m	struct:t_options	access:public
t_options::hmetis_input_file	base/read_options.h	/^    argparse::ArgValue<std::string> hmetis_input_file;$/;"	m	struct:t_options	access:public
t_options::incr_reroute_delay_ripup	base/read_options.h	/^    argparse::ArgValue<e_incr_reroute_delay_ripup> incr_reroute_delay_ripup;$/;"	m	struct:t_options	access:public
t_options::initial_pres_fac	base/read_options.h	/^    argparse::ArgValue<float> initial_pres_fac;$/;"	m	struct:t_options	access:public
t_options::inner_loop_recompute_divider	base/read_options.h	/^    argparse::ArgValue<int> inner_loop_recompute_divider;$/;"	m	struct:t_options	access:public
t_options::max_criticality	base/read_options.h	/^    argparse::ArgValue<float> max_criticality;$/;"	m	struct:t_options	access:public
t_options::max_router_iterations	base/read_options.h	/^    argparse::ArgValue<int> max_router_iterations;$/;"	m	struct:t_options	access:public
t_options::min_incremental_reroute_fanout	base/read_options.h	/^    argparse::ArgValue<int> min_incremental_reroute_fanout;$/;"	m	struct:t_options	access:public
t_options::min_route_chan_width_hint	base/read_options.h	/^    argparse::ArgValue<int> min_route_chan_width_hint; \/\/Hint to binary search router about what the min chan width is$/;"	m	struct:t_options	access:public
t_options::netlist_verbosity	base/read_options.h	/^    argparse::ArgValue<int> netlist_verbosity;$/;"	m	struct:t_options	access:public
t_options::num_workers	base/read_options.h	/^    argparse::ArgValue<size_t> num_workers;$/;"	m	struct:t_options	access:public
t_options::out_file_prefix	base/read_options.h	/^    argparse::ArgValue<std::string> out_file_prefix;$/;"	m	struct:t_options	access:public
t_options::pack_verbosity	base/read_options.h	/^    argparse::ArgValue<int> pack_verbosity;$/;"	m	struct:t_options	access:public
t_options::pad_loc_file	base/read_options.h	/^    argparse::ArgValue<std::string> pad_loc_file;$/;"	m	struct:t_options	access:public
t_options::pad_loc_type	base/read_options.h	/^    argparse::ArgValue<e_pad_loc_type> pad_loc_type;$/;"	m	struct:t_options	access:public
t_options::place_delay_model	base/read_options.h	/^    argparse::ArgValue<PlaceDelayModelType> place_delay_model;$/;"	m	struct:t_options	access:public
t_options::place_delay_model_reducer	base/read_options.h	/^    argparse::ArgValue<e_reducer> place_delay_model_reducer;$/;"	m	struct:t_options	access:public
t_options::place_delay_offset	base/read_options.h	/^    argparse::ArgValue<float> place_delay_offset;$/;"	m	struct:t_options	access:public
t_options::place_delay_ramp_delta_threshold	base/read_options.h	/^    argparse::ArgValue<int> place_delay_ramp_delta_threshold;$/;"	m	struct:t_options	access:public
t_options::place_delay_ramp_slope	base/read_options.h	/^    argparse::ArgValue<float> place_delay_ramp_slope;$/;"	m	struct:t_options	access:public
t_options::place_exp_first	base/read_options.h	/^    argparse::ArgValue<float> place_exp_first;$/;"	m	struct:t_options	access:public
t_options::place_exp_last	base/read_options.h	/^    argparse::ArgValue<float> place_exp_last;$/;"	m	struct:t_options	access:public
t_options::place_tsu_abs_margin	base/read_options.h	/^    argparse::ArgValue<float> place_tsu_abs_margin;$/;"	m	struct:t_options	access:public
t_options::place_tsu_rel_margin	base/read_options.h	/^    argparse::ArgValue<float> place_tsu_rel_margin;$/;"	m	struct:t_options	access:public
t_options::post_place_timing_report_file	base/read_options.h	/^    argparse::ArgValue<std::string> post_place_timing_report_file;$/;"	m	struct:t_options	access:public
t_options::pres_fac_mult	base/read_options.h	/^    argparse::ArgValue<float> pres_fac_mult;$/;"	m	struct:t_options	access:public
t_options::read_rr_graph_file	base/read_options.h	/^    argparse::ArgValue<std::string> read_rr_graph_file;$/;"	m	struct:t_options	access:public
t_options::route_bb_update	base/read_options.h	/^    argparse::ArgValue<e_route_bb_update> route_bb_update;$/;"	m	struct:t_options	access:public
t_options::router_debug_net	base/read_options.h	/^    argparse::ArgValue<int> router_debug_net;$/;"	m	struct:t_options	access:public
t_options::router_debug_sink_rr	base/read_options.h	/^    argparse::ArgValue<int> router_debug_sink_rr;$/;"	m	struct:t_options	access:public
t_options::router_first_iteration_timing_report_file	base/read_options.h	/^    argparse::ArgValue<std::string> router_first_iteration_timing_report_file;$/;"	m	struct:t_options	access:public
t_options::router_high_fanout_threshold	base/read_options.h	/^    argparse::ArgValue<int> router_high_fanout_threshold;$/;"	m	struct:t_options	access:public
t_options::router_lookahead_type	base/read_options.h	/^    argparse::ArgValue<e_router_lookahead> router_lookahead_type;$/;"	m	struct:t_options	access:public
t_options::router_max_convergence_count	base/read_options.h	/^    argparse::ArgValue<int> router_max_convergence_count;$/;"	m	struct:t_options	access:public
t_options::router_reconvergence_cpd_threshold	base/read_options.h	/^    argparse::ArgValue<float> router_reconvergence_cpd_threshold;$/;"	m	struct:t_options	access:public
t_options::routing_budgets_algorithm	base/read_options.h	/^    argparse::ArgValue<e_routing_budgets_algorithm> routing_budgets_algorithm;$/;"	m	struct:t_options	access:public
t_options::routing_failure_predictor	base/read_options.h	/^    argparse::ArgValue<e_routing_failure_predictor> routing_failure_predictor;$/;"	m	struct:t_options	access:public
t_options::save_routing_per_iteration	base/read_options.h	/^    argparse::ArgValue<bool> save_routing_per_iteration;$/;"	m	struct:t_options	access:public
t_options::show_graphics	base/read_options.h	/^    argparse::ArgValue<bool> show_graphics; \/\/Enable argparse::ArgValue<int>eractive graphics?$/;"	m	struct:t_options	access:public
t_options::show_help	base/read_options.h	/^    argparse::ArgValue<bool> show_help;$/;"	m	struct:t_options	access:public
t_options::show_version	base/read_options.h	/^    argparse::ArgValue<bool> show_version;$/;"	m	struct:t_options	access:public
t_options::sweep_constant_primary_outputs	base/read_options.h	/^    argparse::ArgValue<bool> sweep_constant_primary_outputs;$/;"	m	struct:t_options	access:public
t_options::sweep_dangling_blocks	base/read_options.h	/^    argparse::ArgValue<bool> sweep_dangling_blocks;$/;"	m	struct:t_options	access:public
t_options::sweep_dangling_nets	base/read_options.h	/^    argparse::ArgValue<bool> sweep_dangling_nets;$/;"	m	struct:t_options	access:public
t_options::sweep_dangling_primary_ios	base/read_options.h	/^    argparse::ArgValue<bool> sweep_dangling_primary_ios;$/;"	m	struct:t_options	access:public
t_options::target_device_utilization	base/read_options.h	/^    argparse::ArgValue<float> target_device_utilization;$/;"	m	struct:t_options	access:public
t_options::target_external_pin_util	base/read_options.h	/^    argparse::ArgValue<std::vector<std::string>> target_external_pin_util;$/;"	m	struct:t_options	access:public
t_options::timing_analysis	base/read_options.h	/^    argparse::ArgValue<bool> timing_analysis;$/;"	m	struct:t_options	access:public
t_options::timing_driven_clustering	base/read_options.h	/^    argparse::ArgValue<bool> timing_driven_clustering;$/;"	m	struct:t_options	access:public
t_options::timing_report_detail	base/read_options.h	/^    argparse::ArgValue<e_timing_report_detail> timing_report_detail;$/;"	m	struct:t_options	access:public
t_options::timing_report_npaths	base/read_options.h	/^    argparse::ArgValue<int> timing_report_npaths;$/;"	m	struct:t_options	access:public
t_options::timing_report_skew	base/read_options.h	/^    argparse::ArgValue<bool> timing_report_skew;$/;"	m	struct:t_options	access:public
t_options::verify_binary_search	base/read_options.h	/^    argparse::ArgValue<bool> verify_binary_search;$/;"	m	struct:t_options	access:public
t_options::verify_file_digests	base/read_options.h	/^    argparse::ArgValue<bool> verify_file_digests;$/;"	m	struct:t_options	access:public
t_options::write_rr_graph_file	base/read_options.h	/^    argparse::ArgValue<std::string> write_rr_graph_file;$/;"	m	struct:t_options	access:public
t_override	place/place_delay_model.h	/^        struct t_override {$/;"	s	class:OverrideDelayModel	access:private
t_override_constraint	base/vpr_types.h	/^struct t_override_constraint {$/;"	s	class:ScreenUpdatePriority	access:private
t_pack_molecule	base/vpr_types.h	/^struct t_pack_molecule {$/;"	s	class:ScreenUpdatePriority	access:private
t_pack_pattern_block	../../libs/libarchfpga/src/cad_types.h	/^struct t_pack_pattern_block {$/;"	s
t_pack_pattern_block::block_id	../../libs/libarchfpga/src/cad_types.h	/^	int block_id;$/;"	m	struct:t_pack_pattern_block	access:public
t_pack_pattern_block::connections	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_connections *connections; \/* linked list of connections of logic blocks in pattern *\/$/;"	m	struct:t_pack_pattern_block	access:public
t_pack_pattern_block::pattern_index	../../libs/libarchfpga/src/cad_types.h	/^	int pattern_index; \/* index of pattern that this block is a part of *\/$/;"	m	struct:t_pack_pattern_block	access:public
t_pack_pattern_block::pb_type	../../libs/libarchfpga/src/cad_types.h	/^	const t_pb_type *pb_type; \/* pb_type that this block is an instance of *\/$/;"	m	struct:t_pack_pattern_block	access:public
t_pack_pattern_connections	../../libs/libarchfpga/src/cad_types.h	/^struct t_pack_pattern_connections {$/;"	s
t_pack_pattern_connections::from_block	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_block *from_block;$/;"	m	struct:t_pack_pattern_connections	access:public
t_pack_pattern_connections::from_pin	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_pin *from_pin;$/;"	m	struct:t_pack_pattern_connections	access:public
t_pack_pattern_connections::next	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_connections *next;$/;"	m	struct:t_pack_pattern_connections	access:public
t_pack_pattern_connections::to_block	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_block *to_block;$/;"	m	struct:t_pack_pattern_connections	access:public
t_pack_pattern_connections::to_pin	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_pin *to_pin;$/;"	m	struct:t_pack_pattern_connections	access:public
t_pack_patterns	../../libs/libarchfpga/src/cad_types.h	/^struct t_pack_patterns {$/;"	s
t_pack_patterns::base_cost	../../libs/libarchfpga/src/cad_types.h	/^	float base_cost; \/* base cost of pattern eg. If a group of logical blocks match a pattern of smaller primitives, that is better than the same group using bigger primitives *\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::chain_root_pin	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_pin *chain_root_pin; \/* pointer to logic block input pin that drives this chain from the preceding logic block *\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::index	../../libs/libarchfpga/src/cad_types.h	/^	int index; \/* array index  for pattern*\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::is_block_optional	../../libs/libarchfpga/src/cad_types.h	/^	bool *is_block_optional; \/* [0..num_blocks-1] is the block_id in this pattern mandatory or optional to form a molecule *\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::is_chain	../../libs/libarchfpga/src/cad_types.h	/^	bool is_chain; \/* Does this pattern chain across logic blocks *\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::name	../../libs/libarchfpga/src/cad_types.h	/^	char *name; \/* name of this logic model pattern *\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::num_blocks	../../libs/libarchfpga/src/cad_types.h	/^	int num_blocks; \/* number of blocks in pattern *\/$/;"	m	struct:t_pack_patterns	access:public
t_pack_patterns::root_block	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_block *root_block; \/* root block used by this pattern *\/$/;"	m	struct:t_pack_patterns	access:public
t_packer_opts	base/vpr_types.h	/^struct t_packer_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_panning_state	../../libs/libeasygl/src/graphics.cpp	/^} t_panning_state;$/;"	t	typeref:struct:__anon21	file:
t_pb	base/vpr_types.h	/^struct t_pb {$/;"	s	class:ScreenUpdatePriority	access:private
t_pb_graph_edge	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_graph_edge {$/;"	s
t_pb_graph_edge::capacitance	../../libs/libarchfpga/src/physical_types.h	/^	float capacitance;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::delay_max	../../libs/libarchfpga/src/physical_types.h	/^	float delay_max;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::delay_min	../../libs/libarchfpga/src/physical_types.h	/^	float delay_min;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::driver_pin	../../libs/libarchfpga/src/physical_types.h	/^	int driver_pin;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::driver_set	../../libs/libarchfpga/src/physical_types.h	/^	int driver_set;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::infer_pattern	../../libs/libarchfpga/src/physical_types.h	/^	bool infer_pattern; \/*If true, infer pattern based on patterns connected to it*\/$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::input_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **input_pins;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::interconnect	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::num_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_pins;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::num_output_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_pins;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::num_pack_patterns	../../libs/libarchfpga/src/physical_types.h	/^	int num_pack_patterns;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::output_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **output_pins;$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::pack_pattern_indices	../../libs/libarchfpga/src/physical_types.h	/^	int *pack_pattern_indices; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge::pack_pattern_names	../../libs/libarchfpga/src/physical_types.h	/^	const char **pack_pattern_names; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:t_pb_graph_edge	access:public
t_pb_graph_edge_comparator	pack/pb_type_graph.h	/^struct t_pb_graph_edge_comparator{$/;"	s
t_pb_graph_edge_comparator::input_pin	pack/pb_type_graph.h	/^	t_pb_graph_pin* input_pin;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
t_pb_graph_edge_comparator::input_pin_id_in_cluster	pack/pb_type_graph.h	/^	int input_pin_id_in_cluster;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
t_pb_graph_edge_comparator::output_pin	pack/pb_type_graph.h	/^	t_pb_graph_pin* output_pin;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
t_pb_graph_edge_comparator::output_pin_id_in_cluster	pack/pb_type_graph.h	/^	int output_pin_id_in_cluster;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
t_pb_graph_edge_comparator::parent_edge	pack/pb_type_graph.h	/^	t_pb_graph_edge* parent_edge;$/;"	m	struct:t_pb_graph_edge_comparator	access:public
t_pb_graph_node	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_graph_node {$/;"	s
t_pb_graph_node::child_pb_graph_nodes	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node ***child_pb_graph_nodes; \/* [0..num_modes-1][0..num_pb_type_in_mode-1][0..num_pb-1] *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::clock_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **clock_pins; \/* [0..num_clock_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::cluster_placement_primitive	../../libs/libarchfpga/src/physical_types.h	/^	t_cluster_placement_primitive *cluster_placement_primitive; \/* pointer to indexing structure useful during packing stage *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::input_pin_class_size	../../libs/libarchfpga/src/physical_types.h	/^	int *input_pin_class_size; \/* Stores the number of pins that belong to a particular input pin class *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::input_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **input_pins; \/* [0..num_input_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::interconnect_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_interconnect_pins ** interconnect_pins; \/* [0..num_modes-1][0..num_interconnect_in_mode] *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_clock_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_clock_pins; \/* [0..num_clock_ports - 1] *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_clock_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_clock_ports;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_input_pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_pin_class; \/* number of input pin classes that this pb_graph_node has *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_input_pins; \/* [0..num_input_ports - 1] *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_input_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_ports;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_output_pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_pin_class; \/* number of output pin classes that this pb_graph_node has *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_output_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_output_pins; \/* [0..num_output_ports - 1] *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_output_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_ports;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::num_pins	../../libs/libarchfpga/src/physical_types.h	/^    int num_pins() {$/;"	f	struct:t_pb_graph_node	access:public	signature:()
t_pb_graph_node::output_pin_class_size	../../libs/libarchfpga/src/physical_types.h	/^	int *output_pin_class_size; \/* Stores the number of pins that belong to a particular output pin class *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::output_pins	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin **output_pins; \/* [0..num_output_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::parent_pb_graph_node	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node *parent_pb_graph_node;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::pb_node_power	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node_power * pb_node_power;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *pb_type;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::placement_index	../../libs/libarchfpga/src/physical_types.h	/^	int placement_index;$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::temp_scratch_pad	../../libs/libarchfpga/src/physical_types.h	/^	void *temp_scratch_pad; \/* temporary data, useful for keeping track of things when traversing data structure *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node::total_pb_pins	../../libs/libarchfpga/src/physical_types.h	/^	int total_pb_pins; \/* only valid for top-level *\/$/;"	m	struct:t_pb_graph_node	access:public
t_pb_graph_node_power	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_graph_node_power {$/;"	s
t_pb_graph_node_power::transistor_cnt_buffers	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt_buffers;$/;"	m	struct:t_pb_graph_node_power	access:public
t_pb_graph_node_power::transistor_cnt_interc	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt_interc; \/* Total transistor size of the interconnect in this pb *\/$/;"	m	struct:t_pb_graph_node_power	access:public
t_pb_graph_node_power::transistor_cnt_pb_children	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt_pb_children; \/* Total transistor size of this pb *\/$/;"	m	struct:t_pb_graph_node_power	access:public
t_pb_graph_pin	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_graph_pin {$/;"	s
t_pb_graph_pin::associated_clock_pin	../../libs/libarchfpga/src/physical_types.h	/^    t_pb_graph_pin* associated_clock_pin = nullptr; \/* For sequentail elements, the associated clock *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::input_edges	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_edge** input_edges = nullptr; \/* [0..num_input_edges] *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::is_forced_connection	../../libs/libarchfpga/src/physical_types.h	/^	bool is_forced_connection = false; \/* This output pin connects to one and only one input pin *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::list_of_connectable_input_pin_ptrs	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin ***list_of_connectable_input_pin_ptrs = nullptr; \/* [0..depth-1][0..num_connectable_primitive_input_pins-1] what input pins this output can connect to without exiting cluster at given depth *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::num_connectable_primitive_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int *num_connectable_primitive_input_pins = nullptr; \/* [0..depth-1] number of input pins that this output pin can reach without exiting cluster at given depth *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::num_input_edges	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_edges = 0;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::num_output_edges	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_edges = 0;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::num_pin_timing	../../libs/libarchfpga/src/physical_types.h	/^	int num_pin_timing = 0; \/* Number of ipin to opin timing edges*\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::num_pin_timing_del_max_annotated	../../libs/libarchfpga/src/physical_types.h	/^    int num_pin_timing_del_max_annotated = 0; \/\/The list of valid pin_timing_del_max entries runs from [0..num_pin_timing_del_max_annotated-1]$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::num_pin_timing_del_min_annotated	../../libs/libarchfpga/src/physical_types.h	/^    int num_pin_timing_del_min_annotated = 0; \/\/The list of valid pin_timing_del_max entries runs from [0..num_pin_timing_del_min_annotated-1]$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::output_edges	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_edge** output_edges = nullptr; \/* [0..num_output_edges] *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::parent_node	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node *parent_node = nullptr;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::parent_pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int *parent_pin_class = nullptr; \/* [0..depth-1] the grouping of pins that this particular pin belongs to *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int pin_class = 0;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_count_in_cluster	../../libs/libarchfpga/src/physical_types.h	/^	int pin_count_in_cluster = 0;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_number	../../libs/libarchfpga/src/physical_types.h	/^	int pin_number = 0;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_power	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin_power* pin_power = nullptr;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_timing	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin** pin_timing = nullptr; \/* timing edge sink pins  [0..num_pin_timing-1]*\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_timing_del_max	../../libs/libarchfpga/src/physical_types.h	/^	float *pin_timing_del_max = nullptr; \/* primitive ipin to opin max-delay [0..num_pin_timing-1]*\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::pin_timing_del_min	../../libs/libarchfpga/src/physical_types.h	/^	float *pin_timing_del_min = nullptr; \/* primitive ipin to opin min-delay [0..num_pin_timing-1]*\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::port	../../libs/libarchfpga/src/physical_types.h	/^	t_port *port = nullptr;$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::scratch_pad	../../libs/libarchfpga/src/physical_types.h	/^	int scratch_pad = 0; \/* temporary data structure useful to store traversal info *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::tco_max	../../libs/libarchfpga/src/physical_types.h	/^	float tco_max = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the maximum clock to output time *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::tco_min	../../libs/libarchfpga/src/physical_types.h	/^	float tco_min = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the minimum clock to output time *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::thld	../../libs/libarchfpga/src/physical_types.h	/^	float thld = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the hold time *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::tsu	../../libs/libarchfpga/src/physical_types.h	/^	float tsu = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the setup time *\/$/;"	m	struct:t_pb_graph_pin	access:public
t_pb_graph_pin::type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pb_graph_pin_type type = PB_PIN_NORMAL; \/* The type of this pin (sequential, i\/o etc.) *\/$/;"	m	struct:t_pb_graph_pin	typeref:enum:t_pb_graph_pin::e_pb_graph_pin_type	access:public
t_pb_graph_pin_power	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_graph_pin_power {$/;"	s
t_pb_graph_pin_power::C_wire	../../libs/libarchfpga/src/physical_types.h	/^	float C_wire;$/;"	m	struct:t_pb_graph_pin_power	access:public
t_pb_graph_pin_power::buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float buffer_size;$/;"	m	struct:t_pb_graph_pin_power	access:public
t_pb_graph_pin_power::scaled_by_pin	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_pin *scaled_by_pin;$/;"	m	struct:t_pb_graph_pin_power	access:public
t_pb_route	base/vpr_types.h	/^struct t_pb_route {$/;"	s	class:ScreenUpdatePriority	access:private
t_pb_routes	base/vpr_types.h	/^typedef vtr::flat_map2<int,t_pb_route> t_pb_routes;$/;"	t	class:ScreenUpdatePriority	access:private
t_pb_stats	pack/pack_types.h	/^struct t_pb_stats {$/;"	s
t_pb_stats::connectiongain	pack/pack_types.h	/^	std::map<AtomBlockId, float> connectiongain; \/* Weighted sum of connections to attraction function *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::explore_transitive_fanout	pack/pack_types.h	/^	bool explore_transitive_fanout; \/* If no marked candidate molecules and no high fanout nets to determine next candidate molecule then explore molecules on transitive fanout *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::feasible_blocks	pack/pack_types.h	/^	t_pack_molecule **feasible_blocks;$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::gain	pack/pack_types.h	/^	std::map<AtomBlockId, float> gain; \/* Attraction (inverse of cost) function *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::hillgain	pack/pack_types.h	/^	std::map<AtomBlockId, float> hillgain;$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::input_pins_used	pack/pack_types.h	/^    std::vector<std::vector<AtomNetId>> input_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of input pins of this class that are used *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::lookahead_input_pins_used	pack/pack_types.h	/^    std::vector<std::vector<AtomNetId>> lookahead_input_pins_used; \/* [0..pb_graph_node->num_pin_classes-1] vector of input pins of this class that are speculatively used *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::lookahead_output_pins_used	pack/pack_types.h	/^    std::vector<std::vector<AtomNetId>> lookahead_output_pins_used; \/* [0..pb_graph_node->num_pin_classes-1] vector of input pins of this class that are speculatively used *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::marked_blocks	pack/pack_types.h	/^    std::vector<AtomBlockId> marked_blocks; \/\/List of blocks with the num_pins_of_net_in_pb and gain entries altered$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::marked_nets	pack/pack_types.h	/^    std::vector<AtomNetId> marked_nets; \/\/List of nets with the num_pins_of_net_in_pb and gain entries altered$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::num_child_blocks_in_pb	pack/pack_types.h	/^	int num_child_blocks_in_pb;$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::num_feasible_blocks	pack/pack_types.h	/^	int num_feasible_blocks; \/* [0..num_marked_models-1] *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::num_pins_of_net_in_pb	pack/pack_types.h	/^	std::map<AtomNetId, int> num_pins_of_net_in_pb;$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::output_pins_used	pack/pack_types.h	/^	std::vector<std::vector<AtomNetId>> output_pins_used; \/* [0..pb_graph_node->num_pin_classes-1][0..pin_class_size] number of output pins of this class that are used *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::sharinggain	pack/pack_types.h	/^	std::map<AtomBlockId, float> sharinggain; \/* How many nets on an atom cluster_ctx.blocks are already in the pb under consideration *\/$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::tie_break_high_fanout_net	pack/pack_types.h	/^	AtomNetId tie_break_high_fanout_net; \/* If no marked candidate molecules, use$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::timinggain	pack/pack_types.h	/^	std::map<AtomBlockId, float> timinggain; \/* The timing criticality score of this atom cluster_ctx.blocks.$/;"	m	struct:t_pb_stats	access:public
t_pb_stats::transitive_fanout_candidates	pack/pack_types.h	/^	std::vector<t_pack_molecule *> *transitive_fanout_candidates;$/;"	m	struct:t_pb_stats	access:public
t_pb_type	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_type {$/;"	s
t_pb_type::annotations	../../libs/libarchfpga/src/physical_types.h	/^	t_pin_to_pin_annotation *annotations = nullptr; \/* [0..num_annotations-1] *\/$/;"	m	struct:t_pb_type	access:public
t_pb_type::blif_model	../../libs/libarchfpga/src/physical_types.h	/^	char* blif_model = nullptr;$/;"	m	struct:t_pb_type	access:public
t_pb_type::class_type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pb_type_class class_type = UNKNOWN_CLASS;$/;"	m	struct:t_pb_type	typeref:enum:t_pb_type::e_pb_type_class	access:public
t_pb_type::depth	../../libs/libarchfpga/src/physical_types.h	/^	int depth = 0; \/* depth of pb_type *\/$/;"	m	struct:t_pb_type	access:public
t_pb_type::max_internal_delay	../../libs/libarchfpga/src/physical_types.h	/^	float max_internal_delay = -1; \/\/TODO: remove when VPR's classic timing analyzer is removed$/;"	m	struct:t_pb_type	access:public
t_pb_type::model	../../libs/libarchfpga/src/physical_types.h	/^	t_model *model = nullptr;$/;"	m	struct:t_pb_type	access:public
t_pb_type::modes	../../libs/libarchfpga/src/physical_types.h	/^	t_mode *modes = nullptr; \/* [0..num_modes-1] *\/$/;"	m	struct:t_pb_type	access:public
t_pb_type::name	../../libs/libarchfpga/src/physical_types.h	/^	char* name = nullptr;$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_annotations	../../libs/libarchfpga/src/physical_types.h	/^	int num_annotations = 0;$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_clock_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_clock_pins = 0;$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_input_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_input_pins = 0; \/* inputs not including clock pins *\/$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_modes	../../libs/libarchfpga/src/physical_types.h	/^	int num_modes = 0;$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_output_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_output_pins = 0;$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_pb	../../libs/libarchfpga/src/physical_types.h	/^	int num_pb = 0;$/;"	m	struct:t_pb_type	access:public
t_pb_type::num_ports	../../libs/libarchfpga/src/physical_types.h	/^	int num_ports = 0;$/;"	m	struct:t_pb_type	access:public
t_pb_type::parent_mode	../../libs/libarchfpga/src/physical_types.h	/^	t_mode *parent_mode = nullptr;$/;"	m	struct:t_pb_type	access:public
t_pb_type::pb_type_power	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type_power * pb_type_power = nullptr;$/;"	m	struct:t_pb_type	access:public
t_pb_type::ports	../../libs/libarchfpga/src/physical_types.h	/^	t_port *ports = nullptr; \/* [0..num_ports] *\/$/;"	m	struct:t_pb_type	access:public
t_pb_type_power	../../libs/libarchfpga/src/physical_types.h	/^struct t_pb_type_power {$/;"	s
t_pb_type_power::C_internal	../../libs/libarchfpga/src/physical_types.h	/^	float C_internal; \/*Internal capacitance of the pb *\/$/;"	m	struct:t_pb_type_power	access:public
t_pb_type_power::absolute_power_per_instance	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage absolute_power_per_instance; \/* User-provided absolute power per block *\/$/;"	m	struct:t_pb_type_power	access:public
t_pb_type_power::estimation_method	../../libs/libarchfpga/src/physical_types.h	/^	e_power_estimation_method estimation_method;$/;"	m	struct:t_pb_type_power	access:public
t_pb_type_power::leakage_default_mode	../../libs/libarchfpga/src/physical_types.h	/^	int leakage_default_mode; \/* Default mode for leakage analysis, if block has no set mode *\/$/;"	m	struct:t_pb_type_power	access:public
t_pb_type_power::power_usage	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage; \/* Total power usage of this pb type *\/$/;"	m	struct:t_pb_type_power	access:public
t_pb_type_power::power_usage_bufs_wires	../../libs/libarchfpga/src/physical_types.h	/^	t_power_usage power_usage_bufs_wires; \/* Power dissipated in local buffers and wire switching (Subset of total power) *\/$/;"	m	struct:t_pb_type_power	access:public
t_permutation_map	../../libs/libarchfpga/src/physical_types.h	/^typedef std::map< SB_Side_Connection, std::vector<std::string> > t_permutation_map;$/;"	t
t_pin_loc	route/rr_graph.cpp	/^struct t_pin_loc {$/;"	s	file:
t_pin_loc::height_offset	route/rr_graph.cpp	/^    int height_offset;$/;"	m	struct:t_pin_loc	file:	access:public
t_pin_loc::pin_index	route/rr_graph.cpp	/^    int pin_index;$/;"	m	struct:t_pin_loc	file:	access:public
t_pin_loc::side	route/rr_graph.cpp	/^    e_side side;$/;"	m	struct:t_pin_loc	file:	access:public
t_pin_loc::width_offset	route/rr_graph.cpp	/^    int width_offset;$/;"	m	struct:t_pin_loc	file:	access:public
t_pin_to_pin_annotation	../../libs/libarchfpga/src/physical_types.h	/^struct t_pin_to_pin_annotation {$/;"	s
t_pin_to_pin_annotation::clock	../../libs/libarchfpga/src/physical_types.h	/^	char *clock;$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_pin_annotation::format	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_to_pin_annotation_format format;$/;"	m	struct:t_pin_to_pin_annotation	typeref:enum:t_pin_to_pin_annotation::e_pin_to_pin_annotation_format	access:public
t_pin_to_pin_annotation::input_pins	../../libs/libarchfpga/src/physical_types.h	/^	char *input_pins;$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_pin_annotation::line_num	../../libs/libarchfpga/src/physical_types.h	/^	int line_num; \/* used to report what line number this annotation is found in architecture file *\/$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_pin_annotation::num_value_prop_pairs	../../libs/libarchfpga/src/physical_types.h	/^	int num_value_prop_pairs;$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_pin_annotation::output_pins	../../libs/libarchfpga/src/physical_types.h	/^	char *output_pins;$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_pin_annotation::prop	../../libs/libarchfpga/src/physical_types.h	/^	int *prop; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_pin_annotation::type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_to_pin_annotation_type type;$/;"	m	struct:t_pin_to_pin_annotation	typeref:enum:t_pin_to_pin_annotation::e_pin_to_pin_annotation_type	access:public
t_pin_to_pin_annotation::value	../../libs/libarchfpga/src/physical_types.h	/^	char **value; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:t_pin_to_pin_annotation	access:public
t_pin_to_track_lookup	route/rr_types.h	/^typedef std::vector<vtr::NdMatrix<std::vector<int>,4>> t_pin_to_track_lookup;$/;"	t
t_pl_blocks_to_be_moved	base/vpr_types.h	/^struct t_pl_blocks_to_be_moved {$/;"	s	class:ScreenUpdatePriority	access:private
t_pl_macro	place/place_macro.h	/^struct t_pl_macro {$/;"	s
t_pl_macro::members	place/place_macro.h	/^	t_pl_macro_member* members;$/;"	m	struct:t_pl_macro	access:public
t_pl_macro::num_blocks	place/place_macro.h	/^	int num_blocks;$/;"	m	struct:t_pl_macro	access:public
t_pl_macro_member	place/place_macro.h	/^struct t_pl_macro_member{$/;"	s
t_pl_macro_member::blk_index	place/place_macro.h	/^	ClusterBlockId blk_index;$/;"	m	struct:t_pl_macro_member	access:public
t_pl_macro_member::x_offset	place/place_macro.h	/^	int x_offset;$/;"	m	struct:t_pl_macro_member	access:public
t_pl_macro_member::y_offset	place/place_macro.h	/^	int y_offset;$/;"	m	struct:t_pl_macro_member	access:public
t_pl_macro_member::z_offset	place/place_macro.h	/^	int z_offset;$/;"	m	struct:t_pl_macro_member	access:public
t_pl_moved_block	base/vpr_types.h	/^struct t_pl_moved_block {$/;"	s	class:ScreenUpdatePriority	access:private
t_place_region	base/vpr_types.h	/^struct t_place_region {$/;"	s	class:ScreenUpdatePriority	access:private
t_placer_costs	place/place.cpp	/^struct t_placer_costs {$/;"	s	file:
t_placer_costs::bb_cost	place/place.cpp	/^    float bb_cost;$/;"	m	struct:t_placer_costs	file:	access:public
t_placer_costs::cost	place/place.cpp	/^    float cost;$/;"	m	struct:t_placer_costs	file:	access:public
t_placer_costs::delay_cost	place/place.cpp	/^    float delay_cost;$/;"	m	struct:t_placer_costs	file:	access:public
t_placer_costs::timing_cost	place/place.cpp	/^    float timing_cost;$/;"	m	struct:t_placer_costs	file:	access:public
t_placer_opts	base/vpr_types.h	/^struct t_placer_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_placer_prev_inverse_costs	place/place.cpp	/^struct t_placer_prev_inverse_costs {$/;"	s	file:
t_placer_prev_inverse_costs::bb_cost	place/place.cpp	/^    float bb_cost;$/;"	m	struct:t_placer_prev_inverse_costs	file:	access:public
t_placer_prev_inverse_costs::timing_cost	place/place.cpp	/^    float timing_cost;$/;"	m	struct:t_placer_prev_inverse_costs	file:	access:public
t_placer_statistics	place/place.cpp	/^struct t_placer_statistics {$/;"	s	file:
t_placer_statistics::av_bb_cost	place/place.cpp	/^	double av_cost, av_bb_cost, av_timing_cost,$/;"	m	struct:t_placer_statistics	file:	access:public
t_placer_statistics::av_cost	place/place.cpp	/^	double av_cost, av_bb_cost, av_timing_cost,$/;"	m	struct:t_placer_statistics	file:	access:public
t_placer_statistics::av_delay_cost	place/place.cpp	/^	       sum_of_squares, av_delay_cost;$/;"	m	struct:t_placer_statistics	file:	access:public
t_placer_statistics::av_timing_cost	place/place.cpp	/^	double av_cost, av_bb_cost, av_timing_cost,$/;"	m	struct:t_placer_statistics	file:	access:public
t_placer_statistics::success_sum	place/place.cpp	/^	int success_sum;$/;"	m	struct:t_placer_statistics	file:	access:public
t_placer_statistics::sum_of_squares	place/place.cpp	/^	       sum_of_squares, av_delay_cost;$/;"	m	struct:t_placer_statistics	file:	access:public
t_point	../../libs/libeasygl/src/graphics_types.cpp	/^t_point::t_point() = default;$/;"	p	class:t_point	file:	signature:()
t_point	../../libs/libeasygl/src/graphics_types.cpp	/^t_point::t_point(const t_point&) = default;$/;"	p	class:t_point	file:	signature:(const t_point&)
t_point	../../libs/libeasygl/src/graphics_types.cpp	/^t_point::t_point(float _x, float _y) : x(_x), y(_y) {$/;"	f	class:t_point	signature:(float _x, float _y)
t_point	../../libs/libeasygl/src/graphics_types.h	/^    t_point();$/;"	p	class:t_point	access:public	signature:()
t_point	../../libs/libeasygl/src/graphics_types.h	/^    t_point(const t_point& src);$/;"	p	class:t_point	access:public	signature:(const t_point& src)
t_point	../../libs/libeasygl/src/graphics_types.h	/^    t_point(float x, float y);$/;"	p	class:t_point	access:public	signature:(float x, float y)
t_point	../../libs/libeasygl/src/graphics_types.h	/^class t_point {$/;"	c
t_point::offset	../../libs/libeasygl/src/graphics_types.cpp	/^void t_point::offset(float _x, float _y) {$/;"	f	class:t_point	signature:(float _x, float _y)
t_point::offset	../../libs/libeasygl/src/graphics_types.h	/^    void offset(float x, float y);$/;"	p	class:t_point	access:public	signature:(float x, float y)
t_point::operator *	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_point::operator*(float rhs) const {$/;"	f	class:t_point	signature:(float rhs) const
t_point::operator *	../../libs/libeasygl/src/graphics_types.h	/^    t_point operator*(float rhs) const;$/;"	p	class:t_point	access:public	signature:(float rhs) const
t_point::operator *=	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator*=(float rhs) {$/;"	f	class:t_point	signature:(float rhs)
t_point::operator *=	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator*=(float rhs);$/;"	p	class:t_point	access:public	signature:(float rhs)
t_point::operator +	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_point::operator+(const t_point& rhs) const {$/;"	f	class:t_point	signature:(const t_point& rhs) const
t_point::operator +	../../libs/libeasygl/src/graphics_types.h	/^    t_point operator+(const t_point& rhs) const;$/;"	p	class:t_point	access:public	signature:(const t_point& rhs) const
t_point::operator +=	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator+=(const t_point& rhs) {$/;"	f	class:t_point	signature:(const t_point& rhs)
t_point::operator +=	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator+=(const t_point& rhs);$/;"	p	class:t_point	access:public	signature:(const t_point& rhs)
t_point::operator -	../../libs/libeasygl/src/graphics_types.cpp	/^t_point t_point::operator-(const t_point& rhs) const {$/;"	f	class:t_point	signature:(const t_point& rhs) const
t_point::operator -	../../libs/libeasygl/src/graphics_types.h	/^    t_point operator-(const t_point& rhs) const;$/;"	p	class:t_point	access:public	signature:(const t_point& rhs) const
t_point::operator -=	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator-=(const t_point& rhs) {$/;"	f	class:t_point	signature:(const t_point& rhs)
t_point::operator -=	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator-=(const t_point& rhs);$/;"	p	class:t_point	access:public	signature:(const t_point& rhs)
t_point::operator =	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_point::operator=(const t_point&) = default;$/;"	p	class:t_point	file:	signature:(const t_point&)
t_point::operator =	../../libs/libeasygl/src/graphics_types.h	/^    t_point& operator=(const t_point& src);$/;"	p	class:t_point	access:public	signature:(const t_point& src)
t_point::t_point	../../libs/libeasygl/src/graphics_types.cpp	/^t_point::t_point() = default;$/;"	p	class:t_point	file:	signature:()
t_point::t_point	../../libs/libeasygl/src/graphics_types.cpp	/^t_point::t_point(const t_point&) = default;$/;"	p	class:t_point	file:	signature:(const t_point&)
t_point::t_point	../../libs/libeasygl/src/graphics_types.cpp	/^t_point::t_point(float _x, float _y) : x(_x), y(_y) {$/;"	f	class:t_point	signature:(float _x, float _y)
t_point::t_point	../../libs/libeasygl/src/graphics_types.h	/^    t_point();$/;"	p	class:t_point	access:public	signature:()
t_point::t_point	../../libs/libeasygl/src/graphics_types.h	/^    t_point(const t_point& src);$/;"	p	class:t_point	access:public	signature:(const t_point& src)
t_point::t_point	../../libs/libeasygl/src/graphics_types.h	/^    t_point(float x, float y);$/;"	p	class:t_point	access:public	signature:(float x, float y)
t_point::x	../../libs/libeasygl/src/graphics_types.h	/^    float x = 0;$/;"	m	class:t_point	access:public
t_point::y	../../libs/libeasygl/src/graphics_types.h	/^    float y = 0;$/;"	m	class:t_point	access:public
t_port	../../libs/libarchfpga/src/physical_types.h	/^struct t_port {$/;"	s
t_port::equivalent	../../libs/libarchfpga/src/physical_types.h	/^	PortEquivalence equivalent;$/;"	m	struct:t_port	access:public
t_port::index	../../libs/libarchfpga/src/physical_types.h	/^	int index;$/;"	m	struct:t_port	access:public
t_port::is_clock	../../libs/libarchfpga/src/physical_types.h	/^	bool is_clock;$/;"	m	struct:t_port	access:public
t_port::is_non_clock_global	../../libs/libarchfpga/src/physical_types.h	/^	bool is_non_clock_global;$/;"	m	struct:t_port	access:public
t_port::model_port	../../libs/libarchfpga/src/physical_types.h	/^	t_model_ports *model_port;$/;"	m	struct:t_port	access:public
t_port::name	../../libs/libarchfpga/src/physical_types.h	/^	char* name;$/;"	m	struct:t_port	access:public
t_port::num_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins;$/;"	m	struct:t_port	access:public
t_port::parent_pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *parent_pb_type;$/;"	m	struct:t_port	access:public
t_port::port_class	../../libs/libarchfpga/src/physical_types.h	/^	char * port_class;$/;"	m	struct:t_port	access:public
t_port::port_index_by_type	../../libs/libarchfpga/src/physical_types.h	/^	int port_index_by_type;$/;"	m	struct:t_port	access:public
t_port::port_power	../../libs/libarchfpga/src/physical_types.h	/^	t_port_power *port_power;$/;"	m	struct:t_port	access:public
t_port::type	../../libs/libarchfpga/src/physical_types.h	/^	enum PORTS type;$/;"	m	struct:t_port	typeref:enum:t_port::PORTS	access:public
t_port_power	../../libs/libarchfpga/src/physical_types.h	/^struct t_port_power {$/;"	s
t_port_power::__anon13::C	../../libs/libarchfpga/src/physical_types.h	/^		float C;$/;"	m	union:t_port_power::__anon13	access:public
t_port_power::__anon13::absolute_length	../../libs/libarchfpga/src/physical_types.h	/^		float absolute_length;$/;"	m	union:t_port_power::__anon13	access:public
t_port_power::__anon13::relative_length	../../libs/libarchfpga/src/physical_types.h	/^		float relative_length;$/;"	m	union:t_port_power::__anon13	access:public
t_port_power::buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float buffer_size;$/;"	m	struct:t_port_power	access:public
t_port_power::buffer_type	../../libs/libarchfpga/src/physical_types.h	/^	e_power_buffer_type buffer_type;$/;"	m	struct:t_port_power	access:public
t_port_power::energy_per_toggle	../../libs/libarchfpga/src/physical_types.h	/^	float energy_per_toggle;$/;"	m	struct:t_port_power	access:public
t_port_power::pin_toggle_initialized	../../libs/libarchfpga/src/physical_types.h	/^	bool pin_toggle_initialized;$/;"	m	struct:t_port_power	access:public
t_port_power::reverse_scaled	../../libs/libarchfpga/src/physical_types.h	/^	bool reverse_scaled; \/* Scale by (1-prob) *\/$/;"	m	struct:t_port_power	access:public
t_port_power::scaled_by_port	../../libs/libarchfpga/src/physical_types.h	/^	t_port * scaled_by_port;$/;"	m	struct:t_port_power	access:public
t_port_power::scaled_by_port_pin_idx	../../libs/libarchfpga/src/physical_types.h	/^	int scaled_by_port_pin_idx;$/;"	m	struct:t_port_power	access:public
t_port_power::wire	../../libs/libarchfpga/src/physical_types.h	/^	} wire;$/;"	m	struct:t_port_power	typeref:union:t_port_power::__anon13	access:public
t_port_power::wire_type	../../libs/libarchfpga/src/physical_types.h	/^	e_power_wire_type wire_type;$/;"	m	struct:t_port_power	access:public
t_power_arch	../../libs/libarchfpga/src/physical_types.h	/^struct t_power_arch {$/;"	s
t_power_arch::C_wire_local	../../libs/libarchfpga/src/physical_types.h	/^	float C_wire_local; \/* Capacitance of local interconnect (per meter) *\/$/;"	m	struct:t_power_arch	access:public
t_power_arch::FF_size	../../libs/libarchfpga/src/physical_types.h	/^	float FF_size;$/;"	m	struct:t_power_arch	access:public
t_power_arch::LUT_transistor_size	../../libs/libarchfpga/src/physical_types.h	/^	float LUT_transistor_size;$/;"	m	struct:t_power_arch	access:public
t_power_arch::local_interc_factor	../../libs/libarchfpga/src/physical_types.h	/^	float local_interc_factor;$/;"	m	struct:t_power_arch	access:public
t_power_arch::logical_effort_factor	../../libs/libarchfpga/src/physical_types.h	/^	float logical_effort_factor;$/;"	m	struct:t_power_arch	access:public
t_power_arch::mux_transistor_size	../../libs/libarchfpga/src/physical_types.h	/^	float mux_transistor_size;$/;"	m	struct:t_power_arch	access:public
t_power_arch::transistors_per_SRAM_bit	../../libs/libarchfpga/src/physical_types.h	/^	float transistors_per_SRAM_bit;$/;"	m	struct:t_power_arch	access:public
t_power_breakdown	power/power_components.h	/^struct t_power_breakdown {$/;"	s
t_power_breakdown::components	power/power_components.h	/^	t_power_usage * components;$/;"	m	struct:t_power_breakdown	access:public
t_power_buffer_sc_levr_inf	power/power.h	/^struct t_power_buffer_sc_levr_inf {$/;"	s
t_power_buffer_sc_levr_inf::mux_size	power/power.h	/^	int mux_size;$/;"	m	struct:t_power_buffer_sc_levr_inf	access:public
t_power_buffer_sc_levr_inf::sc_levr	power/power.h	/^	float sc_levr;$/;"	m	struct:t_power_buffer_sc_levr_inf	access:public
t_power_buffer_size_inf	power/power.h	/^struct t_power_buffer_size_inf {$/;"	s
t_power_buffer_size_inf::num_strengths	power/power.h	/^	int num_strengths;$/;"	m	struct:t_power_buffer_size_inf	access:public
t_power_buffer_size_inf::strength_inf	power/power.h	/^	t_power_buffer_strength_inf * strength_inf;$/;"	m	struct:t_power_buffer_size_inf	access:public
t_power_buffer_strength_inf	power/power.h	/^struct t_power_buffer_strength_inf {$/;"	s
t_power_buffer_strength_inf::num_levr_entries	power/power.h	/^	int num_levr_entries;$/;"	m	struct:t_power_buffer_strength_inf	access:public
t_power_buffer_strength_inf::sc_levr_inf	power/power.h	/^	t_power_buffer_sc_levr_inf * sc_levr_inf;$/;"	m	struct:t_power_buffer_strength_inf	access:public
t_power_buffer_strength_inf::sc_no_levr	power/power.h	/^	float sc_no_levr;$/;"	m	struct:t_power_buffer_strength_inf	access:public
t_power_buffer_strength_inf::stage_gain	power/power.h	/^	float stage_gain;$/;"	m	struct:t_power_buffer_strength_inf	access:public
t_power_commonly_used	power/power.h	/^struct t_power_commonly_used {$/;"	s
t_power_commonly_used::INV_1X_C	power/power.h	/^	float INV_1X_C;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::INV_1X_C_in	power/power.h	/^	float INV_1X_C_in;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::INV_2X_C	power/power.h	/^	float INV_2X_C;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::NMOS_1X_C_d	power/power.h	/^	float NMOS_1X_C_d;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::NMOS_1X_C_g	power/power.h	/^	float NMOS_1X_C_g;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::NMOS_1X_C_s	power/power.h	/^	float NMOS_1X_C_s;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::NMOS_1X_st_leakage	power/power.h	/^	float NMOS_1X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::NMOS_2X_st_leakage	power/power.h	/^	float NMOS_2X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::PMOS_1X_C_d	power/power.h	/^	float PMOS_1X_C_d;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::PMOS_1X_C_g	power/power.h	/^	float PMOS_1X_C_g;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::PMOS_1X_C_s	power/power.h	/^	float PMOS_1X_C_s;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::PMOS_1X_st_leakage	power/power.h	/^	float PMOS_1X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::PMOS_2X_st_leakage	power/power.h	/^	float PMOS_2X_st_leakage;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::component_callibration	power/power.h	/^	PowerSpicedComponent ** component_callibration;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::max_IPIN_fanin	power/power.h	/^	int max_IPIN_fanin;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::max_routing_mux_size	power/power.h	/^	int max_routing_mux_size;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::max_seg_fanout	power/power.h	/^	int max_seg_fanout;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::max_seg_to_IPIN_fanout	power/power.h	/^	int max_seg_to_IPIN_fanout;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::max_seg_to_seg_fanout	power/power.h	/^	int max_seg_to_seg_fanout;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::mux_info	power/power.h	/^	std::map<float, t_power_mux_info*> mux_info;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::num_cb_buffers	power/power.h	/^	int num_cb_buffers;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::num_sb_buffers	power/power.h	/^	int num_sb_buffers;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::tile_length	power/power.h	/^	float tile_length;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::total_cb_buffer_size	power/power.h	/^	float total_cb_buffer_size;$/;"	m	struct:t_power_commonly_used	access:public
t_power_commonly_used::total_sb_buffer_size	power/power.h	/^	float total_sb_buffer_size;$/;"	m	struct:t_power_commonly_used	access:public
t_power_components	power/power_components.h	/^typedef t_power_breakdown t_power_components;$/;"	t
t_power_estimation_method	../../libs/libarchfpga/src/physical_types.h	/^typedef enum e_power_estimation_method_ t_power_estimation_method;$/;"	t	typeref:enum:e_power_estimation_method_
t_power_mux_info	power/power.h	/^struct t_power_mux_info {$/;"	s
t_power_mux_info::mux_arch	power/power.h	/^	t_mux_arch * mux_arch;$/;"	m	struct:t_power_mux_info	access:public
t_power_mux_info::mux_arch_max_size	power/power.h	/^	int mux_arch_max_size;$/;"	m	struct:t_power_mux_info	access:public
t_power_mux_volt_inf	power/power.h	/^struct t_power_mux_volt_inf {$/;"	s
t_power_mux_volt_inf::mux_voltage_pairs	power/power.h	/^	t_power_mux_volt_pair * mux_voltage_pairs;$/;"	m	struct:t_power_mux_volt_inf	access:public
t_power_mux_volt_inf::num_voltage_pairs	power/power.h	/^	int num_voltage_pairs;$/;"	m	struct:t_power_mux_volt_inf	access:public
t_power_mux_volt_pair	power/power.h	/^struct t_power_mux_volt_pair {$/;"	s
t_power_mux_volt_pair::v_in	power/power.h	/^	float v_in;$/;"	m	struct:t_power_mux_volt_pair	access:public
t_power_mux_volt_pair::v_out_max	power/power.h	/^	float v_out_max;$/;"	m	struct:t_power_mux_volt_pair	access:public
t_power_mux_volt_pair::v_out_min	power/power.h	/^	float v_out_min;$/;"	m	struct:t_power_mux_volt_pair	access:public
t_power_nmos_leakage_inf	power/power.h	/^struct t_power_nmos_leakage_inf {$/;"	s
t_power_nmos_leakage_inf::leakage_pairs	power/power.h	/^	t_power_nmos_leakage_pair * leakage_pairs;$/;"	m	struct:t_power_nmos_leakage_inf	access:public
t_power_nmos_leakage_inf::nmos_size	power/power.h	/^	float nmos_size;$/;"	m	struct:t_power_nmos_leakage_inf	access:public
t_power_nmos_leakage_inf::num_leakage_pairs	power/power.h	/^	int num_leakage_pairs;$/;"	m	struct:t_power_nmos_leakage_inf	access:public
t_power_nmos_leakage_pair	power/power.h	/^struct t_power_nmos_leakage_pair {$/;"	s
t_power_nmos_leakage_pair::i_ds	power/power.h	/^	float i_ds;$/;"	m	struct:t_power_nmos_leakage_pair	access:public
t_power_nmos_leakage_pair::v_ds	power/power.h	/^	float v_ds;$/;"	m	struct:t_power_nmos_leakage_pair	access:public
t_power_nmos_mux_inf	power/power.h	/^struct t_power_nmos_mux_inf {$/;"	s
t_power_nmos_mux_inf::max_mux_sl_size	power/power.h	/^	int max_mux_sl_size;$/;"	m	struct:t_power_nmos_mux_inf	access:public
t_power_nmos_mux_inf::mux_voltage_inf	power/power.h	/^	t_power_mux_volt_inf * mux_voltage_inf;$/;"	m	struct:t_power_nmos_mux_inf	access:public
t_power_nmos_mux_inf::nmos_size	power/power.h	/^	float nmos_size;$/;"	m	struct:t_power_nmos_mux_inf	access:public
t_power_opts	base/vpr_types.h	/^struct t_power_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_power_output	power/power.h	/^struct t_power_output {$/;"	s
t_power_output::logs	power/power.h	/^	t_log * logs;$/;"	m	struct:t_power_output	access:public
t_power_output::num_logs	power/power.h	/^	int num_logs;$/;"	m	struct:t_power_output	access:public
t_power_output::out	power/power.h	/^	FILE * out;$/;"	m	struct:t_power_output	access:public
t_power_tech	power/power.h	/^struct t_power_tech {$/;"	s
t_power_tech::NMOS_inf	power/power.h	/^	t_transistor_inf NMOS_inf;$/;"	m	struct:t_power_tech	access:public
t_power_tech::PMOS_inf	power/power.h	/^	t_transistor_inf PMOS_inf;$/;"	m	struct:t_power_tech	access:public
t_power_tech::PN_ratio	power/power.h	/^	float PN_ratio; \/* Ratio of PMOS to NMOS in inverter *\/$/;"	m	struct:t_power_tech	access:public
t_power_tech::Vdd	power/power.h	/^	float Vdd;$/;"	m	struct:t_power_tech	access:public
t_power_tech::buffer_size_inf	power/power.h	/^	t_power_buffer_size_inf * buffer_size_inf;$/;"	m	struct:t_power_tech	access:public
t_power_tech::max_buffer_size	power/power.h	/^	int max_buffer_size;$/;"	m	struct:t_power_tech	access:public
t_power_tech::nmos_leakage_info	power/power.h	/^	t_power_nmos_leakage_inf * nmos_leakage_info;$/;"	m	struct:t_power_tech	access:public
t_power_tech::nmos_mux_info	power/power.h	/^	t_power_nmos_mux_inf * nmos_mux_info;$/;"	m	struct:t_power_tech	access:public
t_power_tech::num_nmos_leakage_info	power/power.h	/^	int num_nmos_leakage_info;$/;"	m	struct:t_power_tech	access:public
t_power_tech::num_nmos_mux_info	power/power.h	/^	int num_nmos_mux_info;$/;"	m	struct:t_power_tech	access:public
t_power_tech::tech_size	power/power.h	/^	float tech_size; \/* Tech size in nm, for example 90e-9 for 90nm *\/$/;"	m	struct:t_power_tech	access:public
t_power_tech::temperature	power/power.h	/^	float temperature; \/* Temp in C *\/$/;"	m	struct:t_power_tech	access:public
t_power_usage	../../libs/libarchfpga/src/physical_types.h	/^struct t_power_usage {$/;"	s
t_power_usage::dynamic	../../libs/libarchfpga/src/physical_types.h	/^	float dynamic;$/;"	m	struct:t_power_usage	access:public
t_power_usage::leakage	../../libs/libarchfpga/src/physical_types.h	/^	float leakage;$/;"	m	struct:t_power_usage	access:public
t_prepacked_tnode_data	base/vpr_types.h	/^struct t_prepacked_tnode_data {$/;"	s	class:ScreenUpdatePriority	access:private
t_profile_info	place/timing_place_lookup.cpp	/^struct t_profile_info {$/;"	s	file:
t_profile_info::locations	place/timing_place_lookup.cpp	/^    std::vector<t_profile_loc> locations;$/;"	m	struct:t_profile_info	file:	access:public
t_profile_info::max_delta_x	place/timing_place_lookup.cpp	/^    int max_delta_x;$/;"	m	struct:t_profile_info	file:	access:public
t_profile_info::max_delta_y	place/timing_place_lookup.cpp	/^    int max_delta_y;$/;"	m	struct:t_profile_info	file:	access:public
t_profile_loc	place/timing_place_lookup.cpp	/^    t_profile_loc(int x, int y, std::vector<vtr::Point<int>> delta_values)$/;"	f	struct:t_profile_loc	access:public	signature:(int x, int y, std::vector<vtr::Point<int>> delta_values)
t_profile_loc	place/timing_place_lookup.cpp	/^struct t_profile_loc {$/;"	s	file:
t_profile_loc::deltas	place/timing_place_lookup.cpp	/^    std::vector<vtr::Point<int>> deltas;$/;"	m	struct:t_profile_loc	file:	access:public
t_profile_loc::root	place/timing_place_lookup.cpp	/^    vtr::Point<int> root;$/;"	m	struct:t_profile_loc	file:	access:public
t_profile_loc::t_profile_loc	place/timing_place_lookup.cpp	/^    t_profile_loc(int x, int y, std::vector<vtr::Point<int>> delta_values)$/;"	f	struct:t_profile_loc	access:public	signature:(int x, int y, std::vector<vtr::Point<int>> delta_values)
t_rc_node	timing/net_delay.cpp	/^struct t_rc_node {$/;"	s	file:
t_rc_node::C_downstream	timing/net_delay.cpp	/^	float C_downstream;$/;"	m	struct:t_rc_node	file:	access:public
t_rc_node::Tdel	timing/net_delay.cpp	/^	float Tdel;$/;"	m	struct:t_rc_node	file:	access:public
t_rc_node::__anon11::child_list	timing/net_delay.cpp	/^		t_linked_rc_edge *child_list;$/;"	m	union:t_rc_node::__anon11	file:	access:public
t_rc_node::__anon11::next	timing/net_delay.cpp	/^		t_rc_node *next;$/;"	m	union:t_rc_node::__anon11	file:	access:public
t_rc_node::inode	timing/net_delay.cpp	/^	int inode;$/;"	m	struct:t_rc_node	file:	access:public
t_rc_node::u	timing/net_delay.cpp	/^	} u;$/;"	m	struct:t_rc_node	typeref:union:t_rc_node::__anon11	file:	access:public
t_report	../../libs/libeasygl/src/graphics.h	/^} t_report;$/;"	t	typeref:struct:__anon22
t_router_opts	base/vpr_types.h	/^struct t_router_opts {$/;"	s	class:ScreenUpdatePriority	access:private
t_routing_cost_map	route/router_lookahead_map.cpp	/^typedef vtr::Matrix<Expansion_Cost_Entry> t_routing_cost_map; \/\/[0..device_ctx.grid.width()-1][0..device_ctx.grid.height()-1]$/;"	t	file:
t_rr_edge	route/rr_node.h	/^        struct t_rr_edge {$/;"	s	class:t_rr_node	access:private
t_rr_edge_info	route/rr_graph2.h	/^    t_rr_edge_info(int from, int to, short type)$/;"	f	struct:t_rr_edge_info	access:public	signature:(int from, int to, short type)
t_rr_edge_info	route/rr_graph2.h	/^struct t_rr_edge_info {$/;"	s
t_rr_edge_info::from_node	route/rr_graph2.h	/^    int from_node = OPEN;$/;"	m	struct:t_rr_edge_info	access:public
t_rr_edge_info::operator <	route/rr_graph2.h	/^    friend bool operator<(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs) {$/;"	f	struct:t_rr_edge_info	access:friend	signature:(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs)
t_rr_edge_info::operator ==	route/rr_graph2.h	/^    friend bool operator==(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs) {$/;"	f	struct:t_rr_edge_info	access:friend	signature:(const t_rr_edge_info& lhs, const t_rr_edge_info& rhs)
t_rr_edge_info::switch_type	route/rr_graph2.h	/^    short switch_type = OPEN;$/;"	m	struct:t_rr_edge_info	access:public
t_rr_edge_info::t_rr_edge_info	route/rr_graph2.h	/^    t_rr_edge_info(int from, int to, short type)$/;"	f	struct:t_rr_edge_info	access:public	signature:(int from, int to, short type)
t_rr_edge_info::to_node	route/rr_graph2.h	/^    int to_node = OPEN;$/;"	m	struct:t_rr_edge_info	access:public
t_rr_edge_info_set	route/rr_graph2.h	/^typedef std::vector<t_rr_edge_info> t_rr_edge_info_set;$/;"	t
t_rr_indexed_data	route/rr_node.h	/^struct t_rr_indexed_data {$/;"	s
t_rr_indexed_data::C_load	route/rr_node.h	/^	float C_load;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::T_linear	route/rr_node.h	/^	float T_linear;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::T_quadratic	route/rr_node.h	/^	float T_quadratic;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::base_cost	route/rr_node.h	/^	float base_cost;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::inv_length	route/rr_node.h	/^	float inv_length;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::ortho_cost_index	route/rr_node.h	/^	int ortho_cost_index;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::saved_base_cost	route/rr_node.h	/^	float saved_base_cost;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_indexed_data::seg_index	route/rr_node.h	/^	int seg_index;$/;"	m	struct:t_rr_indexed_data	access:public
t_rr_node	route/rr_node.h	/^class t_rr_node {$/;"	c
t_rr_node::C	route/rr_node.cpp	/^float t_rr_node::C() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::C	route/rr_node.h	/^        float C() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::R	route/rr_node.cpp	/^float t_rr_node::R() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::R	route/rr_node.h	/^        float R() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::__anon8::direction	route/rr_node.h	/^            e_direction direction; \/\/Valid only for CHANX\/CHANY$/;"	m	union:t_rr_node::__anon8	access:public
t_rr_node::__anon8::side	route/rr_node.h	/^            e_side side; \/\/Valid only for IPINs\/OPINs$/;"	m	union:t_rr_node::__anon8	access:public
t_rr_node::__anon9::class_num	route/rr_node.h	/^            int16_t class_num;$/;"	m	union:t_rr_node::__anon9	access:public
t_rr_node::__anon9::pin_num	route/rr_node.h	/^            int16_t pin_num;$/;"	m	union:t_rr_node::__anon9	access:public
t_rr_node::__anon9::track_num	route/rr_node.h	/^            int16_t track_num;$/;"	m	union:t_rr_node::__anon9	access:public
t_rr_node::add_edge	route/rr_node.cpp	/^short t_rr_node::add_edge(int sink_node, int iswitch) {$/;"	f	class:t_rr_node	signature:(int sink_node, int iswitch)
t_rr_node::add_edge	route/rr_node.h	/^        short add_edge(int sink_node, int iswitch);$/;"	p	class:t_rr_node	access:public	signature:(int sink_node, int iswitch)
t_rr_node::capacity	route/rr_node.cpp	/^short t_rr_node::capacity() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::capacity	route/rr_node.h	/^        short capacity() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::capacity_	route/rr_node.h	/^        uint16_t capacity_ = 0;$/;"	m	class:t_rr_node	access:private
t_rr_node::class_num	route/rr_node.cpp	/^short t_rr_node::class_num() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::class_num	route/rr_node.h	/^        short class_num() const; \/\/Same as ptc_num() but checks that type() is consistent$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::configurable_edges	route/rr_node.h	/^        edge_idx_range configurable_edges() const { return vtr::make_range(edge_idx_iterator(0), edge_idx_iterator(num_edges() - num_non_configurable_edges())); }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::cost_index	route/rr_node.cpp	/^short t_rr_node::cost_index() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::cost_index	route/rr_node.h	/^        short cost_index() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::cost_index_	route/rr_node.h	/^        int8_t cost_index_ = -1;$/;"	m	class:t_rr_node	access:private
t_rr_node::dir_side_	route/rr_node.h	/^        } dir_side_;$/;"	m	class:t_rr_node	typeref:union:t_rr_node::__anon8	access:private
t_rr_node::direction	route/rr_node.cpp	/^e_direction t_rr_node::direction() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::direction	route/rr_node.h	/^        e_direction direction() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::direction_string	route/rr_node.cpp	/^const char* t_rr_node::direction_string() const{$/;"	f	class:t_rr_node	signature:() const
t_rr_node::direction_string	route/rr_node.h	/^        const char *direction_string() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::edge_idx_iterator	route/rr_node.h	/^        class edge_idx_iterator : public std::iterator<std::bidirectional_iterator_tag, short> {$/;"	c	class:t_rr_node	inherits:std::iterator	access:public
t_rr_node::edge_idx_iterator::edge_idx_iterator	route/rr_node.h	/^            edge_idx_iterator(value_type init): value_(init) {}$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:(value_type init)
t_rr_node::edge_idx_iterator::operator !=	route/rr_node.h	/^            friend bool operator!= (const edge_idx_iterator lhs, const edge_idx_iterator rhs) { return !(lhs == rhs); }$/;"	f	class:t_rr_node::edge_idx_iterator	access:friend	signature:(const edge_idx_iterator lhs, const edge_idx_iterator rhs)
t_rr_node::edge_idx_iterator::operator *	route/rr_node.h	/^            reference operator*() { return value_; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
t_rr_node::edge_idx_iterator::operator ++	route/rr_node.h	/^            iterator operator++() { value_ += 1; return *this; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
t_rr_node::edge_idx_iterator::operator --	route/rr_node.h	/^            iterator operator--() { value_ -= 1; return *this; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
t_rr_node::edge_idx_iterator::operator ->	route/rr_node.h	/^            pointer operator->() { return &value_; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:public	signature:()
t_rr_node::edge_idx_iterator::operator ==	route/rr_node.h	/^            friend bool operator== (const edge_idx_iterator lhs, const edge_idx_iterator rhs) { return lhs.value_ == rhs.value_; }$/;"	f	class:t_rr_node::edge_idx_iterator	access:friend	signature:(const edge_idx_iterator lhs, const edge_idx_iterator rhs)
t_rr_node::edge_idx_iterator::value_	route/rr_node.h	/^                value_type value_;$/;"	m	class:t_rr_node::edge_idx_iterator	access:private
t_rr_node::edge_idx_range	route/rr_node.h	/^        typedef vtr::Range<edge_idx_iterator> edge_idx_range;$/;"	t	class:t_rr_node	access:public
t_rr_node::edge_is_configurable	route/rr_node.cpp	/^bool t_rr_node::edge_is_configurable(short iedge) const {$/;"	f	class:t_rr_node	signature:(short iedge) const
t_rr_node::edge_is_configurable	route/rr_node.h	/^        bool edge_is_configurable(short iedge) const;$/;"	p	class:t_rr_node	access:public	signature:(short iedge) const
t_rr_node::edge_sink_node	route/rr_node.h	/^        int edge_sink_node(short iedge) const { VTR_ASSERT_SAFE(iedge < num_edges()); return edges_[iedge].sink_node; }$/;"	f	class:t_rr_node	access:public	signature:(short iedge) const
t_rr_node::edge_switch	route/rr_node.h	/^        short edge_switch(short iedge) const { VTR_ASSERT_SAFE(iedge < num_edges()); return edges_[iedge].switch_id; }$/;"	f	class:t_rr_node	access:public	signature:(short iedge) const
t_rr_node::edges	route/rr_node.h	/^        edge_idx_range edges() const { return vtr::make_range(edge_idx_iterator(0), edge_idx_iterator(num_edges())); }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::edges_	route/rr_node.h	/^        std::unique_ptr<t_rr_edge[]> edges_ = nullptr;$/;"	m	class:t_rr_node	access:private
t_rr_node::edges_capacity_	route/rr_node.h	/^        uint16_t edges_capacity_ = 0;$/;"	m	class:t_rr_node	access:private
t_rr_node::fan_in	route/rr_node.cpp	/^short t_rr_node::fan_in() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::fan_in	route/rr_node.h	/^        short fan_in() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::fan_in_	route/rr_node.h	/^        uint16_t fan_in_ = 0;$/;"	m	class:t_rr_node	access:private
t_rr_node::length	route/rr_node.cpp	/^short t_rr_node::length() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::length	route/rr_node.h	/^        signed short length() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::non_configurable_edges	route/rr_node.h	/^        edge_idx_range non_configurable_edges() const { return vtr::make_range(edge_idx_iterator(num_edges() - num_non_configurable_edges()), edge_idx_iterator(num_edges())); }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::num_configurable_edges	route/rr_node.h	/^        short num_configurable_edges() const { return num_edges() - num_non_configurable_edges(); }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::num_edges	route/rr_node.h	/^        short num_edges() const { return num_edges_; }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::num_edges_	route/rr_node.h	/^        uint16_t num_edges_ = 0;$/;"	m	class:t_rr_node	access:private
t_rr_node::num_non_configurable_edges	route/rr_node.h	/^        short num_non_configurable_edges() const { return num_non_configurable_edges_; }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::num_non_configurable_edges_	route/rr_node.h	/^        uint8_t num_non_configurable_edges_ = 0;$/;"	m	class:t_rr_node	access:private
t_rr_node::partition_edges	route/rr_node.cpp	/^void t_rr_node::partition_edges() {$/;"	f	class:t_rr_node	signature:()
t_rr_node::partition_edges	route/rr_node.h	/^        void partition_edges();$/;"	p	class:t_rr_node	access:public	signature:()
t_rr_node::pin_num	route/rr_node.cpp	/^short t_rr_node::pin_num() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::pin_num	route/rr_node.h	/^        short pin_num() const; \/\/Same as ptc_num() but checks that type() is consistent$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::ptc_	route/rr_node.h	/^        } ptc_;$/;"	m	class:t_rr_node	typeref:union:t_rr_node::__anon9	access:private
t_rr_node::ptc_num	route/rr_node.cpp	/^short t_rr_node::ptc_num() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::ptc_num	route/rr_node.h	/^        short ptc_num() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::rc_index	route/rr_node.cpp	/^short t_rr_node::rc_index() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::rc_index	route/rr_node.h	/^        short rc_index() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::rc_index_	route/rr_node.h	/^        int16_t rc_index_ = -1;$/;"	m	class:t_rr_node	access:private
t_rr_node::set_capacity	route/rr_node.cpp	/^void t_rr_node::set_capacity(short new_capacity) {$/;"	f	class:t_rr_node	signature:(short new_capacity)
t_rr_node::set_capacity	route/rr_node.h	/^        void set_capacity(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_class_num	route/rr_node.cpp	/^void t_rr_node::set_class_num(short new_class_num) {$/;"	f	class:t_rr_node	signature:(short new_class_num)
t_rr_node::set_class_num	route/rr_node.h	/^        void set_class_num(short); \/\/Same as set_ptc_num() by checks type() is consistent$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_coordinates	route/rr_node.cpp	/^void t_rr_node::set_coordinates(short x1, short y1, short x2, short y2) {$/;"	f	class:t_rr_node	signature:(short x1, short y1, short x2, short y2)
t_rr_node::set_coordinates	route/rr_node.h	/^        void set_coordinates(short x1, short y1, short x2, short y2);$/;"	p	class:t_rr_node	access:public	signature:(short x1, short y1, short x2, short y2)
t_rr_node::set_cost_index	route/rr_node.cpp	/^void t_rr_node::set_cost_index(short new_cost_index) {$/;"	f	class:t_rr_node	signature:(short new_cost_index)
t_rr_node::set_cost_index	route/rr_node.h	/^        void set_cost_index(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_direction	route/rr_node.cpp	/^void t_rr_node::set_direction(e_direction new_direction) {$/;"	f	class:t_rr_node	signature:(e_direction new_direction)
t_rr_node::set_direction	route/rr_node.h	/^        void set_direction(e_direction);$/;"	p	class:t_rr_node	access:public	signature:(e_direction)
t_rr_node::set_edge_sink_node	route/rr_node.cpp	/^void t_rr_node::set_edge_sink_node(short iedge, int sink_node) {$/;"	f	class:t_rr_node	signature:(short iedge, int sink_node)
t_rr_node::set_edge_sink_node	route/rr_node.h	/^        void set_edge_sink_node(short iedge, int sink_node);$/;"	p	class:t_rr_node	access:public	signature:(short iedge, int sink_node)
t_rr_node::set_edge_switch	route/rr_node.cpp	/^void t_rr_node::set_edge_switch(short iedge, short switch_index) {$/;"	f	class:t_rr_node	signature:(short iedge, short switch_index)
t_rr_node::set_edge_switch	route/rr_node.h	/^        void set_edge_switch(short iedge, short switch_index);$/;"	p	class:t_rr_node	access:public	signature:(short iedge, short switch_index)
t_rr_node::set_fan_in	route/rr_node.cpp	/^void t_rr_node::set_fan_in(short new_fan_in) {$/;"	f	class:t_rr_node	signature:(short new_fan_in)
t_rr_node::set_fan_in	route/rr_node.h	/^        void set_fan_in(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_num_edges	route/rr_node.cpp	/^void t_rr_node::set_num_edges(short new_num_edges) {$/;"	f	class:t_rr_node	signature:(short new_num_edges)
t_rr_node::set_num_edges	route/rr_node.h	/^        void set_num_edges(short); \/\/Note will remove any previous edges$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_pin_num	route/rr_node.cpp	/^void t_rr_node::set_pin_num(short new_pin_num) {$/;"	f	class:t_rr_node	signature:(short new_pin_num)
t_rr_node::set_pin_num	route/rr_node.h	/^        void set_pin_num(short); \/\/Same as set_ptc_num() by checks type() is consistent$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_ptc_num	route/rr_node.cpp	/^void t_rr_node::set_ptc_num(short new_ptc_num) {$/;"	f	class:t_rr_node	signature:(short new_ptc_num)
t_rr_node::set_ptc_num	route/rr_node.h	/^        void set_ptc_num(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_rc_index	route/rr_node.cpp	/^void t_rr_node::set_rc_index(short new_rc_index) {$/;"	f	class:t_rr_node	signature:(short new_rc_index)
t_rr_node::set_rc_index	route/rr_node.h	/^        void set_rc_index(short);$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_side	route/rr_node.cpp	/^void t_rr_node::set_side(e_side new_side) {$/;"	f	class:t_rr_node	signature:(e_side new_side)
t_rr_node::set_side	route/rr_node.h	/^        void set_side(e_side);$/;"	p	class:t_rr_node	access:public	signature:(e_side)
t_rr_node::set_track_num	route/rr_node.cpp	/^void t_rr_node::set_track_num(short new_track_num) {$/;"	f	class:t_rr_node	signature:(short new_track_num)
t_rr_node::set_track_num	route/rr_node.h	/^        void set_track_num(short); \/\/Same as set_ptc_num() by checks type() is consistent$/;"	p	class:t_rr_node	access:public	signature:(short)
t_rr_node::set_type	route/rr_node.cpp	/^void t_rr_node::set_type(t_rr_type new_type) {$/;"	f	class:t_rr_node	signature:(t_rr_type new_type)
t_rr_node::set_type	route/rr_node.h	/^        void set_type(t_rr_type new_type);$/;"	p	class:t_rr_node	access:public	signature:(t_rr_type new_type)
t_rr_node::shrink_to_fit	route/rr_node.cpp	/^void t_rr_node::shrink_to_fit() {$/;"	f	class:t_rr_node	signature:()
t_rr_node::shrink_to_fit	route/rr_node.h	/^        void shrink_to_fit();$/;"	p	class:t_rr_node	access:public	signature:()
t_rr_node::side	route/rr_node.cpp	/^e_side t_rr_node::side() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::side	route/rr_node.h	/^        e_side side() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::side_string	route/rr_node.cpp	/^const char* t_rr_node::side_string() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::side_string	route/rr_node.h	/^        const char *side_string() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::t_rr_edge	route/rr_node.h	/^        struct t_rr_edge {$/;"	s	class:t_rr_node	access:private
t_rr_node::t_rr_edge::sink_node	route/rr_node.h	/^            int sink_node = -1; \/\/The ID of the sink RR node associated with this edge$/;"	m	struct:t_rr_node::t_rr_edge	access:public
t_rr_node::t_rr_edge::switch_id	route/rr_node.h	/^            short switch_id = -1; \/\/The ID of the switch type this edge represents$/;"	m	struct:t_rr_node::t_rr_edge	access:public
t_rr_node::track_num	route/rr_node.cpp	/^short t_rr_node::track_num() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::track_num	route/rr_node.h	/^        short track_num() const; \/\/Same as ptc_num() but checks that type() is consistent$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::type	route/rr_node.h	/^        t_rr_type type() const { return type_; }$/;"	f	class:t_rr_node	access:public	signature:() const
t_rr_node::type_	route/rr_node.h	/^        t_rr_type type_ = NUM_RR_TYPES;$/;"	m	class:t_rr_node	access:private
t_rr_node::type_string	route/rr_node.cpp	/^const char *t_rr_node::type_string() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::type_string	route/rr_node.h	/^        const char *type_string() const; \/* Retrieve type as a string *\/$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::validate	route/rr_node.cpp	/^bool t_rr_node::validate() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::validate	route/rr_node.h	/^        bool validate() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::xhigh	route/rr_node.cpp	/^short t_rr_node::xhigh() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::xhigh	route/rr_node.h	/^        short xhigh() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::xhigh_	route/rr_node.h	/^        int16_t xhigh_ = -1;$/;"	m	class:t_rr_node	access:private
t_rr_node::xlow	route/rr_node.cpp	/^short t_rr_node::xlow() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::xlow	route/rr_node.h	/^        short xlow() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::xlow_	route/rr_node.h	/^        int16_t xlow_ = -1;$/;"	m	class:t_rr_node	access:private
t_rr_node::yhigh	route/rr_node.cpp	/^short t_rr_node::yhigh() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::yhigh	route/rr_node.h	/^        short yhigh() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::yhigh_	route/rr_node.h	/^        int16_t yhigh_ = -1;$/;"	m	class:t_rr_node	access:private
t_rr_node::ylow	route/rr_node.cpp	/^short t_rr_node::ylow() const {$/;"	f	class:t_rr_node	signature:() const
t_rr_node::ylow	route/rr_node.h	/^        short ylow() const;$/;"	p	class:t_rr_node	access:public	signature:() const
t_rr_node::ylow_	route/rr_node.h	/^        int16_t ylow_ = -1;$/;"	m	class:t_rr_node	access:private
t_rr_node_indices	base/vpr_types.h	/^typedef std::vector<std::vector<std::vector<std::vector<std::vector<int>>>>> t_rr_node_indices; \/\/[0..num_rr_types-1][0..grid_width-1][0..grid_height-1][0..NUM_SIDES-1][0..max_ptc-1]$/;"	t	class:ScreenUpdatePriority	access:private
t_rr_node_power	power/power.h	/^struct t_rr_node_power {$/;"	s
t_rr_node_power::driver_switch_type	power/power.h	/^	short driver_switch_type; \/* Switch type that drives this resource *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_power::in_dens	power/power.h	/^	float * in_dens; \/* Switching density of inputs *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_power::in_prob	power/power.h	/^	float * in_prob; \/* Static probability of inputs *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_power::net_num	power/power.h	/^	ClusterNetId net_num; \/* Net number using the associated rr_node *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_power::num_inputs	power/power.h	/^	short num_inputs; \/* Number of inputs *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_power::selected_input	power/power.h	/^	short selected_input; \/* Input index that is selected *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_power::visited	power/power.h	/^	bool visited; \/* When traversing netlist, need to track whether the node has been processed *\/$/;"	m	struct:t_rr_node_power	access:public
t_rr_node_route_inf	base/vpr_types.h	/^struct t_rr_node_route_inf {$/;"	s	class:ScreenUpdatePriority	access:private
t_rr_rc_data	route/rr_node.cpp	/^t_rr_rc_data::t_rr_rc_data(float Rval, float Cval)$/;"	f	class:t_rr_rc_data	signature:(float Rval, float Cval)
t_rr_rc_data	route/rr_node.h	/^    t_rr_rc_data(float Rval, float Cval);$/;"	p	struct:t_rr_rc_data	access:public	signature:(float Rval, float Cval)
t_rr_rc_data	route/rr_node.h	/^struct t_rr_rc_data {$/;"	s
t_rr_rc_data::C	route/rr_node.h	/^    float C;$/;"	m	struct:t_rr_rc_data	access:public
t_rr_rc_data::R	route/rr_node.h	/^    float R;$/;"	m	struct:t_rr_rc_data	access:public
t_rr_rc_data::t_rr_rc_data	route/rr_node.cpp	/^t_rr_rc_data::t_rr_rc_data(float Rval, float Cval)$/;"	f	class:t_rr_rc_data	signature:(float Rval, float Cval)
t_rr_rc_data::t_rr_rc_data	route/rr_node.h	/^    t_rr_rc_data(float Rval, float Cval);$/;"	p	struct:t_rr_rc_data	access:public	signature:(float Rval, float Cval)
t_rr_switch_inf	../../libs/libarchfpga/src/physical_types.h	/^struct t_rr_switch_inf {$/;"	s
t_rr_switch_inf::Cin	../../libs/libarchfpga/src/physical_types.h	/^	float Cin = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::Cout	../../libs/libarchfpga/src/physical_types.h	/^	float Cout = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::R	../../libs/libarchfpga/src/physical_types.h	/^	float R = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::Tdel	../../libs/libarchfpga/src/physical_types.h	/^	float Tdel = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::buf_size	../../libs/libarchfpga/src/physical_types.h	/^	float buf_size = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::buffered	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_rr_switch_inf::buffered() const {$/;"	f	class:t_rr_switch_inf	signature:() const
t_rr_switch_inf::buffered	../../libs/libarchfpga/src/physical_types.h	/^        bool buffered() const;$/;"	p	struct:t_rr_switch_inf	access:public	signature:() const
t_rr_switch_inf::configurable	../../libs/libarchfpga/src/physical_types.cpp	/^bool t_rr_switch_inf::configurable() const {$/;"	f	class:t_rr_switch_inf	signature:() const
t_rr_switch_inf::configurable	../../libs/libarchfpga/src/physical_types.h	/^        bool configurable() const;$/;"	p	struct:t_rr_switch_inf	access:public	signature:() const
t_rr_switch_inf::mux_trans_size	../../libs/libarchfpga/src/physical_types.h	/^	float mux_trans_size = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::name	../../libs/libarchfpga/src/physical_types.h	/^	const char *name = nullptr;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::power_buffer_size	../../libs/libarchfpga/src/physical_types.h	/^	float power_buffer_size = 0.;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::power_buffer_type	../../libs/libarchfpga/src/physical_types.h	/^	e_power_buffer_type power_buffer_type = POWER_BUFFER_TYPE_UNDEFINED;$/;"	m	struct:t_rr_switch_inf	access:public
t_rr_switch_inf::set_type	../../libs/libarchfpga/src/physical_types.cpp	/^void t_rr_switch_inf::set_type(SwitchType type_val) {$/;"	f	class:t_rr_switch_inf	signature:(SwitchType type_val)
t_rr_switch_inf::set_type	../../libs/libarchfpga/src/physical_types.h	/^        void set_type(SwitchType type_val);$/;"	p	struct:t_rr_switch_inf	access:public	signature:(SwitchType type_val)
t_rr_switch_inf::type	../../libs/libarchfpga/src/physical_types.cpp	/^SwitchType t_rr_switch_inf::type() const {$/;"	f	class:t_rr_switch_inf	signature:() const
t_rr_switch_inf::type	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type() const;$/;"	p	struct:t_rr_switch_inf	access:public	signature:() const
t_rr_switch_inf::type_	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type_ = SwitchType::INVALID;$/;"	m	struct:t_rr_switch_inf	access:private
t_rr_type	base/vpr_types.h	/^} t_rr_type;$/;"	m	class:ScreenUpdatePriority	access:private
t_rt_node	route/route_tree_type.h	/^struct t_rt_node {$/;"	s
t_rt_node::C_downstream	route/route_tree_type.h	/^	float C_downstream;$/;"	m	struct:t_rt_node	access:public
t_rt_node::R_upstream	route/route_tree_type.h	/^	float R_upstream;$/;"	m	struct:t_rt_node	access:public
t_rt_node::Tdel	route/route_tree_type.h	/^	float Tdel;$/;"	m	struct:t_rt_node	access:public
t_rt_node::__anon7::child_list	route/route_tree_type.h	/^		t_linked_rt_edge *child_list;$/;"	m	union:t_rt_node::__anon7	access:public
t_rt_node::__anon7::next	route/route_tree_type.h	/^		t_rt_node *next;$/;"	m	union:t_rt_node::__anon7	access:public
t_rt_node::inode	route/route_tree_type.h	/^	int inode;$/;"	m	struct:t_rt_node	access:public
t_rt_node::parent_node	route/route_tree_type.h	/^	t_rt_node *parent_node;$/;"	m	struct:t_rt_node	access:public
t_rt_node::parent_switch	route/route_tree_type.h	/^	short parent_switch;$/;"	m	struct:t_rt_node	access:public
t_rt_node::re_expand	route/route_tree_type.h	/^	bool re_expand;$/;"	m	struct:t_rt_node	access:public
t_rt_node::u	route/route_tree_type.h	/^	} u;$/;"	m	struct:t_rt_node	typeref:union:t_rt_node::__anon7	access:public
t_sb_connection_map	route/build_switchblocks.h	/^typedef std::unordered_map<Switchblock_Lookup, std::vector<t_switchblock_edge>, t_hash_Switchblock_Lookup > t_sb_connection_map;$/;"	t
t_sblock_pattern	route/rr_graph2.h	/^typedef vtr::NdMatrix<short,6> t_sblock_pattern;$/;"	t
t_sdc_clock	timing/read_sdc.cpp	/^struct t_sdc_clock {$/;"	s	file:
t_sdc_clock::falling_edge	timing/read_sdc.cpp	/^	float falling_edge;$/;"	m	struct:t_sdc_clock	file:	access:public
t_sdc_clock::name	timing/read_sdc.cpp	/^	char * name;$/;"	m	struct:t_sdc_clock	file:	access:public
t_sdc_clock::period	timing/read_sdc.cpp	/^	float period;$/;"	m	struct:t_sdc_clock	file:	access:public
t_sdc_clock::rising_edge	timing/read_sdc.cpp	/^	float rising_edge;$/;"	m	struct:t_sdc_clock	file:	access:public
t_sdc_exclusive_group	timing/read_sdc.cpp	/^struct t_sdc_exclusive_group {$/;"	s	file:
t_sdc_exclusive_group::clock_names	timing/read_sdc.cpp	/^	char ** clock_names;$/;"	m	struct:t_sdc_exclusive_group	file:	access:public
t_sdc_exclusive_group::num_clock_names	timing/read_sdc.cpp	/^	int num_clock_names;$/;"	m	struct:t_sdc_exclusive_group	file:	access:public
t_seg_details	base/vpr_types.h	/^struct t_seg_details {$/;"	s	class:ScreenUpdatePriority	access:private
t_segment_inf	../../libs/libarchfpga/src/physical_types.h	/^struct t_segment_inf {$/;"	s
t_segment_inf::Cmetal	../../libs/libarchfpga/src/physical_types.h	/^	float Cmetal;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::Rmetal	../../libs/libarchfpga/src/physical_types.h	/^	float Rmetal;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::arch_opin_switch	../../libs/libarchfpga/src/physical_types.h	/^	short arch_opin_switch;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::arch_wire_switch	../../libs/libarchfpga/src/physical_types.h	/^	short arch_wire_switch;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::cb	../../libs/libarchfpga/src/physical_types.h	/^	bool *cb;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::cb_len	../../libs/libarchfpga/src/physical_types.h	/^	int cb_len;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::directionality	../../libs/libarchfpga/src/physical_types.h	/^	enum e_directionality directionality;$/;"	m	struct:t_segment_inf	typeref:enum:t_segment_inf::e_directionality	access:public
t_segment_inf::frac_cb	../../libs/libarchfpga/src/physical_types.h	/^	float frac_cb;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::frac_sb	../../libs/libarchfpga/src/physical_types.h	/^	float frac_sb;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::frequency	../../libs/libarchfpga/src/physical_types.h	/^	int frequency;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::length	../../libs/libarchfpga/src/physical_types.h	/^	int length;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::longline	../../libs/libarchfpga/src/physical_types.h	/^	bool longline;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::name	../../libs/libarchfpga/src/physical_types.h	/^	char *name;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::sb	../../libs/libarchfpga/src/physical_types.h	/^	bool *sb;$/;"	m	struct:t_segment_inf	access:public
t_segment_inf::sb_len	../../libs/libarchfpga/src/physical_types.h	/^	int sb_len;$/;"	m	struct:t_segment_inf	access:public
t_selected_sub_block_info	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::t_selected_sub_block_info() {$/;"	f	class:t_selected_sub_block_info	signature:()
t_selected_sub_block_info	draw/intra_logic_block.h	/^	t_selected_sub_block_info();$/;"	p	struct:t_selected_sub_block_info	access:public	signature:()
t_selected_sub_block_info	draw/intra_logic_block.h	/^struct t_selected_sub_block_info {$/;"	s
t_selected_sub_block_info::clb_pin_tuple	draw/intra_logic_block.h	/^	struct clb_pin_tuple {$/;"	s	struct:t_selected_sub_block_info	access:public
t_selected_sub_block_info::clb_pin_tuple::clb_index	draw/intra_logic_block.h	/^		ClusterBlockId clb_index;$/;"	m	struct:t_selected_sub_block_info::clb_pin_tuple	access:public
t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple(ClusterBlockId clb_index_, const t_pb_graph_node* pb_gnode_) :$/;"	f	class:t_selected_sub_block_info::clb_pin_tuple	signature:(ClusterBlockId clb_index_, const t_pb_graph_node* pb_gnode_)
t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple(const AtomPinId atom_pin) {$/;"	f	class:t_selected_sub_block_info::clb_pin_tuple	signature:(const AtomPinId atom_pin)
t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple	draw/intra_logic_block.h	/^		clb_pin_tuple(ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode);$/;"	p	struct:t_selected_sub_block_info::clb_pin_tuple	access:public	signature:(ClusterBlockId clb_index, const t_pb_graph_node* pb_gnode)
t_selected_sub_block_info::clb_pin_tuple::clb_pin_tuple	draw/intra_logic_block.h	/^		clb_pin_tuple(const AtomPinId atom_pin);$/;"	p	struct:t_selected_sub_block_info::clb_pin_tuple	access:public	signature:(const AtomPinId atom_pin)
t_selected_sub_block_info::clb_pin_tuple::operator ==	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::clb_pin_tuple::operator==(const clb_pin_tuple& rhs) const {$/;"	f	class:t_selected_sub_block_info::clb_pin_tuple	signature:(const clb_pin_tuple& rhs) const
t_selected_sub_block_info::clb_pin_tuple::operator ==	draw/intra_logic_block.h	/^		bool operator==(const clb_pin_tuple&) const;$/;"	p	struct:t_selected_sub_block_info::clb_pin_tuple	access:public	signature:(const clb_pin_tuple&) const
t_selected_sub_block_info::clb_pin_tuple::pb_gnode	draw/intra_logic_block.h	/^		const t_pb_graph_node* pb_gnode;$/;"	m	struct:t_selected_sub_block_info::clb_pin_tuple	access:public
t_selected_sub_block_info::clear	draw/intra_logic_block.cpp	/^void t_selected_sub_block_info::clear() {$/;"	f	class:t_selected_sub_block_info	signature:()
t_selected_sub_block_info::clear	draw/intra_logic_block.h	/^	void clear();$/;"	p	struct:t_selected_sub_block_info	access:public	signature:()
t_selected_sub_block_info::containing_block_index	draw/intra_logic_block.h	/^	ClusterBlockId containing_block_index;$/;"	m	struct:t_selected_sub_block_info	access:private
t_selected_sub_block_info::get_containing_block	draw/intra_logic_block.cpp	/^ClusterBlockId t_selected_sub_block_info::get_containing_block() const { return containing_block_index; }$/;"	f	class:t_selected_sub_block_info	signature:() const
t_selected_sub_block_info::get_containing_block	draw/intra_logic_block.h	/^	ClusterBlockId get_containing_block() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
t_selected_sub_block_info::get_selected_pb	draw/intra_logic_block.cpp	/^t_pb* t_selected_sub_block_info::get_selected_pb() const { return selected_pb; }$/;"	f	class:t_selected_sub_block_info	signature:() const
t_selected_sub_block_info::get_selected_pb	draw/intra_logic_block.h	/^	t_pb* get_selected_pb() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
t_selected_sub_block_info::get_selected_pb_gnode	draw/intra_logic_block.cpp	/^t_pb_graph_node* t_selected_sub_block_info::get_selected_pb_gnode() const { return selected_pb_gnode; }$/;"	f	class:t_selected_sub_block_info	signature:() const
t_selected_sub_block_info::get_selected_pb_gnode	draw/intra_logic_block.h	/^	t_pb_graph_node* get_selected_pb_gnode() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
t_selected_sub_block_info::gnode_clb_pair	draw/intra_logic_block.h	/^	struct gnode_clb_pair {$/;"	s	struct:t_selected_sub_block_info	access:public
t_selected_sub_block_info::gnode_clb_pair::clb_index	draw/intra_logic_block.h	/^		const ClusterBlockId clb_index;$/;"	m	struct:t_selected_sub_block_info::gnode_clb_pair	access:public
t_selected_sub_block_info::gnode_clb_pair::gnode_clb_pair	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::gnode_clb_pair::gnode_clb_pair(const t_pb_graph_node* pb_gnode_, const ClusterBlockId clb_index_) :$/;"	f	class:t_selected_sub_block_info::gnode_clb_pair	signature:(const t_pb_graph_node* pb_gnode_, const ClusterBlockId clb_index_)
t_selected_sub_block_info::gnode_clb_pair::gnode_clb_pair	draw/intra_logic_block.h	/^		gnode_clb_pair() = default;$/;"	p	struct:t_selected_sub_block_info::gnode_clb_pair	access:public	signature:()
t_selected_sub_block_info::gnode_clb_pair::gnode_clb_pair	draw/intra_logic_block.h	/^		gnode_clb_pair(const t_pb_graph_node* pb_gnode, const ClusterBlockId clb_index);$/;"	p	struct:t_selected_sub_block_info::gnode_clb_pair	access:public	signature:(const t_pb_graph_node* pb_gnode, const ClusterBlockId clb_index)
t_selected_sub_block_info::gnode_clb_pair::operator ==	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::gnode_clb_pair::operator==(const gnode_clb_pair& rhs) const {$/;"	f	class:t_selected_sub_block_info::gnode_clb_pair	signature:(const gnode_clb_pair& rhs) const
t_selected_sub_block_info::gnode_clb_pair::operator ==	draw/intra_logic_block.h	/^		bool operator==(const gnode_clb_pair &) const;$/;"	p	struct:t_selected_sub_block_info::gnode_clb_pair	access:public	signature:(const gnode_clb_pair &) const
t_selected_sub_block_info::gnode_clb_pair::pb_gnode	draw/intra_logic_block.h	/^		const t_pb_graph_node* pb_gnode = nullptr;$/;"	m	struct:t_selected_sub_block_info::gnode_clb_pair	access:public
t_selected_sub_block_info::has_selection	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::has_selection() const {$/;"	f	class:t_selected_sub_block_info	signature:() const
t_selected_sub_block_info::has_selection	draw/intra_logic_block.h	/^	bool has_selection() const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:() const
t_selected_sub_block_info::in_selected_subtree	draw/intra_logic_block.h	/^	std::unordered_set< gnode_clb_pair, sel_subblk_hasher > in_selected_subtree;$/;"	m	struct:t_selected_sub_block_info	access:private
t_selected_sub_block_info::is_in_selected_subtree	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_in_selected_subtree(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_in_selected_subtree	draw/intra_logic_block.h	/^	bool is_in_selected_subtree(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_selected	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_selected	draw/intra_logic_block.h	/^	bool is_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_sink_of_selected	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_sink_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_sink_of_selected	draw/intra_logic_block.h	/^	bool is_sink_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_source_of_selected	draw/intra_logic_block.cpp	/^bool t_selected_sub_block_info::is_source_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const {$/;"	f	class:t_selected_sub_block_info	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::is_source_of_selected	draw/intra_logic_block.h	/^	bool is_source_of_selected(const t_pb_graph_node* test, const ClusterBlockId clb_index) const;$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(const t_pb_graph_node* test, const ClusterBlockId clb_index) const
t_selected_sub_block_info::sel_subblk_hasher	draw/intra_logic_block.h	/^	struct sel_subblk_hasher {$/;"	s	struct:t_selected_sub_block_info	access:public
t_selected_sub_block_info::sel_subblk_hasher::operator ()	draw/intra_logic_block.h	/^		inline std::size_t operator()(const clb_pin_tuple& v) const {$/;"	f	struct:t_selected_sub_block_info::sel_subblk_hasher	access:public	signature:(const clb_pin_tuple& v) const
t_selected_sub_block_info::sel_subblk_hasher::operator ()	draw/intra_logic_block.h	/^		inline std::size_t operator()(const gnode_clb_pair& v) const {$/;"	f	struct:t_selected_sub_block_info::sel_subblk_hasher	access:public	signature:(const gnode_clb_pair& v) const
t_selected_sub_block_info::sel_subblk_hasher::operator ()	draw/intra_logic_block.h	/^		inline std::size_t operator()(const std::pair<clb_pin_tuple, clb_pin_tuple>& v) const {$/;"	f	struct:t_selected_sub_block_info::sel_subblk_hasher	access:public	signature:(const std::pair<clb_pin_tuple, clb_pin_tuple>& v) const
t_selected_sub_block_info::selected_pb	draw/intra_logic_block.h	/^	t_pb* selected_pb;$/;"	m	struct:t_selected_sub_block_info	access:private
t_selected_sub_block_info::selected_pb_gnode	draw/intra_logic_block.h	/^	t_pb_graph_node* selected_pb_gnode;$/;"	m	struct:t_selected_sub_block_info	access:private
t_selected_sub_block_info::set	draw/intra_logic_block.cpp	/^void t_selected_sub_block_info::set(t_pb* new_selected_sub_block, const ClusterBlockId new_containing_block_index) {$/;"	f	class:t_selected_sub_block_info	signature:(t_pb* new_selected_sub_block, const ClusterBlockId new_containing_block_index)
t_selected_sub_block_info::set	draw/intra_logic_block.h	/^	void set(t_pb* new_selected_sub_block, const ClusterBlockId containing_block_index);$/;"	p	struct:t_selected_sub_block_info	access:public	signature:(t_pb* new_selected_sub_block, const ClusterBlockId containing_block_index)
t_selected_sub_block_info::sinks	draw/intra_logic_block.h	/^	std::unordered_set< gnode_clb_pair, sel_subblk_hasher > sinks;$/;"	m	struct:t_selected_sub_block_info	access:private
t_selected_sub_block_info::sources	draw/intra_logic_block.h	/^	std::unordered_set< gnode_clb_pair, sel_subblk_hasher > sources;$/;"	m	struct:t_selected_sub_block_info	access:private
t_selected_sub_block_info::t_selected_sub_block_info	draw/intra_logic_block.cpp	/^t_selected_sub_block_info::t_selected_sub_block_info() {$/;"	f	class:t_selected_sub_block_info	signature:()
t_selected_sub_block_info::t_selected_sub_block_info	draw/intra_logic_block.h	/^	t_selected_sub_block_info();$/;"	p	struct:t_selected_sub_block_info	access:public	signature:()
t_slack	base/vpr_types.h	/^struct t_slack {$/;"	s	class:ScreenUpdatePriority	access:private
t_solution_inf	power/power.h	/^struct t_solution_inf {$/;"	s
t_solution_inf::T_crit	power/power.h	/^	float T_crit;$/;"	m	struct:t_solution_inf	access:public
t_solution_inf::channel_width	power/power.h	/^	int channel_width;$/;"	m	struct:t_solution_inf	access:public
t_switch_block_type	../../libs/libarchfpga/src/physical_types.h	/^typedef enum e_switch_block_type t_switch_block_type;$/;"	t	typeref:enum:e_switch_block_type
t_switchblock_edge	route/build_switchblocks.h	/^struct t_switchblock_edge {$/;"	s
t_switchblock_edge::from_wire	route/build_switchblocks.h	/^	short from_wire;$/;"	m	struct:t_switchblock_edge	access:public
t_switchblock_edge::switch_ind	route/build_switchblocks.h	/^	short switch_ind;$/;"	m	struct:t_switchblock_edge	access:public
t_switchblock_edge::to_wire	route/build_switchblocks.h	/^	short to_wire;$/;"	m	struct:t_switchblock_edge	access:public
t_switchblock_inf	../../libs/libarchfpga/src/physical_types.h	/^struct t_switchblock_inf{$/;"	s
t_switchblock_inf::directionality	../../libs/libarchfpga/src/physical_types.h	/^	e_directionality directionality;	\/* the directionality of this switchblock (unidir\/bidir) *\/$/;"	m	struct:t_switchblock_inf	access:public
t_switchblock_inf::location	../../libs/libarchfpga/src/physical_types.h	/^	e_sb_location location;			\/* where on the FPGA this switchblock should be built (i.e. perimeter, core, everywhere) *\/$/;"	m	struct:t_switchblock_inf	access:public
t_switchblock_inf::name	../../libs/libarchfpga/src/physical_types.h	/^	std::string name;			\/* the name of this switchblock *\/$/;"	m	struct:t_switchblock_inf	access:public
t_switchblock_inf::permutation_map	../../libs/libarchfpga/src/physical_types.h	/^	t_permutation_map permutation_map;	\/* map holding the permutation functions attributed to this switchblock *\/$/;"	m	struct:t_switchblock_inf	access:public
t_switchblock_inf::wireconns	../../libs/libarchfpga/src/physical_types.h	/^	std::vector<t_wireconn_inf> wireconns;	\/* list of wire types\/groups this SB will connect *\/$/;"	m	struct:t_switchblock_inf	access:public
t_tedge	base/vpr_types.h	/^struct t_tedge {$/;"	s	class:ScreenUpdatePriority	access:private
t_timing_constraints	base/vpr_types.h	/^struct t_timing_constraints { \/* Container structure for all SDC timing constraints.$/;"	s	class:ScreenUpdatePriority	access:private
t_timing_driven_node_costs	route/route_timing.cpp	/^struct t_timing_driven_node_costs {$/;"	s	file:
t_timing_driven_node_costs::R_upstream	route/route_timing.cpp	/^    float R_upstream = 0.;$/;"	m	struct:t_timing_driven_node_costs	file:	access:public
t_timing_driven_node_costs::backward_cost	route/route_timing.cpp	/^    float backward_cost = 0.;$/;"	m	struct:t_timing_driven_node_costs	file:	access:public
t_timing_driven_node_costs::total_cost	route/route_timing.cpp	/^    float total_cost = 0.;$/;"	m	struct:t_timing_driven_node_costs	file:	access:public
t_timing_inf	base/vpr_types.h	/^struct t_timing_inf {$/;"	s	class:ScreenUpdatePriority	access:private
t_timing_stats	base/vpr_types.h	/^struct t_timing_stats {$/;"	s	class:ScreenUpdatePriority	access:private
t_tnode	base/vpr_types.h	/^struct t_tnode {$/;"	s	class:ScreenUpdatePriority	access:private
t_token	util/token.h	/^struct t_token {$/;"	s
t_token::data	util/token.h	/^	char *data;$/;"	m	struct:t_token	access:public
t_token::type	util/token.h	/^	enum e_token_type type;$/;"	m	struct:t_token	typeref:enum:t_token::e_token_type	access:public
t_trace	base/vpr_types.h	/^struct t_trace {$/;"	s	class:ScreenUpdatePriority	access:private
t_trace_branch	route/route_common.cpp	/^struct t_trace_branch {$/;"	s	file:
t_trace_branch::head	route/route_common.cpp	/^    t_trace* head;$/;"	m	struct:t_trace_branch	file:	access:public
t_trace_branch::tail	route/route_common.cpp	/^    t_trace* tail;$/;"	m	struct:t_trace_branch	file:	access:public
t_traceback	route/route_traceback.cpp	/^t_traceback::t_traceback(const t_traceback& other) {$/;"	f	class:t_traceback	signature:(const t_traceback& other)
t_traceback	route/route_traceback.cpp	/^t_traceback::t_traceback(t_traceback&& other)$/;"	f	class:t_traceback	signature:(t_traceback&& other)
t_traceback	route/route_traceback.h	/^    t_traceback() = default;$/;"	p	struct:t_traceback	access:public	signature:()
t_traceback	route/route_traceback.h	/^    t_traceback(const t_traceback&);$/;"	p	struct:t_traceback	access:public	signature:(const t_traceback&)
t_traceback	route/route_traceback.h	/^    t_traceback(t_traceback&&);$/;"	p	struct:t_traceback	access:public	signature:(t_traceback&&)
t_traceback	route/route_traceback.h	/^struct t_traceback {$/;"	s
t_traceback::head	route/route_traceback.h	/^    t_trace* head = nullptr;$/;"	m	struct:t_traceback	access:public
t_traceback::operator =	route/route_traceback.cpp	/^t_traceback t_traceback::operator=(t_traceback other) {$/;"	f	class:t_traceback	signature:(t_traceback other)
t_traceback::operator =	route/route_traceback.h	/^    t_traceback operator=(t_traceback);$/;"	p	struct:t_traceback	access:public	signature:(t_traceback)
t_traceback::swap	route/route_traceback.h	/^    friend void swap(t_traceback& first, t_traceback& second);$/;"	p	struct:t_traceback	access:friend	signature:(t_traceback& first, t_traceback& second)
t_traceback::t_traceback	route/route_traceback.cpp	/^t_traceback::t_traceback(const t_traceback& other) {$/;"	f	class:t_traceback	signature:(const t_traceback& other)
t_traceback::t_traceback	route/route_traceback.cpp	/^t_traceback::t_traceback(t_traceback&& other)$/;"	f	class:t_traceback	signature:(t_traceback&& other)
t_traceback::t_traceback	route/route_traceback.h	/^    t_traceback() = default;$/;"	p	struct:t_traceback	access:public	signature:()
t_traceback::t_traceback	route/route_traceback.h	/^    t_traceback(const t_traceback&);$/;"	p	struct:t_traceback	access:public	signature:(const t_traceback&)
t_traceback::t_traceback	route/route_traceback.h	/^    t_traceback(t_traceback&&);$/;"	p	struct:t_traceback	access:public	signature:(t_traceback&&)
t_traceback::tail	route/route_traceback.h	/^    t_trace* tail = nullptr;$/;"	m	struct:t_traceback	access:public
t_traceback::~t_traceback	route/route_traceback.cpp	/^t_traceback::~t_traceback() {$/;"	f	class:t_traceback	signature:()
t_traceback::~t_traceback	route/route_traceback.h	/^    ~t_traceback();$/;"	p	struct:t_traceback	access:public	signature:()
t_track_to_pin_lookup	route/rr_types.h	/^typedef std::vector<vtr::NdMatrix<std::vector<int>,4>> t_track_to_pin_lookup;$/;"	t
t_transform_coordinates	../../libs/libeasygl/src/graphics.cpp	/^} t_transform_coordinates;$/;"	t	typeref:struct:__anon20	file:
t_transistor_inf	power/power.h	/^struct t_transistor_inf {$/;"	s
t_transistor_inf::long_trans_inf	power/power.h	/^	t_transistor_size_inf * long_trans_inf; \/* Long transistor (W=1,L=2) *\/$/;"	m	struct:t_transistor_inf	access:public
t_transistor_inf::num_size_entries	power/power.h	/^	int num_size_entries;$/;"	m	struct:t_transistor_inf	access:public
t_transistor_inf::size_inf	power/power.h	/^	t_transistor_size_inf * size_inf; \/* Array of transistor sizes *\/$/;"	m	struct:t_transistor_inf	access:public
t_transistor_size_inf	power/power.h	/^struct t_transistor_size_inf {$/;"	s
t_transistor_size_inf::C_d	power/power.h	/^	float C_d;$/;"	m	struct:t_transistor_size_inf	access:public
t_transistor_size_inf::C_g	power/power.h	/^	float C_g;$/;"	m	struct:t_transistor_size_inf	access:public
t_transistor_size_inf::C_s	power/power.h	/^	float C_s;$/;"	m	struct:t_transistor_size_inf	access:public
t_transistor_size_inf::leakage_gate	power/power.h	/^	float leakage_gate;$/;"	m	struct:t_transistor_size_inf	access:public
t_transistor_size_inf::leakage_subthreshold	power/power.h	/^	float leakage_subthreshold;$/;"	m	struct:t_transistor_size_inf	access:public
t_transistor_size_inf::size	power/power.h	/^	float size;$/;"	m	struct:t_transistor_size_inf	access:public
t_type_descriptor	../../libs/libarchfpga/src/physical_types.h	/^struct t_type_descriptor \/* TODO rename this.  maybe physical type descriptor or complex logic block or physical logic block*\/$/;"	s
t_type_descriptor::area	../../libs/libarchfpga/src/physical_types.h	/^	float area = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::capacity	../../libs/libarchfpga/src/physical_types.h	/^	int capacity = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::class_inf	../../libs/libarchfpga/src/physical_types.h	/^	t_class *class_inf = nullptr; \/* [0..num_class-1] *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::fc_specs	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_fc_specification> fc_specs;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::get_clock_pins_indices	../../libs/libarchfpga/src/physical_types.cpp	/^std::vector<int> t_type_descriptor::get_clock_pins_indices () {$/;"	f	class:t_type_descriptor	signature:()
t_type_descriptor::get_clock_pins_indices	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> get_clock_pins_indices();$/;"	p	struct:t_type_descriptor	access:public	signature:()
t_type_descriptor::height	../../libs/libarchfpga/src/physical_types.h	/^	int height = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::index	../../libs/libarchfpga/src/physical_types.h	/^	int index = -1; \/* index of type descriptor in array (allows for index referencing) *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::is_global_pin	../../libs/libarchfpga/src/physical_types.h	/^	bool *is_global_pin = nullptr; \/* [0..num_pins-1] *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::name	../../libs/libarchfpga/src/physical_types.h	/^	char *name = nullptr;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::num_class	../../libs/libarchfpga/src/physical_types.h	/^	int num_class = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::num_drivers	../../libs/libarchfpga/src/physical_types.h	/^	int num_drivers = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::num_pin_loc_assignments	../../libs/libarchfpga/src/physical_types.h	/^	int ***num_pin_loc_assignments = nullptr; \/* [0..width-1][0..height-1][0..3] *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::num_pins	../../libs/libarchfpga/src/physical_types.h	/^	int num_pins = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::num_receivers	../../libs/libarchfpga/src/physical_types.h	/^	int num_receivers = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pb_graph_head	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_graph_node *pb_graph_head = nullptr;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pb_type	../../libs/libarchfpga/src/physical_types.h	/^	t_pb_type *pb_type = nullptr;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pin_class	../../libs/libarchfpga/src/physical_types.h	/^	int *pin_class = nullptr; \/* [0..num_pins-1] *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pin_height_offset	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> pin_height_offset; \/\/[0..num_pins-1]$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pin_loc_assignments	../../libs/libarchfpga/src/physical_types.h	/^	char *****pin_loc_assignments = nullptr; \/* [0..width-1][0..height-1][0..3][0..num_tokens-1][0..string_name] *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pin_location_distribution	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_location_distr pin_location_distribution = E_SPREAD_PIN_DISTR;$/;"	m	struct:t_type_descriptor	typeref:enum:t_type_descriptor::e_pin_location_distr	access:public
t_type_descriptor::pin_width_offset	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> pin_width_offset; \/\/[0..num_pins-1]$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::pinloc	../../libs/libarchfpga/src/physical_types.h	/^	bool ****pinloc = nullptr; \/* [0..width-1][0..height-1][0..3][0..num_pins-1] *\/$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::switchblock_locations	../../libs/libarchfpga/src/physical_types.h	/^    vtr::Matrix<e_sb_type> switchblock_locations;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::switchblock_switch_overrides	../../libs/libarchfpga/src/physical_types.h	/^    vtr::Matrix<int> switchblock_switch_overrides;$/;"	m	struct:t_type_descriptor	access:public
t_type_descriptor::width	../../libs/libarchfpga/src/physical_types.h	/^	int width = 0;$/;"	m	struct:t_type_descriptor	access:public
t_type_ptr	../../libs/libarchfpga/src/physical_types.h	/^typedef const t_type_descriptor* t_type_ptr;$/;"	t
t_vec_vec_set	route/cb_metrics.h	/^typedef std::vector< std::vector< std::set<int> > > t_vec_vec_set;$/;"	t
t_vpr_error_type	util/vpr_error.h	/^typedef enum e_vpr_error t_vpr_error_type;$/;"	t	typeref:enum:e_vpr_error
t_vpr_setup	base/vpr_types.h	/^struct t_vpr_setup {$/;"	s	class:ScreenUpdatePriority	access:private
t_win32_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state::t_win32_state()$/;"	f	class:t_win32_state	signature:()
t_win32_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state::t_win32_state(bool _InEventLoop, t_window_button_state _windowAdjustFlag, int _adjustButton)$/;"	f	class:t_win32_state	signature:(bool _InEventLoop, t_window_button_state _windowAdjustFlag, int _adjustButton)
t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^	t_win32_state();$/;"	p	class:t_win32_state	access:public	signature:()
t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^	t_win32_state(bool, t_window_button_state, int);$/;"	p	class:t_win32_state	access:public	signature:(bool, t_window_button_state, int)
t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^class t_win32_state {$/;"	c
t_win32_state::InEventLoop	../../libs/libeasygl/src/graphics_state.h	/^    bool InEventLoop;$/;"	m	class:t_win32_state	access:public
t_win32_state::adjustButton	../../libs/libeasygl/src/graphics_state.h	/^    int adjustButton;$/;"	m	class:t_win32_state	access:public
t_win32_state::adjustRect	../../libs/libeasygl/src/graphics_state.h	/^    RECT adjustRect;$/;"	m	class:t_win32_state	access:public
t_win32_state::getInstance	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state *t_win32_state::getInstance()$/;"	f	class:t_win32_state	signature:()
t_win32_state::getInstance	../../libs/libeasygl/src/graphics_state.h	/^    static t_win32_state *getInstance();$/;"	p	class:t_win32_state	access:public	signature:()
t_win32_state::hButtonsWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsBrush	../../libs/libeasygl/src/graphics_state.h	/^    HBRUSH hGraphicsBrush, hGrayBrush;$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsDC	../../libs/libeasygl/src/graphics_state.h	/^    HDC hGraphicsDC;	\/\/ Current Active Drawing buffer \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsDCPassive	../../libs/libeasygl/src/graphics_state.h	/^	HDC hGraphicsDCPassive;	\/\/ Front Buffer for display purpose \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsFont	../../libs/libeasygl/src/graphics_state.h	/^    HFONT hGraphicsFont;$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsPassive	../../libs/libeasygl/src/graphics_state.h	/^	HGDIOBJ hGraphicsPassive;	\/\/ Backup of old drawing context object, usage see set_drawing_buffer() \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsPen	../../libs/libeasygl/src/graphics_state.h	/^    HPEN hGraphicsPen;$/;"	m	class:t_win32_state	access:public
t_win32_state::hGraphicsWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::hGrayBrush	../../libs/libeasygl/src/graphics_state.h	/^    HBRUSH hGraphicsBrush, hGrayBrush;$/;"	m	class:t_win32_state	access:public
t_win32_state::hMainWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::hStatusWnd	../../libs/libeasygl/src/graphics_state.h	/^    HWND hMainWnd, hGraphicsWnd, hButtonsWnd, hStatusWnd; \/\/ <Addition\/Mod: Charles>$/;"	m	class:t_win32_state	access:public
t_win32_state::instance	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state *t_win32_state::instance = NULL;$/;"	m	class:t_win32_state	file:
t_win32_state::instance	../../libs/libeasygl/src/graphics_state.h	/^    static t_win32_state *instance;$/;"	m	class:t_win32_state	access:private
t_win32_state::t_win32_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state::t_win32_state()$/;"	f	class:t_win32_state	signature:()
t_win32_state::t_win32_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state::t_win32_state(bool _InEventLoop, t_window_button_state _windowAdjustFlag, int _adjustButton)$/;"	f	class:t_win32_state	signature:(bool _InEventLoop, t_window_button_state _windowAdjustFlag, int _adjustButton)
t_win32_state::t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^	t_win32_state();$/;"	p	class:t_win32_state	access:public	signature:()
t_win32_state::t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^	t_win32_state(bool, t_window_button_state, int);$/;"	p	class:t_win32_state	access:public	signature:(bool, t_window_button_state, int)
t_win32_state::windowAdjustFlag	../../libs/libeasygl/src/graphics_state.h	/^    t_window_button_state windowAdjustFlag;$/;"	m	class:t_win32_state	access:public
t_win32_state::~t_win32_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state::~t_win32_state()$/;"	f	class:t_win32_state	signature:()
t_win32_state::~t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^    ~t_win32_state();$/;"	p	class:t_win32_state	access:public	signature:()
t_window_button_state	../../libs/libeasygl/src/graphics_state.h	/^} t_window_button_state;$/;"	t	typeref:enum:__anon23
t_wire_switchpoint	route/build_switchblocks.cpp	/^struct t_wire_switchpoint {$/;"	s	file:
t_wire_switchpoint::switchpoint	route/build_switchblocks.cpp	/^    int switchpoint;    \/\/Switchpoint of the wire$/;"	m	struct:t_wire_switchpoint	file:	access:public
t_wire_switchpoint::wire	route/build_switchblocks.cpp	/^    int wire;           \/\/Wire index within the channel$/;"	m	struct:t_wire_switchpoint	file:	access:public
t_wire_switchpoints	../../libs/libarchfpga/src/physical_types.h	/^struct t_wire_switchpoints {$/;"	s
t_wire_switchpoints::segment_name	../../libs/libarchfpga/src/physical_types.h	/^    std::string segment_name; \/\/The type of segment$/;"	m	struct:t_wire_switchpoints	access:public
t_wire_switchpoints::switchpoints	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<int> switchpoints; \/\/The indices of wire points along the segment$/;"	m	struct:t_wire_switchpoints	access:public
t_wire_type_sizes	route/build_switchblocks.cpp	/^typedef map< string, Wire_Info > t_wire_type_sizes;$/;"	t	file:
t_wireconn_inf	../../libs/libarchfpga/src/physical_types.h	/^struct t_wireconn_inf {$/;"	s
t_wireconn_inf::from_switchpoint_order	../../libs/libarchfpga/src/physical_types.h	/^    SwitchPointOrder from_switchpoint_order = SwitchPointOrder::FIXED; \/\/The desired from_switchpoint_set ordering$/;"	m	struct:t_wireconn_inf	access:public
t_wireconn_inf::from_switchpoint_set	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_wire_switchpoints> from_switchpoint_set; \/\/The set of segment\/wirepoints representing the 'from' set (union of all t_wire_switchpoints in vector)$/;"	m	struct:t_wireconn_inf	access:public
t_wireconn_inf::num_conns_formula	../../libs/libarchfpga/src/physical_types.h	/^    std::string num_conns_formula;      \/* Specifies how many connections should be made for this wireconn.$/;"	m	struct:t_wireconn_inf	access:public
t_wireconn_inf::to_switchpoint_order	../../libs/libarchfpga/src/physical_types.h	/^    SwitchPointOrder to_switchpoint_order = SwitchPointOrder::FIXED; \/\/The desired to_switchpoint_set ordering$/;"	m	struct:t_wireconn_inf	access:public
t_wireconn_inf::to_switchpoint_set	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_wire_switchpoints> to_switchpoint_set;   \/\/The set of segment\/wirepoints representing the 'to' set (union of all t_wire_switchpoints in vector)$/;"	m	struct:t_wireconn_inf	access:public
t_x11_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state::t_x11_state()$/;"	f	class:t_x11_state	signature:()
t_x11_state	../../libs/libeasygl/src/graphics_state.h	/^    t_x11_state();$/;"	p	class:t_x11_state	access:public	signature:()
t_x11_state	../../libs/libeasygl/src/graphics_state.h	/^class t_x11_state {$/;"	c
t_x11_state::attributes	../../libs/libeasygl/src/graphics_state.h	/^    XWindowAttributes attributes;$/;"	m	class:t_x11_state	access:public
t_x11_state::cairo_surface	../../libs/libeasygl/src/graphics_state.h	/^    cairo_surface_t *cairo_surface = nullptr;$/;"	m	class:t_x11_state	access:public
t_x11_state::colormap_to_use	../../libs/libeasygl/src/graphics_state.h	/^    Colormap colormap_to_use;$/;"	m	class:t_x11_state	access:public
t_x11_state::ctx	../../libs/libeasygl/src/graphics_state.h	/^    cairo_t *ctx = nullptr;$/;"	m	class:t_x11_state	access:public
t_x11_state::current_gc	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
t_x11_state::display	../../libs/libeasygl/src/graphics_state.h	/^    Display *display = nullptr;$/;"	m	class:t_x11_state	access:public
t_x11_state::draw_area	../../libs/libeasygl/src/graphics_state.h	/^    Drawable* draw_area = nullptr;$/;"	m	class:t_x11_state	access:public
t_x11_state::draw_area_draw	../../libs/libeasygl/src/graphics_state.h	/^            *draw_area_draw = nullptr;$/;"	m	class:t_x11_state	access:public
t_x11_state::draw_buffer	../../libs/libeasygl/src/graphics_state.h	/^    Pixmap draw_buffer;$/;"	m	class:t_x11_state	access:public
t_x11_state::draw_buffer_draw	../../libs/libeasygl/src/graphics_state.h	/^    XftDraw *draw_buffer_draw = nullptr,$/;"	m	class:t_x11_state	access:public
t_x11_state::gc_menus	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
t_x11_state::gc_normal	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
t_x11_state::gc_xor	../../libs/libeasygl/src/graphics_state.h	/^    GC gc_normal, gc_xor, gc_menus, current_gc;$/;"	m	class:t_x11_state	access:public
t_x11_state::getInstance	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state *t_x11_state::getInstance()$/;"	f	class:t_x11_state	signature:()
t_x11_state::getInstance	../../libs/libeasygl/src/graphics_state.h	/^    static t_x11_state *getInstance();$/;"	p	class:t_x11_state	access:public	signature:()
t_x11_state::instance	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state *t_x11_state::instance = nullptr;$/;"	m	class:t_x11_state	file:
t_x11_state::instance	../../libs/libeasygl/src/graphics_state.h	/^    static t_x11_state *instance;$/;"	m	class:t_x11_state	access:private
t_x11_state::menu	../../libs/libeasygl/src/graphics_state.h	/^    Window toplevel, menu, textarea;$/;"	m	class:t_x11_state	access:public
t_x11_state::menu_draw	../../libs/libeasygl/src/graphics_state.h	/^            *menu_draw = nullptr,$/;"	m	class:t_x11_state	access:public
t_x11_state::screen_num	../../libs/libeasygl/src/graphics_state.h	/^    int screen_num;$/;"	m	class:t_x11_state	access:public
t_x11_state::t_x11_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state::t_x11_state()$/;"	f	class:t_x11_state	signature:()
t_x11_state::t_x11_state	../../libs/libeasygl/src/graphics_state.h	/^    t_x11_state();$/;"	p	class:t_x11_state	access:public	signature:()
t_x11_state::textarea	../../libs/libeasygl/src/graphics_state.h	/^    Window toplevel, menu, textarea;$/;"	m	class:t_x11_state	access:public
t_x11_state::textarea_draw	../../libs/libeasygl/src/graphics_state.h	/^            *textarea_draw = nullptr;$/;"	m	class:t_x11_state	access:public
t_x11_state::toplevel	../../libs/libeasygl/src/graphics_state.h	/^    Window toplevel, menu, textarea;$/;"	m	class:t_x11_state	access:public
t_x11_state::toplevel_draw	../../libs/libeasygl/src/graphics_state.h	/^    XftDraw *toplevel_draw = nullptr,$/;"	m	class:t_x11_state	access:public
t_x11_state::visual_info	../../libs/libeasygl/src/graphics_state.h	/^    XVisualInfo visual_info;$/;"	m	class:t_x11_state	access:public
t_x11_state::xft_currentcolor	../../libs/libeasygl/src/graphics_state.h	/^    XftColor xft_currentcolor;$/;"	m	class:t_x11_state	access:public
t_x11_state::xft_menutextcolor	../../libs/libeasygl/src/graphics_state.h	/^    XftColor xft_menutextcolor;$/;"	m	class:t_x11_state	access:public
t_x11_state::~t_x11_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state::~t_x11_state()$/;"	f	class:t_x11_state	signature:()
t_x11_state::~t_x11_state	../../libs/libeasygl/src/graphics_state.h	/^    ~t_x11_state();$/;"	p	class:t_x11_state	access:public	signature:()
t_xbar_matrix	route/cb_metrics.h	/^typedef std::vector< std::vector<float> > t_xbar_matrix;$/;"	t
table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const unsigned char* table;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
tail	route/route_common.cpp	/^    t_trace* tail;$/;"	m	struct:t_trace_branch	file:	access:public
tail	route/route_traceback.h	/^    t_trace* tail = nullptr;$/;"	m	struct:t_traceback	access:public
target_budget_delay_ch	route/route_budgets.h	/^    vtr::t_chunk target_budget_delay_ch;$/;"	m	class:route_budgets	access:private
target_delay	route/route_timing.h	/^    float target_delay; \/\/Target\/goal connection delay$/;"	m	struct:t_conn_delay_budget	access:public
target_device_utilization	base/read_options.h	/^    argparse::ArgValue<float> target_device_utilization;$/;"	m	struct:t_options	access:public
target_device_utilization	base/vpr_types.h	/^    float target_device_utilization;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
target_external_pin_util	base/read_options.h	/^    argparse::ArgValue<std::vector<std::string>> target_external_pin_util;$/;"	m	struct:t_options	access:public
target_external_pin_util	base/vpr_types.h	/^    std::vector<std::string> target_external_pin_util;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
target_external_pin_util_to_string	pack/pack.cpp	/^static std::string target_external_pin_util_to_string(const t_ext_pin_util_targets& ext_pin_utils) {$/;"	f	file:	signature:(const t_ext_pin_util_targets& ext_pin_utils)
target_external_pin_util_to_string	pack/pack.cpp	/^static std::string target_external_pin_util_to_string(const t_ext_pin_util_targets& ext_pin_utils);$/;"	p	file:	signature:(const t_ext_pin_util_targets& ext_pin_utils)
target_flag	base/vpr_types.h	/^	short target_flag;$/;"	m	struct:ScreenUpdatePriority::t_rr_node_route_inf	access:public
tc_	timing/read_sdc2.cpp	/^        tatum::TimingConstraints& tc_;$/;"	m	class:SdcParseCallback2	file:	access:private
tco_max	../../libs/libarchfpga/src/physical_types.h	/^	float tco_max = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the maximum clock to output time *\/$/;"	m	struct:t_pb_graph_pin	access:public
tco_min	../../libs/libarchfpga/src/physical_types.h	/^	float tco_min = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the minimum clock to output time *\/$/;"	m	struct:t_pb_graph_pin	access:public
tcq_	base/netlist_writer.cpp	/^        double tcq_; \/\/Clock delay + tcq$/;"	m	class:LatchInst	file:	access:private
td_place_exp_first	base/vpr_types.h	/^	float td_place_exp_first;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
td_place_exp_last	base/vpr_types.h	/^	float td_place_exp_last;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
tech	base/vpr_context.h	/^    t_power_tech* tech;$/;"	m	struct:PowerContext	access:public
tech_size	power/power.h	/^	float tech_size; \/* Tech size in nm, for example 90e-9 for 90nm *\/$/;"	m	struct:t_power_tech	access:public
tedge_ch	timing/path_delay.cpp	/^static vtr::t_chunk tedge_ch;$/;"	v	file:
temp	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator temp;$/;"	m	struct:xpath_stack_data	file:	access:public
temp	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* temp;$/;"	m	struct:xpath_stack	file:	access:public
temp_net_cost	place/place.cpp	/^static vtr::vector<ClusterNetId, float> net_cost, temp_net_cost;$/;"	v	file:
temp_point_to_point_delay_cost	place/place.cpp	/^static vtr::vector<ClusterNetId, float *> temp_point_to_point_delay_cost;$/;"	v	file:
temp_point_to_point_timing_cost	place/place.cpp	/^static vtr::vector<ClusterNetId, float *> temp_point_to_point_timing_cost;$/;"	v	file:
temp_scratch_pad	../../libs/libarchfpga/src/physical_types.h	/^	void *temp_scratch_pad; \/* temporary data, useful for keeping track of things when traversing data structure *\/$/;"	m	struct:t_pb_graph_node	access:public
temperature	power/power.h	/^	float temperature; \/* Temp in C *\/$/;"	m	struct:t_power_tech	access:public
terminals	pack/pack_types.h	/^    std::vector<int> terminals;			\/* endpoints of the intra_lb_net, 0th position is the source, all others are sinks *\/$/;"	m	struct:t_intra_lb_net	access:public
text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text xml_node::text() const$/;"	f	class:pugi::xml_node	signature:() const
text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text text() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
text	../../libs/libeasygl/src/graphics.cpp	/^    char text[BUTTON_TEXT_LEN]; \/\/Space for terminator$/;"	m	struct:__anon18	file:	access:public
text_output	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void text_output(xml_buffered_writer& writer, const char_t* s, chartypex_t type, unsigned int flags)$/;"	f	signature:(xml_buffered_writer& writer, const char_t* s, chartypex_t type, unsigned int flags)
text_output_cdata	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void text_output_cdata(xml_buffered_writer& writer, const char_t* s)$/;"	f	signature:(xml_buffered_writer& writer, const char_t* s)
text_output_escaped	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void text_output_escaped(xml_buffered_writer& writer, const char_t* s, chartypex_t type)$/;"	f	signature:(xml_buffered_writer& writer, const char_t* s, chartypex_t type)
text_output_indent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void text_output_indent(xml_buffered_writer& writer, const char_t* indent, size_t indent_length, unsigned int depth)$/;"	f	signature:(xml_buffered_writer& writer, const char_t* indent, size_t indent_length, unsigned int depth)
textarea	../../libs/libeasygl/src/graphics_state.h	/^    Window toplevel, menu, textarea;$/;"	m	class:t_x11_state	access:public
textarea_draw	../../libs/libeasygl/src/graphics_state.h	/^            *textarea_draw = nullptr;$/;"	m	class:t_x11_state	access:public
tg_	timing/read_sdc2.cpp	/^        tatum::TimingGraph& tg_;$/;"	m	class:SdcParseCallback2	file:	access:private
tg_	timing/timing_graph_builder.h	/^        std::unique_ptr<tatum::TimingGraph> tg_;$/;"	m	class:TimingGraphBuilder	access:private
thld	../../libs/libarchfpga/src/physical_types.h	/^	float thld = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the hold time *\/$/;"	m	struct:t_pb_graph_pin	access:public
thld_	base/netlist_writer.cpp	/^        double thld_; \/\/Hold time$/;"	m	class:LatchInst	file:	access:private
throw_error	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void throw_error(const char* message)$/;"	f	struct:xpath_parser	access:public	signature:(const char* message)
throw_error_oom	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void throw_error_oom()$/;"	f	struct:xpath_parser	access:public	signature:()
tie_break_high_fanout_net	pack/pack_types.h	/^	AtomNetId tie_break_high_fanout_net; \/* If no marked candidate molecules, use$/;"	m	struct:t_pb_stats	access:public
tile_length	power/power.h	/^	float tile_length;$/;"	m	struct:t_power_commonly_used	access:public
tile_width	draw/draw_types.h	/^	float tile_width;$/;"	m	struct:t_draw_coords	access:private
tile_x	draw/draw_types.h	/^	float *tile_x, *tile_y;$/;"	m	struct:t_draw_coords	access:public
tile_y	draw/draw_types.h	/^	float *tile_x, *tile_y;$/;"	m	struct:t_draw_coords	access:public
time_on_criticality_analysis	route/route_profiling.cpp	/^void time_on_criticality_analysis() {}$/;"	f	namespace:profiling	signature:()
time_on_criticality_analysis	route/route_profiling.h	/^void time_on_criticality_analysis();$/;"	p	namespace:profiling	signature:()
time_on_fanout_analysis	route/route_profiling.cpp	/^void time_on_fanout_analysis() {}$/;"	f	namespace:profiling	signature:()
time_on_fanout_analysis	route/route_profiling.h	/^void time_on_fanout_analysis();$/;"	p	namespace:profiling	signature:()
timing	base/vpr_context.h	/^        const TimingContext& timing() const { return timing_; }$/;"	f	class:VprContext	access:public	signature:() const
timing_	base/vpr_context.h	/^        TimingContext timing_;$/;"	m	class:VprContext	access:private
timing_analysis	base/read_options.h	/^    argparse::ArgValue<bool> timing_analysis;$/;"	m	struct:t_options	access:public
timing_analysis_enabled	base/vpr_types.h	/^	bool timing_analysis_enabled;$/;"	m	struct:ScreenUpdatePriority::t_timing_inf	access:public
timing_analysis_profile_info	base/vpr_context.h	/^    struct timing_analysis_profile_info {$/;"	s	struct:TimingContext	access:public
timing_analysis_wallclock_time	base/vpr_context.h	/^        double timing_analysis_wallclock_time() const {$/;"	f	struct:TimingContext::timing_analysis_profile_info	access:public	signature:() const
timing_arcs	base/netlist_writer.cpp	/^        const std::vector<Arc>& timing_arcs() { return timing_arcs_; }$/;"	f	class:LutInst	access:public	signature:()
timing_arcs_	base/netlist_writer.cpp	/^        std::vector<Arc> timing_arcs_;$/;"	m	class:BlackBoxInst	file:	access:private
timing_arcs_	base/netlist_writer.cpp	/^        std::vector<Arc> timing_arcs_;$/;"	m	class:LutInst	file:	access:private
timing_constraints	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::TimingConstraints> timing_constraints() const = 0;$/;"	p	class:TimingInfo	access:public	signature:() const
timing_constraints_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingConstraints> timing_constraints_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
timing_constraints_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingConstraints> timing_constraints_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
timing_cost	place/place.cpp	/^    float timing_cost;$/;"	m	struct:t_placer_costs	file:	access:public
timing_cost	place/place.cpp	/^    float timing_cost;$/;"	m	struct:t_placer_prev_inverse_costs	file:	access:public
timing_criticality	base/vpr_types.h	/^	float ** timing_criticality;$/;"	m	struct:ScreenUpdatePriority::t_slack	access:public
timing_driven	base/vpr_types.h	/^	bool timing_driven;$/;"	m	struct:ScreenUpdatePriority::t_packer_opts	access:public
timing_driven_add_to_heap	route/route_timing.cpp	/^static void timing_driven_add_to_heap($/;"	f	file:	signature:( const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, const t_heap* current, const int from_node, const int to_node, const int iconn, const int target_node, RouterStats& router_stats)
timing_driven_add_to_heap	route/route_timing.cpp	/^static void timing_driven_add_to_heap($/;"	p	file:	signature:( const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, const t_heap* current, const int from_node, const int to_node, const int iconn, const int target_node, RouterStats& router_stats)
timing_driven_check_net_delays	route/route_timing.cpp	/^static bool timing_driven_check_net_delays(vtr::vector<ClusterNetId, float *> &net_delay) {$/;"	f	file:	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
timing_driven_check_net_delays	route/route_timing.cpp	/^static bool timing_driven_check_net_delays(vtr::vector<ClusterNetId, float *> &net_delay);$/;"	p	file:	signature:(vtr::vector<ClusterNetId, float *> &net_delay)
timing_driven_clustering	base/read_options.h	/^    argparse::ArgValue<bool> timing_driven_clustering;$/;"	m	struct:t_options	access:public
timing_driven_expand_cheapest	route/route_timing.cpp	/^static void timing_driven_expand_cheapest(t_heap* cheapest,$/;"	f	file:	signature:(t_heap* cheapest, int target_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_expand_cheapest	route/route_timing.cpp	/^static void timing_driven_expand_cheapest(t_heap* cheapest,$/;"	p	file:	signature:(t_heap* cheapest, int target_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_expand_neighbours	route/route_timing.cpp	/^static void timing_driven_expand_neighbours(t_heap *current,$/;"	f	file:	signature:(t_heap *current, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, int target_node, RouterStats& router_stats)
timing_driven_expand_neighbours	route/route_timing.cpp	/^static void timing_driven_expand_neighbours(t_heap *current,$/;"	p	file:	signature:(t_heap *current, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, int target_node, RouterStats& router_stats)
timing_driven_expand_node	route/route_timing.cpp	/^static void timing_driven_expand_node(const t_conn_cost_params cost_params,$/;"	f	file:	signature:(const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, t_heap* current, const int from_node, const int to_node, const int iconn, const int target_node)
timing_driven_expand_node	route/route_timing.cpp	/^static void timing_driven_expand_node(const t_conn_cost_params cost_params,$/;"	p	file:	signature:(const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, t_heap* current, const int from_node, const int to_node, const int iconn, const int target_node)
timing_driven_expand_node_non_configurable_recurr	route/route_timing.cpp	/^static void timing_driven_expand_node_non_configurable_recurr($/;"	f	file:	signature:( const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, t_heap* current, const int from_node, const int to_node, const int iconn, const int target_node, std::set<int>& visited)
timing_driven_expand_node_non_configurable_recurr	route/route_timing.cpp	/^static void timing_driven_expand_node_non_configurable_recurr($/;"	p	file:	signature:( const t_conn_cost_params cost_params, const RouterLookahead& router_lookahead, t_heap* current, const int from_node, const int to_node, const int iconn, const int target_node, std::set<int>& visited)
timing_driven_find_all_shortest_paths_from_heap	route/route_timing.cpp	/^static std::vector<t_heap> timing_driven_find_all_shortest_paths_from_heap($/;"	f	file:	signature:( const t_conn_cost_params cost_params, t_bb bounding_box, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_find_all_shortest_paths_from_heap	route/route_timing.cpp	/^static std::vector<t_heap> timing_driven_find_all_shortest_paths_from_heap($/;"	p	file:	signature:( const t_conn_cost_params cost_params, t_bb bounding_box, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_find_all_shortest_paths_from_route_tree	route/route_timing.cpp	/^std::vector<t_heap> timing_driven_find_all_shortest_paths_from_route_tree($/;"	f	signature:( t_rt_node* rt_root, const t_conn_cost_params cost_params, t_bb bounding_box, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_find_all_shortest_paths_from_route_tree	route/route_timing.h	/^std::vector<t_heap> timing_driven_find_all_shortest_paths_from_route_tree($/;"	p	signature:( t_rt_node* rt_root, const t_conn_cost_params cost_params, t_bb bounding_box, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_connection_from_heap	route/route_timing.cpp	/^static t_heap* timing_driven_route_connection_from_heap(int sink_node,$/;"	f	file:	signature:(int sink_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_connection_from_heap	route/route_timing.cpp	/^static t_heap* timing_driven_route_connection_from_heap(int sink_node,$/;"	p	file:	signature:(int sink_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_connection_from_route_tree	route/route_timing.cpp	/^t_heap* timing_driven_route_connection_from_route_tree(t_rt_node* rt_root, int sink_node,$/;"	f	signature:(t_rt_node* rt_root, int sink_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_connection_from_route_tree	route/route_timing.h	/^t_heap* timing_driven_route_connection_from_route_tree(t_rt_node* rt_root, int sink_node,$/;"	p	signature:(t_rt_node* rt_root, int sink_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_connection_from_route_tree_high_fanout	route/route_timing.cpp	/^static t_heap* timing_driven_route_connection_from_route_tree_high_fanout(t_rt_node* rt_root, int sink_node,$/;"	f	file:	signature:(t_rt_node* rt_root, int sink_node, const t_conn_cost_params cost_params, t_bb net_bounding_box, const RouterLookahead& router_lookahead, const SpatialRouteTreeLookup& spatial_rt_lookup, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_connection_from_route_tree_high_fanout	route/route_timing.cpp	/^static t_heap* timing_driven_route_connection_from_route_tree_high_fanout(t_rt_node* rt_root, int sink_node,$/;"	p	file:	signature:(t_rt_node* rt_root, int sink_node, const t_conn_cost_params cost_params, t_bb bounding_box, const RouterLookahead& router_lookahead, const SpatialRouteTreeLookup& spatial_rt_lookup, std::vector<int>& modified_rr_node_inf, RouterStats& router_stats)
timing_driven_route_net	route/route_timing.cpp	/^bool timing_driven_route_net(ClusterNetId net_id, int itry,$/;"	f	signature:(ClusterNetId net_id, int itry, float pres_fac, const t_router_opts& router_opts, CBRR& connections_inf, RouterStats& router_stats, float *pin_criticality, t_rt_node ** rt_node_of_sink, float *net_delay, const RouterLookahead& router_lookahead, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, std::shared_ptr<const SetupTimingInfo> timing_info, route_budgets &budgeting_inf)
timing_driven_route_net	route/route_timing.h	/^bool timing_driven_route_net(ClusterNetId net_id, int itry, float pres_fac,$/;"	p	signature:(ClusterNetId net_id, int itry, float pres_fac, const t_router_opts& router_opts, CBRR& connections_inf, RouterStats& connections_routed, float *pin_criticality, t_rt_node ** rt_node_of_sink, float *net_delay, const RouterLookahead& router_lookahead, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, std::shared_ptr<const SetupTimingInfo> timing_info, route_budgets &budgeting_inf)
timing_driven_route_sink	route/route_timing.cpp	/^static bool timing_driven_route_sink(ClusterNetId net_id, unsigned itarget, int target_pin,$/;"	f	file:	signature:(ClusterNetId net_id, unsigned itarget, int target_pin, const t_conn_cost_params cost_params, float pres_fac, int high_fanout_threshold, t_rt_node* rt_root, t_rt_node** rt_node_of_sink, const RouterLookahead& router_lookahead, SpatialRouteTreeLookup& spatial_rt_lookup, RouterStats& router_stats)
timing_driven_route_sink	route/route_timing.cpp	/^static bool timing_driven_route_sink(ClusterNetId net_id, unsigned itarget, int target_pin,$/;"	p	file:	signature:(ClusterNetId net_id, unsigned itarget, int target_pin, const t_conn_cost_params cost_params, float pres_fac, int high_fanout_threshold, t_rt_node* rt_root, t_rt_node** rt_node_of_sink, const RouterLookahead& router_lookahead, SpatialRouteTreeLookup& spatial_rt_lookup, RouterStats& router_stats)
timing_driven_route_structs	route/route_timing.cpp	/^timing_driven_route_structs::timing_driven_route_structs() {$/;"	f	class:timing_driven_route_structs	signature:()
timing_driven_route_structs	route/route_timing.h	/^    timing_driven_route_structs();$/;"	p	struct:timing_driven_route_structs	access:public	signature:()
timing_driven_route_structs	route/route_timing.h	/^struct timing_driven_route_structs {$/;"	s
timing_driven_route_structs::pin_criticality	route/route_timing.h	/^    float* pin_criticality; \/* [1..max_pins_per_net-1] *\/$/;"	m	struct:timing_driven_route_structs	access:public
timing_driven_route_structs::rt_node_of_sink	route/route_timing.h	/^    t_rt_node** rt_node_of_sink; \/* [1..max_pins_per_net-1] *\/$/;"	m	struct:timing_driven_route_structs	access:public
timing_driven_route_structs::sink_order	route/route_timing.h	/^    int* sink_order; \/* [1..max_pins_per_net-1] *\/$/;"	m	struct:timing_driven_route_structs	access:public
timing_driven_route_structs::timing_driven_route_structs	route/route_timing.cpp	/^timing_driven_route_structs::timing_driven_route_structs() {$/;"	f	class:timing_driven_route_structs	signature:()
timing_driven_route_structs::timing_driven_route_structs	route/route_timing.h	/^    timing_driven_route_structs();$/;"	p	struct:timing_driven_route_structs	access:public	signature:()
timing_driven_route_structs::~timing_driven_route_structs	route/route_timing.cpp	/^timing_driven_route_structs::~timing_driven_route_structs() {$/;"	f	class:timing_driven_route_structs	signature:()
timing_driven_route_structs::~timing_driven_route_structs	route/route_timing.h	/^    ~timing_driven_route_structs();$/;"	p	struct:timing_driven_route_structs	access:public	signature:()
timing_graph	timing/timing_graph_builder.cpp	/^std::unique_ptr<TimingGraph> TimingGraphBuilder::timing_graph() {$/;"	f	class:TimingGraphBuilder	signature:()
timing_graph	timing/timing_graph_builder.h	/^        std::unique_ptr<tatum::TimingGraph> timing_graph();$/;"	p	class:TimingGraphBuilder	access:public	signature:()
timing_graph	timing/timing_info.h	/^        virtual std::shared_ptr<const tatum::TimingGraph> timing_graph() const = 0;$/;"	p	class:TimingInfo	access:public	signature:() const
timing_graph_	timing/VprTimingGraphResolver.h	/^        const tatum::TimingGraph& timing_graph_;$/;"	m	class:VprTimingGraphResolver	access:private
timing_graph_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingGraph> timing_graph_;$/;"	m	class:ConcreteHoldTimingInfo	access:private
timing_graph_	timing/concrete_timing_info.h	/^        std::shared_ptr<const tatum::TimingGraph> timing_graph_;$/;"	m	class:ConcreteSetupTimingInfo	access:private
timing_report_detail	base/read_options.h	/^    argparse::ArgValue<e_timing_report_detail> timing_report_detail;$/;"	m	struct:t_options	access:public
timing_report_detail	base/vpr_types.h	/^    e_timing_report_detail timing_report_detail;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
timing_report_npaths	base/read_options.h	/^    argparse::ArgValue<int> timing_report_npaths;$/;"	m	struct:t_options	access:public
timing_report_npaths	base/vpr_types.h	/^    int timing_report_npaths;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
timing_report_skew	base/read_options.h	/^    argparse::ArgValue<bool> timing_report_skew;$/;"	m	struct:t_options	access:public
timing_report_skew	base/vpr_types.h	/^    bool timing_report_skew;$/;"	m	struct:ScreenUpdatePriority::t_analysis_opts	access:public
timing_tradeoff	base/vpr_types.h	/^	float timing_tradeoff;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
timinggain	pack/pack_types.h	/^	std::map<AtomBlockId, float> timinggain; \/* The timing criticality score of this atom cluster_ctx.blocks.$/;"	m	struct:t_pb_stats	access:public
tnode_atom_pin	base/atom_lookup.cpp	/^AtomPinId AtomLookup::tnode_atom_pin(const tatum::NodeId tnode) const {$/;"	f	class:AtomLookup	signature:(const tatum::NodeId tnode) const
tnode_atom_pin	base/atom_lookup.h	/^        AtomPinId tnode_atom_pin(const tatum::NodeId tnode) const;$/;"	p	class:AtomLookup	access:public	signature:(const tatum::NodeId tnode) const
tnode_atom_pin_	base/atom_lookup.h	/^        vtr::linear_map<tatum::NodeId,AtomPinId> tnode_atom_pin_;$/;"	m	class:AtomLookup	access:private
tnode_atom_pins	base/atom_lookup.cpp	/^AtomLookup::tnode_pin_range AtomLookup::tnode_atom_pins() const {$/;"	f	class:AtomLookup	signature:() const
tnode_atom_pins	base/atom_lookup.h	/^        tnode_pin_range tnode_atom_pins() const;$/;"	p	class:AtomLookup	access:public	signature:() const
tnode_draw_coord	draw/draw.cpp	/^t_point tnode_draw_coord(tatum::NodeId node) {$/;"	f	signature:(tatum::NodeId node)
tnode_draw_coord	draw/draw.h	/^t_point tnode_draw_coord(tatum::NodeId node);$/;"	p	signature:(tatum::NodeId node)
tnode_pin_iterator	base/atom_lookup.h	/^        typedef vtr::linear_map<tatum::NodeId,AtomPinId>::const_iterator tnode_pin_iterator;$/;"	t	class:AtomLookup	access:public
tnode_pin_range	base/atom_lookup.h	/^        typedef vtr::Range<tnode_pin_iterator> tnode_pin_range;$/;"	t	class:AtomLookup	access:public
tnodes	base/vpr_context.h	/^    t_tnode* tnodes; \/* [0..num_tnodes - 1] nodes in the timing graph *\/$/;"	m	struct:TimingContext	access:public
tnodes_at_level	base/vpr_context.h	/^    std::vector<std::vector<int>> tnodes_at_level; \/* [0..num__tnode_levels - 1].  Count and list of tnodes at each level of$/;"	m	struct:TimingContext	access:public
to_block	../../libs/libarchfpga/src/cad_types.h	/^	t_pack_pattern_block *to_block;$/;"	m	struct:t_pack_pattern_connections	access:public
to_class	place/place_delay_model.h	/^            int to_class;$/;"	m	struct:OverrideDelayModel::t_override	access:public
to_clb_pin_end_index	route/rr_graph.cpp	/^    int to_clb_pin_end_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
to_clb_pin_start_index	route/rr_graph.cpp	/^    int to_clb_pin_start_index;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
to_clb_type	route/rr_graph.cpp	/^    t_type_descriptor *to_clb_type;$/;"	m	struct:t_clb_to_clb_directs	file:	access:public
to_index	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        size_t to_index(size_t address)$/;"	f	class:BitSpace::VerilogBits	access:private	signature:(size_t address)
to_node	base/vpr_types.h	/^	int to_node; \/* index of node at the sink end of this edge *\/$/;"	m	struct:ScreenUpdatePriority::t_tedge	access:public
to_node	route/check_route.cpp	/^    int to_node;$/;"	m	struct:t_node_edge	file:	access:public
to_node	route/route_common.h	/^    int to_node = NO_PREVIOUS; \/\/The target node$/;"	m	struct:t_heap_prev	access:public
to_node	route/rr_graph2.h	/^    int to_node = OPEN;$/;"	m	struct:t_rr_edge_info	access:public
to_pin	../../libs/libarchfpga/src/cad_types.h	/^	t_pb_graph_pin *to_pin;$/;"	m	struct:t_pack_pattern_connections	access:public
to_pin	../../libs/libarchfpga/src/physical_types.h	/^	char *to_pin;$/;"	m	struct:t_direct_inf	access:public
to_side	../../libs/libarchfpga/src/physical_types.h	/^	enum e_side to_side = TOP;$/;"	m	class:SB_Side_Connection	typeref:enum:SB_Side_Connection::e_side	access:public
to_side	../../libs/libarchfpga/src/physical_types.h	/^    e_side to_side;$/;"	m	struct:t_direct_inf	access:public
to_side	route/build_switchblocks.h	/^	e_side to_side;		\/* destination side of switchblock connection *\/$/;"	m	class:Switchblock_Lookup	access:public
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(PlaceDelayModelType val) {$/;"	f	struct:ParsePlaceDelayModel	access:public	signature:(PlaceDelayModelType val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(bool val) {$/;"	f	struct:ParseOnOff	access:public	signature:(bool val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_base_cost_type val) {$/;"	f	struct:ParseBaseCost	access:public	signature:(e_base_cost_type val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_circuit_format val) {$/;"	f	struct:ParseCircuitFormat	access:public	signature:(e_circuit_format val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_clock_modeling val) {$/;"	f	struct:ParseClockModeling	access:public	signature:(e_clock_modeling val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_cluster_seed val) {$/;"	f	struct:ParseClusterSeed	access:public	signature:(e_cluster_seed val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_const_gen_inference val) {$/;"	f	struct:ParseConstGenInference	access:public	signature:(e_const_gen_inference val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_constant_net_method val) {$/;"	f	struct:ParseConstantNetMethod	access:public	signature:(e_constant_net_method val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_incr_reroute_delay_ripup val) {$/;"	f	struct:ParseIncrRerouteDelayRipup	access:public	signature:(e_incr_reroute_delay_ripup val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_place_algorithm val) {$/;"	f	struct:ParsePlaceAlgorithm	access:public	signature:(e_place_algorithm val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_reducer val) {$/;"	f	struct:ParseReducer	access:public	signature:(e_reducer val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_route_bb_update val) {$/;"	f	struct:ParseRouteBBUpdate	access:public	signature:(e_route_bb_update val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_route_type val) {$/;"	f	struct:ParseRouteType	access:public	signature:(e_route_type val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_router_algorithm val) {$/;"	f	struct:ParseRouterAlgorithm	access:public	signature:(e_router_algorithm val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_router_lookahead val) {$/;"	f	struct:ParseRouterLookahead	access:public	signature:(e_router_lookahead val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_routing_budgets_algorithm val) {$/;"	f	struct:RouteBudgetsAlgorithm	access:public	signature:(e_routing_budgets_algorithm val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_routing_failure_predictor val) {$/;"	f	struct:ParseRoutePredictor	access:public	signature:(e_routing_failure_predictor val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_timing_report_detail val) {$/;"	f	struct:ParseTimingReportDetail	access:public	signature:(e_timing_report_detail val)
to_str	base/read_options.cpp	/^    ConvertedValue<std::string> to_str(e_unrelated_clustering val) {$/;"	f	struct:ParseUnrelatedClustering	access:public	signature:(e_unrelated_clustering val)
to_string	../../libs/libarchfpga/src/expr_eval.cpp	/^    std::string to_string() const {$/;"	f	class:Formula_Object	access:public	signature:() const
to_string	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        std::string to_string(bool big_endian)$/;"	f	class:BitSpace::VerilogBits	access:public	signature:(bool big_endian)
to_string	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    std::string to_string()$/;"	f	class:VNumber	access:public	signature:()
to_switchpoint_order	../../libs/libarchfpga/src/physical_types.h	/^    SwitchPointOrder to_switchpoint_order = SwitchPointOrder::FIXED; \/\/The desired to_switchpoint_set ordering$/;"	m	struct:t_wireconn_inf	access:public
to_switchpoint_set	../../libs/libarchfpga/src/physical_types.h	/^    std::vector<t_wire_switchpoints> to_switchpoint_set;   \/\/The set of segment\/wirepoints representing the 'to' set (union of all t_wire_switchpoints in vector)$/;"	m	struct:t_wireconn_inf	access:public
to_t_color	draw/draw.cpp	/^t_color to_t_color(vtr::Color<float> color) {$/;"	f	signature:(vtr::Color<float> color)
to_t_color	draw/draw.cpp	/^t_color to_t_color(vtr::Color<float> color);$/;"	p	file:	signature:(vtr::Color<float> color)
to_type	place/place_delay_model.h	/^            int to_type;$/;"	m	struct:OverrideDelayModel::t_override	access:public
to_vtr_logic_value	base/read_blif.cpp	/^vtr::LogicValue to_vtr_logic_value(blifparse::LogicValue val) {$/;"	f	signature:(blifparse::LogicValue val)
to_wire	route/build_switchblocks.h	/^	short to_wire;$/;"	m	struct:t_switchblock_edge	access:public
toggle_blk_internal	draw/draw.cpp	/^void toggle_blk_internal(void (*drawscreen_ptr)()) {$/;"	f	signature:(void (*drawscreen_ptr)())
toggle_blk_internal	draw/intra_logic_block.h	/^void toggle_blk_internal(void (*drawscreen_ptr)());$/;"	p	signature:(void (*drawscreen_ptr)())
toggle_block_pin_util	draw/draw.cpp	/^static void toggle_block_pin_util(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_block_pin_util	draw/draw.cpp	/^static void toggle_block_pin_util(void (*drawscreen_ptr)());$/;"	p	file:	signature:(void (*drawscreen_ptr)())
toggle_congestion	draw/draw.cpp	/^static void toggle_congestion(void (*drawscreen)());$/;"	p	file:	signature:(void (*drawscreen)())
toggle_congestion	draw/draw.cpp	/^static void toggle_congestion(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_crit_path	draw/draw.cpp	/^static void toggle_crit_path(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_crit_path	draw/draw.cpp	/^static void toggle_crit_path(void (*drawscreen_ptr)());$/;"	p	file:	signature:(void (*drawscreen_ptr)())
toggle_nets	draw/draw.cpp	/^static void toggle_nets(void (*drawscreen)());$/;"	p	file:	signature:(void (*drawscreen)())
toggle_nets	draw/draw.cpp	/^static void toggle_nets(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_router_rr_costs	draw/draw.cpp	/^static void toggle_router_rr_costs(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_router_rr_costs	draw/draw.cpp	/^static void toggle_router_rr_costs(void (*drawscreen_ptr)());$/;"	p	file:	signature:(void (*drawscreen_ptr)())
toggle_routing_bounding_box	draw/draw.cpp	/^static void toggle_routing_bounding_box(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_routing_bounding_box	draw/draw.cpp	/^static void toggle_routing_bounding_box(void (*drawscreen_ptr)());$/;"	p	file:	signature:(void (*drawscreen_ptr)())
toggle_routing_congestion_cost	draw/draw.cpp	/^static void toggle_routing_congestion_cost(void (*drawscreen)());$/;"	p	file:	signature:(void (*drawscreen)())
toggle_routing_congestion_cost	draw/draw.cpp	/^static void toggle_routing_congestion_cost(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_routing_util	draw/draw.cpp	/^static void toggle_routing_util(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
toggle_routing_util	draw/draw.cpp	/^static void toggle_routing_util(void (*drawscreen_ptr)());$/;"	p	file:	signature:(void (*drawscreen_ptr)())
toggle_rr	draw/draw.cpp	/^static void toggle_rr(void (*drawscreen)());$/;"	p	file:	signature:(void (*drawscreen)())
toggle_rr	draw/draw.cpp	/^static void toggle_rr(void (*drawscreen_ptr)()) {$/;"	f	file:	signature:(void (*drawscreen_ptr)())
tolower_ascii	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t tolower_ascii(char_t ch)$/;"	f	signature:(char_t ch)
top	../../libs/libeasygl/src/graphics_types.cpp	/^const float& t_bound_box::top() const {$/;"	f	class:t_bound_box	signature:() const
top	../../libs/libeasygl/src/graphics_types.cpp	/^float& t_bound_box::top() {$/;"	f	class:t_bound_box	signature:()
top	../../libs/libeasygl/src/graphics_types.h	/^    const float& top() const;$/;"	p	class:t_bound_box	access:public	signature:() const
top	../../libs/libeasygl/src/graphics_types.h	/^    float& top();$/;"	p	class:t_bound_box	access:public	signature:()
top_height	../../libs/libeasygl/src/graphics.cpp	/^    int top_width, top_height;$/;"	m	struct:__anon20	file:	access:public
top_height	../../libs/libeasygl/src/graphics.h	/^    int top_width, top_height;$/;"	m	struct:__anon22	access:public
top_module_name_	base/netlist_writer.cpp	/^        std::string top_module_name_; \/\/Name of the top level module (i.e. the circuit)$/;"	m	class:NetlistWriterVisitor	file:	access:private
top_right	../../libs/libeasygl/src/graphics_types.cpp	/^const t_point& t_bound_box::top_right() const {$/;"	f	class:t_bound_box	signature:() const
top_right	../../libs/libeasygl/src/graphics_types.cpp	/^t_point& t_bound_box::top_right() {$/;"	f	class:t_bound_box	signature:()
top_right	../../libs/libeasygl/src/graphics_types.h	/^    const t_point& top_right() const;$/;"	p	class:t_bound_box	access:public	signature:() const
top_right	../../libs/libeasygl/src/graphics_types.h	/^    t_point& top_right();$/;"	p	class:t_bound_box	access:public	signature:()
top_right	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> top_right() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
top_right	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Point<T> Rect<T>::top_right() const {$/;"	f	class:vtr::Rect	signature:() const
top_right_	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> top_right_;$/;"	m	class:vtr::Rect	access:private
top_width	../../libs/libeasygl/src/graphics.cpp	/^    int top_width, top_height;$/;"	m	struct:__anon20	file:	access:public
top_width	../../libs/libeasygl/src/graphics.h	/^    int top_width, top_height;$/;"	m	struct:__anon22	access:public
toplevel	../../libs/libeasygl/src/graphics_state.h	/^    Window toplevel, menu, textarea;$/;"	m	class:t_x11_state	access:public
toplevel_draw	../../libs/libeasygl/src/graphics_state.h	/^    XftDraw *toplevel_draw = nullptr,$/;"	m	class:t_x11_state	access:public
topright	../../libs/libeasygl/src/graphics_types.h	/^    t_point topright;$/;"	m	class:t_bound_box	access:private
toreach_rr_sink	route/connection_based_routing.h	/^	void toreach_rr_sink(int rr_sink_node) {remaining_targets.push_back(rr_sink_node);}$/;"	f	class:Connection_based_routing_resources	access:public	signature:(int rr_sink_node)
total_cb_buffer_size	power/power.h	/^	float total_cb_buffer_size;$/;"	m	struct:t_power_commonly_used	access:public
total_cost	route/route_timing.cpp	/^    float total_cost = 0.;$/;"	m	struct:t_timing_driven_node_costs	file:	access:public
total_nodes	route/route_timing.cpp	/^    size_t total_nodes() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
total_nodes_	route/route_timing.cpp	/^    size_t total_nodes_;$/;"	m	class:OveruseInfo	file:	access:private
total_overuse	route/route_timing.cpp	/^    size_t total_overuse() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
total_overuse_	route/route_timing.cpp	/^    size_t total_overuse_;$/;"	m	class:OveruseInfo	file:	access:private
total_pb_pins	../../libs/libarchfpga/src/physical_types.h	/^	int total_pb_pins; \/* only valid for top-level *\/$/;"	m	struct:t_pb_graph_node	access:public
total_sb_buffer_size	power/power.h	/^	float total_sb_buffer_size;$/;"	m	struct:t_power_commonly_used	access:public
trace	base/vpr_context.h	/^    vtr::vector<ClusterNetId, t_traceback> trace;$/;"	m	struct:RoutingContext	access:public
trace_ch	route/route_common.cpp	/^static vtr::t_chunk trace_ch;$/;"	v	file:
trace_delay	timing/clb_delay_calc.h	/^        float trace_delay(ClusterBlockId clb, int src_pb_route_pin, int sink_pb_route_pin, DelayType delay_type) const;$/;"	p	class:ClbDelayCalc	access:private	signature:(ClusterBlockId clb, int src_pb_route_pin, int sink_pb_route_pin, DelayType delay_type) const
trace_delay	timing/clb_delay_calc.inl	/^inline float ClbDelayCalc::trace_delay(ClusterBlockId clb, int src_pb_route_id, int sink_pb_route_id, DelayType delay_type) const {$/;"	f	class:ClbDelayCalc	signature:(ClusterBlockId clb, int src_pb_route_id, int sink_pb_route_id, DelayType delay_type) const
trace_free_head	route/route_common.cpp	/^static t_trace *trace_free_head = nullptr;$/;"	v	file:
trace_nodes	base/vpr_context.h	/^    vtr::vector<ClusterNetId, std::unordered_set<int>> trace_nodes;$/;"	m	struct:RoutingContext	access:public
trace_routed_connection_rr_nodes	draw/draw.cpp	/^static std::vector<int> trace_routed_connection_rr_nodes(const ClusterNetId net_id, const int driver_pin, const int sink_pin) {$/;"	f	file:	signature:(const ClusterNetId net_id, const int driver_pin, const int sink_pin)
trace_routed_connection_rr_nodes	draw/draw.cpp	/^static std::vector<int> trace_routed_connection_rr_nodes(const ClusterNetId net_id, const int driver_pin, const int sink_pin);$/;"	p	file:	signature:(const ClusterNetId net_id, const int driver_pin, const int sink_pin)
trace_routed_connection_rr_nodes_recurr	draw/draw.cpp	/^bool trace_routed_connection_rr_nodes_recurr(const t_rt_node* rt_node, int sink_rr_node, std::vector<int>& rr_nodes_on_path) {$/;"	f	signature:(const t_rt_node* rt_node, int sink_rr_node, std::vector<int>& rr_nodes_on_path)
trace_routed_connection_rr_nodes_recurr	draw/draw.cpp	/^static bool trace_routed_connection_rr_nodes_recurr(const t_rt_node* rt_node, int sink_rr_node, std::vector<int>& rr_nodes_on_path);$/;"	p	file:	signature:(const t_rt_node* rt_node, int sink_rr_node, std::vector<int>& rr_nodes_on_path)
traceback_branch	route/route_common.cpp	/^static t_trace_branch traceback_branch(int node, const std::vector<t_heap_prev>& previous, std::unordered_set<int>& main_branch_visited);$/;"	p	file:	signature:(int node, const std::vector<t_heap_prev>& previous, std::unordered_set<int>& main_branch_visited)
traceback_branch	route/route_common.cpp	/^static t_trace_branch traceback_branch(int node, const std::vector<t_heap_prev>& previous, std::unordered_set<int>& trace_nodes) {$/;"	f	file:	signature:(int node, const std::vector<t_heap_prev>& previous, std::unordered_set<int>& trace_nodes)
traceback_from_route_tree	route/route_tree_timing.cpp	/^t_trace* traceback_from_route_tree(ClusterNetId inet, const t_rt_node* root, int num_routed_sinks) {$/;"	f	signature:(ClusterNetId inet, const t_rt_node* root, int num_routed_sinks)
traceback_from_route_tree	route/route_tree_timing.h	/^t_trace* traceback_from_route_tree(ClusterNetId inet, const t_rt_node* root, int num_remaining_sinks);$/;"	p	signature:(ClusterNetId inet, const t_rt_node* root, int num_remaining_sinks)
traceback_from_route_tree_recurr	route/route_tree_timing.cpp	/^static std::pair<t_trace*,t_trace*> traceback_from_route_tree_recurr(t_trace* head, t_trace* tail, const t_rt_node* node) {$/;"	f	file:	signature:(t_trace* head, t_trace* tail, const t_rt_node* node)
traceback_from_route_tree_recurr	route/route_tree_timing.cpp	/^static std::pair<t_trace*,t_trace*> traceback_from_route_tree_recurr(t_trace* head, t_trace* tail, const t_rt_node* node);$/;"	p	file:	signature:(t_trace* head, t_trace* tail, const t_rt_node* node)
traceback_to_route_tree	route/route_tree_timing.cpp	/^t_rt_node* traceback_to_route_tree(ClusterNetId inet) {$/;"	f	signature:(ClusterNetId inet)
traceback_to_route_tree	route/route_tree_timing.cpp	/^t_rt_node* traceback_to_route_tree(t_trace* head) {$/;"	f	signature:(t_trace* head)
traceback_to_route_tree	route/route_tree_timing.cpp	/^t_rt_node* traceback_to_route_tree(t_trace* head);$/;"	p	file:	signature:(t_trace* head)
traceback_to_route_tree	route/route_tree_timing.h	/^t_rt_node* traceback_to_route_tree(ClusterNetId inet);$/;"	p	signature:(ClusterNetId inet)
traceback_to_route_tree_branch	route/route_tree_timing.cpp	/^static t_trace* traceback_to_route_tree_branch(t_trace* trace, std::map<int,t_rt_node*>& rr_node_to_rt) {$/;"	f	file:	signature:(t_trace* trace, std::map<int,t_rt_node*>& rr_node_to_rt)
traceback_to_route_tree_branch	route/route_tree_timing.cpp	/^static t_trace* traceback_to_route_tree_branch(t_trace* trace, std::map<int,t_rt_node*>& rr_node_to_rt);$/;"	p	file:	signature:(t_trace* trace, std::map<int,t_rt_node*>& rr_node_to_rt)
track_num	route/rr_node.cpp	/^short t_rr_node::track_num() const {$/;"	f	class:t_rr_node	signature:() const
track_num	route/rr_node.h	/^            int16_t track_num;$/;"	m	union:t_rr_node::__anon9	access:public
track_num	route/rr_node.h	/^        short track_num() const; \/\/Same as ptc_num() but checks that type() is consistent$/;"	p	class:t_rr_node	access:public	signature:() const
track_to_pins	route/cb_metrics.h	/^	t_vec_vec_set track_to_pins;		\/* [0..3][0..W-1][0..pins_connected-1]. A convenient lookup for which pins connect to a given track *\/$/;"	m	class:Conn_Block_Metrics	access:public
trans_area_eq	route/rr_graph_area.cpp	/^static const e_trans_area_eq trans_area_eq = AREA_IMPROVED_NMOS_ONLY;$/;"	v	file:
trans_coord	../../libs/libeasygl/src/graphics.cpp	/^static t_transform_coordinates trans_coord;$/;"	v	file:
trans_per_R	route/rr_graph_area.cpp	/^static float trans_per_R(float Rtrans, float R_minW_trans) {$/;"	f	file:	signature:(float Rtrans, float R_minW_trans)
trans_per_R	route/rr_graph_area.cpp	/^static float trans_per_R(float Rtrans, float R_minW_trans);$/;"	p	file:	signature:(float Rtrans, float R_minW_trans)
trans_per_buf	route/rr_graph_area.cpp	/^float trans_per_buf(float Rbuf, float R_minW_nmos, float R_minW_pmos) {$/;"	f	signature:(float Rbuf, float R_minW_nmos, float R_minW_pmos)
trans_per_buf	route/rr_graph_area.h	/^float trans_per_buf(float Rbuf, float R_minW_nmos, float R_minW_pmos);$/;"	p	signature:(float Rbuf, float R_minW_nmos, float R_minW_pmos)
trans_per_mux	route/rr_graph_area.cpp	/^static float trans_per_mux(int num_inputs, float trans_sram_bit,$/;"	f	file:	signature:(int num_inputs, float trans_sram_bit, float pass_trans_area)
trans_per_mux	route/rr_graph_area.cpp	/^static float trans_per_mux(int num_inputs, float trans_sram_bit,$/;"	p	file:	signature:(int num_inputs, float trans_sram_bit, float pass_trans_area)
transistor_cnt	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt;$/;"	m	struct:t_interconnect_power	access:public
transistor_cnt_buffers	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt_buffers;$/;"	m	struct:t_pb_graph_node_power	access:public
transistor_cnt_interc	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt_interc; \/* Total transistor size of the interconnect in this pb *\/$/;"	m	struct:t_pb_graph_node_power	access:public
transistor_cnt_pb_children	../../libs/libarchfpga/src/physical_types.h	/^	float transistor_cnt_pb_children; \/* Total transistor size of this pb *\/$/;"	m	struct:t_pb_graph_node_power	access:public
transistor_size	power/PowerSpicedComponent.h	/^	float transistor_size;$/;"	m	class:PowerCallibSize	access:public
transistor_size	power/power.h	/^	float transistor_size;$/;"	m	struct:t_mux_arch	access:public
transistor_type_name	power/power_util.cpp	/^const char * transistor_type_name(e_tx_type type) {$/;"	f	signature:(e_tx_type type)
transistor_type_name	power/power_util.h	/^const char * transistor_type_name(e_tx_type type);$/;"	p	signature:(e_tx_type type)
transistors_per_SRAM_bit	../../libs/libarchfpga/src/physical_types.h	/^	float transistors_per_SRAM_bit;$/;"	m	struct:t_power_arch	access:public
transitive_fanout_candidates	pack/pack_types.h	/^	std::vector<t_pack_molecule *> *transitive_fanout_candidates;$/;"	m	struct:t_pb_stats	access:public
translate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* translate(char_t* buffer, const char_t* from, const char_t* to, size_t to_length)$/;"	f	signature:(char_t* buffer, const char_t* from, const char_t* to, size_t to_length)
translate_down	../../libs/libeasygl/src/graphics.cpp	/^static void translate_down(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
translate_down	../../libs/libeasygl/src/graphics.cpp	/^translate_down(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
translate_left	../../libs/libeasygl/src/graphics.cpp	/^static void translate_left(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
translate_left	../../libs/libeasygl/src/graphics.cpp	/^translate_left(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
translate_right	../../libs/libeasygl/src/graphics.cpp	/^static void translate_right(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
translate_right	../../libs/libeasygl/src/graphics.cpp	/^translate_right(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
translate_table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN char_t* translate_table(char_t* buffer, const unsigned char* table)$/;"	f	signature:(char_t* buffer, const unsigned char* table)
translate_table_generate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN unsigned char* translate_table_generate(xpath_allocator* alloc, const char_t* from, const char_t* to)$/;"	f	signature:(xpath_allocator* alloc, const char_t* from, const char_t* to)
translate_up	../../libs/libeasygl/src/graphics.cpp	/^static void translate_up(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
translate_up	../../libs/libeasygl/src/graphics.cpp	/^translate_up(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
transpose_xbar	route/cb_metrics.cpp	/^static t_xbar_matrix transpose_xbar( const t_xbar_matrix *xbar ){$/;"	f	file:	signature:( const t_xbar_matrix *xbar )
traverse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN bool xml_node::traverse(xml_tree_walker& walker)$/;"	f	class:pugi::xml_node	signature:(xml_tree_walker& walker)
traverse	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		bool traverse(xml_tree_walker& walker);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_tree_walker& walker)
traverse_indented_route_tree	route/route_tree_timing.cpp	/^static void traverse_indented_route_tree(const t_rt_node* rt_root, int branch_level, bool new_branch, Op op, int indent_level) {$/;"	f	file:	signature:(const t_rt_node* rt_root, int branch_level, bool new_branch, Op op, int indent_level)
treat_clock_pins_as_non_globals	base/clock_modeling.cpp	/^void ClockModeling::treat_clock_pins_as_non_globals() {$/;"	f	class:ClockModeling	signature:()
treat_clock_pins_as_non_globals	base/clock_modeling.h	/^    void treat_clock_pins_as_non_globals();$/;"	p	namespace:ClockModeling	signature:()
triangle_LOD_screen_area_test	draw/draw.cpp	/^static inline bool triangle_LOD_screen_area_test(float arrow_size) {$/;"	f	file:	signature:(float arrow_size)
triangle_LOD_screen_area_test	draw/draw.cpp	/^static inline bool triangle_LOD_screen_area_test(float arrow_size);$/;"	p	file:	signature:(float arrow_size)
tried	base/vpr_types.h	/^	t_cluster_placement_primitive *tried; \/* ptrs to primitives that are open but current logic block unable to pack to *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
trim_empty_channels	base/vpr_types.h	/^	bool trim_empty_channels;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
trim_obs_channels	base/vpr_types.h	/^	bool trim_obs_channels;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
truncate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void truncate(xpath_node* pos)$/;"	f	class:xpath_node_set_raw	access:public	signature:(xpath_node* pos)
truncate_zeros	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void truncate_zeros(char* begin, char* end)$/;"	f	signature:(char* begin, char* end)
truth_table_encodes_on_set	base/atom_netlist_utils.cpp	/^bool truth_table_encodes_on_set(const AtomNetlist::TruthTable& truth_table) {$/;"	f	signature:(const AtomNetlist::TruthTable& truth_table)
truth_table_encodes_on_set	base/atom_netlist_utils.h	/^bool truth_table_encodes_on_set(const AtomNetlist::TruthTable& truth_table);$/;"	p	signature:(const AtomNetlist::TruthTable& truth_table)
truth_table_to_lut_mask	base/atom_netlist_utils.cpp	/^std::vector<vtr::LogicValue> truth_table_to_lut_mask(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs) {$/;"	f	signature:(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs)
truth_table_to_lut_mask	base/atom_netlist_utils.h	/^std::vector<vtr::LogicValue> truth_table_to_lut_mask(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs);$/;"	p	signature:(const AtomNetlist::TruthTable& truth_table, const size_t num_inputs)
try_breadth_first_route	route/route_breadth_first.cpp	/^bool try_breadth_first_route(t_router_opts router_opts) {$/;"	f	signature:(t_router_opts router_opts)
try_breadth_first_route	route/route_breadth_first.h	/^bool try_breadth_first_route(t_router_opts router_opts);$/;"	p	signature:(t_router_opts router_opts)
try_breadth_first_route_net	route/route_breadth_first.cpp	/^bool try_breadth_first_route_net(ClusterNetId net_id, float pres_fac,$/;"	f	signature:(ClusterNetId net_id, float pres_fac, t_router_opts router_opts)
try_breadth_first_route_net	route/route_breadth_first.h	/^bool try_breadth_first_route_net(ClusterNetId net_id, float pres_fac,$/;"	p	signature:(ClusterNetId net_id, float pres_fac, t_router_opts router_opts)
try_create_molecule	pack/prepack.cpp	/^static t_pack_molecule *try_create_molecule($/;"	f	file:	signature:( t_pack_patterns *list_of_pack_patterns, std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const int pack_pattern_index, AtomBlockId blk_id)
try_create_molecule	pack/prepack.cpp	/^static t_pack_molecule *try_create_molecule($/;"	p	file:	signature:( t_pack_patterns *list_of_pack_patterns, std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const int pack_pattern_index, AtomBlockId blk_id)
try_expand_molecule	pack/prepack.cpp	/^static bool try_expand_molecule(t_pack_molecule *molecule,$/;"	f	file:	signature:(t_pack_molecule *molecule, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const AtomBlockId blk_id, const t_pack_pattern_block *current_pattern_block)
try_expand_molecule	pack/prepack.cpp	/^static bool try_expand_molecule(t_pack_molecule *molecule,$/;"	p	file:	signature:(t_pack_molecule *molecule, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const AtomBlockId blk_id, const t_pack_pattern_block *current_pattern_block)
try_graph	route/route_common.cpp	/^void try_graph(int width_fac, t_router_opts router_opts,$/;"	f	signature:(int width_fac, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_chan_width_dist chan_width_dist, t_direct_inf *directs, int num_directs)
try_graph	route/route_export.h	/^void try_graph(int width_fac, t_router_opts router_opts,$/;"	p	signature:(int width_fac, t_router_opts router_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_chan_width_dist chan_width_dist, t_direct_inf *directs, int num_directs)
try_intra_lb_route	pack/cluster_router.cpp	/^bool try_intra_lb_route(t_lb_router_data *router_data,$/;"	f	signature:(t_lb_router_data *router_data, int verbosity)
try_intra_lb_route	pack/cluster_router.h	/^bool try_intra_lb_route(t_lb_router_data *router_data, int verbosity);$/;"	p	signature:(t_lb_router_data *router_data, int verbosity)
try_move	route/cb_metrics.cpp	/^static double try_move(const e_metric metric, const int nodes_per_chan, const float initial_orthogonal_metric,$/;"	f	file:	signature:(const e_metric metric, const int nodes_per_chan, const float initial_orthogonal_metric, const float orthogonal_metric_tolerance, const t_type_ptr block_type, const e_pin_type pin_type, const int Fc, const int num_pin_type_pins, const double cost, const double temp, const float target_metric, int *****pin_to_track_connections, Conn_Block_Metrics *cb_metrics)
try_move	route/cb_metrics.cpp	/^static double try_move(const e_metric metric, const int nodes_per_chan, const float initial_orthogonal_metric,$/;"	p	file:	signature:(const e_metric metric, const int nodes_per_chan, const float initial_orthogonal_metric, const float orthogonal_metric_tolerance, const t_type_ptr block_type, const e_pin_type pin_type, const int Fc, const int num_pin_type_pins, const double cost, const double temp, const float target_metric, int *****pin_to_track_connections, Conn_Block_Metrics *cb_metrics)
try_pack	pack/pack.cpp	/^bool try_pack(t_packer_opts *packer_opts,$/;"	f	signature:(t_packer_opts *packer_opts, const t_arch * arch, const t_model *user_models, const t_model *library_models, float interc_delay, vector<t_lb_type_rr_node> *lb_type_rr_graphs , t_timing_inf timing_inf )
try_pack	pack/pack.h	/^bool try_pack(t_packer_opts *packer_opts,$/;"	p	signature:(t_packer_opts *packer_opts, const t_arch * arch, const t_model *user_models, const t_model *library_models, float interc_delay, vector<t_lb_type_rr_node> *lb_type_rr_graphs , t_timing_inf timing_inf )
try_pack_molecule	pack/cluster.cpp	/^static enum e_block_pack_status try_pack_molecule($/;"	f	file:	signature:( t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const t_pack_molecule *molecule, t_pb_graph_node **primitives_list, t_pb * pb, const int max_models, const int max_cluster_size, const ClusterBlockId clb_index, const int detailed_routing_stage, t_lb_router_data *router_data, int verbosity, bool enable_pin_feasibility_filter, t_ext_pin_util max_external_pin_util)
try_pack_molecule	pack/cluster.cpp	/^static enum e_block_pack_status try_pack_molecule($/;"	p	file:	signature:( t_cluster_placement_stats *cluster_placement_stats_ptr, const std::multimap<AtomBlockId,t_pack_molecule*>& atom_molecules, const t_pack_molecule *molecule, t_pb_graph_node **primitives_list, t_pb * pb, const int max_models, const int max_cluster_size, const ClusterBlockId clb_index, const int detailed_routing_stage, t_lb_router_data *router_data, int verbosity, bool enable_pin_feasibility_filter, t_ext_pin_util max_external_pin_util)
try_place	place/place.cpp	/^void try_place(t_placer_opts placer_opts,$/;"	f	signature:(t_placer_opts placer_opts, t_annealing_sched annealing_sched, t_router_opts router_opts, const t_analysis_opts& analysis_opts, t_chan_width_dist chan_width_dist, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_timing_inf timing_inf, t_direct_inf *directs, int num_directs)
try_place	place/place.h	/^void try_place(t_placer_opts placer_opts,$/;"	p	signature:(t_placer_opts placer_opts, t_annealing_sched annealing_sched, t_router_opts router_opts, const t_analysis_opts& analysis_opts, t_chan_width_dist chan_width_dist, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, t_timing_inf timing_inf, t_direct_inf *directs, int num_directs)
try_place_atom_block_rec	pack/cluster.cpp	/^static enum e_block_pack_status try_place_atom_block_rec($/;"	f	file:	signature:( const t_pb_graph_node *pb_graph_node, const AtomBlockId blk_id, t_pb *cb, t_pb **parent, const int max_models, const int max_cluster_size, const ClusterBlockId clb_index, const t_cluster_placement_stats *cluster_placement_stats_ptr, const bool is_root_of_chain, const t_pb_graph_pin *chain_root_pin, t_lb_router_data *router_data, int verbosity)
try_place_atom_block_rec	pack/cluster.cpp	/^static enum e_block_pack_status try_place_atom_block_rec($/;"	p	file:	signature:( const t_pb_graph_node *pb_graph_node, const AtomBlockId blk_id, t_pb *cb, t_pb **parent, const int max_models, const int max_cluster_size, const ClusterBlockId clb_index, const t_cluster_placement_stats *cluster_placement_stats_ptr, const bool is_root_of_chain, const t_pb_graph_pin *chain_root_pin, t_lb_router_data *router_data, int verbosity)
try_place_macro	place/place.cpp	/^static int try_place_macro(int itype, int ipos, int imacro);$/;"	p	file:	signature:(int itype, int ipos, int imacro)
try_place_macro	place/place.cpp	/^static int try_place_macro(int itype, int ipos, int imacro){$/;"	f	file:	signature:(int itype, int ipos, int imacro)
try_place_molecule	pack/cluster_placement.cpp	/^static float try_place_molecule(const t_pack_molecule *molecule,$/;"	f	file:	signature:(const t_pack_molecule *molecule, t_pb_graph_node *root, t_pb_graph_node **primitives_list)
try_place_molecule	pack/cluster_placement.cpp	/^static float try_place_molecule(const t_pack_molecule *molecule,$/;"	p	file:	signature:(const t_pack_molecule *molecule, t_pb_graph_node *root, t_pb_graph_node **primitives_list)
try_route	route/route_common.cpp	/^bool try_route(int width_fac,$/;"	f	signature:(int width_fac, const t_router_opts& router_opts, const t_analysis_opts& analysis_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, vtr::vector<ClusterNetId, float *> &net_delay, t_slack * slacks, const t_timing_inf& timing_inf, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, t_chan_width_dist chan_width_dist, t_direct_inf *directs, int num_directs, ScreenUpdatePriority first_iteration_priority)
try_route	route/route_export.h	/^bool try_route(int width_fac,$/;"	p	signature:(int width_fac, const t_router_opts& router_opts, const t_analysis_opts& analysis_opts, t_det_routing_arch *det_routing_arch, t_segment_inf * segment_inf, vtr::vector<ClusterNetId, float *> &net_delay, t_slack * slacks, const t_timing_inf& timing_inf, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, t_chan_width_dist chan_width_dist, t_direct_inf *directs, int num_directs, ScreenUpdatePriority first_iteration_priority)
try_size_device_grid	pack/pack.cpp	/^static bool try_size_device_grid(const t_arch& arch, const std::map<t_type_ptr,size_t>& num_type_instances, float target_device_utilization, std::string device_layout_name) {$/;"	f	file:	signature:(const t_arch& arch, const std::map<t_type_ptr,size_t>& num_type_instances, float target_device_utilization, std::string device_layout_name)
try_size_device_grid	pack/pack.cpp	/^static bool try_size_device_grid(const t_arch& arch, const std::map<t_type_ptr,size_t>& num_type_instances, float target_device_utilization, std::string device_layout_name);$/;"	p	file:	signature:(const t_arch& arch, const std::map<t_type_ptr,size_t>& num_type_instances, float target_device_utilization, std::string device_layout_name)
try_swap	place/place.cpp	/^static e_swap_result try_swap(float t,$/;"	f	file:	signature:(float t, t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, float rlim, const PlaceDelayModel& delay_model, enum e_place_algorithm place_algorithm, float timing_tradeoff)
try_swap	place/place.cpp	/^static e_swap_result try_swap(float t,$/;"	p	file:	signature:(float t, t_placer_costs* costs, t_placer_prev_inverse_costs* prev_inverse_costs, float rlim, const PlaceDelayModel& delay_model, enum e_place_algorithm place_algorithm, float timing_tradeoff)
try_timing_driven_route	route/route_timing.cpp	/^bool try_timing_driven_route($/;"	f	signature:( const t_router_opts& router_opts, const t_analysis_opts& analysis_opts, vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, t_slack * slacks, const t_timing_inf &timing_inf, ScreenUpdatePriority first_iteration_priority)
try_timing_driven_route	route/route_timing.h	/^bool try_timing_driven_route($/;"	p	signature:( const t_router_opts& router_opts, const t_analysis_opts& analysis_opts, vtr::vector<ClusterNetId, float *> &net_delay, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, t_slack * slacks, const t_timing_inf &timing_inf, ScreenUpdatePriority first_iteration_priority )
try_timing_driven_route_net	route/route_timing.cpp	/^bool try_timing_driven_route_net(ClusterNetId net_id, int itry, float pres_fac,$/;"	f	signature:(ClusterNetId net_id, int itry, float pres_fac, t_router_opts router_opts, CBRR& connections_inf, RouterStats& router_stats, float* pin_criticality, t_rt_node** rt_node_of_sink, vtr::vector<ClusterNetId, float *> &net_delay, const RouterLookahead& router_lookahead, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, std::shared_ptr<SetupTimingInfo> timing_info, route_budgets &budgeting_inf)
try_timing_driven_route_net	route/route_timing.h	/^bool try_timing_driven_route_net(ClusterNetId net_id, int itry, float pres_fac,$/;"	p	signature:(ClusterNetId net_id, int itry, float pres_fac, t_router_opts router_opts, CBRR& connections_inf, RouterStats& connections_routed, float* pin_criticality, t_rt_node** rt_node_of_sink, vtr::vector<ClusterNetId, float *> &net_delay, const RouterLookahead& router_lookahead, const ClusteredPinAtomPinsLookup& netlist_pin_lookup, std::shared_ptr<SetupTimingInfo> timing_info, route_budgets &budgeting_inf)
try_update_lookahead_pins_used	pack/cluster.cpp	/^static void try_update_lookahead_pins_used(t_pb *cur_pb) {$/;"	f	file:	signature:(t_pb *cur_pb)
try_update_lookahead_pins_used	pack/cluster.cpp	/^static void try_update_lookahead_pins_used(t_pb *cur_pb);$/;"	p	file:	signature:(t_pb *cur_pb)
ts_bb_coord_new	place/place.cpp	/^static vtr::vector<ClusterNetId, t_bb> ts_bb_coord_new, ts_bb_edge_new;$/;"	v	file:
ts_bb_edge_new	place/place.cpp	/^static vtr::vector<ClusterNetId, t_bb> ts_bb_coord_new, ts_bb_edge_new;$/;"	v	file:
ts_nets_to_update	place/place.cpp	/^static std::vector<ClusterNetId> ts_nets_to_update;$/;"	v	file:
tsu	../../libs/libarchfpga/src/physical_types.h	/^	float tsu = std::numeric_limits<float>::quiet_NaN(); \/* For sequential logic elements the setup time *\/$/;"	m	struct:t_pb_graph_pin	access:public
tsu_	base/netlist_writer.cpp	/^        double tsu_; \/\/Setup time$/;"	m	class:LatchInst	file:	access:private
tsu_abs_margin	base/vpr_types.h	/^    float tsu_abs_margin;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
tsu_margin_abs_	timing/PostClusterDelayCalculator.h	/^    float tsu_margin_abs_ = 0.0e-12;$/;"	m	class:PostClusterDelayCalculator	access:private
tsu_margin_rel_	timing/PostClusterDelayCalculator.h	/^    float tsu_margin_rel_ = 1.0;$/;"	m	class:PostClusterDelayCalculator	access:private
tsu_rel_margin	base/vpr_types.h	/^    float tsu_rel_margin;$/;"	m	struct:ScreenUpdatePriority::t_placer_opts	access:public
twisted	base/vpr_types.h	/^	bool twisted = 0;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
twos_complement	../../libs/librtlnumber/src/include/internal_bits.hpp	/^        VerilogBits *twos_complement()$/;"	f	class:BitSpace::VerilogBits	access:public	signature:()
twos_complement	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    VNumber twos_complement()$/;"	f	class:VNumber	access:public	signature:()
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint16_t type;$/;"	t	struct:utf16_decoder	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint16_t type;$/;"	t	struct:wchar_selector	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint32_t type;$/;"	t	struct:utf32_decoder	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint32_t type;$/;"	t	struct:wchar_selector	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t type;$/;"	t	struct:latin1_decoder	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t type;$/;"	t	struct:utf8_decoder	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef wchar_t type;$/;"	t	struct:wchar_decoder	file:	access:public
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set::type_t type() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_type xml_node::type() const$/;"	f	class:pugi::xml_node	signature:() const
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::type_t xpath_node_set::type() const$/;"	f	class:pugi::xpath_node_set	signature:() const
type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_value_type xpath_variable::type() const$/;"	f	class:pugi::xpath_variable	signature:() const
type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		type_t type() const;$/;"	p	class:pugi::xpath_node_set	access:public	signature:() const
type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_type type() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_value_type type() const;$/;"	p	class:pugi::xpath_variable	access:public	signature:() const
type	../../libs/libarchfpga/src/expr_eval.cpp	/^	t_formula_obj type;$/;"	m	class:Formula_Object	file:	access:public
type	../../libs/libarchfpga/src/physical_types.cpp	/^SwitchType t_arch_switch_inf::type() const {$/;"	f	class:t_arch_switch_inf	signature:() const
type	../../libs/libarchfpga/src/physical_types.cpp	/^SwitchType t_rr_switch_inf::type() const {$/;"	f	class:t_rr_switch_inf	signature:() const
type	../../libs/libarchfpga/src/physical_types.h	/^	enum PORTS type;$/;"	m	struct:t_port	typeref:enum:t_port::PORTS	access:public
type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_interconnect type;$/;"	m	struct:t_interconnect	typeref:enum:t_interconnect::e_interconnect	access:public
type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pb_graph_pin_type type = PB_PIN_NORMAL; \/* The type of this pin (sequential, i\/o etc.) *\/$/;"	m	struct:t_pb_graph_pin	typeref:enum:t_pb_graph_pin::e_pb_graph_pin_type	access:public
type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_to_pin_annotation_type type;$/;"	m	struct:t_pin_to_pin_annotation	typeref:enum:t_pin_to_pin_annotation::e_pin_to_pin_annotation_type	access:public
type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_pin_type type;$/;"	m	struct:t_class	typeref:enum:t_class::e_pin_type	access:public
type	../../libs/libarchfpga/src/physical_types.h	/^	enum e_stat type;$/;"	m	struct:t_chan	typeref:enum:t_chan::e_stat	access:public
type	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type() const;$/;"	p	struct:t_arch_switch_inf	access:public	signature:() const
type	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type() const;$/;"	p	struct:t_rr_switch_inf	access:public	signature:() const
type	../../libs/libeasygl/src/graphics.cpp	/^    t_button_type type;$/;"	m	struct:__anon18	file:	access:public
type	base/netlist_writer.cpp	/^        std::string type() { return type_; }$/;"	f	class:LutInst	access:public	signature:()
type	base/vpr_types.h	/^	e_tnode_type type; \/* see the above enum *\/$/;"	m	struct:ScreenUpdatePriority::t_tnode	access:public
type	base/vpr_types.h	/^	enum e_pack_pattern_molecule_type type; \/* what kind of molecule is this? *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	typeref:enum:ScreenUpdatePriority::t_pack_molecule::e_pack_pattern_molecule_type	access:public
type	base/vpr_types.h	/^	enum sched_type type;$/;"	m	struct:ScreenUpdatePriority::t_annealing_sched	typeref:enum:ScreenUpdatePriority::t_annealing_sched::sched_type	access:public
type	base/vpr_types.h	/^	t_type_ptr type = nullptr;$/;"	m	struct:ScreenUpdatePriority::t_grid_tile	access:public
type	pack/pack_types.h	/^	enum e_lb_rr_type type;	\/* Type of logic cluster_ctx.blocks resource node *\/$/;"	m	struct:t_lb_type_rr_node	typeref:enum:t_lb_type_rr_node::e_lb_rr_type	access:public
type	route/rr_node.h	/^        t_rr_type type() const { return type_; }$/;"	f	class:t_rr_node	access:public	signature:() const
type	util/token.h	/^	enum e_token_type type;$/;"	m	struct:t_token	typeref:enum:t_token::e_token_type	access:public
type	util/vpr_error.h	/^        t_vpr_error_type type() const { return type_; }$/;"	f	class:VprError	access:public	signature:() const
type_	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type_ = SwitchType::INVALID;$/;"	m	struct:t_arch_switch_inf	access:private
type_	../../libs/libarchfpga/src/physical_types.h	/^        SwitchType type_ = SwitchType::INVALID;$/;"	m	struct:t_rr_switch_inf	access:private
type_	base/netlist_writer.cpp	/^        Type type_;$/;"	m	class:LatchInst	file:	access:private
type_	base/netlist_writer.cpp	/^        std::string type_;$/;"	m	class:LutInst	file:	access:private
type_	route/rr_node.h	/^        t_rr_type type_ = NUM_RR_TYPES;$/;"	m	class:t_rr_node	access:private
type_	util/vpr_error.h	/^        t_vpr_error_type type_;$/;"	m	class:VprError	access:private
type_name_	base/netlist_writer.cpp	/^        std::string type_name_;$/;"	m	class:BlackBoxInst	file:	access:private
type_name_ptr	base/vpr_types.h	/^	const char *type_name_ptr = nullptr;$/;"	m	struct:ScreenUpdatePriority::t_seg_details	access:public
type_name_ptr	base/vpr_types.h	/^        const char* type_name_ptr() const { return seg_detail_->type_name_ptr; }$/;"	f	class:ScreenUpdatePriority::t_chan_seg_details	access:public	signature:() const
type_sorted	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^			type_sorted,			\/\/ Sorted by document order (ascending)$/;"	e	enum:pugi::xpath_node_set::type_t
type_sorted_reverse	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^			type_sorted_reverse		\/\/ Sorted by document order (descending)$/;"	e	enum:pugi::xpath_node_set::type_t
type_string	route/rr_node.cpp	/^const char *t_rr_node::type_string() const {$/;"	f	class:t_rr_node	signature:() const
type_string	route/rr_node.h	/^        const char *type_string() const; \/* Retrieve type as a string *\/$/;"	p	class:t_rr_node	access:public	signature:() const
type_t	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		enum type_t$/;"	g	class:pugi::xpath_node_set	access:public
type_unsorted	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^			type_unsorted,			\/\/ Not ordered$/;"	e	enum:pugi::xpath_node_set::type_t
u	route/route_tree_type.h	/^	} u;$/;"	m	struct:t_rt_node	typeref:union:t_rt_node::__anon7	access:public
u	timing/net_delay.cpp	/^	} u;$/;"	m	struct:t_rc_node	typeref:union:t_rc_node::__anon11	file:	access:public
u_Data	../../libs/libarchfpga/src/expr_eval.cpp	/^		u_Data(){ memset(this, 0, sizeof(u_Data)); }$/;"	f	union:Formula_Object::u_Data	access:public	signature:()
u_Data	../../libs/libarchfpga/src/expr_eval.cpp	/^	union u_Data {$/;"	u	class:Formula_Object	file:	access:public
unclustered_list_head	pack/cluster.cpp	/^static t_molecule_link *unclustered_list_head;$/;"	v	file:
unclustered_list_head_size	pack/cluster.cpp	/^int unclustered_list_head_size;$/;"	v
unique	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename I> I unique(I begin, I end)$/;"	f	signature:(I begin, I end)
unique_subckt_name	base/read_blif.cpp	/^        std::string unique_subckt_name() {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:()
unique_subckt_name_counter_	base/read_blif.cpp	/^        size_t unique_subckt_name_counter_ = 0;$/;"	m	struct:BlifAllocCallback	file:	access:private
uniquify	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void uniquify() {$/;"	f	class:vtr::flat_map	access:private	signature:()
uniquify_edges	route/rr_graph.cpp	/^void uniquify_edges(t_rr_edge_info_set& rr_edges_to_create) {$/;"	f	signature:(t_rr_edge_info_set& rr_edges_to_create)
uniquify_edges	route/rr_graph.cpp	/^void uniquify_edges(t_rr_edge_info_set& rr_edges_to_create);$/;"	p	file:	signature:(t_rr_edge_info_set& rr_edges_to_create)
unit_scale_	timing/read_sdc2.cpp	/^        float unit_scale_ = 1e-9;$/;"	m	class:SdcParseCallback2	file:	access:private
unmap_button	../../libs/libeasygl/src/graphics.cpp	/^static void unmap_button(int bnum) {$/;"	f	file:	signature:(int bnum)
unmap_button	../../libs/libeasygl/src/graphics.cpp	/^static void unmap_button(int bnum);$/;"	p	file:	signature:(int bnum)
unmark_fanout_intermediate_nodes	pack/cluster_feasibility_filter.cpp	/^static void unmark_fanout_intermediate_nodes($/;"	f	file:	signature:( t_pb_graph_pin *current_pb_graph_pin)
unmark_fanout_intermediate_nodes	pack/cluster_feasibility_filter.cpp	/^static void unmark_fanout_intermediate_nodes($/;"	p	file:	signature:( t_pb_graph_pin *current_pb_graph_pin)
unroll_1d	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    #define unroll_1d(/;"	d
unroll_1d_invert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    #define unroll_1d_invert(/;"	d
unroll_2d	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    #define unroll_2d(/;"	d
unroll_2d_invert	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    #define unroll_2d_invert(/;"	d
unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xml_attribute***);$/;"	t	class:pugi::xml_attribute	access:private
unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xml_node***);$/;"	t	class:pugi::xml_node	access:protected
unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xml_text***);$/;"	t	class:pugi::xml_text	access:private
unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xpath_node***);$/;"	t	class:pugi::xpath_node	access:private
unspecified_bool_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef void (*unspecified_bool_type)(xpath_query***);$/;"	t	class:pugi::xpath_query	access:private
unspecified_bool_xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xml_attribute(xml_attribute***)$/;"	f	namespace:pugi	signature:(xml_attribute***)
unspecified_bool_xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xml_node(xml_node***)$/;"	f	namespace:pugi	signature:(xml_node***)
unspecified_bool_xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xml_text(xml_text***)$/;"	f	namespace:pugi	signature:(xml_text***)
unspecified_bool_xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xpath_node(xpath_node***)$/;"	f	namespace:pugi	signature:(xpath_node***)
unspecified_bool_xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN static void unspecified_bool_xpath_query(xpath_query***)$/;"	f	namespace:pugi	signature:(xpath_query***)
update	../../libs/libvtrutil/src/vtr_bimap.h	/^        void update(const K key, const V value) {$/;"	f	class:vtr::bimap	access:public	signature:(const K key, const V value)
update	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void update(const K key, const V value) { insert(key, value); }$/;"	f	class:vtr::vector_map	access:public	signature:(const K key, const V value)
update	timing/timing_info.h	/^        virtual void update() = 0;$/;"	p	class:TimingInfo	access:public	signature:()
update_all_refs	base/netlist_utils.h	/^Container update_all_refs(const Container& values, const vtr::vector_map<ValId, ValId>& id_map) {$/;"	f	signature:(const Container& values, const vtr::vector_map<ValId, ValId>& id_map)
update_bb	place/place.cpp	/^static void update_bb(ClusterNetId net_id, t_bb *bb_coord_new,$/;"	f	file:	signature:(ClusterNetId net_id, t_bb *bb_coord_new, t_bb *bb_edge_new, int xold, int yold, int xnew, int ynew)
update_bb	place/place.cpp	/^static void update_bb(ClusterNetId net_id, t_bb *bb_coord_new,$/;"	p	file:	signature:(ClusterNetId net_id, t_bb *bb_coord_new, t_bb *bb_edge_new, int xold, int yold, int xnew, int ynew)
update_brushes	../../libs/libeasygl/src/graphics.cpp	/^static void update_brushes() {$/;"	f	file:	signature:()
update_brushes	../../libs/libeasygl/src/graphics.cpp	/^static void update_brushes();$/;"	p	file:	signature:()
update_cluster_stats	pack/cluster.cpp	/^static void update_cluster_stats( const t_pack_molecule *molecule,$/;"	f	file:	signature:( const t_pack_molecule *molecule, const ClusterBlockId clb_index, const std::unordered_set<AtomNetId>& is_clock, const std::unordered_set<AtomNetId>& is_global, const bool global_clocks, const float alpha, const float beta, const bool timing_driven, const bool connection_driven, const SetupTimingInfo& timing_info)
update_cluster_stats	pack/cluster.cpp	/^static void update_cluster_stats( const t_pack_molecule *molecule,$/;"	p	file:	signature:( const t_pack_molecule *molecule, const ClusterBlockId clb_index, const std::unordered_set<AtomNetId>& is_clock, const std::unordered_set<AtomNetId>& is_global, const bool global_clocks, const float alpha, const float beta, const bool timing_driven, const bool connection_driven, const SetupTimingInfo& timing_info)
update_congestion_times	route/route_budgets.cpp	/^void route_budgets::update_congestion_times(ClusterNetId net_id) {$/;"	f	class:route_budgets	signature:(ClusterNetId net_id)
update_congestion_times	route/route_budgets.h	/^    void update_congestion_times(ClusterNetId net_id);$/;"	p	class:route_budgets	access:public	signature:(ClusterNetId net_id)
update_connection_gain_values	pack/cluster.cpp	/^static void update_connection_gain_values(const AtomNetId net_id, const AtomBlockId clustered_blk_id,$/;"	f	file:	signature:(const AtomNetId net_id, const AtomBlockId clustered_blk_id, t_pb *cur_pb, enum e_net_relation_to_clustered_block net_relation_to_clustered_block)
update_connection_gain_values	pack/cluster.cpp	/^static void update_connection_gain_values(const AtomNetId net_id, const AtomBlockId clustered_blk_id,$/;"	p	file:	signature:(const AtomNetId net_id, const AtomBlockId clustered_blk_id, t_pb * cur_pb, enum e_net_relation_to_clustered_block net_relation_to_clustered_block)
update_criticalities	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
update_criticalities	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
update_criticalities	timing/slack_evaluation.h	/^        void update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:private	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
update_criticalities	timing/slack_evaluation.h	/^        void update_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:private	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
update_hold	timing/timing_info.h	/^        virtual void update_hold() = 0;$/;"	p	class:HoldTimingInfo	access:public	signature:()
update_hold_slacks	timing/concrete_timing_info.h	/^        void update_hold_slacks() {$/;"	f	class:ConcreteHoldTimingInfo	access:public	signature:()
update_message	../../libs/libeasygl/src/graphics.cpp	/^update_message(const string& msg) {$/;"	f	signature:(const string& msg)
update_message	../../libs/libeasygl/src/graphics.cpp	/^void update_message(const std::string& \/*msg*\/) { }$/;"	f	signature:(const std::string& )
update_message	../../libs/libeasygl/src/graphics.h	/^void update_message(const std::string& msg);$/;"	p	signature:(const std::string& msg)
update_net_bb	place/place.cpp	/^static void update_net_bb(const ClusterNetId net, int iblk, const ClusterBlockId blk, const ClusterPinId blk_pin) {$/;"	f	file:	signature:(const ClusterNetId net, int iblk, const ClusterBlockId blk, const ClusterPinId blk_pin)
update_net_bb	place/place.cpp	/^static void update_net_bb(const ClusterNetId net, int iblk, const ClusterBlockId blk, const ClusterPinId blk_pin);$/;"	p	file:	signature:(const ClusterNetId net, int iblk, const ClusterBlockId blk, const ClusterPinId blk_pin)
update_net_delays_from_route_tree	route/route_tree_timing.cpp	/^void update_net_delays_from_route_tree(float *net_delay,$/;"	f	signature:(float *net_delay, const t_rt_node* const * rt_node_of_sink, ClusterNetId inet)
update_net_delays_from_route_tree	route/route_tree_timing.h	/^void update_net_delays_from_route_tree(float *net_delay,$/;"	p	signature:(float *net_delay, const t_rt_node* const * rt_node_of_sink, ClusterNetId inet)
update_normalized_costs	timing/path_delay.cpp	/^static void update_normalized_costs(float T_arr_max_this_domain, long max_critical_input_paths,$/;"	p	file:	signature:(float T_arr_max_this_domain, long max_critical_input_paths, long max_critical_output_paths, const t_timing_inf &timing_inf)
update_normalized_costs	timing/path_delay.cpp	/^static void update_normalized_costs(float criticality_denom, long max_critical_input_paths,$/;"	f	file:	signature:(float criticality_denom, long max_critical_input_paths, long max_critical_output_paths, const t_timing_inf &timing_inf)
update_pin_slack	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_pin_slack(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer)
update_pin_slack	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_pin_slack(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer)
update_pin_slack	timing/slack_evaluation.h	/^        void update_pin_slack(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:private	signature:(const AtomPinId pin, const tatum::HoldTimingAnalyzer& analyzer)
update_pin_slack	timing/slack_evaluation.h	/^        void update_pin_slack(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:private	signature:(const AtomPinId pin, const tatum::SetupTimingAnalyzer& analyzer)
update_primitive_cost_or_status	pack/cluster_placement.cpp	/^static void update_primitive_cost_or_status(const t_pb_graph_node *pb_graph_node,$/;"	f	file:	signature:(const t_pb_graph_node *pb_graph_node, const float incremental_cost, const bool valid)
update_primitive_cost_or_status	pack/cluster_placement.cpp	/^static void update_primitive_cost_or_status(const t_pb_graph_node *pb_graph_node,$/;"	p	file:	signature:(const t_pb_graph_node *pb_graph_node, const float incremental_cost, const bool valid)
update_ps_transform	../../libs/libeasygl/src/graphics.cpp	/^update_ps_transform() {$/;"	f	file:	signature:()
update_remaining_net_delays_from_route_tree	route/route_tree_timing.cpp	/^void update_remaining_net_delays_from_route_tree(float* net_delay,$/;"	f	signature:(float* net_delay, const t_rt_node* const * rt_node_of_sink, const vector<int>& remaining_sinks)
update_remaining_net_delays_from_route_tree	route/route_tree_timing.h	/^void update_remaining_net_delays_from_route_tree(float* net_delay,$/;"	p	signature:(float* net_delay, const t_rt_node* const * rt_node_of_sink, const std::vector<int>& remaining_sinks)
update_rlim	place/place.cpp	/^static void update_rlim(float *rlim, float success_rat, const DeviceGrid& grid) {$/;"	f	file:	signature:(float *rlim, float success_rat, const DeviceGrid& grid)
update_rlim	place/place.cpp	/^static void update_rlim(float *rlim, float success_rat, const DeviceGrid& grid);$/;"	p	file:	signature:(float *rlim, float success_rat, const DeviceGrid& grid)
update_route_tree	route/route_tree_timing.cpp	/^t_rt_node* update_route_tree(t_heap * hptr, SpatialRouteTreeLookup* spatial_rt_lookup) {$/;"	f	signature:(t_heap * hptr, SpatialRouteTreeLookup* spatial_rt_lookup)
update_route_tree	route/route_tree_timing.h	/^t_rt_node *update_route_tree(t_heap *hptr, SpatialRouteTreeLookup* spatial_rt_lookup);$/;"	p	signature:(t_heap *hptr, SpatialRouteTreeLookup* spatial_rt_lookup)
update_route_tree_spatial_lookup_recur	route/spatial_route_tree_lookup.cpp	/^void update_route_tree_spatial_lookup_recur(t_rt_node* rt_node, SpatialRouteTreeLookup& spatial_lookup) {$/;"	f	signature:(t_rt_node* rt_node, SpatialRouteTreeLookup& spatial_lookup)
update_route_tree_spatial_lookup_recur	route/spatial_route_tree_lookup.h	/^void update_route_tree_spatial_lookup_recur(t_rt_node* rt_node, SpatialRouteTreeLookup& spatial_lookup);$/;"	p	signature:(t_rt_node* rt_node, SpatialRouteTreeLookup& spatial_lookup)
update_rr_base_costs	route/route_timing.cpp	/^void update_rr_base_costs(int fanout) {$/;"	f	signature:(int fanout)
update_rr_base_costs	route/route_timing.h	/^void update_rr_base_costs(int fanout);$/;"	p	signature:(int fanout)
update_screen	draw/draw.cpp	/^void update_screen(ScreenUpdatePriority priority, const char *msg, enum pic_type pic_on_screen_val,$/;"	f	signature:(ScreenUpdatePriority priority, const char *msg, enum pic_type pic_on_screen_val, std::shared_ptr<SetupTimingInfo> setup_timing_info)
update_screen	draw/draw.h	/^void update_screen(ScreenUpdatePriority priority, const char *msg, enum pic_type pic_on_screen_val,$/;"	p	signature:(ScreenUpdatePriority priority, const char *msg, enum pic_type pic_on_screen_val, std::shared_ptr<SetupTimingInfo> timing_info)
update_setup	timing/timing_info.h	/^        virtual void update_setup() = 0;$/;"	p	class:SetupTimingInfo	access:public	signature:()
update_setup_slacks	timing/concrete_timing_info.h	/^        void update_setup_slacks() {$/;"	f	class:ConcreteSetupTimingInfo	access:public	signature:()
update_slacks	timing/path_delay.cpp	/^static void update_slacks(t_slack * slacks, float criticality_denom,$/;"	f	file:	signature:(t_slack * slacks, float criticality_denom, bool update_slack, bool is_final_analysis, float smallest_slack_in_design, const t_timing_inf &timing_inf)
update_slacks	timing/path_delay.cpp	/^static void update_slacks(t_slack * slacks, float criticality_denom,$/;"	p	file:	signature:(t_slack * slacks, float criticality_denom, bool update_slack, bool is_final_analysis, float smallest_slack_in_design, const t_timing_inf &timing_inf)
update_slacks	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_slacks(const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const tatum::HoldTimingAnalyzer& analyzer)
update_slacks	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_slacks(const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const tatum::SetupTimingAnalyzer& analyzer)
update_slacks	timing/slack_evaluation.h	/^        void update_slacks(const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:private	signature:(const tatum::HoldTimingAnalyzer& analyzer)
update_slacks	timing/slack_evaluation.h	/^        void update_slacks(const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:private	signature:(const tatum::SetupTimingAnalyzer& analyzer)
update_slacks_and_criticalities	timing/slack_evaluation.cpp	/^void HoldSlackCrit::update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer) {$/;"	f	class:HoldSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
update_slacks_and_criticalities	timing/slack_evaluation.cpp	/^void SetupSlackCrit::update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer) {$/;"	f	class:SetupSlackCrit	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
update_slacks_and_criticalities	timing/slack_evaluation.h	/^        void update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer);$/;"	p	class:HoldSlackCrit	access:public	signature:(const tatum::TimingGraph& timing_graph, const tatum::HoldTimingAnalyzer& analyzer)
update_slacks_and_criticalities	timing/slack_evaluation.h	/^        void update_slacks_and_criticalities(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer);$/;"	p	class:SetupSlackCrit	access:public	signature:(const tatum::TimingGraph& timing_graph, const tatum::SetupTimingAnalyzer& analyzer)
update_t	place/place.cpp	/^static void update_t(float *t, float rlim, float success_rat,$/;"	f	file:	signature:(float *t, float rlim, float success_rat, t_annealing_sched annealing_sched)
update_t	place/place.cpp	/^static void update_t(float *t, float rlim, float success_rat,$/;"	p	file:	signature:(float *t, float rlim, float success_rat, t_annealing_sched annealing_sched)
update_td_cost	place/place.cpp	/^static void update_td_cost() {$/;"	f	file:	signature:()
update_td_cost	place/place.cpp	/^static void update_td_cost();$/;"	p	file:	signature:()
update_td_delta_costs	place/place.cpp	/^static void update_td_delta_costs(const PlaceDelayModel& delay_model, const ClusterNetId net, const ClusterPinId pin, float& delta_timing_cost, float& delta_delay_cost) {$/;"	f	file:	signature:(const PlaceDelayModel& delay_model, const ClusterNetId net, const ClusterPinId pin, float& delta_timing_cost, float& delta_delay_cost)
update_td_delta_costs	place/place.cpp	/^static void update_td_delta_costs(const PlaceDelayModel& delay_model, const ClusterNetId net, const ClusterPinId pin, float& delta_timing_cost, float& delta_delay_cost);$/;"	p	file:	signature:(const PlaceDelayModel& delay_model, const ClusterNetId net, const ClusterPinId pin, float& delta_timing_cost, float& delta_delay_cost)
update_temp	route/cb_metrics.cpp	/^static double update_temp(const double temp);$/;"	p	file:	signature:(const double temp)
update_temp	route/cb_metrics.cpp	/^static double update_temp(const double temp){$/;"	f	file:	signature:(const double temp)
update_timing_gain_values	pack/cluster.cpp	/^static void update_timing_gain_values(const AtomNetId net_id,$/;"	f	file:	signature:(const AtomNetId net_id, t_pb *cur_pb, enum e_net_relation_to_clustered_block net_relation_to_clustered_block, const SetupTimingInfo& timing_info, const std::unordered_set<AtomNetId>& is_global)
update_timing_gain_values	pack/cluster.cpp	/^static void update_timing_gain_values(const AtomNetId net_id,$/;"	p	file:	signature:(const AtomNetId net_id, t_pb* cur_pb, enum e_net_relation_to_clustered_block net_relation_to_clustered_block, const SetupTimingInfo& timing_info, const std::unordered_set<AtomNetId>& is_global)
update_total_gain	pack/cluster.cpp	/^static void update_total_gain(float alpha, float beta, bool timing_driven,$/;"	f	file:	signature:(float alpha, float beta, bool timing_driven, bool connection_driven, t_pb *pb)
update_total_gain	pack/cluster.cpp	/^static void update_total_gain(float alpha, float beta, bool timing_driven,$/;"	p	file:	signature:(float alpha, float beta, bool timing_driven, bool connection_driven, t_pb *pb)
update_traceback	route/route_common.cpp	/^update_traceback(t_heap *hptr, ClusterNetId net_id) {$/;"	f	signature:(t_heap *hptr, ClusterNetId net_id)
update_traceback	route/route_common.h	/^t_trace *update_traceback(t_heap *hptr, ClusterNetId net_id);$/;"	p	signature:(t_heap *hptr, ClusterNetId net_id)
update_transform	../../libs/libeasygl/src/graphics.cpp	/^update_transform() {$/;"	f	file:	signature:()
update_unbuffered_ancestors_C_downstream	route/route_tree_timing.cpp	/^static t_rt_node *update_unbuffered_ancestors_C_downstream($/;"	p	file:	signature:( t_rt_node * start_of_new_subtree_rt_node)
update_unbuffered_ancestors_C_downstream	route/route_tree_timing.cpp	/^update_unbuffered_ancestors_C_downstream(t_rt_node * start_of_new_path_rt_node) {$/;"	f	file:	signature:(t_rt_node * start_of_new_path_rt_node)
update_valid_refs	base/netlist_utils.h	/^Container update_valid_refs(const Container& values,$/;"	f	signature:(const Container& values, const vtr::vector_map<ValId, ValId>& id_map, const std::set<size_t>& preserved_indices={})
update_win	../../libs/libeasygl/src/graphics.cpp	/^update_win(int x[2], int y[2], void (*drawscreen)()) {$/;"	f	file:	signature:(int x[2], int y[2], void (*drawscreen)())
upper_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator upper_bound(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
upper_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator upper_bound(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
upper_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator upper_bound(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
upper_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator upper_bound(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
upper_bound_delay_ch	route/route_budgets.h	/^    vtr::t_chunk upper_bound_delay_ch;$/;"	m	class:route_budgets	access:private
usage	base/vpr_types.h	/^    int usage;$/;"	m	struct:ScreenUpdatePriority::t_grid_blocks	access:public
use_cairo	../../libs/libeasygl/src/graphics.cpp	/^static bool use_cairo()$/;"	f	file:	signature:()
use_cairo	../../libs/libeasygl/src/graphics.cpp	/^static bool use_cairo();$/;"	p	file:	signature:()
use_default_timing_constraints	timing/read_sdc.cpp	/^static void use_default_timing_constraints() {$/;"	f	file:	signature:()
use_default_timing_constraints	timing/read_sdc.cpp	/^static void use_default_timing_constraints();$/;"	p	file:	signature:()
used	../../libs/libarchfpga/src/logic_types.h	/^	int used = 0;$/;"	m	struct:t_model	access:public
used_wirelength	route/route_timing.cpp	/^    size_t used_wirelength = 0;$/;"	m	struct:RoutingMetrics	file:	access:public
used_wirelength	route/route_timing.cpp	/^    size_t used_wirelength() const {$/;"	f	class:WirelengthInfo	access:public	signature:() const
used_wirelength_	route/route_timing.cpp	/^    size_t used_wirelength_;$/;"	m	class:WirelengthInfo	file:	access:private
used_wirelength_ratio	route/route_timing.cpp	/^    float used_wirelength_ratio() const {$/;"	f	class:WirelengthInfo	access:public	signature:() const
user_arch_models_	base/read_blif.cpp	/^        const t_model* user_arch_models_ = nullptr;$/;"	m	struct:BlifAllocCallback	file:	access:private
user_models	base/vpr_types.h	/^	t_model * user_models; \/* blif models defined by the user *\/$/;"	m	struct:ScreenUpdatePriority::t_vpr_setup	access:public
uses_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool uses_heap() const$/;"	f	class:xpath_string	access:public	signature:() const
utf16_counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf16_counter$/;"	s	file:
utf16_counter::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf16_counter	access:public	signature:(value_type result, uint32_t)
utf16_counter::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t)$/;"	f	struct:utf16_counter	access:public	signature:(value_type result, uint32_t)
utf16_counter::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef size_t value_type;$/;"	t	struct:utf16_counter	file:	access:public
utf16_decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename opt_swap> struct utf16_decoder$/;"	s	file:
utf16_decoder::process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint16_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:utf16_decoder	access:public	signature:(const uint16_t* data, size_t size, typename Traits::value_type result, Traits)
utf16_decoder::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint16_t type;$/;"	t	struct:utf16_decoder	file:	access:public
utf16_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf16_writer$/;"	s	file:
utf16_writer::any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer	access:public	signature:(value_type result, uint32_t ch)
utf16_writer::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer	access:public	signature:(value_type result, uint32_t ch)
utf16_writer::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer	access:public	signature:(value_type result, uint32_t ch)
utf16_writer::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint16_t* value_type;$/;"	t	struct:utf16_writer	file:	access:public
utf32_counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf32_counter$/;"	s	file:
utf32_counter::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf32_counter	access:public	signature:(value_type result, uint32_t)
utf32_counter::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t)$/;"	f	struct:utf32_counter	access:public	signature:(value_type result, uint32_t)
utf32_counter::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef size_t value_type;$/;"	t	struct:utf32_counter	file:	access:public
utf32_decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename opt_swap> struct utf32_decoder$/;"	s	file:
utf32_decoder::process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint32_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:utf32_decoder	access:public	signature:(const uint32_t* data, size_t size, typename Traits::value_type result, Traits)
utf32_decoder::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint32_t type;$/;"	t	struct:utf32_decoder	file:	access:public
utf32_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf32_writer$/;"	s	file:
utf32_writer::any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer	access:public	signature:(value_type result, uint32_t ch)
utf32_writer::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer	access:public	signature:(value_type result, uint32_t ch)
utf32_writer::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer	access:public	signature:(value_type result, uint32_t ch)
utf32_writer::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint32_t* value_type;$/;"	t	struct:utf32_writer	file:	access:public
utf8_counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf8_counter$/;"	s	file:
utf8_counter::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf8_counter	access:public	signature:(value_type result, uint32_t)
utf8_counter::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf8_counter	access:public	signature:(value_type result, uint32_t ch)
utf8_counter::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef size_t value_type;$/;"	t	struct:utf8_counter	file:	access:public
utf8_decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf8_decoder$/;"	s	file:
utf8_decoder::process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)$/;"	f	struct:utf8_decoder	access:public	signature:(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)
utf8_decoder::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t type;$/;"	t	struct:utf8_decoder	file:	access:public
utf8_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct utf8_writer$/;"	s	file:
utf8_writer::any	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer	access:public	signature:(value_type result, uint32_t ch)
utf8_writer::high	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer	access:public	signature:(value_type result, uint32_t ch)
utf8_writer::low	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer	access:public	signature:(value_type result, uint32_t ch)
utf8_writer::value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t* value_type;$/;"	t	struct:utf8_writer	file:	access:public
v_ds	power/power.h	/^	float v_ds;$/;"	m	struct:t_power_nmos_leakage_pair	access:public
v_in	power/power.h	/^	float v_in;$/;"	m	struct:t_power_mux_volt_pair	access:public
v_out_max	power/power.h	/^	float v_out_max;$/;"	m	struct:t_power_mux_volt_pair	access:public
v_out_min	power/power.h	/^	float v_out_min;$/;"	m	struct:t_power_mux_volt_pair	access:public
valid	../../libs/libarchfpga/src/cad_types.h	/^	bool valid;$/;"	m	struct:t_cluster_placement_primitive	access:public
valid	base/vpr_types.h	/^	bool valid; \/* Whether or not this molecule is still valid *\/$/;"	m	struct:ScreenUpdatePriority::t_pack_molecule	access:public
valid_block_id	base/netlist.h	/^        bool valid_block_id(BlockId block_id) const;$/;"	p	class:Netlist	access:protected	signature:(BlockId block_id) const
valid_block_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_block_id(BlockId block_id) const {$/;"	f	class:Netlist	signature:(BlockId block_id) const
valid_net_id	base/netlist.h	/^        bool valid_net_id(NetId net_id) const;$/;"	p	class:Netlist	access:protected	signature:(NetId net_id) const
valid_net_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_net_id(NetId net_id) const {$/;"	f	class:Netlist	signature:(NetId net_id) const
valid_pin_id	base/netlist.h	/^        bool valid_pin_id(PinId pin_id) const;$/;"	p	class:Netlist	access:protected	signature:(PinId pin_id) const
valid_pin_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_pin_id(PinId pin_id) const {$/;"	f	class:Netlist	signature:(PinId pin_id) const
valid_port_bit	base/netlist.h	/^        bool valid_port_bit(PortId port_id, BitIndex port_bit) const;$/;"	p	class:Netlist	access:protected	signature:(PortId port_id, BitIndex port_bit) const
valid_port_bit	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_port_bit(PortId port_id, BitIndex port_bit) const {$/;"	f	class:Netlist	signature:(PortId port_id, BitIndex port_bit) const
valid_port_id	base/netlist.h	/^        bool valid_port_id(PortId port_id) const;$/;"	p	class:Netlist	access:protected	signature:(PortId port_id) const
valid_port_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_port_id(PortId port_id) const {$/;"	f	class:Netlist	signature:(PortId port_id) const
valid_primitives	base/vpr_types.h	/^	t_cluster_placement_primitive **valid_primitives; \/* [0..num_pb_types-1] ptrs to linked list of valid primitives, for convenience, each linked list head is empty *\/$/;"	m	struct:ScreenUpdatePriority::t_cluster_placement_stats	access:public
valid_size	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type valid_size() const {$/;"	f	class:vtr::linear_map	access:public	signature:() const
valid_string_id	base/netlist.h	/^        bool valid_string_id(StringId string_id) const;$/;"	p	class:Netlist	access:protected	signature:(StringId string_id) const
valid_string_id	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::valid_string_id(typename Netlist<BlockId, PortId, PinId, NetId>::StringId string_id) const {$/;"	f	class:Netlist	signature:(typename Netlist<BlockId, PortId, PinId, NetId>::StringId string_id) const
validate	route/rr_node.cpp	/^bool t_rr_node::validate() const {$/;"	f	class:t_rr_node	signature:() const
validate	route/rr_node.h	/^        bool validate() const;$/;"	p	class:t_rr_node	access:public	signature:() const
validate_block_pin_refs	base/netlist.h	/^        bool validate_block_pin_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_block_pin_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_block_pin_refs() const {$/;"	f	class:Netlist	signature:() const
validate_block_port_refs	base/netlist.h	/^        bool validate_block_port_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_block_port_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_block_port_refs() const {$/;"	f	class:Netlist	signature:() const
validate_block_sizes	base/netlist.h	/^        bool validate_block_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_block_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_block_sizes() const {$/;"	f	class:Netlist	signature:() const
validate_block_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_block_sizes_impl(size_t num_blocks) const {$/;"	f	class:AtomNetlist	signature:(size_t num_blocks) const
validate_block_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_block_sizes_impl(size_t num_blocks) const {$/;"	f	class:ClusteredNetlist	signature:(size_t num_blocks) const
validate_block_sizes_impl	base/netlist.h	/^        virtual bool validate_block_sizes_impl(size_t num_blocks) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_blocks) const
validate_macros	place/place_macro.cpp	/^static void validate_macros(t_pl_macro* macros, int num_macro);$/;"	p	file:	signature:(t_pl_macro* macros, int num_macro)
validate_macros	place/place_macro.cpp	/^static void validate_macros(t_pl_macro* macros, int num_macros) {$/;"	f	file:	signature:(t_pl_macro* macros, int num_macros)
validate_net_pin_refs	base/netlist.h	/^        bool validate_net_pin_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_net_pin_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_net_pin_refs() const {$/;"	f	class:Netlist	signature:() const
validate_net_sizes	base/netlist.h	/^        bool validate_net_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_net_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_net_sizes() const {$/;"	f	class:Netlist	signature:() const
validate_net_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_net_sizes_impl(size_t \/*num_nets*\/) const {$/;"	f	class:AtomNetlist	signature:(size_t ) const
validate_net_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_net_sizes_impl(size_t num_nets) const {$/;"	f	class:ClusteredNetlist	signature:(size_t num_nets) const
validate_net_sizes_impl	base/netlist.h	/^        virtual bool validate_net_sizes_impl(size_t num_nets) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_nets) const
validate_pin_sizes	base/netlist.h	/^        bool validate_pin_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_pin_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_pin_sizes() const {$/;"	f	class:Netlist	signature:() const
validate_pin_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_pin_sizes_impl(size_t \/*num_pins*\/) const {$/;"	f	class:AtomNetlist	signature:(size_t ) const
validate_pin_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_pin_sizes_impl(size_t num_pins) const {$/;"	f	class:ClusteredNetlist	signature:(size_t num_pins) const
validate_pin_sizes_impl	base/netlist.h	/^        virtual bool validate_pin_sizes_impl(size_t num_pins) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_pins) const
validate_port_pin_refs	base/netlist.h	/^        bool validate_port_pin_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_port_pin_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_port_pin_refs() const {$/;"	f	class:Netlist	signature:() const
validate_port_sizes	base/netlist.h	/^        bool validate_port_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_port_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_port_sizes() const {$/;"	f	class:Netlist	signature:() const
validate_port_sizes_impl	base/atom_netlist.cpp	/^bool AtomNetlist::validate_port_sizes_impl(size_t num_ports) const {$/;"	f	class:AtomNetlist	signature:(size_t num_ports) const
validate_port_sizes_impl	base/clustered_netlist.cpp	/^bool ClusteredNetlist::validate_port_sizes_impl(size_t \/*num_ports*\/) const {$/;"	f	class:ClusteredNetlist	signature:(size_t ) const
validate_port_sizes_impl	base/netlist.h	/^        virtual bool validate_port_sizes_impl(size_t num_ports) const = 0;$/;"	p	class:Netlist	access:protected	signature:(size_t num_ports) const
validate_route_tree_spatial_lookup	route/spatial_route_tree_lookup.cpp	/^bool validate_route_tree_spatial_lookup(t_rt_node* rt_node, const SpatialRouteTreeLookup& spatial_lookup) {$/;"	f	signature:(t_rt_node* rt_node, const SpatialRouteTreeLookup& spatial_lookup)
validate_route_tree_spatial_lookup	route/spatial_route_tree_lookup.h	/^bool validate_route_tree_spatial_lookup(t_rt_node* rt_root, const SpatialRouteTreeLookup& spatial_lookup);$/;"	p	signature:(t_rt_node* rt_root, const SpatialRouteTreeLookup& spatial_lookup)
validate_string_refs	base/netlist.h	/^        bool validate_string_refs() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_string_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_string_refs() const {$/;"	f	class:Netlist	signature:() const
validate_string_sizes	base/netlist.h	/^        bool validate_string_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
validate_string_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::validate_string_sizes() const {$/;"	f	class:Netlist	signature:() const
validate_trace_nodes	route/route_common.cpp	/^static bool validate_trace_nodes(t_trace* head, const std::unordered_set<int>& trace_nodes) {$/;"	f	file:	signature:(t_trace* head, const std::unordered_set<int>& trace_nodes)
validate_trace_nodes	route/route_common.cpp	/^static bool validate_trace_nodes(t_trace* head, const std::unordered_set<int>& trace_nodes);$/;"	p	file:	signature:(t_trace* head, const std::unordered_set<int>& trace_nodes)
validate_traceback	route/route_common.cpp	/^bool validate_traceback(t_trace* trace) {$/;"	f	signature:(t_trace* trace)
validate_traceback	route/route_common.h	/^bool validate_traceback(t_trace* trace);$/;"	p	signature:(t_trace* trace)
validate_traceback_recurr	route/route_common.cpp	/^bool validate_traceback_recurr(t_trace* trace, std::set<int>& seen_rr_nodes) {$/;"	f	signature:(t_trace* trace, std::set<int>& seen_rr_nodes)
validate_traceback_recurr	route/route_common.cpp	/^bool validate_traceback_recurr(t_trace* trace, std::set<int>& seen_rr_nodes);$/;"	p	file:	signature:(t_trace* trace, std::set<int>& seen_rr_nodes)
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			void* value;$/;"	m	struct:compact_hash_table::item_t	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool value;$/;"	m	struct:xpath_variable_boolean	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* value;$/;"	m	struct:xpath_variable_string	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		double value;$/;"	m	struct:xpath_variable_number	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		enum { value = 0 };$/;"	e	enum:opt_false::__anon25	file:
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		enum { value = 1 };$/;"	e	enum:opt_true::__anon26	file:
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<5, 3> value;$/;"	m	struct:pugi::xml_attribute_struct	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		impl::compact_string<5, 3> value;$/;"	m	struct:pugi::xml_node_struct	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set value;$/;"	m	struct:xpath_variable_node_set	file:	access:public
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_attribute::value() const$/;"	f	class:pugi::xml_attribute	signature:() const
value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char_t* xml_node::value() const$/;"	f	class:pugi::xml_node	signature:() const
value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* value() const;$/;"	p	class:pugi::xml_attribute	access:public	signature:() const
value	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		const char_t* value() const;$/;"	p	class:pugi::xml_node	access:public	signature:() const
value	../../libs/libarchfpga/src/physical_types.h	/^	char **value; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:t_pin_to_pin_annotation	access:public
value_	../../libs/libvtrutil/src/vtr_vector.h	/^                value_type value_;$/;"	m	class:vtr::vector::key_iterator	access:private
value_	route/rr_node.h	/^                value_type value_;$/;"	m	class:t_rr_node::edge_idx_iterator	access:private
value_comp	../../libs/libvtrutil/src/vtr_flat_map.h	/^        value_compare value_comp() const { return value_compare(key_comp()); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
value_compare	../../libs/libvtrutil/src/vtr_flat_map.h	/^        value_compare(Compare c) : comp(c) {}$/;"	f	class:vtr::flat_map::value_compare	access:private	signature:(Compare c)
value_compare	../../libs/libvtrutil/src/vtr_flat_map.h	/^class flat_map<K,T,Compare>::value_compare {$/;"	c	class:vtr::flat_map
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef size_t value_type;$/;"	t	struct:utf16_counter	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef size_t value_type;$/;"	t	struct:utf32_counter	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef size_t value_type;$/;"	t	struct:utf8_counter	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint16_t* value_type;$/;"	t	struct:utf16_writer	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint32_t* value_type;$/;"	t	struct:utf32_writer	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t* value_type;$/;"	t	struct:latin1_writer	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint8_t* value_type;$/;"	t	struct:utf8_writer	file:	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_attribute value_type;$/;"	t	class:pugi::xml_attribute_iterator	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node value_type;$/;"	t	class:pugi::xml_named_node_iterator	access:public
value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		typedef xml_node value_type;$/;"	t	class:pugi::xml_node_iterator	access:public
value_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef std::pair<K,T> value_type;$/;"	t	class:vtr::flat_map	access:public
value_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef std::pair<K,T> value_type;$/;"	t	class:vtr::linear_map	access:public
values_	base/netlist_writer.cpp	/^        std::vector<vtr::LogicValue> values_; \/\/The logic values$/;"	m	class:LogicVec	file:	access:private
variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			xpath_variable* variable;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
variance	route/routing_predictor.cpp	/^float variance(std::vector<T> values, float avg) {$/;"	f	signature:(std::vector<T> values, float avg)
variance	route/routing_predictor.cpp	/^float variance(std::vector<float> values, float avg);$/;"	p	file:	signature:(std::vector<float> values, float avg)
vars_	../../libs/libarchfpga/src/expr_eval.h	/^        std::map<std::string,int> vars_;$/;"	m	class:t_formula_data	access:private
vec_	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::vector<value_type> vec_;$/;"	m	class:vtr::flat_map	access:private
vec_	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::vector<value_type> vec_;$/;"	m	class:vtr::linear_map	access:private
vec_	../../libs/libvtrutil/src/vtr_vector_map.h	/^        std::vector<V> vec_;$/;"	m	class:vtr::vector_map	access:private
vector	../../libs/libvtrutil/src/vtr_vector.h	/^class vector : private std::vector<V> {$/;"	c	namespace:vtr	inherits:std::vector
vector_map	../../libs/libvtrutil/src/vtr_vector_map.h	/^        vector_map(Args&&... args)$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
vector_map	../../libs/libvtrutil/src/vtr_vector_map.h	/^class vector_map {$/;"	c	namespace:vtr
verbosity_	base/read_blif.cpp	/^        int verbosity_ = 1;$/;"	m	struct:BlifAllocCallback	file:	access:private
veri_internal_bits_t	../../libs/librtlnumber/src/include/internal_bits.hpp	/^typedef uint64_t veri_internal_bits_t;$/;"	t
verify	base/netlist.h	/^        bool verify() const;$/;"	p	class:Netlist	access:public	signature:() const
verify	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify() const {$/;"	f	class:Netlist	signature:() const
verify_args	base/read_options.cpp	/^static bool verify_args(const t_options& args) {$/;"	f	file:	signature:(const t_options& args)
verify_args	base/read_options.cpp	/^static bool verify_args(const t_options& args);$/;"	p	file:	signature:(const t_options& args)
verify_binary_search	base/read_options.h	/^    argparse::ArgValue<bool> verify_binary_search;$/;"	m	struct:t_options	access:public
verify_binary_search	base/vpr_types.h	/^	bool verify_binary_search;$/;"	m	struct:ScreenUpdatePriority::t_router_opts	access:public
verify_blackbox_model	base/read_blif.cpp	/^        bool verify_blackbox_model(AtomNetlist& blif_model) {$/;"	f	struct:BlifAllocCallback	file:	access:private	signature:(AtomNetlist& blif_model)
verify_block_invariants	base/netlist.h	/^        bool verify_block_invariants() const;$/;"	p	class:Netlist	access:protected	signature:() const
verify_block_invariants	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_block_invariants() const {$/;"	f	class:Netlist	signature:() const
verify_blocks	route/rr_graph_reader.cpp	/^void verify_blocks(pugi::xml_node parent, const pugiutil::loc_data & loc_data) {$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
verify_blocks	route/rr_graph_reader.cpp	/^void verify_blocks(pugi::xml_node parent, const pugiutil::loc_data & loc_data);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data)
verify_delta_delays	place/timing_place_lookup.cpp	/^static bool verify_delta_delays(const vtr::Matrix<float>& delta_delays) {$/;"	f	file:	signature:(const vtr::Matrix<float>& delta_delays)
verify_delta_delays	place/timing_place_lookup.cpp	/^static bool verify_delta_delays(const vtr::Matrix<float>& delta_delays);$/;"	p	file:	signature:(const vtr::Matrix<float>& delta_delays)
verify_extract_top	route/route_common.cpp	/^	void verify_extract_top() {$/;"	f	namespace:heap_	signature:()
verify_extract_top	route/route_common.h	/^	void verify_extract_top();$/;"	p	namespace:heap_	signature:()
verify_file_digests	base/read_options.h	/^    argparse::ArgValue<bool> verify_file_digests;$/;"	m	struct:t_options	access:public
verify_file_digests	base/vpr_types.h	/^    bool verify_file_digests;$/;"	m	struct:ScreenUpdatePriority::t_file_name_opts	access:public
verify_grid	route/rr_graph_reader.cpp	/^void verify_grid(pugi::xml_node parent, const pugiutil::loc_data & loc_data, const DeviceGrid& grid) {$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data, const DeviceGrid& grid)
verify_grid	route/rr_graph_reader.cpp	/^void verify_grid(pugi::xml_node parent, const pugiutil::loc_data& loc_data, const DeviceGrid& grid);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data& loc_data, const DeviceGrid& grid)
verify_lookups	base/netlist.h	/^        bool verify_lookups() const;$/;"	p	class:Netlist	access:protected	signature:() const
verify_lookups	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_lookups() const {$/;"	f	class:Netlist	signature:() const
verify_refs	base/netlist.h	/^        bool verify_refs() const; \/\/All cross-references$/;"	p	class:Netlist	access:protected	signature:() const
verify_refs	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_refs() const {$/;"	f	class:Netlist	signature:() const
verify_route_tree	route/route_tree_timing.cpp	/^bool verify_route_tree(t_rt_node* root) {$/;"	f	signature:(t_rt_node* root)
verify_route_tree	route/route_tree_timing.h	/^bool verify_route_tree(t_rt_node* root);$/;"	p	signature:(t_rt_node* root)
verify_route_tree_recurr	route/route_tree_timing.cpp	/^bool verify_route_tree_recurr(t_rt_node* node, std::set<int>& seen_nodes) {$/;"	f	signature:(t_rt_node* node, std::set<int>& seen_nodes)
verify_route_tree_recurr	route/route_tree_timing.cpp	/^bool verify_route_tree_recurr(t_rt_node* node, std::set<int>& seen_nodes);$/;"	p	file:	signature:(t_rt_node* node, std::set<int>& seen_nodes)
verify_segments	route/rr_graph_reader.cpp	/^void verify_segments(pugi::xml_node parent, const pugiutil::loc_data & loc_data, const t_segment_inf * segment_inf) {$/;"	f	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data, const t_segment_inf * segment_inf)
verify_segments	route/rr_graph_reader.cpp	/^void verify_segments(pugi::xml_node parent, const pugiutil::loc_data & loc_data, const t_segment_inf *segment_inf);$/;"	p	file:	signature:(pugi::xml_node parent, const pugiutil::loc_data & loc_data, const t_segment_inf *segment_inf)
verify_sizes	base/netlist.h	/^        bool verify_sizes() const;$/;"	p	class:Netlist	access:protected	signature:() const
verify_sizes	base/netlist.tpp	/^bool Netlist<BlockId, PortId, PinId, NetId>::verify_sizes() const {$/;"	f	class:Netlist	signature:() const
verify_traceback_route_tree_equivalent	route/route_tree_timing.cpp	/^bool verify_traceback_route_tree_equivalent(const t_trace* head, const t_rt_node* rt_root) {$/;"	f	signature:(const t_trace* head, const t_rt_node* rt_root)
verify_traceback_route_tree_equivalent	route/route_tree_timing.h	/^bool verify_traceback_route_tree_equivalent(const t_trace* trace_head, const t_rt_node* rt_root);$/;"	p	signature:(const t_trace* trace_head, const t_rt_node* rt_root)
verilog_os_	base/netlist_writer.cpp	/^        std::ostream& verilog_os_;$/;"	m	class:NetlistWriterVisitor	file:	access:private
viridis_data	../../libs/libvtrutil/src/vtr_color_map.cpp	/^static std::vector<Color<float>> viridis_data = {$/;"	m	namespace:vtr	file:
visit_atom	base/netlist_walker.h	/^        void visit_atom(const t_pb* atom) { visit_atom_impl(atom); }$/;"	f	class:NetlistVisitor	access:public	signature:(const t_pb* atom)
visit_atom_impl	base/netlist_walker.cpp	/^void NetlistVisitor::visit_atom_impl(const t_pb* \/*atom*\/) {$/;"	f	class:NetlistVisitor	signature:(const t_pb* )
visit_atom_impl	base/netlist_walker.h	/^        virtual void visit_atom_impl(const t_pb* atom);$/;"	p	class:NetlistVisitor	access:protected	signature:(const t_pb* atom)
visit_clb	base/netlist_walker.h	/^        void visit_clb(const t_pb* clb) { visit_clb_impl(clb); }$/;"	f	class:NetlistVisitor	access:public	signature:(const t_pb* clb)
visit_clb_impl	base/netlist_walker.cpp	/^void NetlistVisitor::visit_clb_impl(const t_pb* \/*clb*\/) {$/;"	f	class:NetlistVisitor	signature:(const t_pb* )
visit_clb_impl	base/netlist_walker.h	/^        virtual void visit_clb_impl(const t_pb* clb);$/;"	p	class:NetlistVisitor	access:protected	signature:(const t_pb* clb)
visit_top	base/netlist_walker.h	/^        void visit_top(const char* top_level_name) { visit_top_impl(top_level_name); }$/;"	f	class:NetlistVisitor	access:public	signature:(const char* top_level_name)
visit_top_impl	base/netlist_walker.cpp	/^void NetlistVisitor::visit_top_impl(const char* \/*top_level_name*\/) {$/;"	f	class:NetlistVisitor	signature:(const char* )
visit_top_impl	base/netlist_walker.h	/^        virtual void visit_top_impl(const char* top_level_name);$/;"	p	class:NetlistVisitor	access:protected	signature:(const char* top_level_name)
visited	power/power.h	/^	bool visited; \/* When traversing netlist, need to track whether the node has been processed *\/$/;"	m	struct:t_rr_node_power	access:public
visitor_	base/netlist_walker.h	/^        NetlistVisitor& visitor_;$/;"	m	class:NetlistWalker	access:private
visual_info	../../libs/libeasygl/src/graphics_state.h	/^    XVisualInfo visual_info;$/;"	m	class:t_x11_state	access:public
vpr_alloc_and_load_output_file_names	base/vpr_api.h	/^void vpr_alloc_and_load_output_file_names(const char* default_name);$/;"	p	signature:(const char* default_name)
vpr_analysis	base/vpr_api.cpp	/^void vpr_analysis(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status)
vpr_analysis	base/vpr_api.h	/^void vpr_analysis(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status); \/\/Perform post-implementation analysis$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status)
vpr_analysis_flow	base/vpr_api.cpp	/^bool vpr_analysis_flow(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status)
vpr_analysis_flow	base/vpr_api.h	/^bool vpr_analysis_flow(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status); \/\/Perform or skips the analysis stage$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& Arch, const RouteStatus& route_status)
vpr_check_arch	base/vpr_api.cpp	/^void vpr_check_arch(const t_arch& Arch) {$/;"	f	signature:(const t_arch& Arch)
vpr_check_arch	base/vpr_api.h	/^void vpr_check_arch(const t_arch& Arch);$/;"	p	signature:(const t_arch& Arch)
vpr_check_setup	base/vpr_api.cpp	/^void vpr_check_setup($/;"	f	signature:( const t_packer_opts PackerOpts, const t_placer_opts PlacerOpts, const t_router_opts RouterOpts, const t_det_routing_arch RoutingArch, const t_segment_inf * Segments, const t_timing_inf Timing, const t_chan_width_dist Chans)
vpr_check_setup	base/vpr_api.h	/^void vpr_check_setup($/;"	p	signature:( const t_packer_opts PackerOpts, const t_placer_opts PlacerOpts, const t_router_opts RouterOpts, const t_det_routing_arch RoutingArch, const t_segment_inf * Segments, const t_timing_inf Timing, const t_chan_width_dist Chans)
vpr_close_graphics	base/vpr_api.cpp	/^void vpr_close_graphics(const t_vpr_setup& vpr_setup) {$/;"	f	signature:(const t_vpr_setup& vpr_setup)
vpr_close_graphics	base/vpr_api.h	/^void vpr_close_graphics(const t_vpr_setup& vpr_setup);$/;"	p	signature:(const t_vpr_setup& vpr_setup)
vpr_create_device	base/vpr_api.cpp	/^void vpr_create_device(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_create_device	base/vpr_api.h	/^void vpr_create_device(t_vpr_setup& vpr_setup, const t_arch& Arch); \/\/Create the device (grid + rr graph)$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& Arch)
vpr_create_device_grid	base/vpr_api.cpp	/^void vpr_create_device_grid(const t_vpr_setup& vpr_setup, const t_arch& Arch) {$/;"	f	signature:(const t_vpr_setup& vpr_setup, const t_arch& Arch)
vpr_create_device_grid	base/vpr_api.h	/^void vpr_create_device_grid(const t_vpr_setup& vpr_setup, const t_arch& Arch); \/\/Create the device grid$/;"	p	signature:(const t_vpr_setup& vpr_setup, const t_arch& Arch)
vpr_create_rr_graph	base/vpr_api.cpp	/^void vpr_create_rr_graph(t_vpr_setup& vpr_setup, const t_arch& arch, int chan_width_fac) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, int chan_width_fac)
vpr_create_rr_graph	base/vpr_api.h	/^void vpr_create_rr_graph(t_vpr_setup& vpr_setup, const t_arch& arch, int chan_width); \/\/Create routing graph at specified channel width$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, int chan_width)
vpr_flow	base/vpr_api.cpp	/^bool vpr_flow(t_vpr_setup& vpr_setup, t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, t_arch& arch)
vpr_flow	base/vpr_api.h	/^bool vpr_flow(t_vpr_setup& vpr_setup, t_arch& arch); \/\/Run the VPR CAD flow$/;"	p	signature:(t_vpr_setup& vpr_setup, t_arch& arch)
vpr_free_all	base/vpr_api.cpp	/^void vpr_free_all(t_arch& Arch,$/;"	f	signature:(t_arch& Arch, t_vpr_setup& vpr_setup)
vpr_free_all	base/vpr_api.h	/^void vpr_free_all(t_arch& Arch, t_vpr_setup& vpr_setup);$/;"	p	signature:(t_arch& Arch, t_vpr_setup& vpr_setup)
vpr_free_vpr_data_structures	base/vpr_api.cpp	/^void vpr_free_vpr_data_structures(t_arch& Arch,$/;"	f	signature:(t_arch& Arch, t_vpr_setup& vpr_setup)
vpr_free_vpr_data_structures	base/vpr_api.h	/^void vpr_free_vpr_data_structures(t_arch& Arch, t_vpr_setup& vpr_setup);$/;"	p	signature:(t_arch& Arch, t_vpr_setup& vpr_setup)
vpr_get_output_file_name	base/vpr_api.h	/^char *vpr_get_output_file_name(enum e_output_files ename);$/;"	p	signature:(enum e_output_files ename)
vpr_init	base/vpr_api.cpp	/^void vpr_init(const int argc, const char **argv,$/;"	f	signature:(const int argc, const char **argv, t_options *options, t_vpr_setup *vpr_setup, t_arch *arch)
vpr_init	base/vpr_api.h	/^void vpr_init(const int argc, const char **argv,$/;"	p	signature:(const int argc, const char **argv, t_options *options, t_vpr_setup *vpr_setup, t_arch *arch)
vpr_init_graphics	base/vpr_api.cpp	/^void vpr_init_graphics(const t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(const t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_init_graphics	base/vpr_api.h	/^void vpr_init_graphics(const t_vpr_setup& vpr_setup, const t_arch& arch);$/;"	p	signature:(const t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_install_signal_handler	base/vpr_signal_handler.cpp	/^    void vpr_install_signal_handler() {$/;"	f	signature:()
vpr_install_signal_handler	base/vpr_signal_handler.h	/^void vpr_install_signal_handler();$/;"	p	signature:()
vpr_load_packing	base/vpr_api.cpp	/^void vpr_load_packing(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_load_packing	base/vpr_api.h	/^void vpr_load_packing(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Loads a previous packing$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_load_placement	base/vpr_api.cpp	/^void vpr_load_placement(t_vpr_setup& vpr_setup, const t_arch& \/*arch*\/) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& )
vpr_load_placement	base/vpr_api.h	/^void vpr_load_placement(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Loads a previous placement$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_load_routing	base/vpr_api.cpp	/^RouteStatus vpr_load_routing(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *>& net_delay) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *>& net_delay)
vpr_load_routing	base/vpr_api.h	/^RouteStatus vpr_load_routing(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *>& net_delay); \/\/Loads a previous routing$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, vtr::vector<ClusterNetId, float *>& net_delay)
vpr_pack	base/vpr_api.cpp	/^bool vpr_pack(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_pack	base/vpr_api.h	/^bool vpr_pack(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Perform packing$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_pack_flow	base/vpr_api.cpp	/^bool vpr_pack_flow(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_pack_flow	base/vpr_api.h	/^bool vpr_pack_flow(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Perform, load or skip the packing stage$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_place	base/vpr_api.cpp	/^void vpr_place(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_place	base/vpr_api.h	/^void vpr_place(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Perform placement$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_place_flow	base/vpr_api.cpp	/^bool vpr_place_flow(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_place_flow	base/vpr_api.h	/^bool vpr_place_flow(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Perform, load or skip the placement stage$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_power_estimation	base/vpr_api.cpp	/^void vpr_power_estimation(const t_vpr_setup& vpr_setup, const t_arch& Arch, const SetupTimingInfo& timing_info, const RouteStatus& route_status) {$/;"	f	signature:(const t_vpr_setup& vpr_setup, const t_arch& Arch, const SetupTimingInfo& timing_info, const RouteStatus& route_status)
vpr_power_estimation	base/vpr_api.h	/^void vpr_power_estimation(const t_vpr_setup& vpr_setup, const t_arch& Arch, const SetupTimingInfo& timing_info, const RouteStatus& route_status);$/;"	p	signature:(const t_vpr_setup& vpr_setup, const t_arch& Arch, const SetupTimingInfo& timing_info, const RouteStatus& route_status)
vpr_print_args	base/vpr_api.cpp	/^void vpr_print_args(int argc, const char** argv) {$/;"	f	signature:(int argc, const char** argv)
vpr_print_args	base/vpr_api.h	/^void vpr_print_args(int argc, const char** argv);$/;"	p	signature:(int argc, const char** argv)
vpr_print_error	base/vpr_api.cpp	/^void vpr_print_error(const VprError& vpr_error){$/;"	f	signature:(const VprError& vpr_error)
vpr_print_error	base/vpr_api.h	/^void vpr_print_error(const VprError& vpr_error);$/;"	p	signature:(const VprError& vpr_error)
vpr_print_title	base/vpr_api.cpp	/^void vpr_print_title() {$/;"	f	signature:()
vpr_print_title	base/vpr_api.h	/^void vpr_print_title();$/;"	p	signature:()
vpr_read_options	base/vpr_api.cpp	/^void vpr_read_options(const int argc, const char **argv, t_options * options) {$/;"	f	signature:(const int argc, const char **argv, t_options * options)
vpr_read_options	base/vpr_api.h	/^void vpr_read_options(const int argc, const char **argv, t_options * options);$/;"	p	signature:(const int argc, const char **argv, t_options * options)
vpr_route_fixed_W	base/vpr_api.cpp	/^RouteStatus vpr_route_fixed_W(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay)
vpr_route_fixed_W	base/vpr_api.h	/^RouteStatus vpr_route_fixed_W(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay); \/\/Perform routing at a fixed channel width)$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, int fixed_channel_width, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay)
vpr_route_flow	base/vpr_api.cpp	/^RouteStatus vpr_route_flow(t_vpr_setup& vpr_setup, const t_arch& arch) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_route_flow	base/vpr_api.h	/^RouteStatus vpr_route_flow(t_vpr_setup& vpr_setup, const t_arch& arch); \/\/Perform, load or skip the routing stage$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch)
vpr_route_min_W	base/vpr_api.cpp	/^RouteStatus vpr_route_min_W(t_vpr_setup& vpr_setup, const t_arch& arch, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay) {$/;"	f	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay)
vpr_route_min_W	base/vpr_api.h	/^RouteStatus vpr_route_min_W(t_vpr_setup& vpr_setup, const t_arch& arch, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay); \/\/Perform routing to find the minimum channel width$/;"	p	signature:(t_vpr_setup& vpr_setup, const t_arch& arch, std::shared_ptr<SetupHoldTimingInfo> timing_info, std::shared_ptr<RoutingDelayCalculator> delay_calc, vtr::vector<ClusterNetId, float *>& net_delay)
vpr_sdc_error	timing/read_sdc.cpp	/^void vpr_sdc_error(const int line_number, const std::string& \/*near_text*\/, const std::string& msg) {$/;"	f	signature:(const int line_number, const std::string& , const std::string& msg)
vpr_sdc_error	timing/read_sdc.cpp	/^void vpr_sdc_error(const int line_number, const std::string& near_text, const std::string& msg);$/;"	p	file:	signature:(const int line_number, const std::string& near_text, const std::string& msg)
vpr_set_output_file_name	base/vpr_api.h	/^void vpr_set_output_file_name(enum e_output_files ename, const char *name,$/;"	p	signature:(enum e_output_files ename, const char *name, const char* default_name)
vpr_setup_vpr	base/vpr_api.cpp	/^void vpr_setup_vpr(t_options *Options, const bool TimingEnabled,$/;"	f	signature:(t_options *Options, const bool TimingEnabled, const bool readArchFile, t_file_name_opts *FileNameOpts, t_arch * Arch, t_model ** user_models, t_model ** library_models, t_netlist_opts* NetlistOpts, t_packer_opts *PackerOpts, t_placer_opts *PlacerOpts, t_annealing_sched *AnnealSched, t_router_opts *RouterOpts, t_analysis_opts* AnalysisOpts, t_det_routing_arch *RoutingArch, vector <t_lb_type_rr_node> **PackerRRGraph, t_segment_inf ** Segments, t_timing_inf * Timing, bool * ShowGraphics, int *GraphPause, t_power_opts * PowerOpts)
vpr_setup_vpr	base/vpr_api.h	/^void vpr_setup_vpr(t_options *Options, const bool TimingEnabled,$/;"	p	signature:(t_options *Options, const bool TimingEnabled, const bool readArchFile, t_file_name_opts *FileNameOpts, t_arch * Arch, t_model ** user_models, t_model ** library_models, t_netlist_opts* NetlistOpts, t_packer_opts *PackerOpts, t_placer_opts *PlacerOpts, t_annealing_sched *AnnealSched, t_router_opts *RouterOpts, t_analysis_opts* AnalysisOpts, t_det_routing_arch *RoutingArch, vector <t_lb_type_rr_node> **PackerRRGraph, t_segment_inf ** Segments, t_timing_inf * Timing, bool * ShowGraphics, int *GraphPause, t_power_opts * PowerOpts)
vpr_show_setup	base/vpr_api.cpp	/^void vpr_show_setup(const t_vpr_setup& vpr_setup) {$/;"	f	signature:(const t_vpr_setup& vpr_setup)
vpr_show_setup	base/vpr_api.h	/^void vpr_show_setup(const t_vpr_setup& vpr_setup);$/;"	p	signature:(const t_vpr_setup& vpr_setup)
vpr_signal_handler	base/vpr_signal_handler.cpp	/^    void vpr_signal_handler(int \/*signal*\/) {$/;"	f	signature:(int )
vpr_signal_handler	base/vpr_signal_handler.cpp	/^    void vpr_signal_handler(int signal) {$/;"	f	signature:(int signal)
vpr_signal_handler	base/vpr_signal_handler.cpp	/^void vpr_signal_handler(int signal);$/;"	p	file:	signature:(int signal)
vpr_throw	util/vpr_error.cpp	/^void vpr_throw(enum e_vpr_error type,$/;"	f	signature:(enum e_vpr_error type, const char* psz_file_name, unsigned int line_num, const char* psz_message, ...)
vpr_throw	util/vpr_error.h	/^[[noreturn]] void vpr_throw(enum e_vpr_error type, const char* psz_file_name, unsigned int line_num, const char* psz_message, ...);$/;"	p	signature:(enum e_vpr_error type, const char* psz_file_name, unsigned int line_num, const char* psz_message, ...)
vpr_to_phy_track	route/rr_graph2.cpp	/^static int vpr_to_phy_track($/;"	f	file:	signature:( const int itrack, const int chan_num, const int seg_num, const t_chan_seg_details * seg_details, const enum e_directionality directionality)
vpr_to_phy_track	route/rr_graph2.cpp	/^static int vpr_to_phy_track($/;"	p	file:	signature:( const int itrack, const int chan_num, const int seg_num, const t_chan_seg_details * seg_details, const enum e_directionality directionality)
vstring_fmt	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string vstring_fmt(const char* fmt, va_list args) {$/;"	f	namespace:vtr	signature:(const char* fmt, va_list args)
vstring_fmt	../../libs/libvtrutil/src/vtr_util.h	/^    std::string vstring_fmt(const char* fmt, va_list args);$/;"	p	namespace:vtr	signature:(const char* fmt, va_list args)
vtr	../../libs/libvtrutil/src/vtr_assert.cpp	/^namespace vtr { namespace assert {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_assert.h	/^namespace vtr { namespace assert {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_bimap.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_color_map.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_color_map.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_digest.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_digest.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_error.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_flat_map.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_geometry.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_geometry.tpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_hash.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_linear_map.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_list.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_list.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_log.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_log.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_logic.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_map_util.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_math.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_math.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_matrix.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_matrix.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_memory.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_memory.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_pair_util.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_path.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_path.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_random.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_random.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_range.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_rusage.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_rusage.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_sentinels.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_strong_id.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_time.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_time.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_util.cpp	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_util.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_vector.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_vector_map.h	/^namespace vtr {$/;"	n
vtr	../../libs/libvtrutil/src/vtr_version.cpp.in	/^namespace vtr {$/;"	n	file:
vtr	../../libs/libvtrutil/src/vtr_version.h	/^namespace vtr {$/;"	n
vtr::BUILD_TIMESTAMP	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* BUILD_TIMESTAMP = "@VTR_BUILD_TIMESTAMP@";$/;"	m	namespace:vtr	file:
vtr::COMPILER	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* COMPILER = "@VTR_COMPILER_INFO@";$/;"	m	namespace:vtr	file:
vtr::Color	../../libs/libvtrutil/src/vtr_color_map.h	/^struct Color {$/;"	s	namespace:vtr
vtr::Color::b	../../libs/libvtrutil/src/vtr_color_map.h	/^    T b;$/;"	m	struct:vtr::Color	access:public
vtr::Color::g	../../libs/libvtrutil/src/vtr_color_map.h	/^    T g;$/;"	m	struct:vtr::Color	access:public
vtr::Color::r	../../libs/libvtrutil/src/vtr_color_map.h	/^    T r;$/;"	m	struct:vtr::Color	access:public
vtr::ColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class ColorMap {$/;"	c	namespace:vtr
vtr::ColorMap::ColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^ColorMap::ColorMap(float min_val, float max_val, const std::vector<Color<float>>& color_data)$/;"	f	class:vtr::ColorMap	signature:(float min_val, float max_val, const std::vector<Color<float>>& color_data)
vtr::ColorMap::ColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        ColorMap(float min, float max, const std::vector<Color<float>>& color_data);$/;"	p	class:vtr::ColorMap	access:public	signature:(float min, float max, const std::vector<Color<float>>& color_data)
vtr::ColorMap::color	../../libs/libvtrutil/src/vtr_color_map.cpp	/^Color<float> ColorMap::color(float value) const {$/;"	f	class:vtr::ColorMap	signature:(float value) const
vtr::ColorMap::color	../../libs/libvtrutil/src/vtr_color_map.h	/^        Color<float> color(float value) const;$/;"	p	class:vtr::ColorMap	access:public	signature:(float value) const
vtr::ColorMap::color_data_	../../libs/libvtrutil/src/vtr_color_map.h	/^        std::vector<Color<float>> color_data_;$/;"	m	class:vtr::ColorMap	access:private
vtr::ColorMap::max	../../libs/libvtrutil/src/vtr_color_map.cpp	/^float ColorMap::max() const {$/;"	f	class:vtr::ColorMap	signature:() const
vtr::ColorMap::max	../../libs/libvtrutil/src/vtr_color_map.h	/^        float max() const;$/;"	p	class:vtr::ColorMap	access:public	signature:() const
vtr::ColorMap::max_	../../libs/libvtrutil/src/vtr_color_map.h	/^        float max_;$/;"	m	class:vtr::ColorMap	access:private
vtr::ColorMap::min	../../libs/libvtrutil/src/vtr_color_map.cpp	/^float ColorMap::min() const {$/;"	f	class:vtr::ColorMap	signature:() const
vtr::ColorMap::min	../../libs/libvtrutil/src/vtr_color_map.h	/^        float min() const;$/;"	p	class:vtr::ColorMap	access:public	signature:() const
vtr::ColorMap::min_	../../libs/libvtrutil/src/vtr_color_map.h	/^        float min_;$/;"	m	class:vtr::ColorMap	access:private
vtr::ColorMap::range	../../libs/libvtrutil/src/vtr_color_map.cpp	/^float ColorMap::range() const {$/;"	f	class:vtr::ColorMap	signature:() const
vtr::ColorMap::range	../../libs/libvtrutil/src/vtr_color_map.h	/^        float range() const;$/;"	p	class:vtr::ColorMap	access:public	signature:() const
vtr::ColorMap::~ColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        virtual ~ColorMap() = default;$/;"	p	class:vtr::ColorMap	access:public	signature:()
vtr::CustomSentinel	../../libs/libvtrutil/src/vtr_sentinels.h	/^class CustomSentinel {$/;"	c	namespace:vtr
vtr::CustomSentinel::INVALID	../../libs/libvtrutil/src/vtr_sentinels.h	/^        constexpr static T INVALID() { return T(val); }$/;"	f	class:vtr::CustomSentinel	access:public	signature:()
vtr::DEFAULT_ABS_TOL	../../libs/libvtrutil/src/vtr_math.h	/^    constexpr double DEFAULT_ABS_TOL = 0;$/;"	m	namespace:vtr
vtr::DEFAULT_REL_TOL	../../libs/libvtrutil/src/vtr_math.h	/^    constexpr double DEFAULT_REL_TOL = 1e-9;$/;"	m	namespace:vtr
vtr::DefaultSentinel	../../libs/libvtrutil/src/vtr_sentinels.h	/^class DefaultSentinel {$/;"	c	namespace:vtr
vtr::DefaultSentinel	../../libs/libvtrutil/src/vtr_sentinels.h	/^class DefaultSentinel<T*> {$/;"	c	namespace:vtr
vtr::DefaultSentinel::INVALID	../../libs/libvtrutil/src/vtr_sentinels.h	/^        constexpr static T INVALID() { return T(); }$/;"	f	class:vtr::DefaultSentinel	access:public	signature:()
vtr::DefaultSentinel::INVALID	../../libs/libvtrutil/src/vtr_sentinels.h	/^        constexpr static T* INVALID() { return nullptr; }$/;"	f	class:vtr::DefaultSentinel	access:public	signature:()
vtr::DimRange	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class DimRange {$/;"	c	namespace:vtr
vtr::DimRange::DimRange	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        DimRange() = default;$/;"	p	class:vtr::DimRange	access:public	signature:()
vtr::DimRange::DimRange	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        DimRange(size_t begin, size_t end)$/;"	f	class:vtr::DimRange	access:public	signature:(size_t begin, size_t end)
vtr::DimRange::begin_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t begin_index() const { return begin_index_; }$/;"	f	class:vtr::DimRange	access:public	signature:() const
vtr::DimRange::begin_index_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t begin_index_ = 0;$/;"	m	class:vtr::DimRange	access:private
vtr::DimRange::end_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t end_index() const { return end_index_; }$/;"	f	class:vtr::DimRange	access:public	signature:() const
vtr::DimRange::end_index_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t end_index_ = 0;$/;"	m	class:vtr::DimRange	access:private
vtr::DimRange::size	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t size() const { return end_index_ - begin_index_; }$/;"	f	class:vtr::DimRange	access:public	signature:() const
vtr::IA	../../libs/libvtrutil/src/vtr_random.cpp	/^constexpr size_t IA = 1103515245u;$/;"	m	namespace:vtr	file:
vtr::IC	../../libs/libvtrutil/src/vtr_random.cpp	/^constexpr size_t IC = 12345u;$/;"	m	namespace:vtr	file:
vtr::IM	../../libs/libvtrutil/src/vtr_random.cpp	/^constexpr size_t IM = 2147483648u;$/;"	m	namespace:vtr	file:
vtr::InfernoColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class InfernoColorMap : public ColorMap {$/;"	c	namespace:vtr	inherits:ColorMap
vtr::InfernoColorMap::InfernoColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^InfernoColorMap::InfernoColorMap(float min_val, float max_val)$/;"	f	class:vtr::InfernoColorMap	signature:(float min_val, float max_val)
vtr::InfernoColorMap::InfernoColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        InfernoColorMap(float min, float max);$/;"	p	class:vtr::InfernoColorMap	access:public	signature:(float min, float max)
vtr::Line	../../libs/libvtrutil/src/vtr_geometry.h	/^class Line {$/;"	c	namespace:vtr
vtr::Line::Line	../../libs/libvtrutil/src/vtr_geometry.h	/^        Line(std::vector<Point<T>> line_points);$/;"	p	class:vtr::Line	access:public	signature:(std::vector<Point<T>> line_points)
vtr::Line::Line	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Line<T>::Line(std::vector<Point<T>> line_points)$/;"	f	class:vtr::Line	signature:(std::vector<Point<T>> line_points)
vtr::Line::bounding_box	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect<T> bounding_box() const;$/;"	p	class:vtr::Line	access:public	signature:() const
vtr::Line::bounding_box	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T> Line<T>::bounding_box() const {$/;"	f	class:vtr::Line	signature:() const
vtr::Line::point_iter	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef typename std::vector<Point<T>>::const_iterator point_iter;$/;"	t	class:vtr::Line	access:public
vtr::Line::point_range	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef vtr::Range<point_iter> point_range;$/;"	t	class:vtr::Line	access:public
vtr::Line::points	../../libs/libvtrutil/src/vtr_geometry.h	/^        point_range points() const;$/;"	p	class:vtr::Line	access:public	signature:() const
vtr::Line::points	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    typename Line<T>::point_range Line<T>::points() const {$/;"	f	class:vtr::Line	signature:() const
vtr::Line::points_	../../libs/libvtrutil/src/vtr_geometry.h	/^        std::vector<Point<T>> points_;$/;"	m	class:vtr::Line	access:private
vtr::LogicValue	../../libs/libvtrutil/src/vtr_logic.h	/^    enum class LogicValue {$/;"	c	namespace:vtr
vtr::LogicValue::DONT_CARE	../../libs/libvtrutil/src/vtr_logic.h	/^        DONT_CARE = 2,$/;"	m	class:vtr::LogicValue	access:private
vtr::LogicValue::FALSE	../../libs/libvtrutil/src/vtr_logic.h	/^        FALSE = 0,$/;"	m	class:vtr::LogicValue	access:private
vtr::LogicValue::TRUE	../../libs/libvtrutil/src/vtr_logic.h	/^        TRUE = 1,$/;"	m	class:vtr::LogicValue	access:private
vtr::LogicValue::UNKOWN	../../libs/libvtrutil/src/vtr_logic.h	/^        UNKOWN = 3$/;"	m	class:vtr::LogicValue	access:private
vtr::NdMatrix	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrix : public NdMatrixBase<T,N> {$/;"	c	namespace:vtr	inherits:NdMatrixBase
vtr::NdMatrix	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrix<T,1> : public NdMatrixBase<T,1> {$/;"	c	namespace:vtr	inherits:NdMatrixBase
vtr::NdMatrix::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index)
vtr::NdMatrix::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index)
vtr::NdMatrix::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const NdMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index) const
vtr::NdMatrix::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdMatrix	access:public	signature:(size_t index) const
vtr::NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrixBase {$/;"	c	namespace:vtr
vtr::NdMatrixBase::NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase() {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:()
vtr::NdMatrixBase::NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase(NdMatrixBase&& other)$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(NdMatrixBase&& other)
vtr::NdMatrixBase::NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase(const NdMatrixBase& other)$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(const NdMatrixBase& other)
vtr::NdMatrixBase::NdMatrixBase	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
vtr::NdMatrixBase::alloc	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void alloc() {$/;"	f	class:vtr::NdMatrixBase	access:private	signature:()
vtr::NdMatrixBase::begin_index	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t begin_index(size_t i) const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(size_t i) const
vtr::NdMatrixBase::calc_size	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t calc_size() const {$/;"	f	class:vtr::NdMatrixBase	access:private	signature:() const
vtr::NdMatrixBase::clear	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void clear() {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:()
vtr::NdMatrixBase::data_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        std::unique_ptr<T[]> data_ = nullptr;$/;"	m	class:vtr::NdMatrixBase	access:protected
vtr::NdMatrixBase::dim_size	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t dim_size(size_t i) const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(size_t i) const
vtr::NdMatrixBase::dim_sizes_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        std::array<size_t,N> dim_sizes_;$/;"	m	class:vtr::NdMatrixBase	access:protected
vtr::NdMatrixBase::empty	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        bool empty() const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:() const
vtr::NdMatrixBase::end_index	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t end_index(size_t i) const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(size_t i) const
vtr::NdMatrixBase::fill	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void fill(T value) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(T value)
vtr::NdMatrixBase::ndims	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t ndims() const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:() const
vtr::NdMatrixBase::operator =	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixBase& operator=(NdMatrixBase rhs) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(NdMatrixBase rhs)
vtr::NdMatrixBase::resize	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        void resize(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
vtr::NdMatrixBase::size	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t size() const {$/;"	f	class:vtr::NdMatrixBase	access:public	signature:() const
vtr::NdMatrixBase::size_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        size_t size_ = 0;$/;"	m	class:vtr::NdMatrixBase	access:protected
vtr::NdMatrixBase::swap	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        friend void swap(NdMatrixBase<T,N>& m1, NdMatrixBase<T,N>& m2) {$/;"	f	class:vtr::NdMatrixBase	access:friend	signature:(NdMatrixBase<T,N>& m1, NdMatrixBase<T,N>& m2)
vtr::NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrixProxy {$/;"	c	namespace:vtr
vtr::NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^class NdMatrixProxy<T,1> {$/;"	c	namespace:vtr
vtr::NdMatrixProxy::NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,1>(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)
vtr::NdMatrixProxy::NdMatrixProxy	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,N>(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(const size_t* dim_sizes, size_t idim, size_t dim_stride, T* start)
vtr::NdMatrixProxy::data	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T* data() {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:()
vtr::NdMatrixProxy::data	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const T* data() const {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:() const
vtr::NdMatrixProxy::dim_sizes_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const size_t* dim_sizes_;$/;"	m	class:vtr::NdMatrixProxy	access:private
vtr::NdMatrixProxy::dim_stride_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const size_t dim_stride_;$/;"	m	class:vtr::NdMatrixProxy	access:private
vtr::NdMatrixProxy::idim_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const size_t idim_;$/;"	m	class:vtr::NdMatrixProxy	access:private
vtr::NdMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        NdMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index)
vtr::NdMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index)
vtr::NdMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const NdMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index) const
vtr::NdMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdMatrixProxy	access:public	signature:(size_t index) const
vtr::NdMatrixProxy::start_	../../libs/libvtrutil/src/vtr_ndmatrix.h	/^        T* start_;$/;"	m	class:vtr::NdMatrixProxy	access:private
vtr::NdOffsetMatrix	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrix : public NdOffsetMatrixBase<T,N> {$/;"	c	namespace:vtr	inherits:NdOffsetMatrixBase
vtr::NdOffsetMatrix	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrix<T,1> : public NdOffsetMatrixBase<T,1> {$/;"	c	namespace:vtr	inherits:NdOffsetMatrixBase
vtr::NdOffsetMatrix::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index)
vtr::NdOffsetMatrix::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index)
vtr::NdOffsetMatrix::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const NdOffsetMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index) const
vtr::NdOffsetMatrix::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrix	access:public	signature:(size_t index) const
vtr::NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrixBase {$/;"	c	namespace:vtr
vtr::NdOffsetMatrixBase::NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase() {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:()
vtr::NdOffsetMatrixBase::NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(NdOffsetMatrixBase&& other)$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(NdOffsetMatrixBase&& other)
vtr::NdOffsetMatrixBase::NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(const NdOffsetMatrixBase& other)$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(const NdOffsetMatrixBase& other)
vtr::NdOffsetMatrixBase::NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(std::array<DimRange,N> dim_ranges, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<DimRange,N> dim_ranges, T value=T())
vtr::NdOffsetMatrixBase::NdOffsetMatrixBase	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
vtr::NdOffsetMatrixBase::alloc	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void alloc() {$/;"	f	class:vtr::NdOffsetMatrixBase	access:private	signature:()
vtr::NdOffsetMatrixBase::begin_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t begin_index(size_t i) const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(size_t i) const
vtr::NdOffsetMatrixBase::clear	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void clear() {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:()
vtr::NdOffsetMatrixBase::data_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        std::unique_ptr<T[]> data_ = nullptr;$/;"	m	class:vtr::NdOffsetMatrixBase	access:protected
vtr::NdOffsetMatrixBase::dim_ranges_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        std::array<DimRange,N> dim_ranges_;$/;"	m	class:vtr::NdOffsetMatrixBase	access:protected
vtr::NdOffsetMatrixBase::dim_size	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t dim_size(size_t i) const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(size_t i) const
vtr::NdOffsetMatrixBase::empty	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        bool empty() const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:() const
vtr::NdOffsetMatrixBase::end_index	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t end_index(size_t i) const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(size_t i) const
vtr::NdOffsetMatrixBase::fill	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void fill(T value) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(T value)
vtr::NdOffsetMatrixBase::ndims	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t ndims() const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:() const
vtr::NdOffsetMatrixBase::operator =	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixBase& operator=(NdOffsetMatrixBase rhs) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(NdOffsetMatrixBase rhs)
vtr::NdOffsetMatrixBase::resize	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void resize(std::array<DimRange,N> dim_ranges, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<DimRange,N> dim_ranges, T value=T())
vtr::NdOffsetMatrixBase::resize	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        void resize(std::array<size_t,N> dim_sizes, T value=T()) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:(std::array<size_t,N> dim_sizes, T value=T())
vtr::NdOffsetMatrixBase::size	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        size_t size() const {$/;"	f	class:vtr::NdOffsetMatrixBase	access:public	signature:() const
vtr::NdOffsetMatrixBase::swap	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        friend void swap(NdOffsetMatrixBase<T,N>& m1, NdOffsetMatrixBase<T,N>& m2) {$/;"	f	class:vtr::NdOffsetMatrixBase	access:friend	signature:(NdOffsetMatrixBase<T,N>& m1, NdOffsetMatrixBase<T,N>& m2)
vtr::NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrixProxy {$/;"	c	namespace:vtr
vtr::NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^class NdOffsetMatrixProxy<T,1> {$/;"	c	namespace:vtr
vtr::NdOffsetMatrixProxy::NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,1>(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)
vtr::NdOffsetMatrixProxy::NdOffsetMatrixProxy	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,N>(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(const DimRange* dim_ranges, size_t idim, size_t dim_stride, T* start)
vtr::NdOffsetMatrixProxy::dim_ranges_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const DimRange* dim_ranges_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
vtr::NdOffsetMatrixProxy::dim_stride_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const size_t dim_stride_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
vtr::NdOffsetMatrixProxy::idim_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const size_t idim_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
vtr::NdOffsetMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        NdOffsetMatrixProxy<T,N-1> operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index)
vtr::NdOffsetMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        T& operator[](size_t index) {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index)
vtr::NdOffsetMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const NdOffsetMatrixProxy<T,N-1> operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index) const
vtr::NdOffsetMatrixProxy::operator []	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        const T& operator[](size_t index) const {$/;"	f	class:vtr::NdOffsetMatrixProxy	access:public	signature:(size_t index) const
vtr::NdOffsetMatrixProxy::start_	../../libs/libvtrutil/src/vtr_ndoffsetmatrix.h	/^        T* start_;$/;"	m	class:vtr::NdOffsetMatrixProxy	access:private
vtr::OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^class OsFormatGuard {$/;"	c	namespace:vtr
vtr::OsFormatGuard::OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard(const OsFormatGuard&&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&&)
vtr::OsFormatGuard::OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard(const OsFormatGuard&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&)
vtr::OsFormatGuard::OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        explicit OsFormatGuard(std::ostream& os)$/;"	f	class:vtr::OsFormatGuard	access:public	signature:(std::ostream& os)
vtr::OsFormatGuard::fill_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        char fill_;$/;"	m	class:vtr::OsFormatGuard	access:private
vtr::OsFormatGuard::flags_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::ios::fmtflags flags_;$/;"	m	class:vtr::OsFormatGuard	access:private
vtr::OsFormatGuard::operator =	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard& operator=(const OsFormatGuard&&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&&)
vtr::OsFormatGuard::operator =	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        OsFormatGuard& operator=(const OsFormatGuard&) = delete;$/;"	p	class:vtr::OsFormatGuard	access:public	signature:(const OsFormatGuard&)
vtr::OsFormatGuard::os_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::ostream& os_;$/;"	m	class:vtr::OsFormatGuard	access:private
vtr::OsFormatGuard::precision_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::streamsize precision_;$/;"	m	class:vtr::OsFormatGuard	access:private
vtr::OsFormatGuard::width_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::streamsize width_;$/;"	m	class:vtr::OsFormatGuard	access:private
vtr::OsFormatGuard::~OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        ~OsFormatGuard() {$/;"	f	class:vtr::OsFormatGuard	access:public	signature:()
vtr::PATH_DELIM	../../libs/libvtrutil/src/vtr_path.cpp	/^const std::string PATH_DELIM = "\/";$/;"	m	namespace:vtr	file:
vtr::PlasmaColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class PlasmaColorMap : public ColorMap {$/;"	c	namespace:vtr	inherits:ColorMap
vtr::PlasmaColorMap::PlasmaColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^PlasmaColorMap::PlasmaColorMap(float min_val, float max_val)$/;"	f	class:vtr::PlasmaColorMap	signature:(float min_val, float max_val)
vtr::PlasmaColorMap::PlasmaColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        PlasmaColorMap(float min, float max);$/;"	p	class:vtr::PlasmaColorMap	access:public	signature:(float min, float max)
vtr::Point	../../libs/libvtrutil/src/vtr_geometry.h	/^class Point {$/;"	c	namespace:vtr
vtr::Point::Point	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point(T x_val, T y_val);$/;"	p	class:vtr::Point	access:public	signature:(T x_val, T y_val)
vtr::Point::Point	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Point<T>::Point(T x_val, T y_val) $/;"	f	class:vtr::Point	signature:(T x_val, T y_val)
vtr::Point::operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator!= <>(Point<T> lhs, Point<T> rhs);$/;"	p	class:vtr::Point	access:friend	signature:(Point<T> lhs, Point<T> rhs)
vtr::Point::operator <	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator< <>(Point<T> lhs, Point<T> rhs);$/;"	p	class:vtr::Point	access:friend	signature:(Point<T> lhs, Point<T> rhs)
vtr::Point::operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator== <>(Point<T> lhs, Point<T> rhs);$/;"	p	class:vtr::Point	access:friend	signature:(Point<T> lhs, Point<T> rhs)
vtr::Point::x	../../libs/libvtrutil/src/vtr_geometry.h	/^        T x() const;$/;"	p	class:vtr::Point	access:public	signature:() const
vtr::Point::x	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Point<T>::x() const {$/;"	f	class:vtr::Point	signature:() const
vtr::Point::x_	../../libs/libvtrutil/src/vtr_geometry.h	/^        T x_;$/;"	m	class:vtr::Point	access:private
vtr::Point::y	../../libs/libvtrutil/src/vtr_geometry.h	/^        T y() const;$/;"	p	class:vtr::Point	access:public	signature:() const
vtr::Point::y	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Point<T>::y() const {$/;"	f	class:vtr::Point	signature:() const
vtr::Point::y_	../../libs/libvtrutil/src/vtr_geometry.h	/^        T y_;$/;"	m	class:vtr::Point	access:private
vtr::PrintHandlerDirect	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerDirect)(const char* pszMessage,	... );$/;"	t	namespace:vtr
vtr::PrintHandlerError	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerError)(const char* pszFileName, unsigned int lineNum, const char* pszMessage,	... );$/;"	t	namespace:vtr
vtr::PrintHandlerInfo	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerInfo)(const char* pszMessage, ... );$/;"	t	namespace:vtr
vtr::PrintHandlerWarning	../../libs/libvtrutil/src/vtr_log.h	/^typedef void (*PrintHandlerWarning)(const char* pszFileName, unsigned int lineNum, const char* pszMessage,	... );$/;"	t	namespace:vtr
vtr::RandState	../../libs/libvtrutil/src/vtr_random.h	/^    typedef unsigned RandState;$/;"	t	namespace:vtr
vtr::Range	../../libs/libvtrutil/src/vtr_range.h	/^class Range {$/;"	c	namespace:vtr
vtr::Range::Range	../../libs/libvtrutil/src/vtr_range.h	/^        Range(T b, T e): begin_(b), end_(e) {}$/;"	f	class:vtr::Range	access:public	signature:(T b, T e)
vtr::Range::begin	../../libs/libvtrutil/src/vtr_range.h	/^        T begin() { return begin_; }$/;"	f	class:vtr::Range	access:public	signature:()
vtr::Range::begin_	../../libs/libvtrutil/src/vtr_range.h	/^        T begin_;$/;"	m	class:vtr::Range	access:private
vtr::Range::empty	../../libs/libvtrutil/src/vtr_range.h	/^        bool empty() { return begin_ == end_; }$/;"	f	class:vtr::Range	access:public	signature:()
vtr::Range::end	../../libs/libvtrutil/src/vtr_range.h	/^        T end() { return end_; }$/;"	f	class:vtr::Range	access:public	signature:()
vtr::Range::end_	../../libs/libvtrutil/src/vtr_range.h	/^        T end_;$/;"	m	class:vtr::Range	access:private
vtr::Range::size	../../libs/libvtrutil/src/vtr_range.h	/^        size_t size() { return std::distance(begin_, end_); }$/;"	f	class:vtr::Range	access:public	signature:()
vtr::ReadLineTokens	../../libs/libvtrutil/src/vtr_util.cpp	/^std::vector<std::string> ReadLineTokens(FILE * InFile, int *LineNum) {$/;"	f	namespace:vtr	signature:(FILE * InFile, int *LineNum)
vtr::ReadLineTokens	../../libs/libvtrutil/src/vtr_util.h	/^    std::vector<std::string> ReadLineTokens(FILE * InFile, int *LineNum);$/;"	p	namespace:vtr	signature:(FILE * InFile, int *LineNum)
vtr::Rect	../../libs/libvtrutil/src/vtr_geometry.h	/^class Rect {$/;"	c	namespace:vtr
vtr::Rect::Rect	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect(Point<T> bottom_left_val, Point<T> top_right_val);$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> bottom_left_val, Point<T> top_right_val)
vtr::Rect::Rect	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect(T left_val, T bottom_val, T right_val, T top_val);$/;"	p	class:vtr::Rect	access:public	signature:(T left_val, T bottom_val, T right_val, T top_val)
vtr::Rect::Rect	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T>::Rect(Point<T> bottom_left_val, Point<T> top_right_val)$/;"	f	class:vtr::Rect	signature:(Point<T> bottom_left_val, Point<T> top_right_val)
vtr::Rect::Rect	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T>::Rect(T left_val, T bottom_val, T right_val, T top_val)$/;"	f	class:vtr::Rect	signature:(T left_val, T bottom_val, T right_val, T top_val)
vtr::Rect::bottom_left	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> bottom_left() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::bottom_left	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Point<T> Rect<T>::bottom_left() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::bottom_left_	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> bottom_left_;$/;"	m	class:vtr::Rect	access:private
vtr::Rect::coincident	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool coincident(Point<T> point) const;$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> point) const
vtr::Rect::coincident	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool Rect<T>::coincident(Point<T> point) const {$/;"	f	class:vtr::Rect	signature:(Point<T> point) const
vtr::Rect::contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool contains(Point<T> point) const;$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> point) const
vtr::Rect::contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool Rect<T>::contains(Point<T> point) const {$/;"	f	class:vtr::Rect	signature:(Point<T> point) const
vtr::Rect::height	../../libs/libvtrutil/src/vtr_geometry.h	/^        T height() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::height	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::height() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator!= <>(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	class:vtr::Rect	access:friend	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
vtr::Rect::operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator== <>(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	class:vtr::Rect	access:friend	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
vtr::Rect::strictly_contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool strictly_contains(Point<T> point) const;$/;"	p	class:vtr::Rect	access:public	signature:(Point<T> point) const
vtr::Rect::strictly_contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool Rect<T>::strictly_contains(Point<T> point) const {$/;"	f	class:vtr::Rect	signature:(Point<T> point) const
vtr::Rect::top_right	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> top_right() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::top_right	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Point<T> Rect<T>::top_right() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::top_right_	../../libs/libvtrutil/src/vtr_geometry.h	/^        Point<T> top_right_;$/;"	m	class:vtr::Rect	access:private
vtr::Rect::width	../../libs/libvtrutil/src/vtr_geometry.h	/^        T width() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::width	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::width() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::xmax	../../libs/libvtrutil/src/vtr_geometry.h	/^        T xmax() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::xmax	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::xmax() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::xmin	../../libs/libvtrutil/src/vtr_geometry.h	/^        T xmin() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::xmin	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::xmin() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::ymax	../../libs/libvtrutil/src/vtr_geometry.h	/^        T ymax() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::ymax	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::ymax() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::Rect::ymin	../../libs/libvtrutil/src/vtr_geometry.h	/^        T ymin() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
vtr::Rect::ymin	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::ymin() const {$/;"	f	class:vtr::Rect	signature:() const
vtr::RectUnion	../../libs/libvtrutil/src/vtr_geometry.h	/^class RectUnion {$/;"	c	namespace:vtr
vtr::RectUnion::RectUnion	../../libs/libvtrutil/src/vtr_geometry.h	/^        RectUnion(std::vector<Rect<T>> rects);$/;"	p	class:vtr::RectUnion	access:public	signature:(std::vector<Rect<T>> rects)
vtr::RectUnion::RectUnion	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    RectUnion<T>::RectUnion(std::vector<Rect<T>> rectangles)$/;"	f	class:vtr::RectUnion	signature:(std::vector<Rect<T>> rectangles)
vtr::RectUnion::bounding_box	../../libs/libvtrutil/src/vtr_geometry.h	/^        Rect<T> bounding_box() const;$/;"	p	class:vtr::RectUnion	access:public	signature:() const
vtr::RectUnion::bounding_box	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    Rect<T> RectUnion<T>::bounding_box() const {$/;"	f	class:vtr::RectUnion	signature:() const
vtr::RectUnion::coincident	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool coincident(Point<T> point) const;$/;"	p	class:vtr::RectUnion	access:public	signature:(Point<T> point) const
vtr::RectUnion::coincident	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool RectUnion<T>::coincident(Point<T> point) const {$/;"	f	class:vtr::RectUnion	signature:(Point<T> point) const
vtr::RectUnion::contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool contains(Point<T> point) const;$/;"	p	class:vtr::RectUnion	access:public	signature:(Point<T> point) const
vtr::RectUnion::contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool RectUnion<T>::contains(Point<T> point) const {$/;"	f	class:vtr::RectUnion	signature:(Point<T> point) const
vtr::RectUnion::operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator!= <>(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	class:vtr::RectUnion	access:friend	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
vtr::RectUnion::operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^        friend bool operator== <>(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	class:vtr::RectUnion	access:friend	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
vtr::RectUnion::rect_iter	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef typename std::vector<Rect<T>>::const_iterator rect_iter;$/;"	t	class:vtr::RectUnion	access:public
vtr::RectUnion::rect_range	../../libs/libvtrutil/src/vtr_geometry.h	/^        typedef vtr::Range<rect_iter> rect_range;$/;"	t	class:vtr::RectUnion	access:public
vtr::RectUnion::rects	../../libs/libvtrutil/src/vtr_geometry.h	/^        rect_range rects() const;$/;"	p	class:vtr::RectUnion	access:public	signature:() const
vtr::RectUnion::rects	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    typename RectUnion<T>::rect_range RectUnion<T>::rects() const {$/;"	f	class:vtr::RectUnion	signature:() const
vtr::RectUnion::rects_	../../libs/libvtrutil/src/vtr_geometry.h	/^        std::vector<Rect<T>> rects_;$/;"	m	class:vtr::RectUnion	access:private
vtr::RectUnion::strictly_contains	../../libs/libvtrutil/src/vtr_geometry.h	/^        bool strictly_contains(Point<T> point) const;$/;"	p	class:vtr::RectUnion	access:public	signature:(Point<T> point) const
vtr::RectUnion::strictly_contains	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool RectUnion<T>::strictly_contains(Point<T> point) const {$/;"	f	class:vtr::RectUnion	signature:(Point<T> point) const
vtr::ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.h	/^    class ScopedActionTimer : public Timer {$/;"	c	namespace:vtr	inherits:Timer
vtr::ScopedActionTimer::ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedActionTimer::ScopedActionTimer(std::string action_str)$/;"	f	class:vtr::ScopedActionTimer	signature:(std::string action_str)
vtr::ScopedActionTimer::ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ScopedActionTimer(const std::string action);$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:(const std::string action)
vtr::ScopedActionTimer::action	../../libs/libvtrutil/src/vtr_time.cpp	/^std::string ScopedActionTimer::action() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
vtr::ScopedActionTimer::action	../../libs/libvtrutil/src/vtr_time.h	/^            std::string action() const;$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:() const
vtr::ScopedActionTimer::action_	../../libs/libvtrutil/src/vtr_time.h	/^            const std::string action_;$/;"	m	class:vtr::ScopedActionTimer	access:private
vtr::ScopedActionTimer::depth	../../libs/libvtrutil/src/vtr_time.cpp	/^int ScopedActionTimer::depth() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
vtr::ScopedActionTimer::depth	../../libs/libvtrutil/src/vtr_time.h	/^            int depth() const;$/;"	p	class:vtr::ScopedActionTimer	access:protected	signature:() const
vtr::ScopedActionTimer::depth_	../../libs/libvtrutil/src/vtr_time.h	/^            int depth_;$/;"	m	class:vtr::ScopedActionTimer	access:private
vtr::ScopedActionTimer::pad	../../libs/libvtrutil/src/vtr_time.cpp	/^std::string ScopedActionTimer::pad() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
vtr::ScopedActionTimer::pad	../../libs/libvtrutil/src/vtr_time.h	/^            std::string pad() const;$/;"	p	class:vtr::ScopedActionTimer	access:protected	signature:() const
vtr::ScopedActionTimer::quiet	../../libs/libvtrutil/src/vtr_time.cpp	/^bool ScopedActionTimer::quiet() const {$/;"	f	class:vtr::ScopedActionTimer	signature:() const
vtr::ScopedActionTimer::quiet	../../libs/libvtrutil/src/vtr_time.cpp	/^void ScopedActionTimer::quiet(bool value) {$/;"	f	class:vtr::ScopedActionTimer	signature:(bool value)
vtr::ScopedActionTimer::quiet	../../libs/libvtrutil/src/vtr_time.h	/^            bool quiet() const;$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:() const
vtr::ScopedActionTimer::quiet	../../libs/libvtrutil/src/vtr_time.h	/^            void quiet(bool value);$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:(bool value)
vtr::ScopedActionTimer::quiet_	../../libs/libvtrutil/src/vtr_time.h	/^            bool quiet_ = false;$/;"	m	class:vtr::ScopedActionTimer	access:private
vtr::ScopedActionTimer::~ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedActionTimer::~ScopedActionTimer() {$/;"	f	class:vtr::ScopedActionTimer	signature:()
vtr::ScopedActionTimer::~ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ~ScopedActionTimer();$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:()
vtr::ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^    class ScopedFinishTimer : public ScopedActionTimer {$/;"	c	namespace:vtr	inherits:ScopedActionTimer
vtr::ScopedFinishTimer::ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedFinishTimer::ScopedFinishTimer(std::string action_str)$/;"	f	class:vtr::ScopedFinishTimer	signature:(std::string action_str)
vtr::ScopedFinishTimer::ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ScopedFinishTimer(const std::string action);$/;"	p	class:vtr::ScopedFinishTimer	access:public	signature:(const std::string action)
vtr::ScopedFinishTimer::~ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedFinishTimer::~ScopedFinishTimer() {$/;"	f	class:vtr::ScopedFinishTimer	signature:()
vtr::ScopedFinishTimer::~ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ~ScopedFinishTimer();$/;"	p	class:vtr::ScopedFinishTimer	access:public	signature:()
vtr::ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^    class ScopedStartFinishTimer : public ScopedActionTimer {$/;"	c	namespace:vtr	inherits:ScopedActionTimer
vtr::ScopedStartFinishTimer::ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedStartFinishTimer::ScopedStartFinishTimer(std::string action_str)$/;"	f	class:vtr::ScopedStartFinishTimer	signature:(std::string action_str)
vtr::ScopedStartFinishTimer::ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ScopedStartFinishTimer(const std::string action);$/;"	p	class:vtr::ScopedStartFinishTimer	access:public	signature:(const std::string action)
vtr::ScopedStartFinishTimer::~ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedStartFinishTimer::~ScopedStartFinishTimer() {$/;"	f	class:vtr::ScopedStartFinishTimer	signature:()
vtr::ScopedStartFinishTimer::~ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ~ScopedStartFinishTimer();$/;"	p	class:vtr::ScopedStartFinishTimer	access:public	signature:()
vtr::StrongId	../../libs/libvtrutil/src/vtr_strong_id.h	/^class StrongId {$/;"	c	namespace:vtr
vtr::StrongId::INVALID	../../libs/libvtrutil/src/vtr_strong_id.h	/^        static constexpr StrongId INVALID() { return StrongId(); }$/;"	f	class:vtr::StrongId	access:public	signature:()
vtr::StrongId::StrongId	../../libs/libvtrutil/src/vtr_strong_id.h	/^        constexpr StrongId() : id_(sentinel) {}$/;"	f	class:vtr::StrongId	access:public	signature:()
vtr::StrongId::StrongId	../../libs/libvtrutil/src/vtr_strong_id.h	/^        explicit constexpr StrongId(T id): id_(id) {}$/;"	f	class:vtr::StrongId	access:public	signature:(T id)
vtr::StrongId::id_	../../libs/libvtrutil/src/vtr_strong_id.h	/^        T id_;$/;"	m	class:vtr::StrongId	access:private
vtr::StrongId::operator !=	../../libs/libvtrutil/src/vtr_strong_id.h	/^        friend bool operator!= <>(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	class:vtr::StrongId	access:friend	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::StrongId::operator <	../../libs/libvtrutil/src/vtr_strong_id.h	/^        friend bool operator< <>(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	class:vtr::StrongId	access:friend	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::StrongId::operator ==	../../libs/libvtrutil/src/vtr_strong_id.h	/^        friend bool operator== <>(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	class:vtr::StrongId	access:friend	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::StrongId::operator bool	../../libs/libvtrutil/src/vtr_strong_id.h	/^        explicit operator bool() const { return *this != INVALID(); }$/;"	f	class:vtr::StrongId	access:public	signature:() const
vtr::StrongId::operator std::size_t	../../libs/libvtrutil/src/vtr_strong_id.h	/^        explicit operator std::size_t() const { return static_cast<std::size_t>(id_); }$/;"	f	class:vtr::StrongId	access:public	signature:() const
vtr::StrongId::static_assert	../../libs/libvtrutil/src/vtr_strong_id.h	/^    static_assert(std::is_integral<T>::value, "T must be integral");$/;"	p	class:vtr::StrongId	access:private	signature:(std::is_integral<T>::value, Ó)
vtr::Timer	../../libs/libvtrutil/src/vtr_time.h	/^    class Timer {$/;"	c	namespace:vtr
vtr::Timer::BYTE_TO_MIB	../../libs/libvtrutil/src/vtr_time.h	/^            constexpr static float BYTE_TO_MIB = 1024*1024;$/;"	m	class:vtr::Timer	access:private
vtr::Timer::Timer	../../libs/libvtrutil/src/vtr_time.cpp	/^Timer::Timer()$/;"	f	class:vtr::Timer	signature:()
vtr::Timer::Timer	../../libs/libvtrutil/src/vtr_time.h	/^            Timer();$/;"	p	class:vtr::Timer	access:public	signature:()
vtr::Timer::Timer	../../libs/libvtrutil/src/vtr_time.h	/^            Timer(Timer&&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&&)
vtr::Timer::Timer	../../libs/libvtrutil/src/vtr_time.h	/^            Timer(Timer&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&)
vtr::Timer::delta_max_rss_mib	../../libs/libvtrutil/src/vtr_time.cpp	/^float Timer::delta_max_rss_mib() const {$/;"	f	class:vtr::Timer	signature:() const
vtr::Timer::delta_max_rss_mib	../../libs/libvtrutil/src/vtr_time.h	/^            float delta_max_rss_mib() const;$/;"	p	class:vtr::Timer	access:public	signature:() const
vtr::Timer::elapsed_sec	../../libs/libvtrutil/src/vtr_time.cpp	/^float Timer::elapsed_sec() const {$/;"	f	class:vtr::Timer	signature:() const
vtr::Timer::elapsed_sec	../../libs/libvtrutil/src/vtr_time.h	/^            float elapsed_sec() const;$/;"	p	class:vtr::Timer	access:public	signature:() const
vtr::Timer::initial_max_rss_	../../libs/libvtrutil/src/vtr_time.h	/^            size_t initial_max_rss_; \/\/Maximum resident set size In bytes$/;"	m	class:vtr::Timer	access:private
vtr::Timer::max_rss_mib	../../libs/libvtrutil/src/vtr_time.cpp	/^float Timer::max_rss_mib() const {$/;"	f	class:vtr::Timer	signature:() const
vtr::Timer::max_rss_mib	../../libs/libvtrutil/src/vtr_time.h	/^            float max_rss_mib() const;$/;"	p	class:vtr::Timer	access:public	signature:() const
vtr::Timer::operator =	../../libs/libvtrutil/src/vtr_time.h	/^            Timer& operator=(Timer&&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&&)
vtr::Timer::operator =	../../libs/libvtrutil/src/vtr_time.h	/^            Timer& operator=(Timer&) = delete;$/;"	p	class:vtr::Timer	access:public	signature:(Timer&)
vtr::Timer::~Timer	../../libs/libvtrutil/src/vtr_time.h	/^            virtual ~Timer() = default;$/;"	p	class:vtr::Timer	access:public	signature:()
vtr::VCS_REVISION	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VCS_REVISION = "@VTR_VCS_REVISION@";$/;"	m	namespace:vtr	file:
vtr::VERSION	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VERSION = "@VTR_VERSION@";$/;"	m	namespace:vtr	file:
vtr::VERSION_MAJOR	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const size_t VERSION_MAJOR = @VTR_VERSION_MAJOR@;$/;"	m	namespace:vtr	file:
vtr::VERSION_MINOR	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const size_t VERSION_MINOR = @VTR_VERSION_MINOR@;$/;"	m	namespace:vtr	file:
vtr::VERSION_PATCH	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const size_t VERSION_PATCH = @VTR_VERSION_PATCH@;$/;"	m	namespace:vtr	file:
vtr::VERSION_PRERELEASE	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VERSION_PRERELEASE = "@VTR_VERSION_PRERELEASE@";$/;"	m	namespace:vtr	file:
vtr::VERSION_SHORT	../../libs/libvtrutil/src/vtr_version.cpp.in	/^    const char* VERSION_SHORT = "@VTR_VERSION_SHORT@";$/;"	m	namespace:vtr	file:
vtr::ViridisColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^class ViridisColorMap : public ColorMap {$/;"	c	namespace:vtr	inherits:ColorMap
vtr::ViridisColorMap::ViridisColorMap	../../libs/libvtrutil/src/vtr_color_map.cpp	/^ViridisColorMap::ViridisColorMap(float min_val, float max_val)$/;"	f	class:vtr::ViridisColorMap	signature:(float min_val, float max_val)
vtr::ViridisColorMap::ViridisColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        ViridisColorMap(float min, float max);$/;"	p	class:vtr::ViridisColorMap	access:public	signature:(float min, float max)
vtr::VtrError	../../libs/libvtrutil/src/vtr_error.h	/^class VtrError : public std::runtime_error {$/;"	c	namespace:vtr	inherits:std::runtime_error
vtr::VtrError::VtrError	../../libs/libvtrutil/src/vtr_error.h	/^        VtrError(std::string msg="", std::string new_filename="", size_t new_linenumber=-1)$/;"	f	class:vtr::VtrError	access:public	signature:(std::string msg=Ó, std::string new_filename=Ó, size_t new_linenumber=-1)
vtr::VtrError::filename	../../libs/libvtrutil/src/vtr_error.h	/^        std::string filename() const { return filename_; }$/;"	f	class:vtr::VtrError	access:public	signature:() const
vtr::VtrError::filename_	../../libs/libvtrutil/src/vtr_error.h	/^        std::string filename_;$/;"	m	class:vtr::VtrError	access:private
vtr::VtrError::filename_c_str	../../libs/libvtrutil/src/vtr_error.h	/^        const char* filename_c_str() const { return filename_.c_str(); }$/;"	f	class:vtr::VtrError	access:public	signature:() const
vtr::VtrError::line	../../libs/libvtrutil/src/vtr_error.h	/^        size_t line() const { return linenumber_; }$/;"	f	class:vtr::VtrError	access:public	signature:() const
vtr::VtrError::linenumber_	../../libs/libvtrutil/src/vtr_error.h	/^        size_t linenumber_;$/;"	m	class:vtr::VtrError	access:private
vtr::alloc_ivector_and_copy_int_list	../../libs/libvtrutil/src/vtr_matrix.cpp	/^void alloc_ivector_and_copy_int_list(t_linked_int ** list_head_ptr,$/;"	f	namespace:vtr	signature:(t_linked_int ** list_head_ptr, int num_items, std::vector<int> *ivec, t_linked_int ** free_list_head_ptr)
vtr::alloc_ivector_and_copy_int_list	../../libs/libvtrutil/src/vtr_matrix.h	/^    void alloc_ivector_and_copy_int_list(t_linked_int ** list_head_ptr,$/;"	p	namespace:vtr	signature:(t_linked_int ** list_head_ptr, int num_items, std::vector<int> *ivec, t_linked_int ** free_list_head_ptr)
vtr::arithmean	../../libs/libvtrutil/src/vtr_math.h	/^    double arithmean(Container c) {$/;"	f	namespace:vtr	signature:(Container c)
vtr::arithmean	../../libs/libvtrutil/src/vtr_math.h	/^    double arithmean(InputIterator first, InputIterator last, double init=0.) {$/;"	f	namespace:vtr	signature:(InputIterator first, InputIterator last, double init=0.)
vtr::assert	../../libs/libvtrutil/src/vtr_assert.cpp	/^namespace vtr { namespace assert {$/;"	n	namespace:vtr	file:
vtr::assert	../../libs/libvtrutil/src/vtr_assert.h	/^namespace vtr { namespace assert {$/;"	n	namespace:vtr
vtr::assert::handle_assert	../../libs/libvtrutil/src/vtr_assert.cpp	/^void handle_assert(const char* expr, const char* file, unsigned int line, const char* function, const char* msg) {$/;"	f	namespace:vtr::assert	signature:(const char* expr, const char* file, unsigned int line, const char* function, const char* msg)
vtr::assert::handle_assert	../../libs/libvtrutil/src/vtr_assert.h	/^    [[noreturn]] void handle_assert(const char* expr, const char* file, unsigned int line, const char* function, const char* msg);$/;"	p	namespace:vtr::assert	signature:(const char* expr, const char* file, unsigned int line, const char* function, const char* msg)
vtr::atoT	../../libs/libvtrutil/src/vtr_util.cpp	/^T atoT(const std::string& value, const std::string& type_name) {$/;"	f	namespace:vtr	signature:(const std::string& value, const std::string& type_name)
vtr::atod	../../libs/libvtrutil/src/vtr_util.cpp	/^double atod(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
vtr::atod	../../libs/libvtrutil/src/vtr_util.h	/^    double atod(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
vtr::atof	../../libs/libvtrutil/src/vtr_util.cpp	/^float atof(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
vtr::atof	../../libs/libvtrutil/src/vtr_util.h	/^    float atof(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
vtr::atoi	../../libs/libvtrutil/src/vtr_util.cpp	/^int atoi(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
vtr::atoi	../../libs/libvtrutil/src/vtr_util.h	/^    int atoi(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
vtr::atou	../../libs/libvtrutil/src/vtr_util.cpp	/^unsigned atou(const std::string& value) {$/;"	f	namespace:vtr	signature:(const std::string& value)
vtr::atou	../../libs/libvtrutil/src/vtr_util.h	/^    unsigned atou(const std::string& value);$/;"	p	namespace:vtr	signature:(const std::string& value)
vtr::basename	../../libs/libvtrutil/src/vtr_path.cpp	/^std::string basename(const std::string& path) {$/;"	f	namespace:vtr	signature:(const std::string& path)
vtr::basename	../../libs/libvtrutil/src/vtr_path.h	/^    std::string basename(const std::string& path);$/;"	p	namespace:vtr	signature:(const std::string& path)
vtr::bimap	../../libs/libvtrutil/src/vtr_bimap.h	/^class bimap {$/;"	c	namespace:vtr
vtr::bimap::begin	../../libs/libvtrutil/src/vtr_bimap.h	/^        iterator begin() const { return map_.begin(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
vtr::bimap::clear	../../libs/libvtrutil/src/vtr_bimap.h	/^        void clear() { map_.clear(); inverse_map_.clear(); }$/;"	f	class:vtr::bimap	access:public	signature:()
vtr::bimap::contains	../../libs/libvtrutil/src/vtr_bimap.h	/^        bool contains(const K key) const { return find(key) != end(); }$/;"	f	class:vtr::bimap	access:public	signature:(const K key) const
vtr::bimap::contains	../../libs/libvtrutil/src/vtr_bimap.h	/^        bool contains(const V value) const { return find(value) != inverse_end(); }$/;"	f	class:vtr::bimap	access:public	signature:(const V value) const
vtr::bimap::empty	../../libs/libvtrutil/src/vtr_bimap.h	/^        bool empty() const { return (size() == 0); }$/;"	f	class:vtr::bimap	access:public	signature:() const
vtr::bimap::end	../../libs/libvtrutil/src/vtr_bimap.h	/^        iterator end() const { return map_.end(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
vtr::bimap::erase	../../libs/libvtrutil/src/vtr_bimap.h	/^        void erase(const K key) {$/;"	f	class:vtr::bimap	access:public	signature:(const K key)
vtr::bimap::erase	../../libs/libvtrutil/src/vtr_bimap.h	/^        void erase(const V val) {$/;"	f	class:vtr::bimap	access:public	signature:(const V val)
vtr::bimap::find	../../libs/libvtrutil/src/vtr_bimap.h	/^        inverse_iterator find(const V value) const {$/;"	f	class:vtr::bimap	access:public	signature:(const V value) const
vtr::bimap::find	../../libs/libvtrutil/src/vtr_bimap.h	/^        iterator find(const K key) const {$/;"	f	class:vtr::bimap	access:public	signature:(const K key) const
vtr::bimap::insert	../../libs/libvtrutil/src/vtr_bimap.h	/^        std::pair<iterator,bool> insert(const K key, const V value) {$/;"	f	class:vtr::bimap	access:public	signature:(const K key, const V value)
vtr::bimap::inverse_begin	../../libs/libvtrutil/src/vtr_bimap.h	/^        inverse_iterator inverse_begin() const { return inverse_map_.begin(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
vtr::bimap::inverse_end	../../libs/libvtrutil/src/vtr_bimap.h	/^        inverse_iterator inverse_end() const { return inverse_map_.end(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
vtr::bimap::inverse_iterator	../../libs/libvtrutil/src/vtr_bimap.h	/^        typedef typename InvMap<V,K>::const_iterator inverse_iterator;$/;"	t	class:vtr::bimap	access:public
vtr::bimap::inverse_map_	../../libs/libvtrutil/src/vtr_bimap.h	/^        InvMap<V,K> inverse_map_;$/;"	m	class:vtr::bimap	access:private
vtr::bimap::iterator	../../libs/libvtrutil/src/vtr_bimap.h	/^        typedef typename Map<K,V>::const_iterator iterator;$/;"	t	class:vtr::bimap	access:public
vtr::bimap::map_	../../libs/libvtrutil/src/vtr_bimap.h	/^        Map<K,V> map_;$/;"	m	class:vtr::bimap	access:private
vtr::bimap::operator []	../../libs/libvtrutil/src/vtr_bimap.h	/^        const K& operator[] (const V value) const {$/;"	f	class:vtr::bimap	access:public	signature:(const V value) const
vtr::bimap::operator []	../../libs/libvtrutil/src/vtr_bimap.h	/^        const V& operator[] (const K key) const {$/;"	f	class:vtr::bimap	access:public	signature:(const K key) const
vtr::bimap::size	../../libs/libvtrutil/src/vtr_bimap.h	/^        std::size_t size() const { VTR_ASSERT(map_.size() == inverse_map_.size()); return map_.size(); }$/;"	f	class:vtr::bimap	access:public	signature:() const
vtr::bimap::swap	../../libs/libvtrutil/src/vtr_bimap.h	/^        friend void swap(bimap<K,V,Map,InvMap>& x, bimap<K,V,Map,InvMap>& y) {$/;"	f	class:vtr::bimap	access:friend	signature:(bimap<K,V,Map,InvMap>& x, bimap<K,V,Map,InvMap>& y)
vtr::bimap::update	../../libs/libvtrutil/src/vtr_bimap.h	/^        void update(const K key, const V value) {$/;"	f	class:vtr::bimap	access:public	signature:(const K key, const V value)
vtr::bufsize	../../libs/libvtrutil/src/vtr_util.h	/^    constexpr size_t bufsize = 32768; \/* Maximum line length for various parsing proc. *\/$/;"	m	namespace:vtr
vtr::calloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* calloc(size_t nelem, size_t size) {$/;"	f	namespace:vtr	signature:(size_t nelem, size_t size)
vtr::calloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* calloc(size_t nelem, size_t size);$/;"	p	namespace:vtr	signature:(size_t nelem, size_t size)
vtr::check_file_name_extension	../../libs/libvtrutil/src/vtr_util.cpp	/^bool check_file_name_extension(const char* file_name,$/;"	f	namespace:vtr	signature:(const char* file_name, const char* file_extension)
vtr::check_file_name_extension	../../libs/libvtrutil/src/vtr_util.h	/^    bool check_file_name_extension(const char* file_name,$/;"	p	namespace:vtr	signature:(const char* file_name, const char* file_extension)
vtr::chunk_delete	../../libs/libvtrutil/src/vtr_memory.h	/^    void chunk_delete(T* obj, t_chunk * \/*chunk_info*\/) {$/;"	f	namespace:vtr	signature:(T* obj, t_chunk * )
vtr::chunk_malloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* chunk_malloc(size_t size, t_chunk *chunk_info) {$/;"	f	namespace:vtr	signature:(size_t size, t_chunk *chunk_info)
vtr::chunk_malloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* chunk_malloc(size_t size, t_chunk *chunk_info);$/;"	p	namespace:vtr	signature:(size_t size, t_chunk *chunk_info)
vtr::chunk_new	../../libs/libvtrutil/src/vtr_memory.h	/^    T* chunk_new(t_chunk *chunk_info) {$/;"	f	namespace:vtr	signature:(t_chunk *chunk_info)
vtr::cont	../../libs/libvtrutil/src/vtr_util.cpp	/^static int cont; \/* line continued? (used by strtok)*\/$/;"	m	namespace:vtr	file:
vtr::delete_in_vptr_list	../../libs/libvtrutil/src/vtr_list.cpp	/^t_linked_vptr *delete_in_vptr_list(t_linked_vptr *head) {$/;"	f	namespace:vtr	signature:(t_linked_vptr *head)
vtr::delete_in_vptr_list	../../libs/libvtrutil/src/vtr_list.h	/^    t_linked_vptr *delete_in_vptr_list(t_linked_vptr *head);$/;"	p	namespace:vtr	signature:(t_linked_vptr *head)
vtr::dirname	../../libs/libvtrutil/src/vtr_path.cpp	/^std::string dirname(const std::string& path) {$/;"	f	namespace:vtr	signature:(const std::string& path)
vtr::dirname	../../libs/libvtrutil/src/vtr_path.h	/^    std::string dirname(const std::string& path);$/;"	p	namespace:vtr	signature:(const std::string& path)
vtr::f_timer_depth	../../libs/libvtrutil/src/vtr_time.cpp	/^int f_timer_depth = 0;$/;"	m	namespace:vtr	file:
vtr::fclose	../../libs/libvtrutil/src/vtr_util.cpp	/^int fclose(FILE* f) {$/;"	f	namespace:vtr	signature:(FILE* f)
vtr::fclose	../../libs/libvtrutil/src/vtr_util.h	/^    int fclose(FILE* f);$/;"	p	namespace:vtr	signature:(FILE* f)
vtr::fgets	../../libs/libvtrutil/src/vtr_util.cpp	/^char* fgets(char *buf, int max_size, FILE * fp) {$/;"	f	namespace:vtr	signature:(char *buf, int max_size, FILE * fp)
vtr::fgets	../../libs/libvtrutil/src/vtr_util.h	/^    char* fgets(char *buf, int max_size, FILE * fp);$/;"	p	namespace:vtr	signature:(char *buf, int max_size, FILE * fp)
vtr::file_exists	../../libs/libvtrutil/src/vtr_util.cpp	/^bool file_exists(const char* filename) {$/;"	f	namespace:vtr	signature:(const char* filename)
vtr::file_exists	../../libs/libvtrutil/src/vtr_util.h	/^    bool file_exists(const char * filename);$/;"	p	namespace:vtr	signature:(const char * filename)
vtr::file_line_number	../../libs/libvtrutil/src/vtr_util.cpp	/^static int file_line_number = 0; \/* file in line number being parsed (used by fgets) *\/$/;"	m	namespace:vtr	file:
vtr::flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^class flat_map {$/;"	c	namespace:vtr
vtr::flat_map2	../../libs/libvtrutil/src/vtr_flat_map.h	/^class flat_map2 : public flat_map<K,T,Compare> {$/;"	c	namespace:vtr	inherits:flat_map
vtr::flat_map2::operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        T& operator[](const K& key) {$/;"	f	class:vtr::flat_map2	access:public	signature:(const K& key)
vtr::flat_map2::operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const T& operator[](const K& key) const {$/;"	f	class:vtr::flat_map2	access:public	signature:(const K& key) const
vtr::flat_map::at	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const mapped_type& at(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::at	../../libs/libvtrutil/src/vtr_flat_map.h	/^        mapped_type& at(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::begin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          begin()     const   { return vec_.begin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::begin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator                begin()             { return vec_.begin(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::cbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          cbegin()    const   { return vec_.begin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::cend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          cend()      const   { return vec_.end(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::clear	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void clear() { vec_.clear(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::const_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::const_iterator const_iterator;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::const_reference	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef const value_type& const_reference;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::const_reverse_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::const_reverse_iterator const_reverse_iterator;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::convert_to_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator convert_to_iterator(const_iterator const_iter) {$/;"	f	class:vtr::flat_map	access:private	signature:(const_iterator const_iter)
vtr::flat_map::count	../../libs/libvtrutil/src/vtr_flat_map.h	/^        size_type count(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::crbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  crbegin()   const   { return vec_.rbegin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::crend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  crend()     const   { return vec_.rend(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::difference_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::difference_type difference_type;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::emplace	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator emplace(const key_type& key, Args&&... args) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key, Args&&... args)
vtr::flat_map::emplace_hint	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator emplace_hint(const_iterator position, Args&&... args) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator position, Args&&... args)
vtr::flat_map::empty	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool empty() const { return vec_.empty(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::end	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator          end()       const   { return vec_.end(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::end	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator                end()               { return vec_.end(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::equal_range	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::pair<const_iterator,const_iterator> equal_range(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::equal_range	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::erase	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void erase(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::erase	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void erase(const_iterator first, const_iterator last) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator first, const_iterator last)
vtr::flat_map::erase	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void erase(const_iterator position) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator position)
vtr::flat_map::find	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator find(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::find	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator find(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map() = default;$/;"	p	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(InputIterator first, InputIterator last) {$/;"	f	class:vtr::flat_map	access:public	signature:(InputIterator first, InputIterator last)
vtr::flat_map::flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(const flat_map&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(const flat_map&)
vtr::flat_map::flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(flat_map&&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(flat_map&&)
vtr::flat_map::flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map(std::vector<value_type> values) {$/;"	f	class:vtr::flat_map	access:public	signature:(std::vector<value_type> values)
vtr::flat_map::insert	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator insert(const_iterator position, const value_type& value) {$/;"	f	class:vtr::flat_map	access:public	signature:(const_iterator position, const value_type& value)
vtr::flat_map::insert	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:vtr::flat_map	access:public	signature:(const value_type& value)
vtr::flat_map::insert	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void insert(InputIterator first, InputIterator last) {$/;"	f	class:vtr::flat_map	access:public	signature:(InputIterator first, InputIterator last)
vtr::flat_map::iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::iterator iterator;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::key_comp	../../libs/libvtrutil/src/vtr_flat_map.h	/^        key_compare key_comp() const { return key_compare(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::key_compare	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef Compare key_compare;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::key_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef K key_type;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::keys_equivalent	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool keys_equivalent(const key_type& lhs, const key_type& rhs) const {$/;"	f	class:vtr::flat_map	access:private	signature:(const key_type& lhs, const key_type& rhs) const
vtr::flat_map::lower_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator lower_bound(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::lower_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator lower_bound(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::mapped_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef T mapped_type;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::max_size	../../libs/libvtrutil/src/vtr_flat_map.h	/^        size_type max_size() const { return vec_.max_size(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::operator =	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map& operator=(const flat_map&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(const flat_map&)
vtr::flat_map::operator =	../../libs/libvtrutil/src/vtr_flat_map.h	/^        flat_map& operator=(flat_map&&) = default;$/;"	p	class:vtr::flat_map	access:public	signature:(flat_map&&)
vtr::flat_map::operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const mapped_type& operator[](const key_type& key) const  {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::operator []	../../libs/libvtrutil/src/vtr_flat_map.h	/^        mapped_type& operator[](const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::rbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  rbegin()    const   { return vec_.rbegin(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::rbegin	../../libs/libvtrutil/src/vtr_flat_map.h	/^        reverse_iterator        rbegin()            { return vec_.rbegin(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::reference	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef value_type& reference;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::rend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_reverse_iterator  rend()      const   { return vec_.rend(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::rend	../../libs/libvtrutil/src/vtr_flat_map.h	/^        reverse_iterator        rend()              { return vec_.rend(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::reserve	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void reserve(size_type n) { vec_.reserve(n); }$/;"	f	class:vtr::flat_map	access:public	signature:(size_type n)
vtr::flat_map::reverse_iterator	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::reverse_iterator reverse_iterator;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::shrink_to_fit	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void shrink_to_fit() { vec_.shrink_to_fit(); }$/;"	f	class:vtr::flat_map	access:public	signature:()
vtr::flat_map::size	../../libs/libvtrutil/src/vtr_flat_map.h	/^        size_type size() const { return vec_.size(); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::size_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef typename std::vector<value_type>::size_type size_type;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::sort	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void sort() {$/;"	f	class:vtr::flat_map	access:private	signature:()
vtr::flat_map::swap	../../libs/libvtrutil/src/vtr_flat_map.h	/^        friend void swap(flat_map& lhs, flat_map& rhs) { std::swap(lhs.vec_, rhs.vec_); }$/;"	f	class:vtr::flat_map	access:friend	signature:(flat_map& lhs, flat_map& rhs)
vtr::flat_map::swap	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void swap(flat_map& other) { std::swap(*this, other); }$/;"	f	class:vtr::flat_map	access:public	signature:(flat_map& other)
vtr::flat_map::uniquify	../../libs/libvtrutil/src/vtr_flat_map.h	/^        void uniquify() {$/;"	f	class:vtr::flat_map	access:private	signature:()
vtr::flat_map::upper_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        const_iterator upper_bound(const key_type& key) const {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key) const
vtr::flat_map::upper_bound	../../libs/libvtrutil/src/vtr_flat_map.h	/^        iterator upper_bound(const key_type& key) {$/;"	f	class:vtr::flat_map	access:public	signature:(const key_type& key)
vtr::flat_map::value_comp	../../libs/libvtrutil/src/vtr_flat_map.h	/^        value_compare value_comp() const { return value_compare(key_comp()); }$/;"	f	class:vtr::flat_map	access:public	signature:() const
vtr::flat_map::value_compare	../../libs/libvtrutil/src/vtr_flat_map.h	/^class flat_map<K,T,Compare>::value_compare {$/;"	c	class:vtr::flat_map
vtr::flat_map::value_compare::comp	../../libs/libvtrutil/src/vtr_flat_map.h	/^        Compare comp;$/;"	m	class:vtr::flat_map::value_compare	access:private
vtr::flat_map::value_compare::operator ()	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool operator() (const value_type& x, const key_type& y) const {$/;"	f	class:vtr::flat_map::value_compare	access:public	signature:(const value_type& x, const key_type& y) const
vtr::flat_map::value_compare::operator ()	../../libs/libvtrutil/src/vtr_flat_map.h	/^        bool operator() (const value_type& x, const value_type& y) const {$/;"	f	class:vtr::flat_map::value_compare	access:public	signature:(const value_type& x, const value_type& y) const
vtr::flat_map::value_compare::value_compare	../../libs/libvtrutil/src/vtr_flat_map.h	/^        value_compare(Compare c) : comp(c) {}$/;"	f	class:vtr::flat_map::value_compare	access:private	signature:(Compare c)
vtr::flat_map::value_type	../../libs/libvtrutil/src/vtr_flat_map.h	/^        typedef std::pair<K,T> value_type;$/;"	t	class:vtr::flat_map	access:public
vtr::flat_map::vec_	../../libs/libvtrutil/src/vtr_flat_map.h	/^        std::vector<value_type> vec_;$/;"	m	class:vtr::flat_map	access:private
vtr::fopen	../../libs/libvtrutil/src/vtr_util.cpp	/^FILE* fopen(const char *fname, const char *flag) {$/;"	f	namespace:vtr	signature:(const char *fname, const char *flag)
vtr::fopen	../../libs/libvtrutil/src/vtr_util.h	/^    FILE* fopen(const char *fname, const char *flag);$/;"	p	namespace:vtr	signature:(const char *fname, const char *flag)
vtr::frand	../../libs/libvtrutil/src/vtr_random.cpp	/^float frand() {$/;"	f	namespace:vtr	signature:()
vtr::frand	../../libs/libvtrutil/src/vtr_random.h	/^    float frand();$/;"	p	namespace:vtr	signature:()
vtr::free	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* free(void *some){$/;"	f	namespace:vtr	signature:(void *some)
vtr::free	../../libs/libvtrutil/src/vtr_memory.h	/^    void* free(void *some);$/;"	p	namespace:vtr	signature:(void *some)
vtr::free_chunk_memory	../../libs/libvtrutil/src/vtr_memory.cpp	/^void free_chunk_memory(t_chunk *chunk_info) {$/;"	f	namespace:vtr	signature:(t_chunk *chunk_info)
vtr::free_chunk_memory	../../libs/libvtrutil/src/vtr_memory.h	/^    void free_chunk_memory(t_chunk *chunk_info);$/;"	p	namespace:vtr	signature:(t_chunk *chunk_info)
vtr::free_int_list	../../libs/libvtrutil/src/vtr_list.cpp	/^void free_int_list(t_linked_int ** int_list_head_ptr) {$/;"	f	namespace:vtr	signature:(t_linked_int ** int_list_head_ptr)
vtr::free_int_list	../../libs/libvtrutil/src/vtr_list.h	/^    void free_int_list(t_linked_int ** int_list_head_ptr);$/;"	p	namespace:vtr	signature:(t_linked_int ** int_list_head_ptr)
vtr::free_ivec_vector	../../libs/libvtrutil/src/vtr_matrix.cpp	/^void free_ivec_vector(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax) {$/;"	f	namespace:vtr	signature:(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax)
vtr::free_ivec_vector	../../libs/libvtrutil/src/vtr_matrix.h	/^    void free_ivec_vector(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax);$/;"	p	namespace:vtr	signature:(std::vector<std::vector<int>> ivec_vector, int nrmin, int nrmax)
vtr::gcd	../../libs/libvtrutil/src/vtr_math.h	/^    static T gcd(T x, T y){$/;"	f	namespace:vtr	signature:(T x, T y)
vtr::geomean	../../libs/libvtrutil/src/vtr_math.h	/^    double geomean(Container c) {$/;"	f	namespace:vtr	signature:(Container c)
vtr::geomean	../../libs/libvtrutil/src/vtr_math.h	/^    double geomean(InputIterator first, InputIterator last, double init=1.) {$/;"	f	namespace:vtr	signature:(InputIterator first, InputIterator last, double init=1.)
vtr::get_file_line_number_of_last_opened_file	../../libs/libvtrutil/src/vtr_util.cpp	/^int get_file_line_number_of_last_opened_file() {$/;"	f	namespace:vtr	signature:()
vtr::get_file_line_number_of_last_opened_file	../../libs/libvtrutil/src/vtr_util.h	/^    int get_file_line_number_of_last_opened_file();$/;"	p	namespace:vtr	signature:()
vtr::get_max_rss	../../libs/libvtrutil/src/vtr_rusage.cpp	/^size_t get_max_rss() {$/;"	f	namespace:vtr	signature:()
vtr::get_max_rss	../../libs/libvtrutil/src/vtr_rusage.h	/^    size_t get_max_rss();$/;"	p	namespace:vtr	signature:()
vtr::get_random_state	../../libs/libvtrutil/src/vtr_random.cpp	/^RandState get_random_state() {$/;"	f	namespace:vtr	signature:()
vtr::get_random_state	../../libs/libvtrutil/src/vtr_random.h	/^    RandState get_random_state();$/;"	p	namespace:vtr	signature:()
vtr::getcwd	../../libs/libvtrutil/src/vtr_path.cpp	/^std::string getcwd() {$/;"	f	namespace:vtr	signature:()
vtr::getcwd	../../libs/libvtrutil/src/vtr_path.h	/^    std::string getcwd();$/;"	p	namespace:vtr	signature:()
vtr::hash_combine	../../libs/libvtrutil/src/vtr_hash.h	/^inline void hash_combine(std::size_t& seed, const T& v)$/;"	f	namespace:vtr	signature:(std::size_t& seed, const T& v)
vtr::inferno_data	../../libs/libvtrutil/src/vtr_color_map.cpp	/^static std::vector<Color<float>> inferno_data = {$/;"	m	namespace:vtr	file:
vtr::insert_in_int_list	../../libs/libvtrutil/src/vtr_list.cpp	/^t_linked_int *insert_in_int_list(t_linked_int * head, int data,$/;"	f	namespace:vtr	signature:(t_linked_int * head, int data, t_linked_int ** free_list_head_ptr)
vtr::insert_in_int_list	../../libs/libvtrutil/src/vtr_list.h	/^    t_linked_int *insert_in_int_list(t_linked_int * head, int data,$/;"	p	namespace:vtr	signature:(t_linked_int * head, int data, t_linked_int ** free_list_head_ptr)
vtr::insert_in_vptr_list	../../libs/libvtrutil/src/vtr_list.cpp	/^t_linked_vptr *insert_in_vptr_list(t_linked_vptr *head, void *vptr_to_add) {$/;"	f	namespace:vtr	signature:(t_linked_vptr *head, void *vptr_to_add)
vtr::insert_in_vptr_list	../../libs/libvtrutil/src/vtr_list.h	/^    t_linked_vptr *insert_in_vptr_list(t_linked_vptr *head,$/;"	p	namespace:vtr	signature:(t_linked_vptr *head, void *vptr_to_add)
vtr::ipow	../../libs/libvtrutil/src/vtr_math.cpp	/^int ipow(int base, int exp) {$/;"	f	namespace:vtr	signature:(int base, int exp)
vtr::ipow	../../libs/libvtrutil/src/vtr_math.h	/^    int ipow(int base, int exp);$/;"	p	namespace:vtr	signature:(int base, int exp)
vtr::irand	../../libs/libvtrutil/src/vtr_random.cpp	/^int irand(int imax) {$/;"	f	namespace:vtr	signature:(int imax)
vtr::irand	../../libs/libvtrutil/src/vtr_random.cpp	/^int irand(int imax, RandState& state) {$/;"	f	namespace:vtr	signature:(int imax, RandState& state)
vtr::irand	../../libs/libvtrutil/src/vtr_random.h	/^    int irand(int imax);$/;"	p	namespace:vtr	signature:(int imax)
vtr::irand	../../libs/libvtrutil/src/vtr_random.h	/^    int irand(int imax, RandState& rand_state);$/;"	p	namespace:vtr	signature:(int imax, RandState& rand_state)
vtr::isclose	../../libs/libvtrutil/src/vtr_math.h	/^    bool isclose(T a, T b) {$/;"	f	namespace:vtr	signature:(T a, T b)
vtr::isclose	../../libs/libvtrutil/src/vtr_math.h	/^    bool isclose(T a, T b, T rel_tol, T abs_tol) {$/;"	f	namespace:vtr	signature:(T a, T b, T rel_tol, T abs_tol)
vtr::join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Container container, std::string delim) {$/;"	f	namespace:vtr	signature:(Container container, std::string delim)
vtr::join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Container container, std::string delim);$/;"	p	namespace:vtr	signature:(Container container, std::string delim)
vtr::join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Iter begin, Iter end, std::string delim) {$/;"	f	namespace:vtr	signature:(Iter begin, Iter end, std::string delim)
vtr::join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(Iter begin, Iter end, std::string delim);$/;"	p	namespace:vtr	signature:(Iter begin, Iter end, std::string delim)
vtr::join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(std::initializer_list<T> list, std::string delim) {$/;"	f	namespace:vtr	signature:(std::initializer_list<T> list, std::string delim)
vtr::join	../../libs/libvtrutil/src/vtr_util.h	/^    std::string join(std::initializer_list<T> list, std::string delim);$/;"	p	namespace:vtr	signature:(std::initializer_list<T> list, std::string delim)
vtr::lcm	../../libs/libvtrutil/src/vtr_math.h	/^    T lcm(T x, T y) {$/;"	f	namespace:vtr	signature:(T x, T y)
vtr::linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.cpp	/^template double linear_interpolate_or_extrapolate(const std::map<double,double> *xy_map, double requested_x);	\/* (double,double) *\/$/;"	p	namespace:vtr	file:	signature:(const std::map<double,double> *xy_map, double requested_x)
vtr::linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.cpp	/^template double linear_interpolate_or_extrapolate(const std::map<int,double> *xy_map, int requested_x);	\/* (int,double) *\/$/;"	p	namespace:vtr	file:	signature:(const std::map<int,double> *xy_map, int requested_x)
vtr::linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.cpp	/^template<typename X, typename Y> Y linear_interpolate_or_extrapolate(const std::map<X,Y> *xy_map, X requested_x){$/;"	f	namespace:vtr	signature:(const std::map<X,Y> *xy_map, X requested_x)
vtr::linear_interpolate_or_extrapolate	../../libs/libvtrutil/src/vtr_math.h	/^    Y linear_interpolate_or_extrapolate(const std::map<X,Y> *xy_map, X requested_x);$/;"	p	namespace:vtr	signature:(const std::map<X,Y> *xy_map, X requested_x)
vtr::linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^class linear_map {$/;"	c	namespace:vtr
vtr::linear_map::at	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const mapped_type& at(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
vtr::linear_map::at	../../libs/libvtrutil/src/vtr_linear_map.h	/^        mapped_type& at(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::begin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          begin()     const   { return vec_.begin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::begin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator                begin()             { return vec_.begin(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::cbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          cbegin()    const   { return vec_.begin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::cend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          cend()      const   { return vec_.end(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::clear	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void clear() { vec_.clear(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::const_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::const_iterator const_iterator;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::const_reference	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef const value_type& const_reference;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::const_reverse_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::const_reverse_iterator const_reverse_iterator;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::convert_to_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator convert_to_iterator(const_iterator const_iter) {$/;"	f	class:vtr::linear_map	access:private	signature:(const_iterator const_iter)
vtr::linear_map::count	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type count(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
vtr::linear_map::crbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  crbegin()   const   { return vec_.rbegin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::crend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  crend()     const   { return vec_.rend(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::difference_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::difference_type difference_type;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::emplace	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<iterator,bool> emplace(const key_type& key, Args&&... args) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key, Args&&... args)
vtr::linear_map::empty	../../libs/libvtrutil/src/vtr_linear_map.h	/^        bool empty() const { return vec_.empty(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::end	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator          end()       const   { return vec_.end(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::end	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator                end()               { return vec_.end(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::equal_range	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<const_iterator,const_iterator> equal_range(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
vtr::linear_map::equal_range	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::erase	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void erase(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::erase	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void erase(const_iterator first, const_iterator last) {$/;"	f	class:vtr::linear_map	access:public	signature:(const_iterator first, const_iterator last)
vtr::linear_map::erase	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void erase(const_iterator position) {$/;"	f	class:vtr::linear_map	access:public	signature:(const_iterator position)
vtr::linear_map::find	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator find(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
vtr::linear_map::find	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator find(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::insert	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:vtr::linear_map	access:public	signature:(const value_type& value)
vtr::linear_map::insert	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void insert(InputIterator first, InputIterator last) {$/;"	f	class:vtr::linear_map	access:public	signature:(InputIterator first, InputIterator last)
vtr::linear_map::iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::iterator iterator;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::key_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef K key_type;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map() = default;$/;"	p	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map(const linear_map&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(const linear_map&)
vtr::linear_map::linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map(linear_map&&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(linear_map&&)
vtr::linear_map::linear_map	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map(size_t num_keys)$/;"	f	class:vtr::linear_map	access:public	signature:(size_t num_keys)
vtr::linear_map::lower_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator lower_bound(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
vtr::linear_map::lower_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator lower_bound(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::mapped_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef T mapped_type;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::max_size	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type max_size() const { return vec_.max_size(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::operator =	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map& operator=(const linear_map&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(const linear_map&)
vtr::linear_map::operator =	../../libs/libvtrutil/src/vtr_linear_map.h	/^        linear_map& operator=(linear_map&&) = default;$/;"	p	class:vtr::linear_map	access:public	signature:(linear_map&&)
vtr::linear_map::operator []	../../libs/libvtrutil/src/vtr_linear_map.h	/^        mapped_type& operator[](const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::rbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  rbegin()    const   { return vec_.rbegin(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::rbegin	../../libs/libvtrutil/src/vtr_linear_map.h	/^        reverse_iterator        rbegin()            { return vec_.rbegin(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::reference	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef value_type& reference;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::rend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_reverse_iterator  rend()      const   { return vec_.rend(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::rend	../../libs/libvtrutil/src/vtr_linear_map.h	/^        reverse_iterator        rend()              { return vec_.rend(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::reserve	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void reserve(size_type n) { vec_.reserve(n); }$/;"	f	class:vtr::linear_map	access:public	signature:(size_type n)
vtr::linear_map::reverse_iterator	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::reverse_iterator reverse_iterator;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::sentinel	../../libs/libvtrutil/src/vtr_linear_map.h	/^        constexpr K sentinel() const { return Sentinel::INVALID(); }$/;"	f	class:vtr::linear_map	access:private	signature:() const
vtr::linear_map::shrink_to_fit	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void shrink_to_fit() { vec_.shrink_to_fit(); }$/;"	f	class:vtr::linear_map	access:public	signature:()
vtr::linear_map::size	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type size() const { return vec_.size(); }$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::size_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef typename std::vector<value_type>::size_type size_type;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::swap	../../libs/libvtrutil/src/vtr_linear_map.h	/^        friend void swap(linear_map& lhs, linear_map& rhs) {$/;"	f	class:vtr::linear_map	access:friend	signature:(linear_map& lhs, linear_map& rhs)
vtr::linear_map::swap	../../libs/libvtrutil/src/vtr_linear_map.h	/^        void swap(linear_map& other) { std::swap(vec_, other.vec_); }$/;"	f	class:vtr::linear_map	access:public	signature:(linear_map& other)
vtr::linear_map::upper_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        const_iterator upper_bound(const key_type& key) const {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key) const
vtr::linear_map::upper_bound	../../libs/libvtrutil/src/vtr_linear_map.h	/^        iterator upper_bound(const key_type& key) {$/;"	f	class:vtr::linear_map	access:public	signature:(const key_type& key)
vtr::linear_map::valid_size	../../libs/libvtrutil/src/vtr_linear_map.h	/^        size_type valid_size() const {$/;"	f	class:vtr::linear_map	access:public	signature:() const
vtr::linear_map::value_type	../../libs/libvtrutil/src/vtr_linear_map.h	/^        typedef std::pair<K,T> value_type;$/;"	t	class:vtr::linear_map	access:public
vtr::linear_map::vec_	../../libs/libvtrutil/src/vtr_linear_map.h	/^        std::vector<value_type> vec_;$/;"	m	class:vtr::linear_map	access:private
vtr::make_flat_map	../../libs/libvtrutil/src/vtr_flat_map.h	/^flat_map<K,V> make_flat_map(std::vector<std::pair<K, V>> vec) {$/;"	f	namespace:vtr	signature:(std::vector<std::pair<K, V>> vec)
vtr::make_key_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_key_range(T b, T e) {$/;"	f	namespace:vtr	signature:(T b, T e)
vtr::make_key_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_key_range(const Container& c) {$/;"	f	namespace:vtr	signature:(const Container& c)
vtr::make_range	../../libs/libvtrutil/src/vtr_range.h	/^auto make_range(T b, T e) { return Range<T>(b, e); }$/;"	f	namespace:vtr	signature:(T b, T e)
vtr::make_range	../../libs/libvtrutil/src/vtr_range.h	/^auto make_range(const Container& c) { return make_range(std::begin(c), std::end(c)); }$/;"	f	namespace:vtr	signature:(const Container& c)
vtr::make_value_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_value_range(T b, T e) {$/;"	f	namespace:vtr	signature:(T b, T e)
vtr::make_value_range	../../libs/libvtrutil/src/vtr_map_util.h	/^auto make_value_range(const Container& c) {$/;"	f	namespace:vtr	signature:(const Container& c)
vtr::malloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* malloc(size_t size) {$/;"	f	namespace:vtr	signature:(size_t size)
vtr::malloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* malloc(size_t size);$/;"	p	namespace:vtr	signature:(size_t size)
vtr::malloc_trim	../../libs/libvtrutil/src/vtr_memory.cpp	/^int malloc_trim(size_t \/*pad*\/) {$/;"	f	namespace:vtr	signature:(size_t )
vtr::malloc_trim	../../libs/libvtrutil/src/vtr_memory.h	/^    int malloc_trim(size_t pad);$/;"	p	namespace:vtr	signature:(size_t pad)
vtr::median	../../libs/libvtrutil/src/vtr_math.h	/^    double median(Container c) {$/;"	f	namespace:vtr	signature:(Container c)
vtr::median	../../libs/libvtrutil/src/vtr_math.h	/^    double median(InputIterator first, InputIterator last) {$/;"	f	namespace:vtr	signature:(InputIterator first, InputIterator last)
vtr::nint	../../libs/libvtrutil/src/vtr_math.h	/^    constexpr int nint(float val) { return static_cast<int>(val + 0.5); }$/;"	f	namespace:vtr	signature:(float val)
vtr::operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator!=(Point<T> lhs, Point<T> rhs);$/;"	p	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator!=(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator!=(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator!=(Point<T> lhs, Point<T> rhs) {$/;"	f	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator!=(const Rect<T>& lhs, const Rect<T>& rhs) {$/;"	f	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator!=(const RectUnion<T>& lhs, const RectUnion<T>& rhs) {$/;"	f	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator!=(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs) {$/;"	f	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::operator !=	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator!=(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::operator <	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator<(Point<T> lhs, Point<T> rhs);$/;"	p	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
vtr::operator <	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator<(Point<T> lhs, Point<T> rhs) {$/;"	f	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
vtr::operator <	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator<(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs) {$/;"	f	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::operator <	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator<(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator==(Point<T> lhs, Point<T> rhs);$/;"	p	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator==(const Rect<T>& lhs, const Rect<T>& rhs);$/;"	p	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_geometry.h	/^bool operator==(const RectUnion<T>& lhs, const RectUnion<T>& rhs);$/;"	p	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator==(Point<T> lhs, Point<T> rhs) {$/;"	f	namespace:vtr	signature:(Point<T> lhs, Point<T> rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator==(const Rect<T>& lhs, const Rect<T>& rhs) {$/;"	f	namespace:vtr	signature:(const Rect<T>& lhs, const Rect<T>& rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    bool operator==(const RectUnion<T>& lhs, const RectUnion<T>& rhs) {$/;"	f	namespace:vtr	signature:(const RectUnion<T>& lhs, const RectUnion<T>& rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator==(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs) {$/;"	f	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::operator ==	../../libs/libvtrutil/src/vtr_strong_id.h	/^bool operator==(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs);$/;"	p	namespace:vtr	signature:(const StrongId<tag,T,sentinel>& lhs, const StrongId<tag,T,sentinel>& rhs)
vtr::out_file_prefix	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string out_file_prefix; \/* used by fopen *\/$/;"	m	namespace:vtr	file:
vtr::pair_first_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^class pair_first_iter {$/;"	c	namespace:vtr
vtr::pair_first_iter::iter_	../../libs/libvtrutil/src/vtr_pair_util.h	/^        PairIter iter_;$/;"	m	class:vtr::pair_first_iter	access:private
vtr::pair_first_iter::operator !=	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator!= (const pair_first_iter lhs, const pair_first_iter rhs) { return !(lhs == rhs); }$/;"	f	class:vtr::pair_first_iter	access:friend	signature:(const pair_first_iter lhs, const pair_first_iter rhs)
vtr::pair_first_iter::operator *	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator*() { return iter_->first; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
vtr::pair_first_iter::operator ++	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator++() { iter_++; return *this; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
vtr::pair_first_iter::operator --	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator--() { iter_--; return *this; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
vtr::pair_first_iter::operator ->	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator->() { return &iter_->first; }$/;"	f	class:vtr::pair_first_iter	access:public	signature:()
vtr::pair_first_iter::operator ==	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator== (const pair_first_iter lhs, const pair_first_iter rhs) { return lhs.iter_ == rhs.iter_; }$/;"	f	class:vtr::pair_first_iter	access:friend	signature:(const pair_first_iter lhs, const pair_first_iter rhs)
vtr::pair_first_iter::pair_first_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^        pair_first_iter(PairIter init): iter_(init) {}$/;"	f	class:vtr::pair_first_iter	access:public	signature:(PairIter init)
vtr::pair_second_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^class pair_second_iter {$/;"	c	namespace:vtr
vtr::pair_second_iter::iter_	../../libs/libvtrutil/src/vtr_pair_util.h	/^        PairIter iter_;$/;"	m	class:vtr::pair_second_iter	access:private
vtr::pair_second_iter::operator !=	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator!= (const pair_second_iter lhs, const pair_second_iter rhs) { return !(lhs == rhs); }$/;"	f	class:vtr::pair_second_iter	access:friend	signature:(const pair_second_iter lhs, const pair_second_iter rhs)
vtr::pair_second_iter::operator *	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator*() { return iter_->second; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
vtr::pair_second_iter::operator ++	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator++() { iter_++; return *this; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
vtr::pair_second_iter::operator --	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator--() { iter_--; return *this; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
vtr::pair_second_iter::operator ->	../../libs/libvtrutil/src/vtr_pair_util.h	/^        auto operator->() { return &iter_->second; }$/;"	f	class:vtr::pair_second_iter	access:public	signature:()
vtr::pair_second_iter::operator ==	../../libs/libvtrutil/src/vtr_pair_util.h	/^        friend bool operator== (const pair_second_iter lhs, const pair_second_iter rhs) { return lhs.iter_ == rhs.iter_; }$/;"	f	class:vtr::pair_second_iter	access:friend	signature:(const pair_second_iter lhs, const pair_second_iter rhs)
vtr::pair_second_iter::pair_second_iter	../../libs/libvtrutil/src/vtr_pair_util.h	/^        pair_second_iter(PairIter init): iter_(init) {}$/;"	f	class:vtr::pair_second_iter	access:public	signature:(PairIter init)
vtr::plasma_data	../../libs/libvtrutil/src/vtr_color_map.cpp	/^static std::vector<Color<float>> plasma_data = {$/;"	m	namespace:vtr	file:
vtr::printf	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerInfo printf = log_print_info;$/;"	m	namespace:vtr	file:
vtr::printf_direct	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerDirect printf_direct = log_print_direct;$/;"	m	namespace:vtr	file:
vtr::printf_error	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerError printf_error = log_print_error;$/;"	m	namespace:vtr	file:
vtr::printf_info	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerInfo printf_info = log_print_info;$/;"	m	namespace:vtr	file:
vtr::printf_warning	../../libs/libvtrutil/src/vtr_log.cpp	/^PrintHandlerWarning printf_warning = log_print_warning;$/;"	m	namespace:vtr	file:
vtr::random_state	../../libs/libvtrutil/src/vtr_random.cpp	/^static RandState random_state = 0;$/;"	m	namespace:vtr	file:
vtr::realloc	../../libs/libvtrutil/src/vtr_memory.cpp	/^void* realloc(void *ptr, size_t size) {$/;"	f	namespace:vtr	signature:(void *ptr, size_t size)
vtr::realloc	../../libs/libvtrutil/src/vtr_memory.h	/^    void* realloc(void *ptr, size_t size);$/;"	p	namespace:vtr	signature:(void *ptr, size_t size)
vtr::replace_all	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string replace_all(const std::string& input, const std::string& search, const std::string& replace) {$/;"	f	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
vtr::replace_all	../../libs/libvtrutil/src/vtr_util.h	/^    std::string replace_all(const std::string& input, const std::string& search, const std::string& replace);$/;"	p	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
vtr::replace_first	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string replace_first(const std::string& input, const std::string& search, const std::string& replace) {$/;"	f	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
vtr::replace_first	../../libs/libvtrutil/src/vtr_util.h	/^    std::string replace_first(const std::string& input, const std::string& search, const std::string& replace);$/;"	p	namespace:vtr	signature:(const std::string& input, const std::string& search, const std::string& replace)
vtr::safe_ratio	../../libs/libvtrutil/src/vtr_math.h	/^    T safe_ratio(T numerator, T denominator) {$/;"	f	namespace:vtr	signature:(T numerator, T denominator)
vtr::secure_digest_file	../../libs/libvtrutil/src/vtr_digest.cpp	/^std::string secure_digest_file(const std::string& filepath) {$/;"	f	namespace:vtr	signature:(const std::string& filepath)
vtr::secure_digest_file	../../libs/libvtrutil/src/vtr_digest.h	/^std::string secure_digest_file(const std::string& filepath);$/;"	p	namespace:vtr	signature:(const std::string& filepath)
vtr::secure_digest_stream	../../libs/libvtrutil/src/vtr_digest.cpp	/^std::string secure_digest_stream(std::istream& is) {$/;"	f	namespace:vtr	signature:(std::istream& is)
vtr::secure_digest_stream	../../libs/libvtrutil/src/vtr_digest.h	/^std::string secure_digest_stream(std::istream& is);$/;"	p	namespace:vtr	signature:(std::istream& is)
vtr::set_log_file	../../libs/libvtrutil/src/vtr_log.cpp	/^void set_log_file(const char* filename) {$/;"	f	namespace:vtr	signature:(const char* filename)
vtr::set_log_file	../../libs/libvtrutil/src/vtr_log.h	/^void set_log_file(const char* filename);$/;"	p	namespace:vtr	signature:(const char* filename)
vtr::shuffle	../../libs/libvtrutil/src/vtr_random.h	/^    void shuffle(Iter first, Iter last, RandState& rand_state) {$/;"	f	namespace:vtr	signature:(Iter first, Iter last, RandState& rand_state)
vtr::split	../../libs/libvtrutil/src/vtr_util.cpp	/^std::vector<std::string> split(const char* text, const std::string delims) {$/;"	f	namespace:vtr	signature:(const char* text, const std::string delims)
vtr::split	../../libs/libvtrutil/src/vtr_util.cpp	/^std::vector<std::string> split(const std::string& text, const std::string delims) {$/;"	f	namespace:vtr	signature:(const std::string& text, const std::string delims)
vtr::split	../../libs/libvtrutil/src/vtr_util.h	/^    std::vector<std::string> split(const char* text, const std::string delims=" \\t\\n");$/;"	p	namespace:vtr	signature:(const char* text, const std::string delims=Ó)
vtr::split	../../libs/libvtrutil/src/vtr_util.h	/^    std::vector<std::string> split(const std::string& text, const std::string delims=" \\t\\n");$/;"	p	namespace:vtr	signature:(const std::string& text, const std::string delims=Ó)
vtr::split_ext	../../libs/libvtrutil/src/vtr_path.cpp	/^std::array<std::string,2> split_ext(const std::string& filename) {$/;"	f	namespace:vtr	signature:(const std::string& filename)
vtr::split_ext	../../libs/libvtrutil/src/vtr_path.h	/^    std::array<std::string,2> split_ext(const std::string& filename);$/;"	p	namespace:vtr	signature:(const std::string& filename)
vtr::srandom	../../libs/libvtrutil/src/vtr_random.cpp	/^void srandom(int seed) {$/;"	f	namespace:vtr	signature:(int seed)
vtr::srandom	../../libs/libvtrutil/src/vtr_random.h	/^    void srandom(int seed);$/;"	p	namespace:vtr	signature:(int seed)
vtr::starts_with	../../libs/libvtrutil/src/vtr_util.cpp	/^bool starts_with(std::string str, std::string prefix) {$/;"	f	namespace:vtr	signature:(std::string str, std::string prefix)
vtr::starts_with	../../libs/libvtrutil/src/vtr_util.h	/^    bool starts_with(std::string str, std::string prefix);$/;"	p	namespace:vtr	signature:(std::string str, std::string prefix)
vtr::strdup	../../libs/libvtrutil/src/vtr_util.cpp	/^char* strdup(const char *str) {$/;"	f	namespace:vtr	signature:(const char *str)
vtr::strdup	../../libs/libvtrutil/src/vtr_util.h	/^    char* strdup(const char *str);$/;"	p	namespace:vtr	signature:(const char *str)
vtr::string_fmt	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string string_fmt(const char* fmt, ...) {$/;"	f	namespace:vtr	signature:(const char* fmt, ...)
vtr::string_fmt	../../libs/libvtrutil/src/vtr_util.h	/^    std::string string_fmt(const char* fmt, ...);$/;"	p	namespace:vtr	signature:(const char* fmt, ...)
vtr::strncpy	../../libs/libvtrutil/src/vtr_util.cpp	/^char* strncpy(char *dest, const char *src, size_t size) {$/;"	f	namespace:vtr	signature:(char *dest, const char *src, size_t size)
vtr::strncpy	../../libs/libvtrutil/src/vtr_util.h	/^    char* strncpy(char *dest, const char *src, size_t size);$/;"	p	namespace:vtr	signature:(char *dest, const char *src, size_t size)
vtr::strtok	../../libs/libvtrutil/src/vtr_util.cpp	/^char* strtok(char *ptr, const char *tokens, FILE * fp, char *buf) {$/;"	f	namespace:vtr	signature:(char *ptr, const char *tokens, FILE * fp, char *buf)
vtr::strtok	../../libs/libvtrutil/src/vtr_util.h	/^    char* strtok(char *ptr, const char *tokens, FILE * fp, char *buf);$/;"	p	namespace:vtr	signature:(char *ptr, const char *tokens, FILE * fp, char *buf)
vtr::t_chunk	../../libs/libvtrutil/src/vtr_memory.h	/^    struct t_chunk {$/;"	s	namespace:vtr
vtr::t_chunk::chunk_ptr_head	../../libs/libvtrutil/src/vtr_memory.h	/^        t_linked_vptr *chunk_ptr_head = nullptr;$/;"	m	struct:vtr::t_chunk	access:public
vtr::t_chunk::mem_avail	../../libs/libvtrutil/src/vtr_memory.h	/^        int mem_avail = 0; \/* number of bytes left in the current chunk *\/$/;"	m	struct:vtr::t_chunk	access:public
vtr::t_chunk::next_mem_loc_ptr	../../libs/libvtrutil/src/vtr_memory.h	/^        char *next_mem_loc_ptr = nullptr;\/* pointer to the first available (free) *$/;"	m	struct:vtr::t_chunk	access:public
vtr::t_linked_int	../../libs/libvtrutil/src/vtr_list.h	/^    struct t_linked_int {$/;"	s	namespace:vtr
vtr::t_linked_int::data	../../libs/libvtrutil/src/vtr_list.h	/^        int data;$/;"	m	struct:vtr::t_linked_int	access:public
vtr::t_linked_int::next	../../libs/libvtrutil/src/vtr_list.h	/^        t_linked_int *next;$/;"	m	struct:vtr::t_linked_int	access:public
vtr::t_linked_vptr	../../libs/libvtrutil/src/vtr_list.h	/^    struct t_linked_vptr {$/;"	s	namespace:vtr
vtr::t_linked_vptr::data_vptr	../../libs/libvtrutil/src/vtr_list.h	/^        void *data_vptr;$/;"	m	struct:vtr::t_linked_vptr	access:public
vtr::t_linked_vptr::next	../../libs/libvtrutil/src/vtr_list.h	/^        struct t_linked_vptr *next;$/;"	m	struct:vtr::t_linked_vptr	typeref:struct:vtr::t_linked_vptr::t_linked_vptr	access:public
vtr::vector	../../libs/libvtrutil/src/vtr_vector.h	/^class vector : private std::vector<V> {$/;"	c	namespace:vtr	inherits:std::vector
vtr::vector::at	../../libs/libvtrutil/src/vtr_vector.h	/^        const_reference at(const key_type id) const {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id) const
vtr::vector::at	../../libs/libvtrutil/src/vtr_vector.h	/^        reference at(const key_type id) {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id)
vtr::vector::key_begin	../../libs/libvtrutil/src/vtr_vector.h	/^        key_iterator key_begin() const { return key_iterator(key_type(0)); }$/;"	f	class:vtr::vector	access:private	signature:() const
vtr::vector::key_end	../../libs/libvtrutil/src/vtr_vector.h	/^        key_iterator key_end() const { return key_iterator(key_type(size())); }$/;"	f	class:vtr::vector	access:private	signature:() const
vtr::vector::key_iterator	../../libs/libvtrutil/src/vtr_vector.h	/^        class key_iterator : public std::iterator<std::bidirectional_iterator_tag, key_type> {$/;"	c	class:vtr::vector	inherits:std::iterator	access:public
vtr::vector::key_iterator::key_iterator	../../libs/libvtrutil/src/vtr_vector.h	/^                key_iterator(key_iterator::value_type init): value_(init) {}$/;"	f	class:vtr::vector::key_iterator	access:public	signature:(key_iterator::value_type init)
vtr::vector::key_iterator::operator !=	../../libs/libvtrutil/src/vtr_vector.h	/^                friend bool operator!= (const key_iterator lhs, const key_iterator rhs) { return !(lhs == rhs); }$/;"	f	class:vtr::vector::key_iterator	access:friend	signature:(const key_iterator lhs, const key_iterator rhs)
vtr::vector::key_iterator::operator *	../../libs/libvtrutil/src/vtr_vector.h	/^                reference operator*() { return value_; }$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
vtr::vector::key_iterator::operator ++	../../libs/libvtrutil/src/vtr_vector.h	/^                key_iterator operator++() {$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
vtr::vector::key_iterator::operator --	../../libs/libvtrutil/src/vtr_vector.h	/^                key_iterator operator--() {$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
vtr::vector::key_iterator::operator ->	../../libs/libvtrutil/src/vtr_vector.h	/^                pointer operator->() { return &value_; }$/;"	f	class:vtr::vector::key_iterator	access:public	signature:()
vtr::vector::key_iterator::operator ==	../../libs/libvtrutil/src/vtr_vector.h	/^                friend bool operator== (const key_iterator lhs, const key_iterator rhs) { return lhs.value_ == rhs.value_; }$/;"	f	class:vtr::vector::key_iterator	access:friend	signature:(const key_iterator lhs, const key_iterator rhs)
vtr::vector::key_iterator::value_	../../libs/libvtrutil/src/vtr_vector.h	/^                value_type value_;$/;"	m	class:vtr::vector::key_iterator	access:private
vtr::vector::key_range	../../libs/libvtrutil/src/vtr_vector.h	/^        typedef vtr::Range<key_iterator> key_range;$/;"	t	class:vtr::vector	access:public
vtr::vector::key_type	../../libs/libvtrutil/src/vtr_vector.h	/^        typedef K key_type;$/;"	t	class:vtr::vector	access:public
vtr::vector::keys	../../libs/libvtrutil/src/vtr_vector.h	/^        key_range keys() const {$/;"	f	class:vtr::vector	access:public	signature:() const
vtr::vector::operator []	../../libs/libvtrutil/src/vtr_vector.h	/^        const_reference operator[](const key_type id) const {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id) const
vtr::vector::operator []	../../libs/libvtrutil/src/vtr_vector.h	/^        reference operator[](const key_type id) {$/;"	f	class:vtr::vector	access:public	signature:(const key_type id)
vtr::vector_map	../../libs/libvtrutil/src/vtr_vector_map.h	/^class vector_map {$/;"	c	namespace:vtr
vtr::vector_map::begin	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_iterator begin() const { return vec_.begin(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::begin	../../libs/libvtrutil/src/vtr_vector_map.h	/^        iterator begin() { return vec_.begin(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
vtr::vector_map::capacity	../../libs/libvtrutil/src/vtr_vector_map.h	/^        size_t capacity() const { return vec_.capacity(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::clear	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void clear() { vec_.clear(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
vtr::vector_map::const_iterator	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::const_iterator const_iterator;$/;"	t	class:vtr::vector_map	access:public
vtr::vector_map::const_reference	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::const_reference const_reference;$/;"	t	class:vtr::vector_map	access:public
vtr::vector_map::const_reverse_iterator	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::const_reverse_iterator const_reverse_iterator;$/;"	t	class:vtr::vector_map	access:public
vtr::vector_map::contains	../../libs/libvtrutil/src/vtr_vector_map.h	/^        bool contains(const K key) const { return size_t(key) < vec_.size(); }$/;"	f	class:vtr::vector_map	access:public	signature:(const K key) const
vtr::vector_map::count	../../libs/libvtrutil/src/vtr_vector_map.h	/^        size_t count(const K key) const { return contains(key) ? 1 : 0; }$/;"	f	class:vtr::vector_map	access:public	signature:(const K key) const
vtr::vector_map::emplace_back	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void emplace_back(Args&&... args) { vec_.emplace_back(std::forward<Args>(args)...); }$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
vtr::vector_map::empty	../../libs/libvtrutil/src/vtr_vector_map.h	/^        bool empty() const { return vec_.empty(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::end	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_iterator end() const { return vec_.end(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::end	../../libs/libvtrutil/src/vtr_vector_map.h	/^        iterator end() { return vec_.end(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
vtr::vector_map::find	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_iterator find(const K key) const {$/;"	f	class:vtr::vector_map	access:public	signature:(const K key) const
vtr::vector_map::find	../../libs/libvtrutil/src/vtr_vector_map.h	/^        iterator find(const K key) {$/;"	f	class:vtr::vector_map	access:public	signature:(const K key)
vtr::vector_map::insert	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void insert(const K key, const V value) {$/;"	f	class:vtr::vector_map	access:public	signature:(const K key, const V value)
vtr::vector_map::iterator	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::iterator iterator;$/;"	t	class:vtr::vector_map	access:public
vtr::vector_map::operator []	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_reference operator[] (const K n) const {$/;"	f	class:vtr::vector_map	access:public	signature:(const K n) const
vtr::vector_map::operator []	../../libs/libvtrutil/src/vtr_vector_map.h	/^        reference operator[] (const K n) {$/;"	f	class:vtr::vector_map	access:public	signature:(const K n)
vtr::vector_map::push_back	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void push_back(Args&&... args) { vec_.push_back(std::forward<Args>(args)...); }$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
vtr::vector_map::rbegin	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_reverse_iterator rbegin() const { return vec_.rbegin(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::reference	../../libs/libvtrutil/src/vtr_vector_map.h	/^        typedef typename std::vector<V>::reference reference;$/;"	t	class:vtr::vector_map	access:public
vtr::vector_map::rend	../../libs/libvtrutil/src/vtr_vector_map.h	/^        const_reverse_iterator rend() const { return vec_.rend(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::resize	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void resize(Args&&... args) { vec_.resize(std::forward<Args>(args)...); }$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
vtr::vector_map::shrink_to_fit	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void shrink_to_fit() { vec_.shrink_to_fit(); }$/;"	f	class:vtr::vector_map	access:public	signature:()
vtr::vector_map::size	../../libs/libvtrutil/src/vtr_vector_map.h	/^        std::size_t size() const { return vec_.size(); }$/;"	f	class:vtr::vector_map	access:public	signature:() const
vtr::vector_map::swap	../../libs/libvtrutil/src/vtr_vector_map.h	/^        friend void swap(vector_map<K,V>& x, vector_map<K,V>& y) {$/;"	f	class:vtr::vector_map	access:friend	signature:(vector_map<K,V>& x, vector_map<K,V>& y)
vtr::vector_map::update	../../libs/libvtrutil/src/vtr_vector_map.h	/^        void update(const K key, const V value) { insert(key, value); }$/;"	f	class:vtr::vector_map	access:public	signature:(const K key, const V value)
vtr::vector_map::vec_	../../libs/libvtrutil/src/vtr_vector_map.h	/^        std::vector<V> vec_;$/;"	m	class:vtr::vector_map	access:private
vtr::vector_map::vector_map	../../libs/libvtrutil/src/vtr_vector_map.h	/^        vector_map(Args&&... args)$/;"	f	class:vtr::vector_map	access:public	signature:(Args&&.... args)
vtr::viridis_data	../../libs/libvtrutil/src/vtr_color_map.cpp	/^static std::vector<Color<float>> viridis_data = {$/;"	m	namespace:vtr	file:
vtr::vstring_fmt	../../libs/libvtrutil/src/vtr_util.cpp	/^std::string vstring_fmt(const char* fmt, va_list args) {$/;"	f	namespace:vtr	signature:(const char* fmt, va_list args)
vtr::vstring_fmt	../../libs/libvtrutil/src/vtr_util.h	/^    std::string vstring_fmt(const char* fmt, va_list args);$/;"	p	namespace:vtr	signature:(const char* fmt, va_list args)
vvpr_throw	util/vpr_error.cpp	/^void vvpr_throw(enum e_vpr_error type,$/;"	f	signature:(enum e_vpr_error type, const char* psz_file_name, unsigned int line_num, const char* psz_message, va_list va_args)
vvpr_throw	util/vpr_error.h	/^[[noreturn]] void vvpr_throw(enum e_vpr_error type, const char* psz_file_name, unsigned int line_num, const char* psz_message, va_list args);$/;"	p	signature:(enum e_vpr_error type, const char* psz_file_name, unsigned int line_num, const char* psz_message, va_list args)
walk	base/netlist_walker.cpp	/^void NetlistWalker::walk() {$/;"	f	class:NetlistWalker	signature:()
walk	base/netlist_walker.h	/^        void walk();$/;"	p	class:NetlistWalker	access:public	signature:()
walk_atoms	base/netlist_walker.cpp	/^void NetlistWalker::walk_atoms(const t_pb* pb) {$/;"	f	class:NetlistWalker	signature:(const t_pb* pb)
walk_atoms	base/netlist_walker.h	/^        void walk_atoms(const t_pb* pb);$/;"	p	class:NetlistWalker	access:private	signature:(const t_pb* pb)
warn_model_missing_timing	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^void warn_model_missing_timing(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model) {$/;"	f	signature:(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model)
warn_model_missing_timing	../../libs/libarchfpga/src/read_xml_arch_file.cpp	/^void warn_model_missing_timing(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model);$/;"	p	file:	signature:(pugi::xml_node model_tag, const pugiutil::loc_data& loc_data, const t_model* model)
warn_unconstrained	timing/concrete_timing_info.cpp	/^void warn_unconstrained(std::shared_ptr<const tatum::TimingAnalyzer> analyzer) {$/;"	f	signature:(std::shared_ptr<const tatum::TimingAnalyzer> analyzer)
warn_unconstrained	timing/concrete_timing_info.h	/^void warn_unconstrained(std::shared_ptr<const tatum::TimingAnalyzer> analyzer);$/;"	p	signature:(std::shared_ptr<const tatum::TimingAnalyzer> analyzer)
warn_unconstrained_	timing/concrete_timing_info.h	/^        bool warn_unconstrained_ = true;$/;"	m	class:ConcreteHoldTimingInfo	access:private
warn_unconstrained_	timing/concrete_timing_info.h	/^        bool warn_unconstrained_ = true;$/;"	m	class:ConcreteSetupHoldTimingInfo	access:private
warn_unconstrained_	timing/concrete_timing_info.h	/^        bool warn_unconstrained_ = true;$/;"	m	class:ConcreteSetupTimingInfo	access:private
wchar_counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	typedef wchar_selector<sizeof(wchar_t)>::counter wchar_counter;$/;"	t	file:
wchar_decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct wchar_decoder$/;"	s	file:
wchar_decoder::process	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <typename Traits> static inline typename Traits::value_type process(const wchar_t* data, size_t size, typename Traits::value_type result, Traits traits)$/;"	f	struct:wchar_decoder	access:public	signature:(const wchar_t* data, size_t size, typename Traits::value_type result, Traits traits)
wchar_decoder::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef wchar_t type;$/;"	t	struct:wchar_decoder	file:	access:public
wchar_selector	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <> struct wchar_selector<2>$/;"	s	file:
wchar_selector	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <> struct wchar_selector<4>$/;"	s	file:
wchar_selector::counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf16_counter counter;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::counter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf32_counter counter;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf16_decoder<opt_false> decoder;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::decoder	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf32_decoder<opt_false> decoder;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint16_t type;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef uint32_t type;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf16_writer writer;$/;"	t	struct:wchar_selector	file:	access:public
wchar_selector::writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf32_writer writer;$/;"	t	struct:wchar_selector	file:	access:public
wchar_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	typedef wchar_selector<sizeof(wchar_t)>::writer wchar_writer;$/;"	t	file:
what	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN const char* xpath_exception::what() const throw()$/;"	f	class:pugi::xpath_exception	signature:() const
what	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual const char* what() const throw();$/;"	p	class:pugi::xpath_exception	access:public	signature:() const
wide_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream;$/;"	m	class:pugi::xml_writer_stream	access:private
width	../../libs/libarchfpga/src/physical_types.h	/^	float width;$/;"	m	struct:t_chan	access:public
width	../../libs/libarchfpga/src/physical_types.h	/^	int width = 0;$/;"	m	struct:t_type_descriptor	access:public
width	../../libs/libarchfpga/src/physical_types.h	/^    int width = -1;                             \/\/Fixed device width (only valid for grid_type == FIXED)$/;"	m	struct:t_grid_def	access:public
width	../../libs/libeasygl/src/graphics.cpp	/^    int width;$/;"	m	struct:__anon18	file:	access:public
width	../../libs/libvtrutil/src/vtr_geometry.h	/^        T width() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
width	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::width() const {$/;"	f	class:vtr::Rect	signature:() const
width	base/device_grid.h	/^        size_t width() const { return grid_.dim_size(0); }$/;"	f	class:DeviceGrid	access:public	signature:() const
width_	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        std::streamsize width_;$/;"	m	class:vtr::OsFormatGuard	access:private
width_offset	base/vpr_types.h	/^	int width_offset = 0;$/;"	m	struct:ScreenUpdatePriority::t_grid_tile	access:public
width_offset	route/rr_graph.cpp	/^    int width_offset;$/;"	m	struct:t_pin_loc	file:	access:public
win	../../libs/libeasygl/src/graphics.cpp	/^    Window win;$/;"	m	struct:__anon18	file:	access:public
win32_GraphicsWND_handle_WM_LRBUTTONDOWN	../../libs/libeasygl/src/graphics.cpp	/^static void win32_GraphicsWND_handle_WM_LRBUTTONDOWN(UINT message, WPARAM wParam, LPARAM lParam,$/;"	f	file:	signature:(UINT message, WPARAM wParam, LPARAM lParam, int &X, int &Y, RECT &oldAdjustRect)
win32_GraphicsWND_handle_WM_LRBUTTONDOWN	../../libs/libeasygl/src/graphics.cpp	/^static void win32_GraphicsWND_handle_WM_LRBUTTONDOWN(UINT message, WPARAM wParam, LPARAM lParam,$/;"	p	file:	signature:(UINT message, WPARAM wParam, LPARAM lParam, int &X, int &Y, RECT &oldAdjustRect)
win32_GraphicsWND_handle_WM_MBUTTONDOWN	../../libs/libeasygl/src/graphics.cpp	/^static void win32_GraphicsWND_handle_WM_MBUTTONDOWN(HWND hwnd, UINT message, WPARAM wParam,$/;"	p	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
win32_GraphicsWND_handle_WM_MBUTTONDOWN	../../libs/libeasygl/src/graphics.cpp	/^win32_GraphicsWND_handle_WM_MBUTTONDOWN(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {$/;"	f	file:	signature:(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
win32_GraphicsWND_handle_WM_MOUSEMOVE	../../libs/libeasygl/src/graphics.cpp	/^static void win32_GraphicsWND_handle_WM_MOUSEMOVE(LPARAM lParam, int &X, int &Y,$/;"	p	file:	signature:(LPARAM lParam, int &X, int &Y, RECT &oldAdjustRect)
win32_GraphicsWND_handle_WM_MOUSEMOVE	../../libs/libeasygl/src/graphics.cpp	/^win32_GraphicsWND_handle_WM_MOUSEMOVE(LPARAM lParam, int &X, int &Y, RECT &oldAdjustRect) {$/;"	f	file:	signature:(LPARAM lParam, int &X, int &Y, RECT &oldAdjustRect)
win32_GraphicsWND_handle_WM_PAINT	../../libs/libeasygl/src/graphics.cpp	/^static void win32_GraphicsWND_handle_WM_PAINT(HWND hwnd, PAINTSTRUCT &ps, HPEN &hDotPen,$/;"	p	file:	signature:(HWND hwnd, PAINTSTRUCT &ps, HPEN &hDotPen, RECT &oldAdjustRect)
win32_GraphicsWND_handle_WM_PAINT	../../libs/libeasygl/src/graphics.cpp	/^win32_GraphicsWND_handle_WM_PAINT(HWND hwnd, PAINTSTRUCT &ps, HPEN &hDotPen, RECT &oldAdjustRect) {$/;"	f	file:	signature:(HWND hwnd, PAINTSTRUCT &ps, HPEN &hDotPen, RECT &oldAdjustRect)
win32_drain_message_queue	../../libs/libeasygl/src/graphics.cpp	/^static void win32_drain_message_queue() {$/;"	f	file:	signature:()
win32_drain_message_queue	../../libs/libeasygl/src/graphics.cpp	/^static void win32_drain_message_queue();$/;"	p	file:	signature:()
win32_drawcurve	../../libs/libeasygl/src/graphics.cpp	/^void win32_drawcurve(t_point *points,$/;"	f	signature:(t_point *points, int npoints)
win32_drawcurve	../../libs/libeasygl/src/graphics.cpp	/^void win32_drawcurve(t_point* \/*points*\/, int npoints) {$/;"	f	signature:(t_point* , int npoints)
win32_drawcurve	../../libs/libeasygl/src/graphics.h	/^void win32_drawcurve(t_point *points, int npoints);$/;"	p	signature:(t_point *points, int npoints)
win32_drawscreen_ptr	../../libs/libeasygl/src/graphics.cpp	/^static void (*win32_drawscreen_ptr)(void);$/;"	v	file:
win32_fillcurve	../../libs/libeasygl/src/graphics.cpp	/^void win32_fillcurve(t_point *points,$/;"	f	signature:(t_point *points, int npoints)
win32_fillcurve	../../libs/libeasygl/src/graphics.cpp	/^void win32_fillcurve(t_point* points, int npoints) {$/;"	f	signature:(t_point* points, int npoints)
win32_fillcurve	../../libs/libeasygl/src/graphics.h	/^void win32_fillcurve(t_point *points, int npoints);$/;"	p	signature:(t_point *points, int npoints)
win32_handle_button_info	../../libs/libeasygl/src/graphics.cpp	/^static void win32_handle_button_info(t_event_buttonPressed &button_info, UINT message,$/;"	p	file:	signature:(t_event_buttonPressed &button_info, UINT message, WPARAM wParam)
win32_handle_button_info	../../libs/libeasygl/src/graphics.cpp	/^static void win32_handle_button_info(t_event_buttonPressed &button_info,$/;"	f	file:	signature:(t_event_buttonPressed &button_info, UINT message, WPARAM wParam)
win32_handle_mousewheel_zooming	../../libs/libeasygl/src/graphics.cpp	/^static void win32_handle_mousewheel_zooming(WPARAM wParam, LPARAM lParam, bool draw_screen) {$/;"	f	file:	signature:(WPARAM wParam, LPARAM lParam, bool draw_screen)
win32_handle_mousewheel_zooming	../../libs/libeasygl/src/graphics.cpp	/^static void win32_handle_mousewheel_zooming(WPARAM wParam, LPARAM lParam, bool draw_screen);$/;"	p	file:	signature:(WPARAM wParam, LPARAM lParam, bool draw_screen)
win32_init_graphics	../../libs/libeasygl/src/graphics.cpp	/^static void win32_init_graphics(const char* window_name);$/;"	p	file:	signature:(const char* window_name)
win32_init_graphics	../../libs/libeasygl/src/graphics.cpp	/^win32_init_graphics(const char *window_name) {$/;"	f	file:	signature:(const char *window_name)
win32_invalidate_screen	../../libs/libeasygl/src/graphics.cpp	/^static void win32_invalidate_screen();$/;"	p	file:	signature:()
win32_invalidate_screen	../../libs/libeasygl/src/graphics.cpp	/^static void win32_invalidate_screen(void) {$/;"	f	file:	signature:(void)
win32_keypress_ptr	../../libs/libeasygl/src/graphics.cpp	/^static void (*win32_keypress_ptr)(char entered_char, int keysym);$/;"	v	file:
win32_line_styles	../../libs/libeasygl/src/graphics.cpp	/^static const int win32_line_styles[2] = {PS_SOLID, PS_DASH};$/;"	v	file:
win32_mouseclick_ptr	../../libs/libeasygl/src/graphics.cpp	/^static void (*win32_mouseclick_ptr)(float x, float y, t_event_buttonPressed button_info);$/;"	v	file:
win32_mousemove_ptr	../../libs/libeasygl/src/graphics.cpp	/^static void (*win32_mousemove_ptr)(float x, float y);$/;"	v	file:
win32_reset_state	../../libs/libeasygl/src/graphics.cpp	/^static void win32_reset_state() {$/;"	f	file:	signature:()
win32_reset_state	../../libs/libeasygl/src/graphics.cpp	/^static void win32_reset_state();$/;"	p	file:	signature:()
windowAdjustFlag	../../libs/libeasygl/src/graphics_state.h	/^    t_window_button_state windowAdjustFlag;$/;"	m	class:t_win32_state	access:public
wire	../../libs/libarchfpga/src/physical_types.h	/^	} wire;$/;"	m	struct:t_port_power	typeref:union:t_port_power::__anon13	access:public
wire	route/build_switchblocks.cpp	/^    int wire;           \/\/Wire index within the channel$/;"	m	struct:t_wire_switchpoint	file:	access:public
wire_homogeneity	route/cb_metrics.h	/^	float wire_homogeneity;$/;"	m	class:Conn_Block_Metrics	access:public
wire_to_arch_ipin_switch	base/vpr_types.h	/^	int wire_to_arch_ipin_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
wire_to_rr_ipin_switch	base/vpr_types.h	/^	int wire_to_rr_ipin_switch;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
wire_type	../../libs/libarchfpga/src/physical_types.h	/^	e_power_wire_type wire_type;$/;"	m	struct:t_port_power	access:public
wire_types_used_count	route/cb_metrics.h	/^	t_3d_int_vec wire_types_used_count;	\/* [0..3][0..num_pins_on_side-1][0..num_wire_types-1]. Keeps track of how many times each pin connects to each of the wire types *\/$/;"	m	class:Conn_Block_Metrics	access:public
wireconns	../../libs/libarchfpga/src/physical_types.h	/^	std::vector<t_wireconn_inf> wireconns;	\/* list of wire types\/groups this SB will connect *\/$/;"	m	struct:t_switchblock_inf	access:public
wirelength	base/place_and_route.h	/^	int wirelength; \/* corresponding wirelength of successful routing at wneed *\/$/;"	m	struct:t_fmap_cell	access:public
wneed	base/place_and_route.h	/^	int wneed; \/* need wneed to route *\/$/;"	m	struct:t_fmap_cell	access:public
word_t	../../libs/libvtrutil/src/picosha2.h	/^typedef unsigned long word_t;$/;"	t	namespace:picosha2
world_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^t_bound_box world_to_scrn(const t_bound_box& \/*box*\/) {$/;"	f	signature:(const t_bound_box& )
world_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^t_bound_box world_to_scrn(const t_bound_box& box) {$/;"	f	signature:(const t_bound_box& box)
world_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^t_point world_to_scrn(const t_point& \/*point*\/) {$/;"	f	signature:(const t_point& )
world_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^t_point world_to_scrn(const t_point& point) {$/;"	f	signature:(const t_point& point)
world_to_scrn	../../libs/libeasygl/src/graphics.h	/^t_bound_box world_to_scrn(const t_bound_box& box);$/;"	p	signature:(const t_bound_box& box)
world_to_scrn	../../libs/libeasygl/src/graphics.h	/^t_point world_to_scrn(const t_point& point);$/;"	p	signature:(const t_point& point)
worst_overuse	route/route_timing.cpp	/^    size_t worst_overuse() const {$/;"	f	class:OveruseInfo	access:public	signature:() const
worst_overuse_	route/route_timing.cpp	/^    size_t worst_overuse_;$/;"	m	class:OveruseInfo	file:	access:private
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2, char_t d3)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_writer_file::write(const void* data, size_t size)$/;"	f	class:pugi::xml_writer_file	signature:(const void* data, size_t size)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN void xml_writer_stream::write(const void* data, size_t size)$/;"	f	class:pugi::xml_writer_stream	signature:(const void* data, size_t size)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual void write(const void* data, size_t size) = 0;$/;"	p	class:pugi::xml_writer	access:public	signature:(const void* data, size_t size)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual void write(const void* data, size_t size);$/;"	p	class:pugi::xml_writer_file	access:public	signature:(const void* data, size_t size)
write	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual void write(const void* data, size_t size);$/;"	p	class:pugi::xml_writer_stream	access:public	signature:(const void* data, size_t size)
write_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write_buffer(const char_t* data, size_t length)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data, size_t length)
write_data_bit_length	../../libs/libvtrutil/src/picosha2.h	/^	void write_data_bit_length(byte_t* begin) {$/;"	f	class:picosha2::hash256_one_by_one	access:private	signature:(byte_t* begin)
write_direct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write_direct(const char_t* data, size_t length)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data, size_t length)
write_hmetis_graph	pack/hmetis_graph_writer.cpp	/^void write_hmetis_graph(std::string &file_name) {$/;"	f	signature:(std::string &file_name)
write_hmetis_graph	pack/hmetis_graph_writer.h	/^void write_hmetis_graph(std::string &file_name);$/;"	p	signature:(std::string &file_name)
write_place_macros	place/place_macro.cpp	/^static void write_place_macros(std::string filename, const t_pl_macro *macros, int num_macros) {$/;"	f	file:	signature:(std::string filename, const t_pl_macro *macros, int num_macros)
write_place_macros	place/place_macro.cpp	/^static void write_place_macros(std::string filename, const t_pl_macro* macros, int num_macros);$/;"	p	file:	signature:(std::string filename, const t_pl_macro* macros, int num_macros)
write_rr_block_types	route/rr_graph_writer.cpp	/^void write_rr_block_types(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_rr_block_types	route/rr_graph_writer.cpp	/^void write_rr_block_types(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_rr_channel	route/rr_graph_writer.cpp	/^void write_rr_channel(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_rr_channel	route/rr_graph_writer.cpp	/^void write_rr_channel(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_rr_edges	route/rr_graph_writer.cpp	/^void write_rr_edges(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_rr_edges	route/rr_graph_writer.cpp	/^void write_rr_edges(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_rr_graph	route/rr_graph_writer.cpp	/^void write_rr_graph(const char *file_name, const t_segment_inf *segment_inf, const int num_seg_types) {$/;"	f	signature:(const char *file_name, const t_segment_inf *segment_inf, const int num_seg_types)
write_rr_graph	route/rr_graph_writer.h	/^void write_rr_graph(const char *file_name, const t_segment_inf* segment_inf, const int num_seg_types);$/;"	p	signature:(const char *file_name, const t_segment_inf* segment_inf, const int num_seg_types)
write_rr_graph_file	base/read_options.h	/^    argparse::ArgValue<std::string> write_rr_graph_file;$/;"	m	struct:t_options	access:public
write_rr_graph_filename	base/vpr_types.h	/^    std::string write_rr_graph_filename;$/;"	m	struct:ScreenUpdatePriority::t_det_routing_arch	access:public
write_rr_grid	route/rr_graph_writer.cpp	/^void write_rr_grid(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_rr_grid	route/rr_graph_writer.cpp	/^void write_rr_grid(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_rr_node	route/rr_graph_writer.cpp	/^void write_rr_node(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_rr_node	route/rr_graph_writer.cpp	/^void write_rr_node(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_rr_segments	route/rr_graph_writer.cpp	/^void write_rr_segments(fstream &fp, const t_segment_inf *segment_inf, const int num_seg_types) {$/;"	f	signature:(fstream &fp, const t_segment_inf *segment_inf, const int num_seg_types)
write_rr_segments	route/rr_graph_writer.cpp	/^void write_rr_segments(fstream &fp, const t_segment_inf *segment_inf, const int num_seg_types);$/;"	p	file:	signature:(fstream &fp, const t_segment_inf *segment_inf, const int num_seg_types)
write_rr_switches	route/rr_graph_writer.cpp	/^void write_rr_switches(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_rr_switches	route/rr_graph_writer.cpp	/^void write_rr_switches(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write_string(const char_t* data)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data)
write_unweighted_edges	pack/hmetis_graph_writer.cpp	/^void write_unweighted_edges(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_unweighted_edges	pack/hmetis_graph_writer.cpp	/^void write_unweighted_edges(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_weighted_edges	pack/hmetis_graph_writer.cpp	/^void write_weighted_edges(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_weighted_edges	pack/hmetis_graph_writer.cpp	/^void write_weighted_edges(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
write_weighted_vertices	pack/hmetis_graph_writer.cpp	/^void write_weighted_vertices(fstream &fp) {$/;"	f	signature:(fstream &fp)
write_weighted_vertices	pack/hmetis_graph_writer.cpp	/^void write_weighted_vertices(fstream &fp);$/;"	p	file:	signature:(fstream &fp)
writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf16_writer writer;$/;"	t	struct:wchar_selector	file:	access:public
writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		typedef utf32_writer writer;$/;"	t	struct:wchar_selector	file:	access:public
writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_writer& writer;$/;"	m	class:xml_buffered_writer	file:	access:public
wtos_xmult	../../libs/libeasygl/src/graphics.cpp	/^    float wtos_xmult, wtos_ymult;$/;"	m	struct:__anon20	file:	access:public
wtos_ymult	../../libs/libeasygl/src/graphics.cpp	/^    float wtos_xmult, wtos_ymult;$/;"	m	struct:__anon20	file:	access:public
x	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_spec x;      \/\/Horizontal location specification$/;"	m	struct:t_grid_loc_def	access:public
x	../../libs/libeasygl/src/graphics_types.h	/^    float x = 0;$/;"	m	class:t_point	access:public
x	../../libs/libvtrutil/src/vtr_geometry.h	/^        T x() const;$/;"	p	class:vtr::Point	access:public	signature:() const
x	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Point<T>::x() const {$/;"	f	class:vtr::Point	signature:() const
x	base/vpr_types.h	/^	int x;$/;"	m	struct:ScreenUpdatePriority::t_legal_pos	access:public
x	base/vpr_types.h	/^    int x = OPEN;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
x11_build_textarea	../../libs/libeasygl/src/graphics.cpp	/^static void x11_build_textarea() {$/;"	f	file:	signature:()
x11_build_textarea	../../libs/libeasygl/src/graphics.cpp	/^static void x11_build_textarea();$/;"	p	file:	signature:()
x11_convert_to_xcolor	../../libs/libeasygl/src/graphics.cpp	/^static unsigned long x11_convert_to_xcolor (t_color color);$/;"	p	file:	signature:(t_color color)
x11_convert_to_xcolor	../../libs/libeasygl/src/graphics.cpp	/^static unsigned long x11_convert_to_xcolor (t_color rgb_color) {$/;"	f	file:	signature:(t_color rgb_color)
x11_drawbut	../../libs/libeasygl/src/graphics.cpp	/^static void x11_drawbut(int bnum) {$/;"	f	file:	signature:(int bnum)
x11_drawbut	../../libs/libeasygl/src/graphics.cpp	/^static void x11_drawbut(int bnum);$/;"	p	file:	signature:(int bnum)
x11_drawmenu	../../libs/libeasygl/src/graphics.cpp	/^static void x11_drawmenu() {$/;"	f	file:	signature:()
x11_drawmenu	../../libs/libeasygl/src/graphics.cpp	/^static void x11_drawmenu();$/;"	p	file:	signature:()
x11_drop_redundant_panning	../../libs/libeasygl/src/graphics.cpp	/^static bool x11_drop_redundant_panning (const XEvent& report,$/;"	f	file:	signature:(const XEvent& report, unsigned int& last_skipped_button_press_button)
x11_drop_redundant_panning	../../libs/libeasygl/src/graphics.cpp	/^static bool x11_drop_redundant_panning (const XEvent& report,$/;"	p	file:	signature:(const XEvent& report, unsigned int& last_skipped_button_press_button)
x11_event_loop	../../libs/libeasygl/src/graphics.cpp	/^static void x11_event_loop(void (*act_on_mousebutton)$/;"	p	file:	signature:(void (*act_on_mousebutton) (float x, float y, t_event_buttonPressed button_info), void (*act_on_mousemove)(float x, float y), void (*act_on_keypress)(char key_pressed, int keysym), void (*drawscreen) ())
x11_event_loop	../../libs/libeasygl/src/graphics.cpp	/^x11_event_loop(void (*act_on_mousebutton)(float x, float y, t_event_buttonPressed button_info),$/;"	f	file:	signature:(void (*act_on_mousebutton)(float x, float y, t_event_buttonPressed button_info), void (*act_on_mousemove)(float x, float y), void (*act_on_keypress)(char key_pressed, int keysym), void (*drawscreen) ())
x11_handle_button_info	../../libs/libeasygl/src/graphics.cpp	/^static void x11_handle_button_info(t_event_buttonPressed *button_info,$/;"	f	file:	signature:(t_event_buttonPressed *button_info, int buttonNumber, int Xbutton_state)
x11_handle_button_info	../../libs/libeasygl/src/graphics.cpp	/^static void x11_handle_button_info(t_event_buttonPressed *button_info,$/;"	p	file:	signature:(t_event_buttonPressed *button_info, int buttonNumber, int Xbutton_state)
x11_handle_configure_notify	../../libs/libeasygl/src/graphics.cpp	/^static void x11_handle_configure_notify(const XEvent& report, void (*drawscreen) ()) {$/;"	f	file:	signature:(const XEvent& report, void (*drawscreen) ())
x11_handle_configure_notify	../../libs/libeasygl/src/graphics.cpp	/^static void x11_handle_configure_notify(const XEvent& report, void (*drawscreen) ());$/;"	p	file:	signature:(const XEvent& report, void (*drawscreen) ())
x11_handle_expose	../../libs/libeasygl/src/graphics.cpp	/^static void x11_handle_expose(const XEvent& report, void (*drawscreen) ()) {$/;"	f	file:	signature:(const XEvent& report, void (*drawscreen) ())
x11_handle_expose	../../libs/libeasygl/src/graphics.cpp	/^static void x11_handle_expose(const XEvent& report, void (*drawscreen) ());$/;"	p	file:	signature:(const XEvent& report, void (*drawscreen) ())
x11_init_graphics	../../libs/libeasygl/src/graphics.cpp	/^static void x11_init_graphics(const char *window_name) {$/;"	f	file:	signature:(const char *window_name)
x11_init_graphics	../../libs/libeasygl/src/graphics.cpp	/^static void x11_init_graphics(const char* window_name);$/;"	p	file:	signature:(const char* window_name)
x11_redraw_all_if_needed	../../libs/libeasygl/src/graphics.cpp	/^static void x11_redraw_all_if_needed (void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
x11_redraw_all_if_needed	../../libs/libeasygl/src/graphics.cpp	/^static void x11_redraw_all_if_needed (void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
x11_state	../../libs/libeasygl/src/graphics.cpp	/^t_x11_state x11_state;$/;"	v
x11_test_if_exposed	../../libs/libeasygl/src/graphics.cpp	/^static Bool x11_test_if_exposed(Display *disp, XEvent *event_ptr, XPointer dummy) {$/;"	f	file:	signature:(Display *disp, XEvent *event_ptr, XPointer dummy)
x11_test_if_exposed	../../libs/libeasygl/src/graphics.cpp	/^static Bool x11_test_if_exposed(Display *disp, XEvent *event_ptr,$/;"	p	file:	signature:(Display *disp, XEvent *event_ptr, XPointer dummy)
x11_turn_on_off	../../libs/libeasygl/src/graphics.cpp	/^static void x11_turn_on_off(int pressed) {$/;"	f	file:	signature:(int pressed)
x11_turn_on_off	../../libs/libeasygl/src/graphics.cpp	/^static void x11_turn_on_off(int pressed);$/;"	p	file:	signature:(int pressed)
x11_which_button	../../libs/libeasygl/src/graphics.cpp	/^static int x11_which_button(Window win) {$/;"	f	file:	signature:(Window win)
x11_which_button	../../libs/libeasygl/src/graphics.cpp	/^static int x11_which_button(Window win);$/;"	p	file:	signature:(Window win)
x_	../../libs/libvtrutil/src/vtr_geometry.h	/^        T x_;$/;"	m	class:vtr::Point	access:private
x_coord	route/build_switchblocks.h	/^	int x_coord;		\/* x coordinate of switchblock connection *\/	\/\/TODO: redundant comment?? add range$/;"	m	class:Switchblock_Lookup	access:public
x_list	base/vpr_types.h	/^    std::vector<int> x_list;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
x_max	base/vpr_types.h	/^	int x_max = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
x_min	base/vpr_types.h	/^	int x_min = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
x_offset	../../libs/libarchfpga/src/physical_types.h	/^	int x_offset;$/;"	m	struct:t_direct_inf	access:public
x_offset	place/place_macro.h	/^	int x_offset;$/;"	m	struct:t_pl_macro_member	access:public
x_to_post	../../libs/libeasygl/src/graphics.cpp	/^static float x_to_post(float worldx);$/;"	p	file:	signature:(float worldx)
x_to_post	../../libs/libeasygl/src/graphics.cpp	/^static float x_to_post(float x) {$/;"	f	file:	signature:(float x)
xft_currentcolor	../../libs/libeasygl/src/graphics_state.h	/^    XftColor xft_currentcolor;$/;"	m	class:t_x11_state	access:public
xft_menutextcolor	../../libs/libeasygl/src/graphics_state.h	/^    XftColor xft_menutextcolor;$/;"	m	class:t_x11_state	access:public
xhigh	route/rr_node.cpp	/^short t_rr_node::xhigh() const {$/;"	f	class:t_rr_node	signature:() const
xhigh	route/rr_node.h	/^        short xhigh() const;$/;"	p	class:t_rr_node	access:public	signature:() const
xhigh_	route/rr_node.h	/^        int16_t xhigh_ = -1;$/;"	m	class:t_rr_node	access:private
xleft	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
xleft	../../libs/libeasygl/src/graphics.cpp	/^    int xleft;$/;"	m	struct:__anon18	file:	access:public
xleft	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
xlow	route/rr_node.cpp	/^short t_rr_node::xlow() const {$/;"	f	class:t_rr_node	signature:() const
xlow	route/rr_node.h	/^        short xlow() const;$/;"	p	class:t_rr_node	access:public	signature:() const
xlow_	route/rr_node.h	/^        int16_t xlow_ = -1;$/;"	m	class:t_rr_node	access:private
xmax	../../libs/libvtrutil/src/vtr_geometry.h	/^        T xmax() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
xmax	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::xmax() const {$/;"	f	class:vtr::Rect	signature:() const
xmax	base/vpr_types.h	/^	int xmax;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
xmin	../../libs/libvtrutil/src/vtr_geometry.h	/^        T xmin() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
xmin	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::xmin() const {$/;"	f	class:vtr::Rect	signature:() const
xmin	base/vpr_types.h	/^	int xmin;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
xml_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator(xml_memory_page* root): _root(root), _busy_size(root->busy_size)$/;"	f	struct:xml_allocator	access:public	signature:(xml_memory_page* root)
xml_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_allocator$/;"	s	file:
xml_allocator::_busy_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _busy_size;$/;"	m	struct:xml_allocator	file:	access:public
xml_allocator::_hash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_hash_table* _hash;$/;"	m	struct:xml_allocator	file:	access:public
xml_allocator::_root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* _root;$/;"	m	struct:xml_allocator	file:	access:public
xml_allocator::allocate_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_memory(size_t size, xml_memory_page*& out_page)$/;"	f	struct:xml_allocator	access:public	signature:(size_t size, xml_memory_page*& out_page)
xml_allocator::allocate_memory_oob	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_memory_oob(size_t size, xml_memory_page*& out_page);$/;"	p	struct:xml_allocator	file:	access:public	signature:(size_t size, xml_memory_page*& out_page)
xml_allocator::allocate_memory_oob	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE void* xml_allocator::allocate_memory_oob(size_t size, xml_memory_page*& out_page)$/;"	f	class:xml_allocator	signature:(size_t size, xml_memory_page*& out_page)
xml_allocator::allocate_object	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_object(size_t size, xml_memory_page*& out_page)$/;"	f	struct:xml_allocator	access:public	signature:(size_t size, xml_memory_page*& out_page)
xml_allocator::allocate_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* allocate_page(size_t data_size)$/;"	f	struct:xml_allocator	access:public	signature:(size_t data_size)
xml_allocator::allocate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* allocate_string(size_t length)$/;"	f	struct:xml_allocator	access:public	signature:(size_t length)
xml_allocator::deallocate_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void deallocate_memory(void* ptr, size_t size, xml_memory_page* page)$/;"	f	struct:xml_allocator	access:public	signature:(void* ptr, size_t size, xml_memory_page* page)
xml_allocator::deallocate_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void deallocate_page(xml_memory_page* page)$/;"	f	struct:xml_allocator	access:public	signature:(xml_memory_page* page)
xml_allocator::deallocate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void deallocate_string(char_t* string)$/;"	f	struct:xml_allocator	access:public	signature:(char_t* string)
xml_allocator::reserve	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool reserve()$/;"	f	struct:xml_allocator	access:public	signature:()
xml_allocator::xml_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator(xml_memory_page* root): _root(root), _busy_size(root->busy_size)$/;"	f	struct:xml_allocator	access:public	signature:(xml_memory_page* root)
xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute::xml_attribute(): _attr(0)$/;"	f	class:pugi::xml_attribute	signature:()
xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute::xml_attribute(xml_attribute_struct* attr): _attr(attr)$/;"	f	class:pugi::xml_attribute	signature:(xml_attribute_struct* attr)
xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xml_attribute(xml_attribute_struct* attr);$/;"	p	class:pugi::xml_attribute	access:public	signature:(xml_attribute_struct* attr)
xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute();$/;"	p	class:pugi::xml_attribute	access:public	signature:()
xml_attribute	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_attribute$/;"	c	namespace:pugi
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator()$/;"	f	class:pugi::xml_attribute_iterator	signature:()
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent): _wrap(attr), _parent(parent)$/;"	f	class:pugi::xml_attribute_iterator	signature:(const xml_attribute& attr, const xml_node& parent)
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)$/;"	f	class:pugi::xml_attribute_iterator	signature:(xml_attribute_struct* ref, xml_node_struct* parent)
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator();$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:()
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent);$/;"	p	class:pugi::xml_attribute_iterator	access:public	signature:(const xml_attribute& attr, const xml_node& parent)
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent);$/;"	p	class:pugi::xml_attribute_iterator	access:private	signature:(xml_attribute_struct* ref, xml_node_struct* parent)
xml_attribute_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_attribute_iterator$/;"	c	namespace:pugi
xml_attribute_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_attribute_struct(impl::xml_memory_page* page): header(page, 0), namevalue_base(0)$/;"	f	struct:pugi::xml_attribute_struct	access:public	signature:(impl::xml_memory_page* page)
xml_attribute_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_attribute_struct$/;"	s	namespace:pugi	file:
xml_buffered_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_buffered_writer(const xml_buffered_writer&);$/;"	p	class:xml_buffered_writer	file:	access:private	signature:(const xml_buffered_writer&)
xml_buffered_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_buffered_writer(xml_writer& writer_, xml_encoding user_encoding): writer(writer_), bufsize(0), encoding(get_write_encoding(user_encoding))$/;"	f	class:xml_buffered_writer	access:public	signature:(xml_writer& writer_, xml_encoding user_encoding)
xml_buffered_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class xml_buffered_writer$/;"	c	file:
xml_buffered_writer::__anon28::data_char	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			char_t data_char[bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
xml_buffered_writer::__anon28::data_u16	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			uint16_t data_u16[2 * bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
xml_buffered_writer::__anon28::data_u32	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			uint32_t data_u32[bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
xml_buffered_writer::__anon28::data_u8	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			uint8_t data_u8[4 * bufcapacity];$/;"	m	union:xml_buffered_writer::__anon28	file:	access:public
xml_buffered_writer::bufcapacity	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			bufcapacity = bufcapacitybytes \/ (sizeof(char_t) + 4)$/;"	e	enum:xml_buffered_writer::__anon27	file:
xml_buffered_writer::bufcapacitybytes	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			bufcapacitybytes =$/;"	e	enum:xml_buffered_writer::__anon27	file:
xml_buffered_writer::buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t buffer[bufcapacity];$/;"	m	class:xml_buffered_writer	file:	access:public
xml_buffered_writer::bufsize	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t bufsize;$/;"	m	class:xml_buffered_writer	file:	access:public
xml_buffered_writer::encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_encoding encoding;$/;"	m	class:xml_buffered_writer	file:	access:public
xml_buffered_writer::flush	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t flush()$/;"	f	class:xml_buffered_writer	access:public	signature:()
xml_buffered_writer::flush	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void flush(const char_t* data, size_t size)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data, size_t size)
xml_buffered_writer::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_buffered_writer& operator=(const xml_buffered_writer&);$/;"	p	class:xml_buffered_writer	file:	access:private	signature:(const xml_buffered_writer&)
xml_buffered_writer::scratch	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		} scratch;$/;"	m	class:xml_buffered_writer	typeref:union:xml_buffered_writer::__anon28	file:	access:public
xml_buffered_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0)
xml_buffered_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1)
xml_buffered_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2)
xml_buffered_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2, char_t d3)
xml_buffered_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)
xml_buffered_writer::write	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)$/;"	f	class:xml_buffered_writer	access:public	signature:(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)
xml_buffered_writer::write_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write_buffer(const char_t* data, size_t length)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data, size_t length)
xml_buffered_writer::write_direct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write_direct(const char_t* data, size_t length)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data, size_t length)
xml_buffered_writer::write_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void write_string(const char_t* data)$/;"	f	class:xml_buffered_writer	access:public	signature:(const char_t* data)
xml_buffered_writer::writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_writer& writer;$/;"	m	class:xml_buffered_writer	file:	access:public
xml_buffered_writer::xml_buffered_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_buffered_writer(const xml_buffered_writer&);$/;"	p	class:xml_buffered_writer	file:	access:private	signature:(const xml_buffered_writer&)
xml_buffered_writer::xml_buffered_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_buffered_writer(xml_writer& writer_, xml_encoding user_encoding): writer(writer_), bufsize(0), encoding(get_write_encoding(user_encoding))$/;"	f	class:xml_buffered_writer	access:public	signature:(xml_writer& writer_, xml_encoding user_encoding)
xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_document::xml_document(): _buffer(0)$/;"	f	class:pugi::xml_document	signature:()
xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_document();$/;"	p	class:pugi::xml_document	access:public	signature:()
xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_document(const xml_document&);$/;"	p	class:pugi::xml_document	access:private	signature:(const xml_document&)
xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_document: public xml_node$/;"	c	namespace:pugi	inherits:xml_node
xml_document_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_document_struct(xml_memory_page* page): xml_node_struct(page, node_document), xml_allocator(page), buffer(0), extra_buffers(0)$/;"	f	struct:xml_document_struct	access:public	signature:(xml_memory_page* page)
xml_document_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_document_struct: public xml_node_struct, public xml_allocator$/;"	s	file:	inherits:xml_node_struct,xml_allocator
xml_document_struct::buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* buffer;$/;"	m	struct:xml_document_struct	file:	access:public
xml_document_struct::extra_buffers	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_extra_buffer* extra_buffers;$/;"	m	struct:xml_document_struct	file:	access:public
xml_document_struct::hash	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		compact_hash_table hash;$/;"	m	struct:xml_document_struct	file:	access:public
xml_document_struct::xml_document_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_document_struct(xml_memory_page* page): xml_node_struct(page, node_document), xml_allocator(page), buffer(0), extra_buffers(0)$/;"	f	struct:xml_document_struct	access:public	signature:(xml_memory_page* page)
xml_encoding	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xml_encoding$/;"	g	namespace:pugi
xml_extra_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_extra_buffer$/;"	s	file:
xml_extra_buffer::buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* buffer;$/;"	m	struct:xml_extra_buffer	file:	access:public
xml_extra_buffer::next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_extra_buffer* next;$/;"	m	struct:xml_extra_buffer	file:	access:public
xml_memory	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	typedef xml_memory_management_function_storage<int> xml_memory;$/;"	t	file:
xml_memory_block_alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_block_alignment = 4;$/;"	v	file:
xml_memory_block_alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_block_alignment = sizeof(void*);$/;"	v	file:
xml_memory_management_function_storage	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_memory_management_function_storage$/;"	s	file:
xml_memory_management_function_storage::allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static allocation_function allocate;$/;"	m	struct:xml_memory_management_function_storage	file:	access:public
xml_memory_management_function_storage::allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> allocation_function xml_memory_management_function_storage<T>::allocate = default_allocate;$/;"	m	class:xml_memory_management_function_storage	file:
xml_memory_management_function_storage::deallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static deallocation_function deallocate;$/;"	m	struct:xml_memory_management_function_storage	file:	access:public
xml_memory_management_function_storage::deallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> deallocation_function xml_memory_management_function_storage<T>::deallocate = default_deallocate;$/;"	m	class:xml_memory_management_function_storage	file:
xml_memory_page	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_memory_page$/;"	s	file:
xml_memory_page::allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator* allocator;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::busy_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t busy_size;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::compact_page_marker	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint32_t* compact_page_marker;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::compact_shared_parent	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* compact_shared_parent;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::compact_string_base	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* compact_string_base;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::construct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xml_memory_page* construct(void* memory)$/;"	f	struct:xml_memory_page	access:public	signature:(void* memory)
xml_memory_page::freed_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t freed_size;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* next;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page::prev	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_memory_page* prev;$/;"	m	struct:xml_memory_page	file:	access:public
xml_memory_page_alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_alignment = 64;$/;"	v	file:
xml_memory_page_alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_alignment = sizeof(void*);$/;"	v	file:
xml_memory_page_contents_shared_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_contents_shared_mask = 32;$/;"	v	file:
xml_memory_page_name_allocated_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_name_allocated_mask = 16;$/;"	v	file:
xml_memory_page_name_allocated_or_shared_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_name_allocated_or_shared_mask = xml_memory_page_name_allocated_mask | xml_memory_page_contents_shared_mask;$/;"	v	file:
xml_memory_page_pointer_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_pointer_mask = ~(xml_memory_page_alignment - 1);$/;"	v	file:
xml_memory_page_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const size_t xml_memory_page_size =$/;"	v	file:
xml_memory_page_type_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_type_mask = 7;$/;"	v	file:
xml_memory_page_value_allocated_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_value_allocated_mask = 8;$/;"	v	file:
xml_memory_page_value_allocated_or_shared_mask	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xml_memory_page_value_allocated_or_shared_mask = xml_memory_page_value_allocated_mask | xml_memory_page_contents_shared_mask;$/;"	v	file:
xml_memory_string_header	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_memory_string_header$/;"	s	file:
xml_memory_string_header::full_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t full_size; \/\/ 0 if string occupies whole page$/;"	m	struct:xml_memory_string_header	file:	access:public
xml_memory_string_header::page_offset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		uint16_t page_offset; \/\/ offset from page->data$/;"	m	struct:xml_memory_string_header	file:	access:public
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(): _name(0)$/;"	f	class:pugi::xml_named_node_iterator	signature:()
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(const xml_node& node, const char_t* name): _wrap(node), _parent(node.parent()), _name(name)$/;"	f	class:pugi::xml_named_node_iterator	signature:(const xml_node& node, const char_t* name)
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name): _wrap(ref), _parent(parent), _name(name)$/;"	f	class:pugi::xml_named_node_iterator	signature:(xml_node_struct* ref, xml_node_struct* parent, const char_t* name)
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator();$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:()
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator(const xml_node& node, const char_t* name);$/;"	p	class:pugi::xml_named_node_iterator	access:public	signature:(const xml_node& node, const char_t* name)
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name);$/;"	p	class:pugi::xml_named_node_iterator	access:private	signature:(xml_node_struct* ref, xml_node_struct* parent, const char_t* name)
xml_named_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_named_node_iterator$/;"	c	namespace:pugi
xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::xml_node(): _root(0)$/;"	f	class:pugi::xml_node	signature:()
xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node::xml_node(xml_node_struct* p): _root(p)$/;"	f	class:pugi::xml_node	signature:(xml_node_struct* p)
xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xml_node(xml_node_struct* p);$/;"	p	class:pugi::xml_node	access:public	signature:(xml_node_struct* p)
xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node();$/;"	p	class:pugi::xml_node	access:public	signature:()
xml_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_node$/;"	c	namespace:pugi
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator::xml_node_iterator()$/;"	f	class:pugi::xml_node_iterator	signature:()
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator::xml_node_iterator(const xml_node& node): _wrap(node), _parent(node.parent())$/;"	f	class:pugi::xml_node_iterator	signature:(const xml_node& node)
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_node_iterator::xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)$/;"	f	class:pugi::xml_node_iterator	signature:(xml_node_struct* ref, xml_node_struct* parent)
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator();$/;"	p	class:pugi::xml_node_iterator	access:public	signature:()
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator(const xml_node& node);$/;"	p	class:pugi::xml_node_iterator	access:public	signature:(const xml_node& node)
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent);$/;"	p	class:pugi::xml_node_iterator	access:private	signature:(xml_node_struct* ref, xml_node_struct* parent)
xml_node_iterator	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_node_iterator$/;"	c	namespace:pugi
xml_node_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): header(page, type - 1), namevalue_base(0)$/;"	f	struct:pugi::xml_node_struct	access:public	signature:(impl::xml_memory_page* page, xml_node_type type)
xml_node_struct	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_node_struct$/;"	s	namespace:pugi	file:
xml_node_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xml_node_type$/;"	g	namespace:pugi
xml_object_range	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_object_range(It b, It e): _begin(b), _end(e)$/;"	f	class:pugi::xml_object_range	access:public	signature:(It b, It e)
xml_object_range	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	template <typename It> class xml_object_range$/;"	c	namespace:pugi
xml_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_parse_result::xml_parse_result(): status(status_internal_error), offset(0), encoding(encoding_auto)$/;"	f	class:pugi::xml_parse_result	signature:()
xml_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_parse_result();$/;"	p	struct:pugi::xml_parse_result	access:public	signature:()
xml_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	struct PUGIXML_CLASS xml_parse_result$/;"	s	namespace:pugi
xml_parse_status	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xml_parse_status$/;"	g	namespace:pugi
xml_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_parser(xml_allocator* alloc_): alloc(*alloc_), alloc_state(alloc_), error_offset(0), error_status(status_ok)$/;"	f	struct:xml_parser	access:public	signature:(xml_allocator* alloc_)
xml_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xml_parser$/;"	s	file:
xml_parser::alloc	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator alloc;$/;"	m	struct:xml_parser	file:	access:public
xml_parser::alloc_state	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_allocator* alloc_state;$/;"	m	struct:xml_parser	file:	access:public
xml_parser::error_offset	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* error_offset;$/;"	m	struct:xml_parser	file:	access:public
xml_parser::error_status	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_parse_status error_status;$/;"	m	struct:xml_parser	file:	access:public
xml_parser::has_element_node_siblings	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static bool has_element_node_siblings(xml_node_struct* node)$/;"	f	struct:xml_parser	access:public	signature:(xml_node_struct* node)
xml_parser::parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xml_parse_result parse(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)$/;"	f	struct:xml_parser	access:public	signature:(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)
xml_parser::parse_doctype_group	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_doctype_group(char_t* s, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, char_t endch)
xml_parser::parse_doctype_ignore	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_doctype_ignore(char_t* s)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s)
xml_parser::parse_doctype_primitive	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_doctype_primitive(char_t* s)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s)
xml_parser::parse_exclamation	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)
xml_parser::parse_question	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_question(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)
xml_parser::parse_skip_bom	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* parse_skip_bom(char_t* s)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s)
xml_parser::parse_tree	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* parse_tree(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser	access:public	signature:(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)
xml_parser::xml_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_parser(xml_allocator* alloc_): alloc(*alloc_), alloc_state(alloc_), error_offset(0), error_status(status_ok)$/;"	f	struct:xml_parser	access:public	signature:(xml_allocator* alloc_)
xml_parser::~xml_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xml_parser()$/;"	f	struct:xml_parser	access:public	signature:()
xml_stream_chunk	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_stream_chunk(): next(0), size(0)$/;"	f	struct:xml_stream_chunk	access:public	signature:()
xml_stream_chunk	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	template <typename T> struct xml_stream_chunk$/;"	s	file:
xml_stream_chunk::create	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xml_stream_chunk* create()$/;"	f	struct:xml_stream_chunk	access:public	signature:()
xml_stream_chunk::data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		T data[xml_memory_page_size \/ sizeof(T)];$/;"	m	struct:xml_stream_chunk	file:	access:public
xml_stream_chunk::destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void destroy(xml_stream_chunk* chunk)$/;"	f	struct:xml_stream_chunk	access:public	signature:(xml_stream_chunk* chunk)
xml_stream_chunk::next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_stream_chunk* next;$/;"	m	struct:xml_stream_chunk	file:	access:public
xml_stream_chunk::size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t size;$/;"	m	struct:xml_stream_chunk	file:	access:public
xml_stream_chunk::xml_stream_chunk	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xml_stream_chunk(): next(0), size(0)$/;"	f	struct:xml_stream_chunk	access:public	signature:()
xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text::xml_text(): _root(0)$/;"	f	class:pugi::xml_text	signature:()
xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_text::xml_text(xml_node_struct* root): _root(root)$/;"	f	class:pugi::xml_text	signature:(xml_node_struct* root)
xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xml_text(xml_node_struct* root);$/;"	p	class:pugi::xml_text	access:private	signature:(xml_node_struct* root)
xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_text();$/;"	p	class:pugi::xml_text	access:public	signature:()
xml_text	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_text$/;"	c	namespace:pugi
xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_tree_walker::xml_tree_walker(): _depth(0)$/;"	f	class:pugi::xml_tree_walker	signature:()
xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_tree_walker();$/;"	p	class:pugi::xml_tree_walker	access:public	signature:()
xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_tree_walker$/;"	c	namespace:pugi
xml_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_writer$/;"	c	namespace:pugi
xml_writer_file	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_writer_file::xml_writer_file(void* file_): file(file_)$/;"	f	class:pugi::xml_writer_file	signature:(void* file_)
xml_writer_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_writer_file(void* file);$/;"	p	class:pugi::xml_writer_file	access:public	signature:(void* file)
xml_writer_file	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_writer_file: public xml_writer$/;"	c	namespace:pugi	inherits:xml_writer
xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream): narrow_stream(&stream), wide_stream(0)$/;"	f	class:pugi::xml_writer_stream	signature:(std::basic_ostream<char, std::char_traits<char> >& stream)
xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream): narrow_stream(0), wide_stream(&stream)$/;"	f	class:pugi::xml_writer_stream	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream)
xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream);$/;"	p	class:pugi::xml_writer_stream	access:public	signature:(std::basic_ostream<char, std::char_traits<char> >& stream)
xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);$/;"	p	class:pugi::xml_writer_stream	access:public	signature:(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream)
xml_writer_stream	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xml_writer_stream: public xml_writer$/;"	c	namespace:pugi	inherits:xml_writer
xmult	../../libs/libeasygl/src/graphics.h	/^    float xmult, ymult;$/;"	m	struct:__anon22	access:public
xnew	base/vpr_types.h	/^	int xnew;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
xold	base/vpr_types.h	/^	int xold;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
xpath_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator(xpath_memory_block* root, size_t root_size = 0): _root(root), _root_size(root_size)$/;"	f	class:xpath_allocator	access:public	signature:(xpath_memory_block* root, size_t root_size = 0)
xpath_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class xpath_allocator$/;"	c	file:
xpath_allocator::_root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block* _root;$/;"	m	class:xpath_allocator	file:	access:private
xpath_allocator::_root_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _root_size;$/;"	m	class:xpath_allocator	file:	access:private
xpath_allocator::allocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate(size_t size)$/;"	f	class:xpath_allocator	access:public	signature:(size_t size)
xpath_allocator::allocate_nothrow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* allocate_nothrow(size_t size)$/;"	f	class:xpath_allocator	access:public	signature:(size_t size)
xpath_allocator::error_handler	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		jmp_buf* error_handler;$/;"	m	class:xpath_allocator	file:	access:public
xpath_allocator::reallocate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* reallocate(void* ptr, size_t old_size, size_t new_size)$/;"	f	class:xpath_allocator	access:public	signature:(void* ptr, size_t old_size, size_t new_size)
xpath_allocator::release	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void release()$/;"	f	class:xpath_allocator	access:public	signature:()
xpath_allocator::revert	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void revert(const xpath_allocator& state)$/;"	f	class:xpath_allocator	access:public	signature:(const xpath_allocator& state)
xpath_allocator::xpath_allocator	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator(xpath_memory_block* root, size_t root_size = 0): _root(root), _root_size(root_size)$/;"	f	class:xpath_allocator	access:public	signature:(xpath_memory_block* root, size_t root_size = 0)
xpath_allocator_capture	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator_capture(xpath_allocator* alloc): _target(alloc), _state(*alloc)$/;"	f	struct:xpath_allocator_capture	access:public	signature:(xpath_allocator* alloc)
xpath_allocator_capture	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_allocator_capture$/;"	s	file:
xpath_allocator_capture::_state	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator _state;$/;"	m	struct:xpath_allocator_capture	file:	access:public
xpath_allocator_capture::_target	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* _target;$/;"	m	struct:xpath_allocator_capture	file:	access:public
xpath_allocator_capture::xpath_allocator_capture	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator_capture(xpath_allocator* alloc): _target(alloc), _state(*alloc)$/;"	f	struct:xpath_allocator_capture	access:public	signature:(xpath_allocator* alloc)
xpath_allocator_capture::~xpath_allocator_capture	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xpath_allocator_capture()$/;"	f	struct:xpath_allocator_capture	access:public	signature:()
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_ast_node* left, xpath_ast_node* right, predicate_t test):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_ast_node* left, xpath_ast_node* right, predicate_t test)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, const char_t* value):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, const char_t* value)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, double value):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, double value)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_variable* value):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, xpath_variable* value)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(const xpath_ast_node&);$/;"	p	class:xpath_ast_node	file:	access:private	signature:(const xpath_ast_node&)
xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class xpath_ast_node$/;"	c	file:
xpath_ast_node::__anon30::nodetest	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const char_t* nodetest;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
xpath_ast_node::__anon30::number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			double number;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
xpath_ast_node::__anon30::string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const char_t* string;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
xpath_ast_node::__anon30::table	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			const unsigned char* table;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
xpath_ast_node::__anon30::variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			xpath_variable* variable;$/;"	m	union:xpath_ast_node::__anon30	file:	access:public
xpath_ast_node::_axis	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _axis;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		} _data;$/;"	m	class:xpath_ast_node	typeref:union:xpath_ast_node::__anon30	file:	access:private
xpath_ast_node::_left	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* _left;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::_next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* _next;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::_rettype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _rettype;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::_right	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* _right;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::_test	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _test;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char _type;$/;"	m	class:xpath_ast_node	file:	access:private
xpath_ast_node::apply_predicate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void apply_predicate(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, bool once)
xpath_ast_node::apply_predicate_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void apply_predicate_boolean(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)
xpath_ast_node::apply_predicate_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void apply_predicate_number(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)
xpath_ast_node::apply_predicate_number_const	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void apply_predicate_number_const(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack)
xpath_ast_node::apply_predicates	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void apply_predicates(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, nodeset_eval_t eval)
xpath_ast_node::compare_eq	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class Comp> static bool compare_eq(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)
xpath_ast_node::compare_rel	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class Comp> static bool compare_rel(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)
xpath_ast_node::eval_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool eval_boolean(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
xpath_ast_node::eval_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set_raw eval_node_set(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval)
xpath_ast_node::eval_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		double eval_number(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
xpath_ast_node::eval_once	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static bool eval_once(xpath_node_set::type_t type, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set::type_t type, nodeset_eval_t eval)
xpath_ast_node::eval_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string eval_string(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
xpath_ast_node::eval_string_concat	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string eval_string_concat(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	access:public	signature:(const xpath_context& c, const xpath_stack& stack)
xpath_ast_node::is_posinv_expr	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool is_posinv_expr() const$/;"	f	class:xpath_ast_node	access:public	signature:() const
xpath_ast_node::is_posinv_step	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool is_posinv_step() const$/;"	f	class:xpath_ast_node	access:public	signature:() const
xpath_ast_node::operator =	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node& operator=(const xpath_ast_node&);$/;"	p	class:xpath_ast_node	file:	access:private	signature:(const xpath_ast_node&)
xpath_ast_node::optimize	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void optimize(xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_allocator* alloc)
xpath_ast_node::optimize_self	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void optimize_self(xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_allocator* alloc)
xpath_ast_node::rettype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_value_type rettype() const$/;"	f	class:xpath_ast_node	access:public	signature:() const
xpath_ast_node::set_next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void set_next(xpath_ast_node* value)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_ast_node* value)
xpath_ast_node::set_right	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void set_right(xpath_ast_node* value)$/;"	f	class:xpath_ast_node	access:public	signature:(xpath_ast_node* value)
xpath_ast_node::step_do	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> xpath_node_set_raw step_do(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval, T v)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval, T v)
xpath_ast_node::step_fill	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> void step_fill(xpath_node_set_raw& ns, const xpath_node& xn, xpath_allocator* alloc, bool once, T v)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, const xpath_node& xn, xpath_allocator* alloc, bool once, T v)
xpath_ast_node::step_fill	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> void step_fill(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* p, xpath_allocator* alloc, bool once, T v)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* p, xpath_allocator* alloc, bool once, T v)
xpath_ast_node::step_fill	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		template <class T> void step_fill(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc, bool once, T)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc, bool once, T)
xpath_ast_node::step_push	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool step_push(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* parent, xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* parent, xpath_allocator* alloc)
xpath_ast_node::step_push	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool step_push(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	file:	access:private	signature:(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_ast_node* left, xpath_ast_node* right, predicate_t test):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_ast_node* left, xpath_ast_node* right, predicate_t test)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, const char_t* value):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, const char_t* value)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, double value):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, double value)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_variable* value):$/;"	f	class:xpath_ast_node	access:public	signature:(ast_type_t type, xpath_value_type rettype_, xpath_variable* value)
xpath_ast_node::xpath_ast_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node(const xpath_ast_node&);$/;"	p	class:xpath_ast_node	file:	access:private	signature:(const xpath_ast_node&)
xpath_context	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_context(const xpath_node& n_, size_t position_, size_t size_): n(n_), position(position_), size(size_)$/;"	f	struct:xpath_context	access:public	signature:(const xpath_node& n_, size_t position_, size_t size_)
xpath_context	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_context$/;"	s	file:
xpath_context::n	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node n;$/;"	m	struct:xpath_context	file:	access:public
xpath_context::position	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t position, size;$/;"	m	struct:xpath_context	file:	access:public
xpath_context::size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t position, size;$/;"	m	struct:xpath_context	file:	access:public
xpath_context::xpath_context	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_context(const xpath_node& n_, size_t position_, size_t size_): n(n_), position(position_), size(size_)$/;"	f	struct:xpath_context	access:public	signature:(const xpath_node& n_, size_t position_, size_t size_)
xpath_exception	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_exception::xpath_exception(const xpath_parse_result& result_): _result(result_)$/;"	f	class:pugi::xpath_exception	signature:(const xpath_parse_result& result_)
xpath_exception	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xpath_exception(const xpath_parse_result& result);$/;"	p	class:pugi::xpath_exception	access:public	signature:(const xpath_parse_result& result)
xpath_exception	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_exception: public std::exception$/;"	c	namespace:pugi	inherits:std::exception
xpath_first	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node xpath_first(const xpath_node* begin, const xpath_node* end, xpath_node_set::type_t type)$/;"	f	signature:(const xpath_node* begin, const xpath_node* end, xpath_node_set::type_t type)
xpath_get_order	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::type_t xpath_get_order(const xpath_node* begin, const xpath_node* end)$/;"	f	signature:(const xpath_node* begin, const xpath_node* end)
xpath_lexer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		explicit xpath_lexer(const char_t* query): _cur(query)$/;"	f	class:xpath_lexer	access:public	signature:(const char_t* query)
xpath_lexer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class xpath_lexer$/;"	c	file:
xpath_lexer::_cur	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _cur;$/;"	m	class:xpath_lexer	file:	access:private
xpath_lexer::_cur_lexeme	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lexeme_t _cur_lexeme;$/;"	m	class:xpath_lexer	file:	access:private
xpath_lexer::_cur_lexeme_contents	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_lexer_string _cur_lexeme_contents;$/;"	m	class:xpath_lexer	file:	access:private
xpath_lexer::_cur_lexeme_pos	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _cur_lexeme_pos;$/;"	m	class:xpath_lexer	file:	access:private
xpath_lexer::contents	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const xpath_lexer_string& contents() const$/;"	f	class:xpath_lexer	access:public	signature:() const
xpath_lexer::current	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		lexeme_t current() const$/;"	f	class:xpath_lexer	access:public	signature:() const
xpath_lexer::current_pos	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* current_pos() const$/;"	f	class:xpath_lexer	access:public	signature:() const
xpath_lexer::next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void next()$/;"	f	class:xpath_lexer	access:public	signature:()
xpath_lexer::state	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* state() const$/;"	f	class:xpath_lexer	access:public	signature:() const
xpath_lexer::xpath_lexer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		explicit xpath_lexer(const char_t* query): _cur(query)$/;"	f	class:xpath_lexer	access:public	signature:(const char_t* query)
xpath_lexer_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_lexer_string(): begin(0), end(0)$/;"	f	struct:xpath_lexer_string	access:public	signature:()
xpath_lexer_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_lexer_string$/;"	s	file:
xpath_lexer_string::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* begin;$/;"	m	struct:xpath_lexer_string	file:	access:public
xpath_lexer_string::end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* end;$/;"	m	struct:xpath_lexer_string	file:	access:public
xpath_lexer_string::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator==(const char_t* other) const$/;"	f	struct:xpath_lexer_string	access:public	signature:(const char_t* other) const
xpath_lexer_string::xpath_lexer_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_lexer_string(): begin(0), end(0)$/;"	f	struct:xpath_lexer_string	access:public	signature:()
xpath_memory_block	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_memory_block$/;"	s	file:
xpath_memory_block::__anon29::alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			double alignment;$/;"	m	union:xpath_memory_block::__anon29	file:	access:public
xpath_memory_block::__anon29::data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			char data[xpath_memory_page_size];$/;"	m	union:xpath_memory_block::__anon29	file:	access:public
xpath_memory_block::capacity	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t capacity;$/;"	m	struct:xpath_memory_block	file:	access:public
xpath_memory_block::next	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block* next;$/;"	m	struct:xpath_memory_block	file:	access:public
xpath_memory_block_alignment	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const uintptr_t xpath_memory_block_alignment = sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*);$/;"	v	file:
xpath_memory_page_size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	static const size_t xpath_memory_page_size =$/;"	v	file:
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::xpath_node()$/;"	f	class:pugi::xpath_node	signature:()
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::xpath_node(const xml_attribute& attribute_, const xml_node& parent_): _node(attribute_ ? parent_ : xml_node()), _attribute(attribute_)$/;"	f	class:pugi::xpath_node	signature:(const xml_attribute& attribute_, const xml_node& parent_)
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node::xpath_node(const xml_node& node_): _node(node_)$/;"	f	class:pugi::xpath_node	signature:(const xml_node& node_)
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node();$/;"	p	class:pugi::xpath_node	access:public	signature:()
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node(const xml_attribute& attribute, const xml_node& parent);$/;"	p	class:pugi::xpath_node	access:public	signature:(const xml_attribute& attribute, const xml_node& parent)
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node(const xml_node& node);$/;"	p	class:pugi::xpath_node	access:public	signature:(const xml_node& node)
xpath_node	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_node$/;"	c	namespace:pugi
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:()
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(const xpath_node_set& ns): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:(const xpath_node_set& ns)
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(const_iterator begin_, const_iterator end_, type_t type_): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:(const_iterator begin_, const_iterator end_, type_t type_)
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::xpath_node_set(xpath_node_set&& rhs): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set	signature:(xpath_node_set&& rhs)
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set();$/;"	p	class:pugi::xpath_node_set	access:public	signature:()
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set(const xpath_node_set& ns);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(const xpath_node_set& ns)
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set(const_iterator begin, const_iterator end, type_t type = type_unsorted);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(const_iterator begin, const_iterator end, type_t type = type_unsorted)
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_node_set(xpath_node_set&& rhs);$/;"	p	class:pugi::xpath_node_set	access:public	signature:(xpath_node_set&& rhs)
xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_node_set$/;"	c	namespace:pugi
xpath_node_set_raw	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set_raw(): _type(xpath_node_set::type_unsorted), _begin(0), _end(0), _eos(0)$/;"	f	class:xpath_node_set_raw	access:public	signature:()
xpath_node_set_raw	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class xpath_node_set_raw$/;"	c	file:
xpath_node_set_raw::_begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* _begin;$/;"	m	class:xpath_node_set_raw	file:	access:private
xpath_node_set_raw::_end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* _end;$/;"	m	class:xpath_node_set_raw	file:	access:private
xpath_node_set_raw::_eos	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* _eos;$/;"	m	class:xpath_node_set_raw	file:	access:private
xpath_node_set_raw::_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set::type_t _type;$/;"	m	class:xpath_node_set_raw	file:	access:private
xpath_node_set_raw::append	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void append(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw	access:public	signature:(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)
xpath_node_set_raw::begin	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* begin() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
xpath_node_set_raw::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool empty() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
xpath_node_set_raw::end	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node* end() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
xpath_node_set_raw::first	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node first() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
xpath_node_set_raw::push_back	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void push_back(const xpath_node& node, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw	access:public	signature:(const xpath_node& node, xpath_allocator* alloc)
xpath_node_set_raw::push_back_grow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void push_back_grow(const xpath_node& node, xpath_allocator* alloc);$/;"	p	class:xpath_node_set_raw	file:	access:public	signature:(const xpath_node& node, xpath_allocator* alloc)
xpath_node_set_raw::push_back_grow	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN_NO_INLINE void xpath_node_set_raw::push_back_grow(const xpath_node& node, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw	signature:(const xpath_node& node, xpath_allocator* alloc)
xpath_node_set_raw::remove_duplicates	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void remove_duplicates()$/;"	f	class:xpath_node_set_raw	access:public	signature:()
xpath_node_set_raw::set_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void set_type(xpath_node_set::type_t value)$/;"	f	class:xpath_node_set_raw	access:public	signature:(xpath_node_set::type_t value)
xpath_node_set_raw::size	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t size() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
xpath_node_set_raw::sort_do	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void sort_do()$/;"	f	class:xpath_node_set_raw	access:public	signature:()
xpath_node_set_raw::truncate	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void truncate(xpath_node* pos)$/;"	f	class:xpath_node_set_raw	access:public	signature:(xpath_node* pos)
xpath_node_set_raw::type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set::type_t type() const$/;"	f	class:xpath_node_set_raw	access:public	signature:() const
xpath_node_set_raw::xpath_node_set_raw	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set_raw(): _type(xpath_node_set::type_unsorted), _begin(0), _end(0), _eos(0)$/;"	f	class:xpath_node_set_raw	access:public	signature:()
xpath_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_parse_result::xpath_parse_result(): error("Internal error"), offset(0)$/;"	f	class:pugi::xpath_parse_result	signature:()
xpath_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_parse_result();$/;"	p	struct:pugi::xpath_parse_result	access:public	signature:()
xpath_parse_result	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	struct PUGIXML_CLASS xpath_parse_result$/;"	s	namespace:pugi
xpath_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_parser(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result): _alloc(alloc), _lexer(query), _query(query), _variables(variables), _result(result)$/;"	f	struct:xpath_parser	access:public	signature:(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)
xpath_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_parser$/;"	s	file:
xpath_parser::_alloc	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* _alloc;$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::_error_handler	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		jmp_buf _error_handler;$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::_lexer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_lexer _lexer;$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _query;$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::_result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_parse_result* _result;$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::_scratch	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t _scratch[32];$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::_variables	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_set* _variables;$/;"	m	struct:xpath_parser	file:	access:public
xpath_parser::alloc_node	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void* alloc_node()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::alloc_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* alloc_string(const xpath_lexer_string& value)$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& value)
xpath_parser::binary_op_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		struct binary_op_t$/;"	s	struct:xpath_parser	file:	access:public
xpath_parser::binary_op_t::asttype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			ast_type_t asttype;$/;"	m	struct:xpath_parser::binary_op_t	file:	access:public
xpath_parser::binary_op_t::binary_op_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			binary_op_t(): asttype(ast_unknown), rettype(xpath_type_none), precedence(0)$/;"	f	struct:xpath_parser::binary_op_t	access:public	signature:()
xpath_parser::binary_op_t::binary_op_t	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			binary_op_t(ast_type_t asttype_, xpath_value_type rettype_, int precedence_): asttype(asttype_), rettype(rettype_), precedence(precedence_)$/;"	f	struct:xpath_parser::binary_op_t	access:public	signature:(ast_type_t asttype_, xpath_value_type rettype_, int precedence_)
xpath_parser::binary_op_t::parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			static binary_op_t parse(xpath_lexer& lexer)$/;"	f	struct:xpath_parser::binary_op_t	access:public	signature:(xpath_lexer& lexer)
xpath_parser::binary_op_t::precedence	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			int precedence;$/;"	m	struct:xpath_parser::binary_op_t	file:	access:public
xpath_parser::binary_op_t::rettype	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^			xpath_value_type rettype;$/;"	m	struct:xpath_parser::binary_op_t	file:	access:public
xpath_parser::parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_ast_node* parse(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)$/;"	f	struct:xpath_parser	access:public	signature:(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)
xpath_parser::parse	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::parse_axis_name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		axis_t parse_axis_name(const xpath_lexer_string& name, bool& specified)$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& name, bool& specified)
xpath_parser::parse_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::parse_expression_rec	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_expression_rec(xpath_ast_node* lhs, int limit)$/;"	f	struct:xpath_parser	access:public	signature:(xpath_ast_node* lhs, int limit)
xpath_parser::parse_filter_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_filter_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::parse_function	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_function(const xpath_lexer_string& name, size_t argc, xpath_ast_node* args[2])$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& name, size_t argc, xpath_ast_node* args[2])
xpath_parser::parse_function_helper	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_function_helper(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])$/;"	f	struct:xpath_parser	access:public	signature:(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])
xpath_parser::parse_location_path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_location_path()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::parse_node_test_type	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		nodetest_t parse_node_test_type(const xpath_lexer_string& name)$/;"	f	struct:xpath_parser	access:public	signature:(const xpath_lexer_string& name)
xpath_parser::parse_path_or_unary_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_path_or_unary_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::parse_primary_expression	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_primary_expression()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::parse_relative_location_path	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_relative_location_path(xpath_ast_node* set)$/;"	f	struct:xpath_parser	access:public	signature:(xpath_ast_node* set)
xpath_parser::parse_step	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* parse_step(xpath_ast_node* set)$/;"	f	struct:xpath_parser	access:public	signature:(xpath_ast_node* set)
xpath_parser::throw_error	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void throw_error(const char* message)$/;"	f	struct:xpath_parser	access:public	signature:(const char* message)
xpath_parser::throw_error_oom	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void throw_error_oom()$/;"	f	struct:xpath_parser	access:public	signature:()
xpath_parser::xpath_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_parser(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result): _alloc(alloc), _lexer(query), _query(query), _variables(variables), _result(result)$/;"	f	struct:xpath_parser	access:public	signature:(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::xpath_query(): _impl(0)$/;"	f	class:pugi::xpath_query	signature:()
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::xpath_query(const char_t* query, xpath_variable_set* variables): _impl(0)$/;"	f	class:pugi::xpath_query	signature:(const char_t* query, xpath_variable_set* variables)
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::xpath_query(xpath_query&& rhs)$/;"	f	class:pugi::xpath_query	signature:(xpath_query&& rhs)
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		explicit xpath_query(const char_t* query, xpath_variable_set* variables = 0);$/;"	p	class:pugi::xpath_query	access:public	signature:(const char_t* query, xpath_variable_set* variables = 0)
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query();$/;"	p	class:pugi::xpath_query	access:public	signature:()
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query(const xpath_query&);$/;"	p	class:pugi::xpath_query	access:private	signature:(const xpath_query&)
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_query(xpath_query&& rhs);$/;"	p	class:pugi::xpath_query	access:public	signature:(xpath_query&& rhs)
xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_query$/;"	c	namespace:pugi
xpath_query_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_query_impl(): root(0), alloc(&block)$/;"	f	struct:xpath_query_impl	access:public	signature:()
xpath_query_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_query_impl$/;"	s	file:
xpath_query_impl::alloc	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator alloc;$/;"	m	struct:xpath_query_impl	file:	access:public
xpath_query_impl::block	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block block;$/;"	m	struct:xpath_query_impl	file:	access:public
xpath_query_impl::create	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_query_impl* create()$/;"	f	struct:xpath_query_impl	access:public	signature:()
xpath_query_impl::destroy	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static void destroy(xpath_query_impl* impl)$/;"	f	struct:xpath_query_impl	access:public	signature:(xpath_query_impl* impl)
xpath_query_impl::root	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_ast_node* root;$/;"	m	struct:xpath_query_impl	file:	access:public
xpath_query_impl::xpath_query_impl	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_query_impl(): root(0), alloc(&block)$/;"	f	struct:xpath_query_impl	access:public	signature:()
xpath_sort	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::type_t xpath_sort(xpath_node* begin, xpath_node* end, xpath_node_set::type_t type, bool rev)$/;"	f	signature:(xpath_node* begin, xpath_node* end, xpath_node_set::type_t type, bool rev)
xpath_stack	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_stack$/;"	s	file:
xpath_stack::result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* result;$/;"	m	struct:xpath_stack	file:	access:public
xpath_stack::temp	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator* temp;$/;"	m	struct:xpath_stack	file:	access:public
xpath_stack_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_stack_data(): result(blocks + 0), temp(blocks + 1)$/;"	f	struct:xpath_stack_data	access:public	signature:()
xpath_stack_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_stack_data$/;"	s	file:
xpath_stack_data::blocks	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_memory_block blocks[2];$/;"	m	struct:xpath_stack_data	file:	access:public
xpath_stack_data::error_handler	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		jmp_buf error_handler;$/;"	m	struct:xpath_stack_data	file:	access:public
xpath_stack_data::result	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator result;$/;"	m	struct:xpath_stack_data	file:	access:public
xpath_stack_data::stack	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_stack stack;$/;"	m	struct:xpath_stack_data	file:	access:public
xpath_stack_data::temp	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_allocator temp;$/;"	m	struct:xpath_stack_data	file:	access:public
xpath_stack_data::xpath_stack_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_stack_data(): result(blocks + 0), temp(blocks + 1)$/;"	f	struct:xpath_stack_data	access:public	signature:()
xpath_stack_data::~xpath_stack_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xpath_stack_data()$/;"	f	struct:xpath_stack_data	access:public	signature:()
xpath_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string(): _buffer(PUGIXML_TEXT("")), _uses_heap(false), _length_heap(0)$/;"	f	class:xpath_string	access:public	signature:()
xpath_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string(const char_t* buffer, bool uses_heap_, size_t length_heap): _buffer(buffer), _uses_heap(uses_heap_), _length_heap(length_heap)$/;"	f	class:xpath_string	file:	access:private	signature:(const char_t* buffer, bool uses_heap_, size_t length_heap)
xpath_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	class xpath_string$/;"	c	file:
xpath_string::_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* _buffer;$/;"	m	class:xpath_string	file:	access:private
xpath_string::_length_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t _length_heap;$/;"	m	class:xpath_string	file:	access:private
xpath_string::_uses_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool _uses_heap;$/;"	m	class:xpath_string	file:	access:private
xpath_string::append	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		void append(const xpath_string& o, xpath_allocator* alloc)$/;"	f	class:xpath_string	access:public	signature:(const xpath_string& o, xpath_allocator* alloc)
xpath_string::c_str	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		const char_t* c_str() const$/;"	f	class:xpath_string	access:public	signature:() const
xpath_string::data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* data(xpath_allocator* alloc)$/;"	f	class:xpath_string	access:public	signature:(xpath_allocator* alloc)
xpath_string::duplicate_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static char_t* duplicate_string(const char_t* string, size_t length, xpath_allocator* alloc)$/;"	f	class:xpath_string	file:	access:private	signature:(const char_t* string, size_t length, xpath_allocator* alloc)
xpath_string::empty	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool empty() const$/;"	f	class:xpath_string	access:public	signature:() const
xpath_string::from_const	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_string from_const(const char_t* str)$/;"	f	class:xpath_string	access:public	signature:(const char_t* str)
xpath_string::from_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_string from_heap(const char_t* begin, const char_t* end, xpath_allocator* alloc)$/;"	f	class:xpath_string	access:public	signature:(const char_t* begin, const char_t* end, xpath_allocator* alloc)
xpath_string::from_heap_preallocated	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		static xpath_string from_heap_preallocated(const char_t* begin, const char_t* end)$/;"	f	class:xpath_string	access:public	signature:(const char_t* begin, const char_t* end)
xpath_string::length	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		size_t length() const$/;"	f	class:xpath_string	access:public	signature:() const
xpath_string::operator !=	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator!=(const xpath_string& o) const$/;"	f	class:xpath_string	access:public	signature:(const xpath_string& o) const
xpath_string::operator ==	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool operator==(const xpath_string& o) const$/;"	f	class:xpath_string	access:public	signature:(const xpath_string& o) const
xpath_string::uses_heap	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool uses_heap() const$/;"	f	class:xpath_string	access:public	signature:() const
xpath_string::xpath_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string(): _buffer(PUGIXML_TEXT("")), _uses_heap(false), _length_heap(0)$/;"	f	class:xpath_string	access:public	signature:()
xpath_string::xpath_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_string(const char_t* buffer, bool uses_heap_, size_t length_heap): _buffer(buffer), _uses_heap(uses_heap_), _length_heap(length_heap)$/;"	f	class:xpath_string	file:	access:private	signature:(const char_t* buffer, bool uses_heap_, size_t length_heap)
xpath_type_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_boolean	  \/\/ Boolean$/;"	e	enum:pugi::xpath_value_type
xpath_type_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_node_set,  \/\/ Node set (xpath_node_set)$/;"	e	enum:pugi::xpath_value_type
xpath_type_none	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_none,	  \/\/ Unknown type (query failed to compile)$/;"	e	enum:pugi::xpath_value_type
xpath_type_number	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_number,	  \/\/ Number$/;"	e	enum:pugi::xpath_value_type
xpath_type_string	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_type_string,	  \/\/ String$/;"	e	enum:pugi::xpath_value_type
xpath_value_type	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	enum xpath_value_type$/;"	g	namespace:pugi
xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable::xpath_variable(xpath_value_type type_): _type(type_), _next(0)$/;"	f	class:pugi::xpath_variable	signature:(xpath_value_type type_)
xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable(const xpath_variable&);$/;"	p	class:pugi::xpath_variable	access:protected	signature:(const xpath_variable&)
xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable(xpath_value_type type);$/;"	p	class:pugi::xpath_variable	access:protected	signature:(xpath_value_type type)
xpath_variable	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_variable$/;"	c	namespace:pugi
xpath_variable_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_boolean(): xpath_variable(xpath_type_boolean), value(false)$/;"	f	struct:xpath_variable_boolean	access:public	signature:()
xpath_variable_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_variable_boolean: xpath_variable$/;"	s	file:	inherits:xpath_variable
xpath_variable_boolean::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_boolean	file:	access:public
xpath_variable_boolean::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		bool value;$/;"	m	struct:xpath_variable_boolean	file:	access:public
xpath_variable_boolean::xpath_variable_boolean	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_boolean(): xpath_variable(xpath_type_boolean), value(false)$/;"	f	struct:xpath_variable_boolean	access:public	signature:()
xpath_variable_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_node_set(): xpath_variable(xpath_type_node_set)$/;"	f	struct:xpath_variable_node_set	access:public	signature:()
xpath_variable_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_variable_node_set: xpath_variable$/;"	s	file:	inherits:xpath_variable
xpath_variable_node_set::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_node_set	file:	access:public
xpath_variable_node_set::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_node_set value;$/;"	m	struct:xpath_variable_node_set	file:	access:public
xpath_variable_node_set::xpath_variable_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_node_set(): xpath_variable(xpath_type_node_set)$/;"	f	struct:xpath_variable_node_set	access:public	signature:()
xpath_variable_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_number(): xpath_variable(xpath_type_number), value(0)$/;"	f	struct:xpath_variable_number	access:public	signature:()
xpath_variable_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_variable_number: xpath_variable$/;"	s	file:	inherits:xpath_variable
xpath_variable_number::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_number	file:	access:public
xpath_variable_number::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		double value;$/;"	m	struct:xpath_variable_number	file:	access:public
xpath_variable_number::xpath_variable_number	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_number(): xpath_variable(xpath_type_number), value(0)$/;"	f	struct:xpath_variable_number	access:public	signature:()
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::xpath_variable_set()$/;"	f	class:pugi::xpath_variable_set	signature:()
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::xpath_variable_set(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(const xpath_variable_set& rhs)
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::xpath_variable_set(xpath_variable_set&& rhs)$/;"	f	class:pugi::xpath_variable_set	signature:(xpath_variable_set&& rhs)
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set();$/;"	p	class:pugi::xpath_variable_set	access:public	signature:()
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set(const xpath_variable_set& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(const xpath_variable_set& rhs)
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		xpath_variable_set(xpath_variable_set&& rhs);$/;"	p	class:pugi::xpath_variable_set	access:public	signature:(xpath_variable_set&& rhs)
xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^	class PUGIXML_CLASS xpath_variable_set$/;"	c	namespace:pugi
xpath_variable_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_string(): xpath_variable(xpath_type_string), value(0)$/;"	f	struct:xpath_variable_string	access:public	signature:()
xpath_variable_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	struct xpath_variable_string: xpath_variable$/;"	s	file:	inherits:xpath_variable
xpath_variable_string::name	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t name[1];$/;"	m	struct:xpath_variable_string	file:	access:public
xpath_variable_string::value	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		char_t* value;$/;"	m	struct:xpath_variable_string	file:	access:public
xpath_variable_string::xpath_variable_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		xpath_variable_string(): xpath_variable(xpath_type_string), value(0)$/;"	f	struct:xpath_variable_string	access:public	signature:()
xpath_variable_string::~xpath_variable_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xpath_variable_string()$/;"	f	struct:xpath_variable_string	access:public	signature:()
xpeak	../../libs/libarchfpga/src/physical_types.h	/^	float xpeak;$/;"	m	struct:t_chan	access:public
xrad_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static float xrad_to_scrn (float xrad) {$/;"	f	file:	signature:(float xrad)
xrad_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static float xrad_to_scrn (float xrad);$/;"	p	file:	signature:(float xrad)
xright	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
xright	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
xscrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^static float xscrn_to_world(int x) {$/;"	f	file:	signature:(int x)
xscrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^static float xscrn_to_world(int x);$/;"	p	file:	signature:(int x)
xworld_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static int xworld_to_scrn(float worldx) {$/;"	f	file:	signature:(float worldx)
xworld_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static int xworld_to_scrn(float worldx);$/;"	p	file:	signature:(float worldx)
xworld_to_scrn_fl	../../libs/libeasygl/src/graphics.cpp	/^static float xworld_to_scrn_fl(float worldx) {$/;"	f	file:	signature:(float worldx)
xworld_to_scrn_fl	../../libs/libeasygl/src/graphics.cpp	/^static float xworld_to_scrn_fl(float worldx); \/\/ without rounding to nearest pixel$/;"	p	file:	signature:(float worldx)
y	../../libs/libarchfpga/src/physical_types.h	/^    t_grid_loc_spec y;      \/\/Veritcal location specification$/;"	m	struct:t_grid_loc_def	access:public
y	../../libs/libeasygl/src/graphics_types.h	/^    float y = 0;$/;"	m	class:t_point	access:public
y	../../libs/libvtrutil/src/vtr_geometry.h	/^        T y() const;$/;"	p	class:vtr::Point	access:public	signature:() const
y	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Point<T>::y() const {$/;"	f	class:vtr::Point	signature:() const
y	base/vpr_types.h	/^	int y;$/;"	m	struct:ScreenUpdatePriority::t_legal_pos	access:public
y	base/vpr_types.h	/^    int y = OPEN;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
y_	../../libs/libvtrutil/src/vtr_geometry.h	/^        T y_;$/;"	m	class:vtr::Point	access:private
y_coord	route/build_switchblocks.h	/^	int y_coord;		\/* y coordinate of switchblock connection *\/$/;"	m	class:Switchblock_Lookup	access:public
y_intercept_	route/routing_predictor.cpp	/^    float y_intercept_;$/;"	m	class:LinearModel	file:	access:private
y_list	base/vpr_types.h	/^	std::vector<int> y_list;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
y_max	base/vpr_types.h	/^	int y_max = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
y_min	base/vpr_types.h	/^	int y_min = 0;$/;"	m	struct:ScreenUpdatePriority::t_chan_width	access:public
y_offset	../../libs/libarchfpga/src/physical_types.h	/^	int y_offset;$/;"	m	struct:t_direct_inf	access:public
y_offset	place/place_macro.h	/^	int y_offset;$/;"	m	struct:t_pl_macro_member	access:public
y_to_post	../../libs/libeasygl/src/graphics.cpp	/^static float y_to_post(float worldy);$/;"	p	file:	signature:(float worldy)
y_to_post	../../libs/libeasygl/src/graphics.cpp	/^static float y_to_post(float y) {$/;"	f	file:	signature:(float y)
ybot	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
ybot	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
yhigh	route/rr_node.cpp	/^short t_rr_node::yhigh() const {$/;"	f	class:t_rr_node	signature:() const
yhigh	route/rr_node.h	/^        short yhigh() const;$/;"	p	class:t_rr_node	access:public	signature:() const
yhigh_	route/rr_node.h	/^        int16_t yhigh_ = -1;$/;"	m	class:t_rr_node	access:private
ylow	route/rr_node.cpp	/^short t_rr_node::ylow() const {$/;"	f	class:t_rr_node	signature:() const
ylow	route/rr_node.h	/^        short ylow() const;$/;"	p	class:t_rr_node	access:public	signature:() const
ylow_	route/rr_node.h	/^        int16_t ylow_ = -1;$/;"	m	class:t_rr_node	access:private
ymax	../../libs/libvtrutil/src/vtr_geometry.h	/^        T ymax() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
ymax	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::ymax() const {$/;"	f	class:vtr::Rect	signature:() const
ymax	base/vpr_types.h	/^	int ymax;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
ymin	../../libs/libvtrutil/src/vtr_geometry.h	/^        T ymin() const;$/;"	p	class:vtr::Rect	access:public	signature:() const
ymin	../../libs/libvtrutil/src/vtr_geometry.tpp	/^    T Rect<T>::ymin() const {$/;"	f	class:vtr::Rect	signature:() const
ymin	base/vpr_types.h	/^	int ymin;$/;"	m	struct:ScreenUpdatePriority::t_bb	access:public
ymult	../../libs/libeasygl/src/graphics.h	/^    float xmult, ymult;$/;"	m	struct:__anon22	access:public
ynew	base/vpr_types.h	/^	int ynew;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
yold	base/vpr_types.h	/^	int yold;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
yrad_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static float yrad_to_scrn (float yrad) {$/;"	f	file:	signature:(float yrad)
yrad_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static float yrad_to_scrn (float yrad);$/;"	p	file:	signature:(float yrad)
yscrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^static float yscrn_to_world(int y) {$/;"	f	file:	signature:(int y)
yscrn_to_world	../../libs/libeasygl/src/graphics.cpp	/^static float yscrn_to_world(int y);$/;"	p	file:	signature:(int y)
ytop	../../libs/libeasygl/src/graphics.cpp	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon20	file:	access:public
ytop	../../libs/libeasygl/src/graphics.cpp	/^    int ytop;$/;"	m	struct:__anon18	file:	access:public
ytop	../../libs/libeasygl/src/graphics.h	/^    float xleft, xright, ytop, ybot;$/;"	m	struct:__anon22	access:public
yworld_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static int yworld_to_scrn(float worldy) {$/;"	f	file:	signature:(float worldy)
yworld_to_scrn	../../libs/libeasygl/src/graphics.cpp	/^static int yworld_to_scrn(float worldy);$/;"	p	file:	signature:(float worldy)
yworld_to_scrn_fl	../../libs/libeasygl/src/graphics.cpp	/^static float yworld_to_scrn_fl(float worldy) {$/;"	f	file:	signature:(float worldy)
yworld_to_scrn_fl	../../libs/libeasygl/src/graphics.cpp	/^static float yworld_to_scrn_fl(float worldy);$/;"	p	file:	signature:(float worldy)
z	base/vpr_types.h	/^	int z;$/;"	m	struct:ScreenUpdatePriority::t_legal_pos	access:public
z	base/vpr_types.h	/^    int z = OPEN;$/;"	m	struct:ScreenUpdatePriority::t_block_loc	access:public
z_offset	../../libs/libarchfpga/src/physical_types.h	/^	int z_offset;$/;"	m	struct:t_direct_inf	access:public
z_offset	place/place_macro.h	/^	int z_offset;$/;"	m	struct:t_pl_macro_member	access:public
zero_terminate_buffer	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN size_t zero_terminate_buffer(void* buffer, size_t size, xml_encoding encoding) $/;"	f	signature:(void* buffer, size_t size, xml_encoding encoding)
znew	base/vpr_types.h	/^	int znew;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
zold	base/vpr_types.h	/^	int zold;$/;"	m	struct:ScreenUpdatePriority::t_pl_moved_block	access:public
zoom_factor	../../libs/libeasygl/src/graphics_state.h	/^    float zoom_factor = 1.6667;$/;"	m	struct:t_gl_state	access:public
zoom_fit	../../libs/libeasygl/src/graphics.cpp	/^static void zoom_fit(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
zoom_fit	../../libs/libeasygl/src/graphics.cpp	/^zoom_fit(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
zoom_in	../../libs/libeasygl/src/graphics.cpp	/^static void zoom_in(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
zoom_in	../../libs/libeasygl/src/graphics.cpp	/^zoom_in(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
zoom_out	../../libs/libeasygl/src/graphics.cpp	/^static void zoom_out(void (*drawscreen) ());$/;"	p	file:	signature:(void (*drawscreen) ())
zoom_out	../../libs/libeasygl/src/graphics.cpp	/^zoom_out(void (*drawscreen) ()) {$/;"	f	file:	signature:(void (*drawscreen) ())
~ColorMap	../../libs/libvtrutil/src/vtr_color_map.h	/^        virtual ~ColorMap() = default;$/;"	p	class:vtr::ColorMap	access:public	signature:()
~Context	base/vpr_context.h	/^    virtual ~Context() = default;$/;"	p	struct:Context	access:public	signature:()
~Instance	base/netlist_writer.cpp	/^        virtual ~Instance() = default;$/;"	p	class:Instance	file:	access:public	signature:()
~IntraLbPbPinLookup	util/vpr_utils.cpp	/^IntraLbPbPinLookup::~IntraLbPbPinLookup() {$/;"	f	class:IntraLbPbPinLookup	signature:()
~IntraLbPbPinLookup	util/vpr_utils.h	/^        ~IntraLbPbPinLookup();$/;"	p	class:IntraLbPbPinLookup	access:public	signature:()
~Netlist	base/netlist.h	/^        virtual ~Netlist();$/;"	p	class:Netlist	access:public	signature:()
~Netlist	base/netlist.tpp	/^Netlist<BlockId, PortId, PinId, NetId>::~Netlist() = default;$/;"	p	class:Netlist	file:	signature:()
~NetlistVisitor	base/netlist_walker.h	/^        virtual ~NetlistVisitor() = default;$/;"	p	class:NetlistVisitor	access:public	signature:()
~OsFormatGuard	../../libs/libvtrutil/src/vtr_ostream_guard.h	/^        ~OsFormatGuard() {$/;"	f	class:vtr::OsFormatGuard	access:public	signature:()
~PlaceDelayModel	place/place_delay_model.h	/^        virtual ~PlaceDelayModel() = default;$/;"	p	class:PlaceDelayModel	access:public	signature:()
~RouterLookahead	route/router_lookahead.h	/^        virtual ~RouterLookahead() {}$/;"	f	class:RouterLookahead	access:public	signature:()
~ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedActionTimer::~ScopedActionTimer() {$/;"	f	class:vtr::ScopedActionTimer	signature:()
~ScopedActionTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ~ScopedActionTimer();$/;"	p	class:vtr::ScopedActionTimer	access:public	signature:()
~ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedFinishTimer::~ScopedFinishTimer() {$/;"	f	class:vtr::ScopedFinishTimer	signature:()
~ScopedFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ~ScopedFinishTimer();$/;"	p	class:vtr::ScopedFinishTimer	access:public	signature:()
~ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.cpp	/^ScopedStartFinishTimer::~ScopedStartFinishTimer() {$/;"	f	class:vtr::ScopedStartFinishTimer	signature:()
~ScopedStartFinishTimer	../../libs/libvtrutil/src/vtr_time.h	/^            ~ScopedStartFinishTimer();$/;"	p	class:vtr::ScopedStartFinishTimer	access:public	signature:()
~Surface	../../libs/libeasygl/src/Surface.cpp	/^Surface::~Surface() {$/;"	f	class:Surface	signature:()
~Surface	../../libs/libeasygl/src/Surface.h	/^        ~Surface();$/;"	p	class:Surface	access:public	signature:()
~SurfaceImpl	../../libs/libeasygl/src/SurfaceImpl.h	/^        ~SurfaceImpl() = default;$/;"	p	class:SurfaceImpl	access:public	signature:()
~Timer	../../libs/libvtrutil/src/vtr_time.h	/^            virtual ~Timer() = default;$/;"	p	class:vtr::Timer	access:public	signature:()
~TimingInfo	timing/timing_info.h	/^        virtual ~TimingInfo() = default;$/;"	p	class:TimingInfo	access:public	signature:()
~VNumber	../../libs/librtlnumber/src/include/internal_bits.hpp	/^    ~VNumber()$/;"	f	class:VNumber	access:public	signature:()
~auto_deleter	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~auto_deleter()$/;"	f	struct:auto_deleter	access:public	signature:()
~name_null_sentry	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~name_null_sentry()$/;"	f	struct:name_null_sentry	access:public	signature:()
~route_budgets	route/route_budgets.cpp	/^route_budgets::~route_budgets() {$/;"	f	class:route_budgets	signature:()
~route_budgets	route/route_budgets.h	/^    virtual ~route_budgets();$/;"	p	class:route_budgets	access:public	signature:()
~t_traceback	route/route_traceback.cpp	/^t_traceback::~t_traceback() {$/;"	f	class:t_traceback	signature:()
~t_traceback	route/route_traceback.h	/^    ~t_traceback();$/;"	p	struct:t_traceback	access:public	signature:()
~t_win32_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_win32_state::~t_win32_state()$/;"	f	class:t_win32_state	signature:()
~t_win32_state	../../libs/libeasygl/src/graphics_state.h	/^    ~t_win32_state();$/;"	p	class:t_win32_state	access:public	signature:()
~t_x11_state	../../libs/libeasygl/src/graphics_state.cpp	/^t_x11_state::~t_x11_state()$/;"	f	class:t_x11_state	signature:()
~t_x11_state	../../libs/libeasygl/src/graphics_state.h	/^    ~t_x11_state();$/;"	p	class:t_x11_state	access:public	signature:()
~timing_driven_route_structs	route/route_timing.cpp	/^timing_driven_route_structs::~timing_driven_route_structs() {$/;"	f	class:timing_driven_route_structs	signature:()
~timing_driven_route_structs	route/route_timing.h	/^    ~timing_driven_route_structs();$/;"	p	struct:timing_driven_route_structs	access:public	signature:()
~xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_document::~xml_document()$/;"	f	class:pugi::xml_document	signature:()
~xml_document	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xml_document();$/;"	p	class:pugi::xml_document	access:public	signature:()
~xml_parser	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xml_parser()$/;"	f	struct:xml_parser	access:public	signature:()
~xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xml_tree_walker::~xml_tree_walker()$/;"	f	class:pugi::xml_tree_walker	signature:()
~xml_tree_walker	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual ~xml_tree_walker();$/;"	p	class:pugi::xml_tree_walker	access:public	signature:()
~xml_writer	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		virtual ~xml_writer() {}$/;"	f	class:pugi::xml_writer	access:public	signature:()
~xpath_allocator_capture	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xpath_allocator_capture()$/;"	f	struct:xpath_allocator_capture	access:public	signature:()
~xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_node_set::~xpath_node_set()$/;"	f	class:pugi::xpath_node_set	signature:()
~xpath_node_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xpath_node_set();$/;"	p	class:pugi::xpath_node_set	access:public	signature:()
~xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_query::~xpath_query()$/;"	f	class:pugi::xpath_query	signature:()
~xpath_query	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xpath_query();$/;"	p	class:pugi::xpath_query	access:public	signature:()
~xpath_stack_data	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xpath_stack_data()$/;"	f	struct:xpath_stack_data	access:public	signature:()
~xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^	PUGI__FN xpath_variable_set::~xpath_variable_set()$/;"	f	class:pugi::xpath_variable_set	signature:()
~xpath_variable_set	../../libs/EXTERNAL/libpugixml/src/pugixml.hpp	/^		~xpath_variable_set();$/;"	p	class:pugi::xpath_variable_set	access:public	signature:()
~xpath_variable_string	../../libs/EXTERNAL/libpugixml/src/pugixml.cpp	/^		~xpath_variable_string()$/;"	f	struct:xpath_variable_string	access:public	signature:()
